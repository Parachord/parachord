<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Parachord Embed Player</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg-primary: #0f0f0f;
      --bg-secondary: #1a1a1a;
      --bg-tertiary: #252525;
      --text-primary: #ffffff;
      --text-secondary: #a0a0a0;
      --accent: #8b5cf6;
      --accent-hover: #7c3aed;
      --spotify: #1DB954;
      --youtube: #FF0000;
      --soundcloud: #FF5500;
      --bandcamp: #629AA9;
      --qobuz: #0E7EBF;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .container {
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
      width: 100%;
    }

    /* Header */
    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 20px;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 1.25rem;
      font-weight: 600;
    }

    .logo-icon {
      width: 32px;
      height: 32px;
      background: linear-gradient(135deg, var(--accent), #ec4899);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .status {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.875rem;
      color: var(--text-secondary);
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #ef4444;
    }

    .status-dot.connected {
      background: #22c55e;
    }

    /* Search */
    .search-container {
      margin-bottom: 20px;
    }

    .search-input {
      width: 100%;
      padding: 12px 16px;
      background: var(--bg-secondary);
      border: 1px solid var(--bg-tertiary);
      border-radius: 8px;
      color: var(--text-primary);
      font-size: 1rem;
      outline: none;
      transition: border-color 0.2s;
    }

    .search-input:focus {
      border-color: var(--accent);
    }

    .search-input::placeholder {
      color: var(--text-secondary);
    }

    /* Now Playing */
    .now-playing {
      background: var(--bg-secondary);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 20px;
    }

    .now-playing-header {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-secondary);
      margin-bottom: 12px;
    }

    .track-info {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .album-art {
      width: 64px;
      height: 64px;
      background: var(--bg-tertiary);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      flex-shrink: 0;
      overflow: hidden;
    }

    .album-art img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .track-details {
      flex: 1;
      min-width: 0;
    }

    .track-title {
      font-weight: 600;
      font-size: 1rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .track-artist {
      color: var(--text-secondary);
      font-size: 0.875rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Controls */
    .controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
      margin-top: 16px;
    }

    .control-btn {
      background: none;
      border: none;
      color: var(--text-primary);
      cursor: pointer;
      padding: 8px;
      border-radius: 50%;
      transition: background 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .control-btn:hover {
      background: var(--bg-tertiary);
    }

    .control-btn.play-pause {
      background: var(--accent);
      width: 48px;
      height: 48px;
    }

    .control-btn.play-pause:hover {
      background: var(--accent-hover);
    }

    .control-btn svg {
      width: 24px;
      height: 24px;
    }

    /* Results */
    .results {
      margin-top: 20px;
    }

    .results-header {
      font-size: 0.875rem;
      font-weight: 600;
      margin-bottom: 12px;
    }

    .result-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: var(--bg-secondary);
      border-radius: 8px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .result-item:hover {
      background: var(--bg-tertiary);
    }

    .result-art {
      width: 48px;
      height: 48px;
      background: var(--bg-tertiary);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      overflow: hidden;
    }

    .result-art img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .result-info {
      flex: 1;
      min-width: 0;
    }

    .result-title {
      font-weight: 500;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .result-artist {
      color: var(--text-secondary);
      font-size: 0.875rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .result-source {
      font-size: 0.75rem;
      padding: 4px 8px;
      border-radius: 4px;
      font-weight: 500;
    }

    .result-source.spotify { background: rgba(29, 185, 84, 0.2); color: var(--spotify); }
    .result-source.youtube { background: rgba(255, 0, 0, 0.2); color: var(--youtube); }
    .result-source.soundcloud { background: rgba(255, 85, 0, 0.2); color: var(--soundcloud); }
    .result-source.bandcamp { background: rgba(98, 154, 169, 0.2); color: var(--bandcamp); }
    .result-source.qobuz { background: rgba(14, 126, 191, 0.2); color: var(--qobuz); }

    /* Fallback Mode */
    .fallback-notice {
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(236, 72, 153, 0.1));
      border: 1px solid rgba(139, 92, 246, 0.3);
      border-radius: 12px;
      padding: 20px;
      text-align: center;
      margin-bottom: 20px;
    }

    .fallback-notice h3 {
      font-size: 1rem;
      margin-bottom: 8px;
    }

    .fallback-notice p {
      color: var(--text-secondary);
      font-size: 0.875rem;
      margin-bottom: 16px;
    }

    .fallback-notice a {
      color: var(--accent);
      text-decoration: none;
    }

    .fallback-notice a:hover {
      text-decoration: underline;
    }

    /* Service Links */
    .service-links {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 12px;
      margin-top: 16px;
    }

    .service-link {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding: 16px;
      background: var(--bg-secondary);
      border-radius: 8px;
      text-decoration: none;
      color: var(--text-primary);
      transition: transform 0.2s, background 0.2s;
    }

    .service-link:hover {
      background: var(--bg-tertiary);
      transform: translateY(-2px);
    }

    .service-link .icon {
      width: 32px;
      height: 32px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.25rem;
    }

    .service-link.spotify .icon { background: var(--spotify); }
    .service-link.youtube .icon { background: var(--youtube); }
    .service-link.soundcloud .icon { background: var(--soundcloud); }
    .service-link.bandcamp .icon { background: var(--bandcamp); }

    .service-link .name {
      font-size: 0.875rem;
      font-weight: 500;
    }

    /* Loading */
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 40px;
      color: var(--text-secondary);
    }

    .spinner {
      width: 24px;
      height: 24px;
      border: 2px solid var(--bg-tertiary);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: 12px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Empty state */
    .empty-state {
      text-align: center;
      padding: 40px;
      color: var(--text-secondary);
    }

    /* Hidden */
    .hidden {
      display: none !important;
    }

    /* Generate Link Button */
    .generate-link-container {
      margin-top: 20px;
      text-align: center;
    }

    .generate-link-btn {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 12px 24px;
      background: linear-gradient(135deg, var(--accent), #ec4899);
      border: none;
      border-radius: 8px;
      color: white;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .generate-link-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(139, 92, 246, 0.4);
    }

    .generate-link-btn svg {
      flex-shrink: 0;
    }

    .generate-link-hint {
      margin-top: 8px;
      font-size: 0.75rem;
      color: var(--text-secondary);
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Header -->
    <div class="header">
      <div class="logo">
        <div class="logo-icon">P</div>
        <span>Parachord</span>
      </div>
      <div class="status">
        <span class="status-dot" id="statusDot"></span>
        <span id="statusText">Connecting...</span>
      </div>
    </div>

    <!-- Fallback Notice (shown when not connected) -->
    <div class="fallback-notice hidden" id="fallbackNotice">
      <h3 id="fallbackTitle">Parachord Not Detected</h3>
      <p id="fallbackText">Install Parachord for the full experience, or search for music on these services:</p>
      <div class="service-links">
        <a href="https://open.spotify.com/search/" target="_blank" class="service-link spotify" id="spotifyLink">
          <div class="icon">S</div>
          <span class="name">Spotify</span>
        </a>
        <a href="https://www.youtube.com/results?search_query=" target="_blank" class="service-link youtube" id="youtubeLink">
          <div class="icon">Y</div>
          <span class="name">YouTube</span>
        </a>
        <a href="https://soundcloud.com/search?q=" target="_blank" class="service-link soundcloud" id="soundcloudLink">
          <div class="icon">S</div>
          <span class="name">SoundCloud</span>
        </a>
        <a href="https://bandcamp.com/search?q=" target="_blank" class="service-link bandcamp" id="bandcampLink">
          <div class="icon">B</div>
          <span class="name">Bandcamp</span>
        </a>
      </div>
    </div>

    <!-- Search -->
    <div class="search-container">
      <input type="text" class="search-input" id="searchInput" placeholder="Search for music..." />
    </div>

    <!-- Now Playing (shown when connected) -->
    <div class="now-playing hidden" id="nowPlaying">
      <div class="now-playing-header">Now Playing</div>
      <div class="track-info">
        <div class="album-art" id="albumArt">-</div>
        <div class="track-details">
          <div class="track-title" id="trackTitle">Not playing</div>
          <div class="track-artist" id="trackArtist">-</div>
        </div>
      </div>
      <div class="controls">
        <button class="control-btn" id="prevBtn" title="Previous">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/>
          </svg>
        </button>
        <button class="control-btn play-pause" id="playPauseBtn" title="Play/Pause">
          <svg viewBox="0 0 24 24" fill="currentColor" id="playIcon">
            <path d="M8 5v14l11-7z"/>
          </svg>
          <svg viewBox="0 0 24 24" fill="currentColor" id="pauseIcon" class="hidden">
            <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
          </svg>
        </button>
        <button class="control-btn" id="nextBtn" title="Next">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/>
          </svg>
        </button>
      </div>
    </div>

    <!-- Results -->
    <div class="results hidden" id="results">
      <div class="results-header" id="resultsHeader">Results</div>
      <div id="resultsList"></div>
    </div>

    <!-- Generate Link Button (shown when we have cached URLs) -->
    <div class="generate-link-container hidden" id="generateLinkContainer">
      <button class="generate-link-btn" id="generateLinkBtn">
        <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20">
          <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/>
        </svg>
        Download Smart Link
      </button>
      <p class="generate-link-hint">Creates an HTML page with all resolved service links</p>
    </div>

    <!-- Loading -->
    <div class="loading hidden" id="loading">
      <div class="spinner"></div>
      <span>Searching...</span>
    </div>
  </div>

  <script>
    // Parachord Embed Player
    const PARACHORD_WS_URL = 'ws://127.0.0.1:9876';

    let socket = null;
    let isConnected = false;
    let reconnectTimer = null;
    let pendingRequests = new Map();
    let requestIdCounter = 0;
    let currentState = {
      currentTrack: null,
      isPlaying: false,
      volume: 70
    };

    // Cache for resolved service URLs (persists after disconnect)
    let resolvedServiceUrls = {
      spotify: null,
      youtube: null,
      soundcloud: null,
      bandcamp: null
    };

    // Extract service URL from a track based on resolver ID
    function getServiceUrl(track) {
      if (!track) return null;

      // Try to get URL from track properties
      const url = track.url || track.externalUrl || track.streamUrl;
      if (!url) return null;

      return url;
    }

    // Map resolver ID to service name
    function resolverToService(resolverId) {
      if (!resolverId) return null;
      const id = resolverId.toLowerCase();
      if (id.includes('spotify')) return 'spotify';
      if (id.includes('youtube') || id.includes('yt')) return 'youtube';
      if (id.includes('soundcloud') || id.includes('sc')) return 'soundcloud';
      if (id.includes('bandcamp') || id.includes('bc')) return 'bandcamp';
      return null;
    }

    // Cache URLs from search results
    function cacheResolvedUrls(tracks, query) {
      if (!tracks || !tracks.length) return;

      // Store first track for link generation
      if (!lastSearchTrack && tracks[0]) {
        lastSearchTrack = tracks[0];
      }
      if (query) {
        lastSearchQuery = query;
      }

      tracks.forEach(track => {
        const service = resolverToService(track.resolverId);
        const url = getServiceUrl(track);

        if (service && url && !resolvedServiceUrls[service]) {
          resolvedServiceUrls[service] = url;
          console.log(`[Embed] Cached ${service} URL:`, url);
        }
      });

      // Update the service links with resolved URLs
      updateServiceLinksFromCache();

      // Show generate link button if we have cached URLs
      if (hasAnyCachedUrls()) {
        generateLinkContainer.classList.remove('hidden');
      }
    }

    // Update service link elements from cache
    function updateServiceLinksFromCache() {
      if (resolvedServiceUrls.spotify) {
        spotifyLink.href = resolvedServiceUrls.spotify;
        spotifyLink.querySelector('.name').textContent = 'Spotify ✓';
      }
      if (resolvedServiceUrls.youtube) {
        youtubeLink.href = resolvedServiceUrls.youtube;
        youtubeLink.querySelector('.name').textContent = 'YouTube ✓';
      }
      if (resolvedServiceUrls.soundcloud) {
        soundcloudLink.href = resolvedServiceUrls.soundcloud;
        soundcloudLink.querySelector('.name').textContent = 'SoundCloud ✓';
      }
      if (resolvedServiceUrls.bandcamp) {
        bandcampLink.href = resolvedServiceUrls.bandcamp;
        bandcampLink.querySelector('.name').textContent = 'Bandcamp ✓';
      }
    }

    // Check if we have any cached URLs
    function hasAnyCachedUrls() {
      return Object.values(resolvedServiceUrls).some(url => url !== null);
    }

    // DOM Elements
    const statusDot = document.getElementById('statusDot');
    const statusText = document.getElementById('statusText');
    const fallbackNotice = document.getElementById('fallbackNotice');
    const searchInput = document.getElementById('searchInput');
    const nowPlaying = document.getElementById('nowPlaying');
    const albumArt = document.getElementById('albumArt');
    const trackTitle = document.getElementById('trackTitle');
    const trackArtist = document.getElementById('trackArtist');
    const playPauseBtn = document.getElementById('playPauseBtn');
    const playIcon = document.getElementById('playIcon');
    const pauseIcon = document.getElementById('pauseIcon');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const results = document.getElementById('results');
    const resultsHeader = document.getElementById('resultsHeader');
    const resultsList = document.getElementById('resultsList');
    const loading = document.getElementById('loading');

    // Service link elements for fallback mode
    const spotifyLink = document.getElementById('spotifyLink');
    const youtubeLink = document.getElementById('youtubeLink');
    const soundcloudLink = document.getElementById('soundcloudLink');
    const bandcampLink = document.getElementById('bandcampLink');

    // Fallback notice elements
    const fallbackTitle = document.getElementById('fallbackTitle');
    const fallbackText = document.getElementById('fallbackText');

    // Generate link elements
    const generateLinkContainer = document.getElementById('generateLinkContainer');
    const generateLinkBtn = document.getElementById('generateLinkBtn');

    // Track info for link generation
    let lastSearchQuery = '';
    let lastSearchTrack = null; // First result from search

    // Connect to Parachord
    function connect() {
      if (socket && socket.readyState === WebSocket.OPEN) return;

      try {
        socket = new WebSocket(PARACHORD_WS_URL);

        socket.onopen = () => {
          console.log('[Embed] Connected to Parachord');
          isConnected = true;
          updateStatus(true);
          clearReconnectTimer();

          // Send initial ping
          sendMessage({ type: 'embed', action: 'ping' }).then(response => {
            console.log('[Embed] Parachord version:', response.parachordVersion);
          });

          // Get initial state
          getState();
        };

        socket.onmessage = (event) => {
          try {
            const message = JSON.parse(event.data);
            handleMessage(message);
          } catch (error) {
            console.error('[Embed] Failed to parse message:', error);
          }
        };

        socket.onclose = () => {
          console.log('[Embed] Disconnected from Parachord');
          isConnected = false;
          updateStatus(false);
          scheduleReconnect();
        };

        socket.onerror = (error) => {
          console.error('[Embed] WebSocket error:', error);
        };
      } catch (error) {
        console.error('[Embed] Failed to connect:', error);
        scheduleReconnect();
      }
    }

    function scheduleReconnect() {
      clearReconnectTimer();
      reconnectTimer = setTimeout(connect, 3000);
    }

    function clearReconnectTimer() {
      if (reconnectTimer) {
        clearTimeout(reconnectTimer);
        reconnectTimer = null;
      }
    }

    // Send message with response handling
    function sendMessage(message) {
      return new Promise((resolve, reject) => {
        if (!socket || socket.readyState !== WebSocket.OPEN) {
          reject(new Error('Not connected'));
          return;
        }

        const requestId = `req-${++requestIdCounter}`;
        message.requestId = requestId;

        pendingRequests.set(requestId, { resolve, reject });

        // Timeout after 30 seconds
        setTimeout(() => {
          if (pendingRequests.has(requestId)) {
            pendingRequests.delete(requestId);
            reject(new Error('Request timeout'));
          }
        }, 30000);

        socket.send(JSON.stringify(message));
      });
    }

    // Handle incoming messages
    function handleMessage(message) {
      if (message.type === 'embed-response') {
        const pending = pendingRequests.get(message.requestId);
        if (pending) {
          pendingRequests.delete(message.requestId);
          pending.resolve(message);
        }
      } else if (message.type === 'embed-event') {
        handleEvent(message);
      }
    }

    // Handle events from Parachord
    function handleEvent(event) {
      console.log('[Embed] Event:', event.event, event);

      if (event.event === 'stateChange') {
        if (event.currentTrack !== undefined) {
          currentState.currentTrack = event.currentTrack;
        }
        if (event.isPlaying !== undefined) {
          currentState.isPlaying = event.isPlaying;
        }
        if (event.volume !== undefined) {
          currentState.volume = event.volume;
        }
        updateNowPlaying();
      }
    }

    // Update UI based on connection status
    function updateStatus(connected) {
      if (connected) {
        statusDot.classList.add('connected');
        statusText.textContent = 'Connected';
        fallbackNotice.classList.add('hidden');
        nowPlaying.classList.remove('hidden');
      } else {
        statusDot.classList.remove('connected');
        const hasCached = hasAnyCachedUrls();
        statusText.textContent = hasCached ? 'Disconnected (links cached)' : 'Not connected';
        fallbackNotice.classList.remove('hidden');
        nowPlaying.classList.add('hidden');

        // Update fallback notice text based on cached state
        if (hasCached) {
          fallbackTitle.textContent = 'Listen on Your Favorite Service';
          fallbackText.textContent = 'Direct links resolved from Parachord (✓ = direct link):';
        } else {
          fallbackTitle.textContent = 'Parachord Not Detected';
          fallbackText.textContent = 'Install Parachord for the full experience, or search for music on these services:';
        }

        // Restore cached URLs to service links (they persist after disconnect)
        updateServiceLinksFromCache();
      }
    }

    // Get current state from Parachord
    async function getState() {
      try {
        const response = await sendMessage({ type: 'embed', action: 'getState' });
        if (response.success) {
          currentState.currentTrack = response.currentTrack;
          currentState.isPlaying = response.isPlaying;
          currentState.volume = response.volume;
          updateNowPlaying();
        }
      } catch (error) {
        console.error('[Embed] Failed to get state:', error);
      }
    }

    // Update Now Playing display
    function updateNowPlaying() {
      const track = currentState.currentTrack;

      if (track) {
        trackTitle.textContent = track.title || 'Unknown';
        trackArtist.textContent = track.artist || 'Unknown Artist';

        if (track.albumArt) {
          albumArt.innerHTML = `<img src="${track.albumArt}" alt="Album art" />`;
        } else {
          albumArt.innerHTML = '-';
        }
      } else {
        trackTitle.textContent = 'Not playing';
        trackArtist.textContent = '-';
        albumArt.innerHTML = '-';
      }

      // Update play/pause button
      if (currentState.isPlaying) {
        playIcon.classList.add('hidden');
        pauseIcon.classList.remove('hidden');
      } else {
        playIcon.classList.remove('hidden');
        pauseIcon.classList.add('hidden');
      }
    }

    // Search
    let searchTimeout = null;

    async function search(query) {
      if (!query.trim()) {
        results.classList.add('hidden');
        return;
      }

      // Update fallback links
      const encodedQuery = encodeURIComponent(query);
      spotifyLink.href = `https://open.spotify.com/search/${encodedQuery}`;
      youtubeLink.href = `https://www.youtube.com/results?search_query=${encodedQuery}`;
      soundcloudLink.href = `https://soundcloud.com/search?q=${encodedQuery}`;
      bandcampLink.href = `https://bandcamp.com/search?q=${encodedQuery}`;

      if (!isConnected) {
        // In fallback mode, just update the links
        return;
      }

      loading.classList.remove('hidden');
      results.classList.add('hidden');

      try {
        const response = await sendMessage({
          type: 'embed',
          action: 'search',
          payload: { query }
        });

        loading.classList.add('hidden');

        if (response.success && response.results) {
          displayResults(response.results, query);
        } else {
          console.error('[Embed] Search failed:', response.error);
        }
      } catch (error) {
        loading.classList.add('hidden');
        console.error('[Embed] Search error:', error);
      }
    }

    function displayResults(tracks, query) {
      if (!tracks || tracks.length === 0) {
        resultsList.innerHTML = '<div class="empty-state">No results found</div>';
        results.classList.remove('hidden');
        return;
      }

      // Cache resolved URLs from search results
      cacheResolvedUrls(tracks, query);

      resultsHeader.textContent = `Results for "${query}"`;
      resultsList.innerHTML = tracks.slice(0, 20).map(track => `
        <div class="result-item" data-track='${JSON.stringify(track).replace(/'/g, "\\'")}'>
          <div class="result-art">
            ${track.albumArt ? `<img src="${track.albumArt}" alt="" />` : '-'}
          </div>
          <div class="result-info">
            <div class="result-title">${escapeHtml(track.title || 'Unknown')}</div>
            <div class="result-artist">${escapeHtml(track.artist || 'Unknown Artist')}</div>
          </div>
          <span class="result-source ${track.resolverId || ''}">${track.resolverName || track.resolverId || 'Unknown'}</span>
        </div>
      `).join('');

      // Add click handlers
      resultsList.querySelectorAll('.result-item').forEach(item => {
        item.addEventListener('click', () => {
          const track = JSON.parse(item.dataset.track);
          playTrack(track);
        });
      });

      results.classList.remove('hidden');
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Playback controls
    async function playTrack(track) {
      try {
        await sendMessage({
          type: 'embed',
          action: 'play',
          payload: { track }
        });
      } catch (error) {
        console.error('[Embed] Play failed:', error);
      }
    }

    async function togglePlayPause() {
      if (!isConnected) return;

      try {
        await sendMessage({
          type: 'embed',
          action: currentState.isPlaying ? 'pause' : 'resume'
        });
      } catch (error) {
        console.error('[Embed] Play/pause failed:', error);
      }
    }

    async function previous() {
      if (!isConnected) return;

      try {
        await sendMessage({ type: 'embed', action: 'previous' });
      } catch (error) {
        console.error('[Embed] Previous failed:', error);
      }
    }

    async function next() {
      if (!isConnected) return;

      try {
        await sendMessage({ type: 'embed', action: 'next' });
      } catch (error) {
        console.error('[Embed] Next failed:', error);
      }
    }

    // Event listeners
    searchInput.addEventListener('input', (e) => {
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(() => search(e.target.value), 300);
    });

    searchInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        clearTimeout(searchTimeout);
        search(e.target.value);
      }
    });

    playPauseBtn.addEventListener('click', togglePlayPause);
    prevBtn.addEventListener('click', previous);
    nextBtn.addEventListener('click', next);

    // Generate smart link HTML
    function generateSmartLinkHtml() {
      const track = lastSearchTrack || {};
      const query = lastSearchQuery || 'Unknown Track';
      const title = track.title || query;
      const artist = track.artist || '';
      const albumArt = track.albumArt || '';

      // Build service links HTML
      const services = [
        { id: 'spotify', name: 'Spotify', color: '#1DB954', icon: '●' },
        { id: 'youtube', name: 'YouTube', color: '#FF0000', icon: '▶' },
        { id: 'soundcloud', name: 'SoundCloud', color: '#FF5500', icon: '☁' },
        { id: 'bandcamp', name: 'Bandcamp', color: '#629AA9', icon: '♫' }
      ];

      const serviceLinksHtml = services.map(s => {
        const url = resolvedServiceUrls[s.id];
        if (!url) return '';
        return `
        <a href="${url}" target="_blank" rel="noopener" class="service-link" style="--service-color: ${s.color}">
          <span class="service-icon">${s.icon}</span>
          <span class="service-name">${s.name}</span>
        </a>`;
      }).filter(Boolean).join('\n');

      return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${escapeHtml(title)}${artist ? ' - ' + escapeHtml(artist) : ''} | Listen Now</title>
  <meta property="og:title" content="${escapeHtml(title)}${artist ? ' - ' + escapeHtml(artist) : ''}">
  <meta property="og:description" content="Listen on your favorite streaming service">
  ${albumArt ? `<meta property="og:image" content="${albumArt}">` : ''}
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    :root {
      --bg-primary: #0f0f0f;
      --bg-secondary: #1a1a1a;
      --text-primary: #ffffff;
      --text-secondary: #a0a0a0;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .container {
      max-width: 400px;
      width: 100%;
      padding: 40px 20px;
      text-align: center;
    }
    .album-art {
      width: 200px;
      height: 200px;
      border-radius: 12px;
      margin: 0 auto 24px;
      background: var(--bg-secondary);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    .album-art img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    .track-title {
      font-size: 1.5rem;
      font-weight: 700;
      margin-bottom: 8px;
    }
    .track-artist {
      font-size: 1.125rem;
      color: var(--text-secondary);
      margin-bottom: 32px;
    }
    .services {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .service-link {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 16px 20px;
      background: var(--bg-secondary);
      border-radius: 12px;
      text-decoration: none;
      color: var(--text-primary);
      transition: transform 0.2s, background 0.2s;
    }
    .service-link:hover {
      background: #252525;
      transform: translateY(-2px);
    }
    .service-icon {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      background: var(--service-color);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.25rem;
    }
    .service-name {
      flex: 1;
      font-weight: 500;
      text-align: left;
    }
    .footer {
      margin-top: 40px;
      font-size: 0.75rem;
      color: var(--text-secondary);
    }
    .footer a { color: #8b5cf6; text-decoration: none; }
  </style>
</head>
<body>
  <div class="container">
    <div class="album-art">
      ${albumArt ? `<img src="${albumArt}" alt="Album art">` : '♫'}
    </div>
    <h1 class="track-title">${escapeHtml(title)}</h1>
    ${artist ? `<p class="track-artist">${escapeHtml(artist)}</p>` : ''}
    <div class="services">
      ${serviceLinksHtml}
    </div>
    <p class="footer">Created with <a href="https://parachord.app">Parachord</a></p>
  </div>
</body>
</html>`;
    }

    // Download the generated HTML file
    function downloadSmartLink() {
      const html = generateSmartLinkHtml();
      const blob = new Blob([html], { type: 'text/html' });
      const url = URL.createObjectURL(blob);

      const filename = (lastSearchQuery || 'smart-link').toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/-+/g, '-')
        .replace(/^-|-$/g, '') + '.html';

      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    generateLinkBtn.addEventListener('click', downloadSmartLink);

    // Start connection
    connect();

    // Periodic state refresh
    setInterval(() => {
      if (isConnected) {
        getState();
      }
    }, 5000);
  </script>
</body>
</html>
