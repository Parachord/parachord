// Harmonix Desktop App - Electron Version
const { useState, useEffect, useRef } = React;

// Use lucide-react icons if available, otherwise fallback to emoji
const Icons = typeof lucideReact !== 'undefined' ? lucideReact : {
  Play: () => React.createElement('span', null, 'â–¶'),
  Pause: () => React.createElement('span', null, 'â¸'),
  SkipForward: () => React.createElement('span', null, 'â­'),
  SkipBack: () => React.createElement('span', null, 'â®'),
  Volume2: () => React.createElement('span', null, 'ðŸ”Š'),
  Music: () => React.createElement('span', null, 'â™«'),
  List: () => React.createElement('span', null, 'â˜°'),
  Users: () => React.createElement('span', null, 'ðŸ‘¥'),
  Radio: () => React.createElement('span', null, 'ðŸ“»'),
  Heart: () => React.createElement('span', null, 'â™¥'),
  Search: () => React.createElement('span', null, 'ðŸ”'),
  Settings: () => React.createElement('span', null, 'âš™'),
  Plus: () => React.createElement('span', null, '+'),
  X: () => React.createElement('span', null, 'âœ•'),
};

const { Play, Pause, SkipForward, SkipBack, Volume2, Search, List, Settings, Plus, Music, Radio, Users, Heart, X } = Icons;

// Function to load built-in resolvers from resolvers/builtin/ directory
const loadBuiltinResolvers = async () => {
  const resolverFiles = [
    'resolvers/builtin/spotify.axe',
    'resolvers/builtin/bandcamp.axe',
    'resolvers/builtin/qobuz.axe',
    'resolvers/builtin/musicbrainz.axe'
  ];
  
  const resolvers = [];
  
  for (const file of resolverFiles) {
    try {
      const response = await fetch(file);
      if (!response.ok) {
        console.error(`âŒ Failed to load ${file}: ${response.status}`);
        continue;
      }
      const axe = await response.json();
      resolvers.push(axe);
      console.log(`âœ… Loaded ${axe.manifest.name} resolver from ${file}`);
    } catch (error) {
      console.error(`âŒ Error loading ${file}:`, error);
    }
  }
  
  return resolvers;
};



// TrackRow component - defined outside to prevent recreation on every render
const TrackRow = React.memo(({ track, isPlaying, handlePlay, onArtistClick }) => {
  const isSpotifyTrack = track.sources?.includes('spotify');
  const isMusicBrainzTrack = track.sources?.includes('musicbrainz');
  const isBandcampTrack = track.sources?.includes('bandcamp');
  const isQobuzTrack = track.sources?.includes('qobuz');
  
  return React.createElement('div', {
    className: 'group flex items-center gap-4 p-3 rounded-lg hover:bg-white/10 transition-colors no-drag'
  },
    // Album art or play button
    React.createElement('div', { className: 'relative w-12 h-12 flex-shrink-0' },
      track.albumArt ? 
        React.createElement('img', {
          src: track.albumArt,
          alt: track.album,
          className: 'w-12 h-12 rounded object-cover'
        })
      :
        React.createElement('div', {
          className: 'w-12 h-12 bg-gradient-to-br from-purple-500 to-pink-500 rounded flex items-center justify-center'
        }, React.createElement(Music)),
      React.createElement('button', {
        onClick: () => handlePlay(track),
        className: 'absolute inset-0 flex items-center justify-center rounded bg-black/60 opacity-0 group-hover:opacity-100 transition-opacity'
      }, 
        React.createElement('div', { className: 'w-8 h-8 flex items-center justify-center rounded-full bg-purple-600 text-sm' },
          isPlaying ? React.createElement(Pause) : React.createElement(Play)
        )
      )
    ),
    React.createElement('div', { className: 'flex-1 min-w-0' },
      React.createElement('div', { className: `font-medium truncate ${isPlaying ? 'text-purple-400' : ''}` }, track.title),
      React.createElement('div', { className: 'flex items-center gap-2' },
        React.createElement('button', {
          onClick: (e) => {
            e.stopPropagation();
            if (onArtistClick) {
              onArtistClick(track.artist);
            }
          },
          className: 'text-sm text-gray-400 truncate hover:text-purple-400 hover:underline cursor-pointer transition-colors',
          title: `View ${track.artist}'s discography`
        }, track.artist),
        isSpotifyTrack && React.createElement('span', {
          className: 'text-xs px-2 py-0.5 bg-green-600/20 text-green-400 rounded-full'
        }, 'â™« Spotify'),
        isMusicBrainzTrack && React.createElement('span', {
          className: 'text-xs px-2 py-0.5 bg-purple-600/20 text-purple-400 rounded-full'
        }, 'â™ª MusicBrainz'),
        isBandcampTrack && React.createElement('span', {
          className: 'text-xs px-2 py-0.5 bg-cyan-600/20 text-cyan-400 rounded-full'
        }, 'â–¶ Bandcamp'),
        isQobuzTrack && React.createElement('span', {
          className: 'text-xs px-2 py-0.5 bg-blue-600/20 text-blue-400 rounded-full'
        }, 'â—† Qobuz')
      )
    ),
    React.createElement('div', { className: 'text-sm text-gray-400 truncate max-w-[200px]' }, track.album),
    React.createElement('div', { className: 'text-sm text-gray-400 w-12 text-right' },
      `${Math.floor(track.duration / 60)}:${(track.duration % 60).toString().padStart(2, '0')}`
    )
  );
});

// ReleaseCard component - FRESH START - Ultra simple, no complications
const ReleaseCard = ({ release, currentArtist, fetchReleaseData, isVisible = true }) => {
  const year = release.date ? release.date.split('-')[0] : 'Unknown';
  
  const cardStyle = {
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
    borderRadius: '12px',
    padding: '16px',
    cursor: 'pointer',
    border: '1px solid rgba(255, 255, 255, 0.1)',
    transition: 'transform 0.2s, background-color 0.2s'
  };
  
  const handleClick = () => {
    console.log('ðŸŽµ Card clicked:', release.title);
    fetchReleaseData(release, currentArtist);
  };
  
  return React.createElement('button', {
    className: 'no-drag',
    style: {
      ...cardStyle,
      width: '100%',
      textAlign: 'left',
      display: isVisible ? 'block' : 'none'  // Hide with CSS instead of destroying DOM
    },
    onClick: handleClick,
    onMouseEnter: (e) => {
      e.currentTarget.style.transform = 'scale(1.05)';
      e.currentTarget.style.backgroundColor = 'rgba(124, 58, 237, 0.2)';
    },
    onMouseLeave: (e) => {
      e.currentTarget.style.transform = 'scale(1)';
      e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.05)';
    }
  },
    // Album art - shows image when loaded, gradient placeholder when not
    React.createElement('div', {
      style: {
        width: '100%',
        aspectRatio: '1',
        borderRadius: '8px',
        background: release.albumArt ? 'none' : 'linear-gradient(135deg, #9333ea 0%, #ec4899 100%)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        marginBottom: '12px',
        pointerEvents: 'none',
        overflow: 'hidden',
        position: 'relative'
      }
    },
      // Album art image (if loaded)
      release.albumArt && React.createElement('img', {
        src: release.albumArt,
        alt: release.title,
        style: {
          width: '100%',
          height: '100%',
          objectFit: 'cover',
          pointerEvents: 'none'
        }
      }),
      
      // Music icon placeholder (only when no album art)
      !release.albumArt && React.createElement('svg', {
        style: { 
          width: '48px', 
          height: '48px', 
          color: 'rgba(255, 255, 255, 0.5)',
          pointerEvents: 'none'
        },
        fill: 'none',
        viewBox: '0 0 24 24',
        stroke: 'currentColor',
        strokeWidth: 2
      },
        React.createElement('path', {
          strokeLinecap: 'round',
          strokeLinejoin: 'round',
          d: 'M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3'
        })
      )
    ),
    
    // Title
    React.createElement('h3', {
      style: {
        fontWeight: '600',
        fontSize: '14px',
        marginBottom: '4px',
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        whiteSpace: 'nowrap',
        color: 'white',
        pointerEvents: 'none'  // KEY FIX!
      },
      title: release.title
    }, release.title),
    
    // Year
    React.createElement('p', {
      style: {
        fontSize: '12px',
        color: '#9ca3af',
        marginBottom: '8px',
        pointerEvents: 'none'  // KEY FIX!
      }
    }, year),
    
    // Badge
    React.createElement('span', {
      style: {
        display: 'inline-block',
        padding: '2px 8px',
        fontSize: '11px',
        borderRadius: '9999px',
        backgroundColor: release.releaseType === 'album' ? 'rgba(37, 99, 235, 0.2)' :
                        release.releaseType === 'ep' ? 'rgba(22, 163, 74, 0.2)' :
                        'rgba(168, 85, 247, 0.2)',
        color: release.releaseType === 'album' ? '#60a5fa' :
              release.releaseType === 'ep' ? '#4ade80' :
              '#a78bfa',
        pointerEvents: 'none'  // KEY FIX!
      }
    }, release.releaseType.toUpperCase())
  );
};

// ReleasePage component - Shows full album/EP/single with tracklist
const ReleasePage = ({ release, handleSearch, handlePlay, trackSources = {}, resolvers = [] }) => {
  const formatDuration = (ms) => {
    if (!ms) return '';
    const totalSeconds = Math.floor(ms / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
  };

  return React.createElement('div', { className: 'space-y-6' },
    // Release info and album art
    React.createElement('div', { className: 'flex gap-6' },
      // Album art
      release.albumArt ?
        React.createElement('img', {
          src: release.albumArt,
          alt: release.title,
          className: 'w-64 h-64 rounded-lg object-cover'
        })
      :
        React.createElement('div', {
          className: 'w-64 h-64 rounded-lg bg-gradient-to-br from-purple-600 to-pink-600 flex items-center justify-center'
        },
          React.createElement('svg', {
            className: 'w-24 h-24 text-white/50',
            fill: 'none',
            viewBox: '0 0 24 24',
            stroke: 'currentColor'
          },
            React.createElement('path', {
              strokeLinecap: 'round',
              strokeLinejoin: 'round',
              strokeWidth: 2,
              d: 'M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3'
            })
          )
        ),
      
      // Metadata
      React.createElement('div', { className: 'flex-1' },
        React.createElement('div', { className: 'space-y-2 text-sm' },
          React.createElement('div', {},
            React.createElement('span', { className: 'text-gray-400' }, 'Type: '),
            React.createElement('span', {
              className: `inline-block px-2 py-0.5 rounded-full text-xs ${
                release.releaseType === 'album' ? 'bg-blue-600/20 text-blue-400' :
                release.releaseType === 'ep' ? 'bg-green-600/20 text-green-400' :
                'bg-purple-600/20 text-purple-400'
              }`
            }, release.releaseType.toUpperCase())
          ),
          release.date && React.createElement('div', {},
            React.createElement('span', { className: 'text-gray-400' }, 'Released: '),
            React.createElement('span', {}, release.date)
          ),
          release.label && React.createElement('div', {},
            React.createElement('span', { className: 'text-gray-400' }, 'Label: '),
            React.createElement('span', {}, release.label)
          ),
          release.country && React.createElement('div', {},
            React.createElement('span', { className: 'text-gray-400' }, 'Country: '),
            React.createElement('span', {}, release.country)
          ),
          release.tracks.length > 0 && React.createElement('div', {},
            React.createElement('span', { className: 'text-gray-400' }, 'Tracks: '),
            React.createElement('span', {}, release.tracks.length)
          )
        )
      )
    ),
    
    // Tracklist
    React.createElement('div', { className: 'mt-8' },
      React.createElement('h2', { className: 'text-2xl font-bold mb-4' }, 'Tracklist'),
      release.tracks.length > 0 ?
        React.createElement('div', { className: 'space-y-1' },
          release.tracks.map((track, index) => {
            const trackKey = `${track.position}-${track.title}`;
            const sources = trackSources[trackKey] || {};
            const availableResolvers = Object.keys(sources);
            
            return React.createElement('div', {
              key: index,
              className: 'flex items-center gap-4 p-3 rounded-lg hover:bg-white/5 cursor-pointer transition-colors no-drag group',
              onClick: () => {
                console.log('Track row clicked:', track.title);
                
                // If we have resolved sources, play the best one based on priority AND confidence
                if (availableResolvers.length > 0) {
                  // Sort sources by: 1) resolver priority (lower index = higher priority), 2) confidence
                  const sortedSources = availableResolvers.map(resolverId => ({
                    resolverId,
                    source: sources[resolverId],
                    priority: resolverOrder.indexOf(resolverId),
                    confidence: sources[resolverId].confidence || 0
                  }))
                  .filter(s => activeResolvers.includes(s.resolverId)) // Only enabled resolvers
                  .sort((a, b) => {
                    // First sort by priority (lower index = higher priority)
                    if (a.priority !== b.priority) {
                      return a.priority - b.priority;
                    }
                    // If same priority, sort by confidence (higher = better)
                    return b.confidence - a.confidence;
                  });
                  
                  const best = sortedSources[0];
                  const bestSource = best.source;
                  const bestResolver = best.resolverId;
                  
                  console.log(`ðŸŽµ Playing from ${bestResolver} (priority #${best.priority + 1}, confidence: ${(best.confidence * 100).toFixed(0)}%)`);
                  handlePlay(bestSource);
                } else {
                  // No resolved sources yet, fall back to search
                  console.log('No resolved sources, searching...');
                  handleSearch(`${release.artist.name} ${track.title}`);
                }
              }
            },
              // Track number
              React.createElement('span', {
                className: 'text-gray-400 text-sm w-8 flex-shrink-0',
                style: { pointerEvents: 'none' }
              }, track.position),
              
              // Track title
              React.createElement('span', {
                className: 'flex-1 group-hover:text-purple-400 transition-colors',
                style: { pointerEvents: 'none' }
              }, track.title),
              
              // Duration
              track.length && React.createElement('span', {
                className: 'text-gray-400 text-sm flex-shrink-0',
                style: { pointerEvents: 'none' }
              }, formatDuration(track.length)),
              
              // Resolver icons (sources available for this track)
              React.createElement('div', {
                className: 'flex items-center gap-1 flex-shrink-0',
                style: { pointerEvents: 'none' }
              },
                (() => {
                  const trackKey = `${track.position}-${track.title}`;
                  const sources = trackSources[trackKey] || {};
                  const availableResolvers = Object.keys(sources);
                  
                  if (availableResolvers.length === 0) {
                    // Show loading indicator while resolving
                    return React.createElement('span', {
                      className: 'text-xs text-gray-500',
                      title: 'Searching for sources...'
                    }, 'ðŸ”');
                  }
                  
                  // Show resolver icons for available sources
                  return availableResolvers.map(resolverId => {
                    const resolver = resolvers.find(r => r.id === resolverId);
                    if (!resolver) return null;
                    
                    const source = sources[resolverId];
                    const confidence = source.confidence || 0;
                    
                    return React.createElement('button', {
                      key: resolverId,
                      className: 'no-drag',
                      onClick: (e) => {
                        e.stopPropagation(); // Don't trigger row click
                        console.log(`Playing from ${resolver.name}:`, source);
                        
                        // Call handlePlay with the resolved source
                        // The source already has the right structure from the resolver
                        handlePlay(source);
                      },
                      style: {
                        width: '24px',
                        height: '24px',
                        borderRadius: '4px',
                        backgroundColor: resolver.color,
                        border: 'none',
                        cursor: 'pointer',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        fontSize: '10px',
                        fontWeight: 'bold',
                        color: 'white',
                        pointerEvents: 'auto',
                        opacity: confidence > 0.8 ? 1 : 0.6,
                        transition: 'transform 0.1s'
                      },
                      onMouseEnter: (e) => e.currentTarget.style.transform = 'scale(1.1)',
                      onMouseLeave: (e) => e.currentTarget.style.transform = 'scale(1)',
                      title: `Play from ${resolver.name} (${Math.round(confidence * 100)}% match)`
                    }, resolver.name.slice(0, 2).toUpperCase());
                  });
                })()
              ),
              
              // Play icon
              React.createElement('svg', {
                className: 'w-5 h-5 text-purple-400 opacity-0 group-hover:opacity-100 transition-opacity flex-shrink-0',
                fill: 'currentColor',
                viewBox: '0 0 24 24',
                style: { pointerEvents: 'none' }
              },
                React.createElement('path', {
                  d: 'M8 5v14l11-7z'
                })
              )
            );
          })
        )
      :
        React.createElement('div', { className: 'text-center py-12 text-gray-400' },
          'No track information available'
        )
    )
  );
};

const Harmonix = () => {
  const [currentTrack, setCurrentTrack] = useState(null);
  const [isPlaying, setIsPlaying] = useState(false);
  const [progress, setProgress] = useState(0);
  const [volume, setVolume] = useState(70);
  const [searchQuery, setSearchQuery] = useState('');
  const [searchResults, setSearchResults] = useState([]);
  const [isSearching, setIsSearching] = useState(false);
  const [resultFilters, setResultFilters] = useState([]); // Which resolvers to show in results
  const [activeView, setActiveView] = useState('library');
  const [currentArtist, setCurrentArtist] = useState(null); // Artist page data
  const [artistReleases, setArtistReleases] = useState([]); // Discography
  const [releaseTypeFilter, setReleaseTypeFilter] = useState('all'); // all, album, ep, single
  const [loadingArtist, setLoadingArtist] = useState(false);
  const [currentRelease, setCurrentRelease] = useState(null); // Release/Album page data
  const [loadingRelease, setLoadingRelease] = useState(false);
  const [trackSources, setTrackSources] = useState({}); // Resolved sources for each track: { trackId: { youtube: {...}, soundcloud: {...} } }
  const [activeResolvers, setActiveResolvers] = useState(['spotify', 'bandcamp', 'qobuz']);
  const [resolverOrder, setResolverOrder] = useState(['spotify', 'bandcamp', 'qobuz', 'musicbrainz', 'youtube', 'soundcloud']);
  const [draggedResolver, setDraggedResolver] = useState(null);
  const [library, setLibrary] = useState([]);
  const [audioContext, setAudioContext] = useState(null);
  const [currentSource, setCurrentSource] = useState(null);
  const [startTime, setStartTime] = useState(0);
  const [showSettings, setShowSettings] = useState(false);
  const [spotifyToken, setSpotifyToken] = useState(null);
  const [spotifyConnected, setSpotifyConnected] = useState(false);
  const [qobuzToken, setQobuzToken] = useState(null);
  const [qobuzConnected, setQobuzConnected] = useState(false);

  // Resolver plugin system
  const resolverLoader = useRef(null);
  const [loadedResolvers, setLoadedResolvers] = useState([]);

  // Cache for album art URLs (releaseId -> imageUrl)
  const albumArtCache = useRef({});

  const sampleTracks = [
    { id: 1, title: 'Midnight Dreams', artist: 'Luna Echo', album: 'Nocturnal', duration: 245, sources: ['youtube', 'soundcloud'] },
    { id: 2, title: 'Electric Pulse', artist: 'Neon Waves', album: 'Synthwave', duration: 198, sources: ['youtube'] },
    { id: 3, title: 'Ocean Breeze', artist: 'Coastal Drift', album: 'Tides', duration: 267, sources: ['soundcloud', 'youtube'] },
    { id: 4, title: 'Urban Nights', artist: 'City Lights', album: 'Metropolitan', duration: 223, sources: ['youtube'] },
    { id: 5, title: 'Forest Path', artist: 'Nature Sound', album: 'Wilderness', duration: 301, sources: ['youtube', 'soundcloud'] },
  ];

  // Initialize resolver plugin system
  useEffect(() => {
    const initResolvers = async () => {
      console.log('ðŸ”Œ Initializing resolver plugin system...');
      
      // Check if ResolverLoader is available
      if (typeof ResolverLoader === 'undefined') {
        console.error('âŒ ResolverLoader not found! Make sure resolver-loader.js is loaded.');
        return;
      }
      
      // Create resolver loader
      resolverLoader.current = new ResolverLoader();
      
      try {
        // Load built-in resolvers from resolvers/builtin/ directory
        console.log('ðŸ“ Loading resolver .axe files from resolvers/builtin/...');
        const builtinAxeFiles = await loadBuiltinResolvers();
        
        if (builtinAxeFiles.length === 0) {
          console.error('âŒ No resolvers loaded! Make sure .axe files are in resolvers/builtin/');
          return;
        }
        
        const resolvers = await resolverLoader.current.loadResolvers(builtinAxeFiles);
        setLoadedResolvers(resolvers);
        console.log(`âœ… Loaded ${resolvers.length} resolver plugins:`, resolvers.map(r => r.name).join(', '));
      } catch (error) {
        console.error('âŒ Failed to load resolvers:', error);
      }
    };
    
    initResolvers();
  }, []);

  // Use loaded resolvers or fallback to empty array
  const allResolvers = loadedResolvers.length > 0 ? loadedResolvers : [];

  // Get resolvers in priority order
  const resolvers = resolverOrder
    .map(id => allResolvers.find(r => r.id === id))
    .filter(Boolean);

  // Helper function to get resolver config
  const getResolverConfig = (resolverId) => {
    const configs = {
      spotify: { token: spotifyToken },
      qobuz: { appId: '285473059', volume: volume / 100 },
      bandcamp: {},
      musicbrainz: {}
    };
    return configs[resolverId] || {};
  };

  const SPOTIFY_CLIENT_ID = 'c040c0ee133344b282e6342198bcbeea';

  useEffect(() => {
    setLibrary(sampleTracks);
    const context = new (window.AudioContext || window.webkitAudioContext)();
    setAudioContext(context);
    return () => context.close();
  }, []);

  useEffect(() => {
    if (isPlaying && audioContext && currentTrack) {
      const interval = setInterval(() => {
        const elapsed = (audioContext.currentTime - startTime);
        if (elapsed >= currentTrack.duration) {
          handleNext();
        } else {
          setProgress(elapsed);
        }
      }, 100);
      return () => clearInterval(interval);
    }
  }, [isPlaying, audioContext, currentTrack, startTime]);

  const playDemoAudio = (track) => {
    if (!audioContext) return;
    if (currentSource) {
      try { currentSource.stop(); } catch (e) {}
    }
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    oscillator.type = 'sine';
    oscillator.frequency.setValueAtTime(440 + (track.id * 100), audioContext.currentTime);
    gainNode.gain.setValueAtTime(volume / 100, audioContext.currentTime);
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    oscillator.start();
    setCurrentSource(oscillator);
    setStartTime(audioContext.currentTime);
  };

  const handlePlay = async (track) => {
    console.log('ðŸŽµ Playing track:', track.title, 'by', track.artist);
    
    // Detect which resolver to use from track.sources
    const resolverId = track.sources?.[0];
    if (!resolverId) {
      console.error('âŒ No resolver found for track');
      return;
    }
    
    const resolver = allResolvers.find(r => r.id === resolverId);
    if (!resolver) {
      console.error(`âŒ Resolver ${resolverId} not found`);
      return;
    }
    
    // Check if resolver can stream
    if (!resolver.capabilities.stream) {
      // For non-streaming resolvers (like Bandcamp, MusicBrainz)
      if (resolverId === 'bandcamp' && track.bandcampUrl) {
        console.log('ðŸŽ¸ Opening Bandcamp in browser...');
        const config = getResolverConfig(resolverId);
        await resolver.play(track, config);
        return;
      } else if (resolverId === 'musicbrainz') {
        alert('MusicBrainz provides metadata only. Try searching for this track on Spotify to play it.');
        return;
      }
    }
    
    // Use resolver's play method
    try {
      const config = getResolverConfig(resolverId);
      console.log(`â–¶ï¸ Using ${resolver.name} to play track...`);
      
      const success = await resolver.play(track, config);
      
      if (success) {
        console.log(`âœ… Playing on ${resolver.name}`);
        setCurrentTrack(track);
        setIsPlaying(true);
        setProgress(0);
      } else {
        console.error(`âŒ ${resolver.name} playback failed`);
      }
    } catch (error) {
      console.error(`âŒ Error playing with ${resolver.name}:`, error);
    }
  };

  const handlePlayPause = async () => {
    if (!currentTrack) return;
    
    const isSpotifyTrack = currentTrack.sources?.includes('spotify') || currentTrack.spotifyUri;
    
    if (isSpotifyTrack && spotifyToken) {
      // Control Spotify playback
      try {
        const endpoint = isPlaying ? 
          'https://api.spotify.com/v1/me/player/pause' :
          'https://api.spotify.com/v1/me/player/play';
        
        const response = await fetch(endpoint, {
          method: 'PUT',
          headers: {
            'Authorization': `Bearer ${spotifyToken}`
          }
        });
        
        if (response.ok || response.status === 204) {
          setIsPlaying(!isPlaying);
          console.log(isPlaying ? 'Paused' : 'Resumed', 'Spotify playback');
        }
      } catch (error) {
        console.error('Spotify play/pause error:', error);
      }
    } else {
      // Toggle local playback
      if (!audioContext) return;
      if (isPlaying) {
        setIsPlaying(false);
        if (currentSource) {
          try { currentSource.stop(); setCurrentSource(null); } catch (e) {}
        }
      } else {
        if (audioContext.state === 'suspended') await audioContext.resume();
        setIsPlaying(true);
        playDemoAudio(currentTrack);
      }
    }
  };

  const handleNext = async () => {
    const isSpotifyTrack = currentTrack?.sources?.includes('spotify') || currentTrack?.spotifyUri;
    
    if (isSpotifyTrack && spotifyToken) {
      // Use Spotify's next track
      try {
        const response = await fetch('https://api.spotify.com/v1/me/player/next', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${spotifyToken}`
          }
        });
        
        if (response.ok || response.status === 204) {
          console.log('Skipped to next Spotify track');
          // Poll after 1 second to get updated track info
          // (longer delay to ensure Spotify has switched tracks)
          setTimeout(() => getCurrentPlaybackState(), 1000);
        }
      } catch (error) {
        console.error('Spotify next error:', error);
      }
    } else {
      // Local track - find next in library
      const currentIndex = library.findIndex(t => t.id === currentTrack?.id);
      const nextTrack = library[(currentIndex + 1) % library.length];
      handlePlay(nextTrack);
    }
  };

  const handlePrevious = async () => {
    if (!currentTrack) return;
    
    const isSpotifyTrack = currentTrack.sources?.includes('spotify') || currentTrack.spotifyUri;
    
    if (isSpotifyTrack && spotifyToken) {
      // Use Spotify's previous track
      try {
        const response = await fetch('https://api.spotify.com/v1/me/player/previous', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${spotifyToken}`
          }
        });
        
        if (response.ok || response.status === 204) {
          console.log('Skipped to previous Spotify track');
          // Poll after 1 second to get updated track info
          // (longer delay to ensure Spotify has switched tracks)
          setTimeout(() => getCurrentPlaybackState(), 1000);
        }
      } catch (error) {
        console.error('Spotify previous error:', error);
      }
    } else {
      // Local track - find previous in library
      const currentIndex = library.findIndex(t => t.id === currentTrack?.id);
      const prevTrack = library[(currentIndex - 1 + library.length) % library.length];
      handlePlay(prevTrack);
    }
  };

  const handleSearch = async (query) => {
    setSearchQuery(query);
    
    // Initialize filters with all active resolvers when starting a new search
    if (query.trim()) {
      setResultFilters(activeResolvers.slice()); // Copy of active resolvers
      setIsSearching(true);
      
      // Search local library
      const localResults = library.filter(track =>
        track.title.toLowerCase().includes(query.toLowerCase()) ||
        track.artist.toLowerCase().includes(query.toLowerCase())
      );
      
      // Search using resolver plugins
      const searchPromises = activeResolvers.map(async (resolverId) => {
        const resolver = allResolvers.find(r => r.id === resolverId);
        if (!resolver || !resolver.capabilities.search) {
          return [];
        }
        
        try {
          const config = getResolverConfig(resolverId);
          const results = await resolver.search(query, config);
          console.log(`ðŸ” ${resolver.name}: Found ${results.length} results`);
          return results;
        } catch (error) {
          console.error(`âŒ ${resolver.name} search error:`, error);
          return [];
        }
      });
      
      try {
        const results = await Promise.all(searchPromises);
        const allRemoteResults = results.flat();
        
        // Combine local and remote results
        const combined = [...localResults, ...allRemoteResults];
        setSearchResults(combined);
        console.log(`âœ… Total search results: ${combined.length}`);
      } catch (err) {
        console.error('Search error:', err);
        setSearchResults(localResults); // Fall back to local only
      }
      
      setIsSearching(false);
    } else {
      setSearchResults([]);
      setIsSearching(false);
    }
  };


  // Fetch artist data and discography from MusicBrainz
  const fetchArtistData = async (artistName) => {
    console.log('Fetching artist data for:', artistName);
    setLoadingArtist(true);
    setActiveView('artist'); // Show artist page immediately with loading animation
    
    try {
      // Step 1: Search for artist by name to get MBID
      const searchResponse = await fetch(
        `https://musicbrainz.org/ws/2/artist?query=${encodeURIComponent(artistName)}&fmt=json&limit=1`,
        {
          headers: {
            'User-Agent': 'Harmonix/1.0.0 (https://github.com/harmonix)'
          }
        }
      );
      
      if (!searchResponse.ok) {
        console.error('Artist search failed:', searchResponse.status);
        setLoadingArtist(false);
        return;
      }
      
      const searchData = await searchResponse.json();
      
      if (!searchData.artists || searchData.artists.length === 0) {
        console.log('Artist not found');
        alert(`Artist "${artistName}" not found in MusicBrainz`);
        setLoadingArtist(false);
        return;
      }
      
      const artist = searchData.artists[0];
      console.log('Found artist:', artist.name, 'MBID:', artist.id);
      
      // Step 2: Fetch artist's releases (albums, EPs, singles)
      const releaseTypes = ['album', 'ep', 'single'];
      const allReleases = [];
      
      for (const type of releaseTypes) {
        const releasesResponse = await fetch(
          `https://musicbrainz.org/ws/2/release?artist=${artist.id}&type=${type}&status=official&fmt=json&limit=100`,
          {
            headers: {
              'User-Agent': 'Harmonix/1.0.0 (https://github.com/harmonix)'
            }
          }
        );
        
        if (releasesResponse.ok) {
          const releasesData = await releasesResponse.json();
          if (releasesData.releases) {
            const typedReleases = releasesData.releases.map(release => ({
              ...release,
              releaseType: type
            }));
            allReleases.push(...typedReleases);
          }
        }
        
        // Rate limiting - wait 1 second between requests
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
      
      console.log(`Found ${allReleases.length} releases for ${artist.name}`);
      
      // Sort by date (newest first)
      allReleases.sort((a, b) => {
        const dateA = a.date || '0000';
        const dateB = b.date || '0000';
        return dateB.localeCompare(dateA);
      });
      
      setCurrentArtist({
        name: artist.name,
        mbid: artist.id,
        country: artist.country,
        disambiguation: artist.disambiguation,
        type: artist.type
      });
      
      // Pre-populate releases with cached album art
      const releasesWithCache = allReleases.map(release => ({
        ...release,
        albumArt: albumArtCache.current[release.id] || null
      }));
      
      // Show page immediately (with cached album art if available)
      setArtistReleases(releasesWithCache);
      setLoadingArtist(false);
      
      // Fetch album art in background (lazy loading) - only for releases without cache
      fetchAlbumArtLazy(allReleases);
      
    } catch (error) {
      console.error('Error fetching artist data:', error);
      alert('Failed to load artist data. Please try again.');
      setLoadingArtist(false);
    }
  };

  // Fetch release data (album/EP/single) with full track listing
  const fetchReleaseData = async (release, artist) => {
    setLoadingRelease(true);
    setCurrentRelease(null);
    
    try {
      console.log('Fetching release data for:', release.title);
      
      // Fetch full release details including recordings (tracks)
      const releaseResponse = await fetch(
        `https://musicbrainz.org/ws/2/release/${release.id}?inc=recordings+artist-credits&fmt=json`,
        { 
          headers: { 'User-Agent': 'Harmonix/1.0.0 (https://github.com/harmonix)' }
        }
      );
      
      if (!releaseResponse.ok) {
        throw new Error('Release not found');
      }
      
      const releaseData = await releaseResponse.json();
      
      // Extract track listing from media
      const tracks = [];
      if (releaseData.media && releaseData.media.length > 0) {
        releaseData.media.forEach((medium, mediumIndex) => {
          if (medium.tracks) {
            medium.tracks.forEach(track => {
              tracks.push({
                position: track.position,
                title: track.title || track.recording?.title || 'Unknown Track',
                length: track.length,
                recording: track.recording,
                mediumIndex: mediumIndex + 1,
                mediumTitle: medium.title
              });
            });
          }
        });
      }
      
      // Try to fetch album art
      let albumArt = null;
      try {
        const artResponse = await fetch(
          `https://coverartarchive.org/release/${release.id}`,
          { headers: { 'User-Agent': 'Harmonix/1.0.0 (https://github.com/harmonix)' }}
        );
        
        if (artResponse.ok) {
          const artData = await artResponse.json();
          const frontCover = artData.images.find(img => img.front);
          if (frontCover) {
            albumArt = frontCover.thumbnails?.['500'] || frontCover.image;
          }
        }
      } catch (error) {
        console.log('No album art found');
      }
      
      const releaseInfo = {
        id: releaseData.id,
        title: releaseData.title,
        artist: artist,
        date: releaseData.date || release.date,
        releaseType: release.releaseType,
        tracks: tracks,
        albumArt: albumArt,
        barcode: releaseData.barcode,
        country: releaseData.country,
        label: releaseData['label-info']?.[0]?.label?.name
      };
      
      console.log('Release data loaded:', tracks.length, 'tracks');
      setCurrentRelease(releaseInfo);
      setLoadingRelease(false);
      
      // Start resolving tracks in background
      resolveAllTracks(releaseInfo, artist.name);
      
    } catch (error) {
      console.error('Error fetching release data:', error);
      alert('Failed to load release data. Please try again.');
      setLoadingRelease(false);
    }
  };

  // Resolve a single track across all active resolvers
  const resolveTrack = async (track, artistName) => {
    const trackKey = `${track.position}-${track.title}`;
    console.log(`ðŸ” Resolving: ${artistName} - ${track.title}`);
    
    const sources = {};
    
    // Query enabled resolvers in priority order
    const enabledResolvers = resolverOrder
      .filter(id => activeResolvers.includes(id))
      .map(id => allResolvers.find(r => r.id === id))
      .filter(Boolean);
    
    const resolverPromises = enabledResolvers.map(async (resolver) => {
      if (!resolver.capabilities.resolve) return;
      
      try {
        const config = getResolverConfig(resolver.id);
        const result = await resolver.resolve(artistName, track.title, null, config);
        
        if (result) {
          sources[resolver.id] = {
            ...result,
            confidence: calculateConfidence(track, result)
          };
          console.log(`  âœ… ${resolver.name}: Found match (confidence: ${(sources[resolver.id].confidence * 100).toFixed(0)}%)`);
        }
      } catch (error) {
        console.error(`  âŒ ${resolver.name} resolve error:`, error);
      }
    });
    
    // Wait for all resolvers to complete
    await Promise.all(resolverPromises);
    
    // Update state with found sources
    if (Object.keys(sources).length > 0) {
      setTrackSources(prev => ({
        ...prev,
        [trackKey]: sources
      }));
      console.log(`âœ… Found ${Object.keys(sources).length} source(s) for: ${track.title}`);
    }
  };
  
  // Calculate confidence score for a match (0-1)
  const calculateConfidence = (originalTrack, foundTrack) => {
    const titleMatch = originalTrack.title.toLowerCase() === foundTrack.title.toLowerCase();
    const durationMatch = originalTrack.length && foundTrack.duration 
      ? Math.abs(originalTrack.length / 1000 - foundTrack.duration) < 10 // Within 10 seconds
      : false;
    
    if (titleMatch && durationMatch) return 0.95;
    if (titleMatch) return 0.85;
    if (durationMatch) return 0.70;
    return 0.50;
  };

  // Resolve all tracks in a release
  const resolveAllTracks = async (release, artistName) => {
    console.log(`ðŸ” Starting resolution for ${release.tracks.length} tracks...`);
    
    // Clear previous track sources
    setTrackSources({});
    
    // Resolve tracks one at a time with small delay
    for (const track of release.tracks) {
      await resolveTrack(track, artistName);
      // Small delay to avoid rate limiting
      await new Promise(resolve => setTimeout(resolve, 200));
    }
    
    console.log('âœ… Track resolution complete');
  };

  // Lazy load album art after page is displayed
  const fetchAlbumArtLazy = async (releases) => {
    console.log('Starting lazy album art loading...');
    let loadedCount = 0;
    let skippedCount = 0;
    
    // Fetch album art one at a time to update UI progressively
    for (const release of releases) {
      // Skip if already in cache
      if (albumArtCache.current[release.id]) {
        skippedCount++;
        continue;
      }
      
      try {
        const artResponse = await fetch(
          `https://coverartarchive.org/release/${release.id}`,
          { 
            headers: { 'User-Agent': 'Harmonix/1.0.0 (https://github.com/harmonix)' }
          }
        );
        
        if (artResponse.ok) {
          const artData = await artResponse.json();
          const frontCover = artData.images.find(img => img.front);
          
          if (frontCover && frontCover.thumbnails && frontCover.thumbnails['250']) {
            const albumArtUrl = frontCover.thumbnails['250'];
            
            // Store in cache
            albumArtCache.current[release.id] = albumArtUrl;
            
            // Update just this release with album art
            setArtistReleases(prev => 
              prev.map(r => 
                r.id === release.id 
                  ? { ...r, albumArt: albumArtUrl }
                  : r
              )
            );
            loadedCount++;
          }
        }
      } catch (error) {
        // Silently continue to next release
      }
      
      // Small delay to avoid rate limiting
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    console.log(`Album art: ${loadedCount} loaded, ${skippedCount} from cache, ${releases.length - loadedCount - skippedCount} not found`);
  };

  const toggleResolver = (resolverId) => {
    setActiveResolvers(prev =>
      prev.includes(resolverId)
        ? prev.filter(id => id !== resolverId)
        : [...prev, resolverId]
    );
  };

  // Drag and drop handlers for resolver reordering
  const handleResolverDragStart = (e, resolverId) => {
    setDraggedResolver(resolverId);
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/html', e.target);
  };

  const handleResolverDragOver = (e) => {
    if (e.preventDefault) {
      e.preventDefault();
    }
    e.dataTransfer.dropEffect = 'move';
    return false;
  };

  const handleResolverDrop = (e, targetResolverId) => {
    if (e.stopPropagation) {
      e.stopPropagation();
    }

    if (draggedResolver !== targetResolverId) {
      const newOrder = [...resolverOrder];
      const draggedIndex = newOrder.indexOf(draggedResolver);
      const targetIndex = newOrder.indexOf(targetResolverId);

      // Remove dragged item and insert at target position
      newOrder.splice(draggedIndex, 1);
      newOrder.splice(targetIndex, 0, draggedResolver);

      setResolverOrder(newOrder);
      console.log('Resolver order updated:', newOrder);
    }

    setDraggedResolver(null);
    return false;
  };

  const handleResolverDragEnd = () => {
    setDraggedResolver(null);
  };

  const toggleResultFilter = (resolverId) => {
    setResultFilters(prev => {
      if (prev.includes(resolverId)) {
        // Remove from filters
        const newFilters = prev.filter(id => id !== resolverId);
        // If removing the last filter, reset to show all
        if (newFilters.length === 0) {
          return activeResolvers.slice();
        }
        return newFilters;
      } else {
        // Add to filters
        return [...prev, resolverId];
      }
    });
  };

  // Filter results based on selected resolvers
  const getFilteredResults = () => {
    if (!searchQuery) return library;
    
    // If all resolvers are active (no filtering), show all results
    if (resultFilters.length === activeResolvers.length || resultFilters.length === 0) {
      return searchResults;
    }
    
    // Filter results to only show tracks from selected resolvers
    return searchResults.filter(track => {
      // Check if track is from any of the selected resolvers
      return track.sources?.some(source => resultFilters.includes(source));
    });
  };

  // Add Spotify authentication functions
  const checkSpotifyToken = async () => {
    console.log('Checking Spotify token...');
    if (window.electron?.spotify) {
      const tokenData = await window.electron.spotify.checkToken();
      console.log('Token data:', tokenData);
      if (tokenData) {
        console.log('Valid token found, setting connected state');
        setSpotifyToken(tokenData.token);
        setSpotifyConnected(true);
        // Enable Spotify resolver if authenticated
        setActiveResolvers(prev => {
          if (!prev.includes('spotify')) {
            console.log('Adding Spotify to active resolvers');
            return [...prev, 'spotify'];
          }
          return prev;
        });
      } else {
        console.log('No valid token found');
      }
    } else {
      console.log('window.electron.spotify not available');
    }
  };

  const connectSpotify = async () => {
    console.log('=== Connect Spotify Clicked ===');
    console.log('window.electron:', !!window.electron);
    console.log('window.electron.spotify:', !!window.electron?.spotify);
    
    if (window.electron?.spotify) {
      try {
        console.log('Calling authenticate...');
        const result = await window.electron.spotify.authenticate();
        console.log('Authenticate result:', result);
      } catch (error) {
        console.error('Spotify auth error:', error);
        alert('Spotify authentication failed. Check console for details.');
      }
    } else {
      console.error('window.electron.spotify not available!');
      alert('Electron API not available. Make sure preload.js is loaded correctly.');
    }
  };

  const disconnectSpotify = async () => {
    if (window.electron?.spotify) {
      await window.electron.store.delete('spotify_token');
      await window.electron.store.delete('spotify_refresh_token');
      await window.electron.store.delete('spotify_token_expiry');
      setSpotifyToken(null);
      setSpotifyConnected(false);
      // Remove Spotify from active resolvers
      setActiveResolvers(prev => prev.filter(id => id !== 'spotify'));
    }
  };

// Listen for Spotify auth events
useEffect(() => {
  checkSpotifyToken();
  
  if (window.electron?.spotify) {
    window.electron.spotify.onAuthSuccess((data) => {
      console.log('Spotify auth success!', data);
      setSpotifyToken(data.token);
      setSpotifyConnected(true);
      // Automatically enable Spotify resolver after successful auth
      setActiveResolvers(prev => {
        if (!prev.includes('spotify')) {
          return [...prev, 'spotify'];
        }
        return prev;
      });
      console.log('Spotify connected and enabled!');
    });
    window.electron.spotify.onAuthError((error) => {
      console.error('Spotify auth failed:', error);
      alert('Spotify authentication failed: ' + error);
    });
  }
}, []);

// Spotify Connect - Get available devices
const getSpotifyDevices = async () => {
  if (!spotifyToken) return [];
  
  try {
    const response = await fetch('https://api.spotify.com/v1/me/player/devices', {
      headers: {
        'Authorization': `Bearer ${spotifyToken}`
      }
    });
    
    if (response.ok) {
      const data = await response.json();
      return data.devices || [];
    }
  } catch (error) {
    console.error('Failed to get devices:', error);
  }
  return [];
};

// Play on Spotify Connect (controls external Spotify clients)
const playOnSpotifyConnect = async (track) => {
  if (!spotifyToken) {
    alert('Spotify not connected');
    return false;
  }
  
  try {
    // Get available devices
    const devices = await getSpotifyDevices();
    console.log('Available Spotify devices:', devices);
    
    if (devices.length === 0) {
      alert('No Spotify devices found. Please open Spotify on your phone, computer, or web player (spotify.com), then try again.');
      return false;
    }
    
    // Log all devices for debugging
    console.log(`Found ${devices.length} Spotify device(s):`);
    devices.forEach((d, i) => {
      console.log(`Device ${i + 1}:`, {
        name: d.name,
        type: d.type,
        is_active: d.is_active,
        is_restricted: d.is_restricted,
        volume_percent: d.volume_percent
      });
    });
    
    // Find active device or use first available
    const activeDevice = devices.find(d => d.is_active) || devices[0];
    console.log('Selected device:', activeDevice.name, 'Active:', activeDevice.is_active);
    
    // If device is not active, try to transfer playback to it first
    if (!activeDevice.is_active) {
      console.log('Device not active, transferring playback first...');
      const transferResponse = await fetch('https://api.spotify.com/v1/me/player', {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${spotifyToken}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          device_ids: [activeDevice.id],
          play: false // Don't start playing yet
        })
      });
      
      if (!transferResponse.ok && transferResponse.status !== 204) {
        console.error('Failed to transfer playback:', transferResponse.status);
        const error = await transferResponse.text();
        console.error('Transfer error details:', error);
      } else {
        console.log('Playback transferred to device');
        // Small delay to let the transfer complete
        await new Promise(resolve => setTimeout(resolve, 500));
      }
    }
    
    // Now play track on device
    console.log('Starting playback on device:', activeDevice.name);
    const response = await fetch(`https://api.spotify.com/v1/me/player/play?device_id=${activeDevice.id}`, {
      method: 'PUT',
      headers: {
        'Authorization': `Bearer ${spotifyToken}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        uris: [track.spotifyUri]
      })
    });
    
    if (response.ok || response.status === 204) {
      console.log('âœ… Playing on Spotify:', activeDevice.name);
      setCurrentTrack(track);
      setIsPlaying(true);
      
      // Don't call getCurrentPlaybackState() here - let polling handle it
      // This prevents flickering when starting playback
      return true;
    } else {
      const error = await response.text();
      console.error('Spotify play failed:', response.status, error);
      
      // Provide specific error messages
      if (response.status === 404) {
        alert(`Spotify device not responding.\n\nTry:\n1. Play any song on Spotify first\n2. Then use Harmonix\n\nDevice: ${activeDevice.name}`);
      } else if (response.status === 403) {
        alert('Spotify Premium required for remote playback.');
      } else {
        alert(`Failed to play on Spotify. Error: ${response.status}\n\n${error}`);
      }
      return false;
    }
  } catch (error) {
    console.error('Spotify Connect error:', error);
    alert('Error playing on Spotify: ' + error.message);
    return false;
  }
};

// Get current playback state from Spotify
const getCurrentPlaybackState = async () => {
  if (!spotifyToken) return;
  
  try {
    const response = await fetch('https://api.spotify.com/v1/me/player', {
      headers: {
        'Authorization': `Bearer ${spotifyToken}`
      }
    });
    
    if (response.ok) {
      const data = await response.json();
      if (data && data.item) {
        const newIsPlaying = data.is_playing;
        const newProgress = data.progress_ms / 1000;
        const newTrackId = `spotify-${data.item.id}`;
        
        // Only update if something changed
        if (isPlaying !== newIsPlaying) {
          setIsPlaying(newIsPlaying);
        }
        
        // Update progress (always, for smooth progress bar)
        setProgress(newProgress);
        
        // Only update track if it's different
        if (currentTrack?.id !== newTrackId) {
          setCurrentTrack({
            id: newTrackId,
            title: data.item.name,
            artist: data.item.artists.map(a => a.name).join(', '),
            album: data.item.album.name,
            duration: data.item.duration_ms / 1000,
            albumArt: data.item.album.images[0]?.url,
            spotifyUri: data.item.uri,
            spotifyId: data.item.id,
            sources: ['spotify']
          });
        }
      }
    }
  } catch (error) {
    console.error('Failed to get playback state:', error);
  }
};

// Poll Spotify playback state when playing
useEffect(() => {
  if (!spotifyToken || !isPlaying) return;
  
  const currentIsSpotify = currentTrack?.sources?.includes('spotify') || currentTrack?.spotifyUri;
  if (!currentIsSpotify) return;
  
  // Poll every 5 seconds (reduced from 2 to minimize flickering)
  const interval = setInterval(() => {
    getCurrentPlaybackState();
  }, 5000);
  
  return () => clearInterval(interval);
}, [spotifyToken, isPlaying, currentTrack]);

  const formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  return React.createElement('div', {
    className: 'h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 text-white flex flex-col'
  },
    // Header (draggable window area)
    React.createElement('div', {
      className: 'flex items-center justify-between p-4 border-b border-white/10',
      style: { WebkitAppRegion: 'drag' }
    },
      React.createElement('div', { className: 'flex items-center gap-3' },
        React.createElement('div', {
          className: 'w-10 h-10 bg-gradient-to-br from-purple-500 to-pink-500 rounded-lg flex items-center justify-center text-2xl'
        }, React.createElement(Music))
      ),
      React.createElement('div', { className: 'flex-1 max-w-2xl mx-8 no-drag' },
        React.createElement('input', {
          type: 'text',
          placeholder: 'Search music...',
          value: searchQuery,
          onChange: (e) => handleSearch(e.target.value),
          className: 'w-full bg-white/10 border border-white/20 rounded-lg px-4 py-2 focus:outline-none focus:ring-2 focus:ring-purple-500'
        })
      ),
      React.createElement('button', {
        onClick: () => setShowSettings(!showSettings),
        className: 'p-2 hover:bg-white/10 rounded-lg transition-colors text-xl no-drag'
      }, React.createElement(Settings))
    ),

    // Main content with sidebar
    React.createElement('div', { 
      className: 'flex-1 flex overflow-hidden'
    },
      // Sidebar
      React.createElement('div', { 
        className: 'w-64 bg-black/20 border-r border-white/10 p-4 flex flex-col gap-2 no-drag overflow-y-auto scrollable-content'
      },
        // Menu buttons
        React.createElement('button', {
          onClick: () => setActiveView('library'),
          className: `flex items-center gap-3 px-4 py-3 rounded-lg transition-colors ${
            activeView === 'library' ? 'bg-purple-600' : 'hover:bg-white/10'
          }`
        },
          React.createElement('span', { className: 'text-xl' }, React.createElement(Music)),
          React.createElement('span', null, 'My Library')
        ),
        React.createElement('button', {
          onClick: () => setActiveView('playlists'),
          className: `flex items-center gap-3 px-4 py-3 rounded-lg transition-colors ${
            activeView === 'playlists' ? 'bg-purple-600' : 'hover:bg-white/10'
          }`
        },
          React.createElement('span', { className: 'text-xl' }, React.createElement(List)),
          React.createElement('span', null, 'Playlists')
        ),
        React.createElement('button', {
          onClick: () => setActiveView('friends'),
          className: `flex items-center gap-3 px-4 py-3 rounded-lg transition-colors ${
            activeView === 'friends' ? 'bg-purple-600' : 'hover:bg-white/10'
          }`
        },
          React.createElement('span', { className: 'text-xl' }, React.createElement(Users)),
          React.createElement('span', null, 'Friends')
        ),
        React.createElement('button', {
          onClick: () => setActiveView('discover'),
          className: `flex items-center gap-3 px-4 py-3 rounded-lg transition-colors ${
            activeView === 'discover' ? 'bg-purple-600' : 'hover:bg-white/10'
          }`
        },
          React.createElement('span', { className: 'text-xl' }, React.createElement(Radio)),
          React.createElement('span', null, 'Discover')
        ),

// Resolvers section
          React.createElement('div', { className: 'space-y-3' },
              // Debug info (temporary)
              React.createElement('div', { className: 'text-xs p-2 bg-black/20 rounded space-y-1' },
                React.createElement('div', { className: 'font-semibold mb-2 text-gray-300' }, 'ðŸ” Spotify Status'),
                React.createElement('div', { className: spotifyConnected ? 'text-green-400' : 'text-red-400' }, 
                  `Connected: ${spotifyConnected ? 'âœ“' : 'âœ—'}`
                ),
                React.createElement('div', { className: spotifyToken ? 'text-green-400' : 'text-red-400' }, 
                  `Token: ${spotifyToken ? 'âœ“ Present' : 'âœ— None'}`
                ),
                React.createElement('div', { className: activeResolvers.includes('spotify') ? 'text-green-400' : 'text-gray-400' }, 
                  `Enabled: ${activeResolvers.includes('spotify') ? 'âœ“' : 'âœ—'}`
                ),
                React.createElement('div', { className: 'text-blue-400 text-xs mt-1' }, 
                  'ðŸ’¡ Using Spotify Connect API'
                ),
                React.createElement('div', { className: 'text-gray-400 text-xs' }, 
                  'Open Spotify app/web to play'
                ),
                React.createElement('button', {
                  onClick: async () => {
                    console.log('=== SPOTIFY STATUS ===');
                    console.log('Connected:', spotifyConnected);
                    console.log('Token:', spotifyToken ? 'Present' : 'None');
                    console.log('Enabled:', activeResolvers.includes('spotify'));
                    
                    if (spotifyToken) {
                      const devices = await getSpotifyDevices();
                      console.log('Available devices:', devices);
                      alert(`Found ${devices.length} Spotify device(s). Check console for details.`);
                    } else {
                      alert('Not connected to Spotify');
                    }
                  },
                  className: 'mt-2 w-full px-2 py-1 bg-blue-600/30 hover:bg-blue-600/50 rounded text-xs'
                },
                  'ðŸ” Check Devices'
                )
              ),
              ...resolvers.map(resolver => {
                const isSpotify = resolver.id === 'spotify';
                const needsAuth = isSpotify && !spotifyConnected;
                
                return React.createElement('div', {
                  key: resolver.id,
                  className: 'p-4 bg-white/5 rounded-lg border border-white/10'
                },
                  React.createElement('div', { className: 'flex items-center justify-between' },
                    React.createElement('div', { className: 'flex items-center gap-3 flex-1' },
                      React.createElement('div', {
                        className: 'w-4 h-4 rounded-full',
                        style: { backgroundColor: resolver.color }
                      }),
                      React.createElement('div', { className: 'flex-1' },
                        React.createElement('div', { className: 'font-medium' }, resolver.name),
                        React.createElement('div', { className: 'text-xs text-gray-400' },
                          isSpotify && spotifyConnected ? 'âœ“ Connected' :
                          isSpotify && !spotifyConnected ? 'Authentication required' :
                          activeResolvers.includes(resolver.id) ? 'Active' : 'Disabled'
                        )
                      )
                    ),
                    React.createElement('label', { className: 'relative inline-block w-12 h-6' },
                      React.createElement('input', {
                        type: 'checkbox',
                        checked: activeResolvers.includes(resolver.id),
                        onChange: () => toggleResolver(resolver.id),
                        disabled: needsAuth,
                        className: 'sr-only peer'
                      }),
                      React.createElement('div', {
                        className: `w-full h-full rounded-full transition-colors ${
                          needsAuth ? 'bg-gray-700' : 'bg-gray-600 peer-checked:bg-purple-600'
                        }`
                      }),
                      React.createElement('div', {
                        className: `absolute left-1 top-1 w-4 h-4 bg-white rounded-full transition-transform peer-checked:translate-x-6 ${
                          needsAuth ? 'opacity-50' : ''
                        }`
                      })
                    )
                  ),
                  
                  // Spotify Auth Buttons
                  isSpotify && React.createElement('div', { className: 'mt-3 pt-3 border-t border-white/10' },
                    !spotifyConnected ? 
                      React.createElement('div', { className: 'space-y-2' },
                        React.createElement('button', {
                          onClick: connectSpotify,
                          className: 'w-full py-2 px-4 bg-green-600 hover:bg-green-700 text-white rounded-lg font-medium transition-colors flex items-center justify-center gap-2'
                        },
                          'ðŸ”“ Connect Spotify Account'
                        ),
                        React.createElement('button', {
                          onClick: () => {
                            console.log('Manual token check triggered');
                            checkSpotifyToken();
                          },
                          className: 'w-full py-1 px-4 bg-blue-600/20 hover:bg-blue-600/30 text-blue-400 rounded-lg text-xs transition-colors'
                        },
                          'ðŸ”„ Refresh Status'
                        )
                      )
                    :
                      React.createElement('div', { className: 'space-y-2' },
                        React.createElement('div', { 
                          className: 'text-sm text-green-400 flex items-center gap-2'
                        },
                          'âœ“ Authenticated and ready to stream'
                        ),
                        React.createElement('button', {
                          onClick: disconnectSpotify,
                          className: 'w-full py-1.5 px-4 bg-red-600/20 hover:bg-red-600/30 text-red-400 rounded-lg text-sm transition-colors'
                        },
                          'Disconnect'
                        )
                      )
                  )
                );
              })
            )
          ),
      
      // Main content area - Artist Page (completely separate layout)
      activeView === 'artist' ? React.createElement('div', { 
        className: 'flex-1 flex flex-col',
        style: { overflow: 'hidden' }
      },
        // Artist page header (not inside scrollable area) - only show when NOT viewing a release
        !currentRelease && React.createElement('div', { 
          className: 'p-6 border-b border-white/10'
        },
          React.createElement('div', { className: 'flex items-center gap-4' },
            React.createElement('button', {
              onClick: () => {
                // If viewing artist page, go back to library
                setActiveView('library');
                setCurrentArtist(null);
                setArtistReleases([]);
                setReleaseTypeFilter('all');
              },
              className: 'p-2 hover:bg-white/10 rounded-full transition-colors no-drag',
              title: 'Back to library'
            }, 
              React.createElement('svg', {
                className: 'w-6 h-6',
                fill: 'none',
                viewBox: '0 0 24 24',
                stroke: 'currentColor'
              },
                React.createElement('path', {
                  strokeLinecap: 'round',
                  strokeLinejoin: 'round',
                  strokeWidth: 2,
                  d: 'M15 19l-7-7 7-7'
                })
              )
            ),
            !loadingArtist && !loadingRelease && !currentRelease && currentArtist && React.createElement('div', null,
              React.createElement('h1', { className: 'text-3xl font-bold' }, currentArtist.name),
              currentArtist.disambiguation && React.createElement('p', { className: 'text-sm text-gray-400 mt-1' }, currentArtist.disambiguation),
              React.createElement('div', { className: 'flex gap-3 mt-2 text-sm text-gray-500' },
                currentArtist.type && React.createElement('span', null, currentArtist.type),
                currentArtist.country && React.createElement('span', null, `â€¢ ${currentArtist.country}`)
              )
            )
          )
        ),
        
        // Loading state for release
        loadingRelease && React.createElement('div', { 
          className: 'flex-1 flex items-center justify-center'
        },
          React.createElement('div', { className: 'text-center' },
            React.createElement('div', { 
              className: 'w-16 h-16 border-4 border-purple-600 border-t-transparent rounded-full animate-spin mx-auto mb-4'
            }),
            React.createElement('div', { className: 'text-gray-400 text-lg' }, 'Loading release...'),
            React.createElement('div', { className: 'text-gray-500 text-sm mt-2' }, 'Fetching track information')
          )
        ),
        
        // Release page header (not inside scrollable area)
        !loadingRelease && currentRelease && React.createElement('div', { 
          className: 'p-6 border-b border-white/10'
        },
          React.createElement('div', { className: 'flex items-center gap-4' },
            React.createElement('button', {
              onClick: () => setCurrentRelease(null),
              className: 'p-2 hover:bg-white/10 rounded-full transition-colors no-drag',
              title: 'Back to artist'
            }, 
              React.createElement('svg', {
                className: 'w-6 h-6',
                fill: 'none',
                viewBox: '0 0 24 24',
                stroke: 'currentColor'
              },
                React.createElement('path', {
                  strokeLinecap: 'round',
                  strokeLinejoin: 'round',
                  strokeWidth: 2,
                  d: 'M15 19l-7-7 7-7'
                })
              )
            ),
            React.createElement('div', null,
              React.createElement('h1', { className: 'text-3xl font-bold' }, currentRelease.title),
              React.createElement('p', { className: 'text-sm text-gray-400 mt-1' }, 
                `${currentRelease.artist.name} â€¢ ${currentRelease.date ? currentRelease.date.split('-')[0] : 'Unknown'}`
              )
            )
          )
        ),
        
        // Release page content (scrollable)
        !loadingRelease && currentRelease && React.createElement('div', { 
          className: 'scrollable-content',
          style: { 
            flex: 1,
            overflowY: 'scroll',
            padding: '24px',
            pointerEvents: 'auto'
          }
        },
          React.createElement(ReleasePage, {
            release: currentRelease,
            handleSearch: handleSearch,
            handlePlay: handlePlay,
            trackSources: trackSources,
            resolvers: resolvers
          })
        ),
        
        // Loading state for artist
        !currentRelease && loadingArtist && React.createElement('div', { 
          className: 'flex-1 flex items-center justify-center'
        },
          React.createElement('div', { className: 'text-center' },
            React.createElement('div', { 
              className: 'w-16 h-16 border-4 border-purple-600 border-t-transparent rounded-full animate-spin mx-auto mb-4'
            }),
            React.createElement('div', { className: 'text-gray-400 text-lg' }, 'Loading discography...'),
            React.createElement('div', { className: 'text-gray-500 text-sm mt-2' }, 'Fetching data from MusicBrainz')
          )
        ),
        
        // Artist content (scrollable) - only show if no release is being viewed
        !currentRelease && !loadingArtist && currentArtist && React.createElement('div', { 
          className: 'scrollable-content',
          style: { 
            flex: 1,
            overflowY: 'scroll',
            padding: '24px',
            pointerEvents: 'auto'
          }
        },
          React.createElement('div', { 
            className: 'space-y-6'
          },
            // Release type filters
            React.createElement('div', { className: 'flex gap-2' },
              ['all', 'album', 'ep', 'single'].map(type => {
                const count = type === 'all' 
                  ? artistReleases.length 
                  : artistReleases.filter(r => r.releaseType === type).length;
                
                return React.createElement('button', {
                  key: type,
                  onClick: () => setReleaseTypeFilter(type),
                  className: `px-4 py-2 rounded-full transition-all no-drag ${
                    releaseTypeFilter === type 
                      ? 'bg-purple-600 text-white' 
                      : 'bg-white/10 text-gray-400 hover:bg-white/20'
                  }`,
                }, `${type.charAt(0).toUpperCase() + type.slice(1)}s (${count})`);
              })
            ),
            
            // Releases count
            React.createElement('p', { className: 'text-sm text-gray-400' },
              `${artistReleases.filter(r => releaseTypeFilter === 'all' || r.releaseType === releaseTypeFilter).length} releases`
            ),
            
            // Discography grid
            React.createElement('div', { 
              className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4 pb-6'
            },
              artistReleases.map(release => 
                React.createElement(ReleaseCard, {
                  key: release.id,
                  release: release,
                  currentArtist: currentArtist,
                  fetchReleaseData: fetchReleaseData,
                  isVisible: releaseTypeFilter === 'all' || release.releaseType === releaseTypeFilter
                })
              )
            ),
            
            // Empty state
            artistReleases.filter(r => releaseTypeFilter === 'all' || r.releaseType === releaseTypeFilter).length === 0 && 
              React.createElement('div', { className: 'text-center py-12 text-gray-400' },
                `No ${releaseTypeFilter === 'all' ? '' : releaseTypeFilter + ' '}releases found`
              )
          )
        )
      )
      
      // Main content area - Normal views (Library, Search, etc.)
      : React.createElement('div', { 
        className: 'flex-1 overflow-y-auto p-6 scrollable-content',
        style: { minHeight: 0, flexBasis: 0 }
      },
        React.createElement('div', { className: 'flex items-center justify-between mb-4' },
          React.createElement('h2', { className: 'text-2xl font-bold' }, 
            searchQuery ? 'Search Results' : 
            activeView === 'library' ? 'My Library' : 
            activeView === 'playlists' ? 'Playlists' : 
            activeView === 'friends' ? 'Friends' : 
            'Discover'
          ),
          // Show active resolvers when searching - now clickable filters
          searchQuery && React.createElement('div', { className: 'flex items-center gap-3 text-xs' },
            React.createElement('span', { className: 'text-gray-400' }, 'Filter:'),
            React.createElement('div', { className: 'flex items-center gap-2' },
              activeResolvers.map(resolverId => {
                const resolver = resolvers.find(r => r.id === resolverId);
                const isActive = resultFilters.includes(resolverId);
                return React.createElement('button', {
                  key: resolverId,
                  onClick: () => toggleResultFilter(resolverId),
                  className: `px-2 py-1 rounded-full transition-all cursor-pointer hover:scale-105 ${
                    isActive ? '' : 'opacity-30 grayscale'
                  }`,
                  style: { 
                    backgroundColor: resolver.color + '33', 
                    color: resolver.color,
                    border: isActive ? `2px solid ${resolver.color}` : '2px solid transparent'
                  },
                  title: isActive ? `Hide ${resolver.name} results` : `Show ${resolver.name} results`
                }, resolver.name);
              })
            ),
            // Show result count and reset button
            !isSearching && React.createElement('div', { className: 'flex items-center gap-2 ml-2' },
              React.createElement('span', { className: 'text-gray-500' }, 
                `${getFilteredResults().length}${resultFilters.length < activeResolvers.length ? `/${searchResults.length}` : ''} results`
              ),
              resultFilters.length < activeResolvers.length && React.createElement('button', {
                onClick: () => setResultFilters(activeResolvers.slice()),
                className: 'text-purple-400 hover:text-purple-300 underline',
                title: 'Show all results'
              }, 'show all')
            )
          )
        ),
        // Loading indicator
        isSearching && React.createElement('div', { className: 'text-center py-8 text-gray-400' },
          React.createElement('div', { className: 'animate-spin w-8 h-8 border-4 border-purple-600 border-t-transparent rounded-full mx-auto mb-2' }),
          React.createElement('div', null, 'Searching...')
        ),
        // Library/Search results
        activeView === 'library' && !isSearching && React.createElement('div', { className: 'space-y-2' },
          getFilteredResults().length === 0 && searchQuery ?
            React.createElement('div', { className: 'text-center py-12 text-gray-400' },
              resultFilters.length < activeResolvers.length ? 
                'ðŸ” No results from selected sources. Try clicking more filter badges above.' :
                'ðŸ” No results found for "' + searchQuery + '"'
            )
          :
          getFilteredResults().map(track =>
            React.createElement(TrackRow, {
              key: track.id,
              track: track,
              isPlaying: isPlaying && currentTrack?.id === track.id,
              handlePlay: handlePlay,
              onArtistClick: fetchArtistData
            })
          )
        ),
        activeView === 'playlists' && React.createElement('div', {
          className: 'text-center py-12 text-gray-400'
        }, 'ðŸŽµ No playlists yet. Create your first playlist!'),
        activeView === 'friends' && React.createElement('div', {
          className: 'text-center py-12 text-gray-400'
        }, 'ðŸ‘¥ Connect with friends to see what they\'re listening to'),
        activeView === 'discover' && React.createElement('div', {
          className: 'text-center py-12 text-gray-400'
        }, 'ðŸ“» Discover new music from trending charts')
      )
    ),

    // Player bar
    currentTrack && React.createElement('div', {
      className: 'bg-black/40 backdrop-blur-xl border-t border-white/10 p-4 no-drag'
    },
      React.createElement('div', { className: 'flex items-center justify-between mb-2' },
        React.createElement('div', { className: 'flex items-center gap-4' },
          currentTrack.albumArt ?
            React.createElement('img', {
              src: currentTrack.albumArt,
              alt: currentTrack.album,
              className: 'w-14 h-14 rounded-lg object-cover'
            })
          :
            React.createElement('div', {
              className: 'w-14 h-14 bg-gradient-to-br from-purple-500 to-pink-500 rounded-lg flex items-center justify-center text-2xl'
            }, React.createElement(Music)),
          React.createElement('div', null,
            React.createElement('div', { className: 'font-semibold' }, currentTrack.title),
            React.createElement('div', { className: 'text-sm text-gray-400 flex items-center gap-2' }, 
              React.createElement('button', {
                onClick: () => {
                  console.log('Navigating to artist:', currentTrack.artist);
                  fetchArtistData(currentTrack.artist);
                },
                className: 'hover:text-purple-400 hover:underline transition-colors cursor-pointer no-drag',
                style: { background: 'none', border: 'none', padding: 0, font: 'inherit', color: 'inherit' }
              }, currentTrack.artist),
              currentTrack.sources?.includes('spotify') && React.createElement('span', {
                className: 'text-xs px-2 py-0.5 bg-green-600/20 text-green-400 rounded-full'
              }, 'â™« Spotify')
            )
          )
        ),
        React.createElement('button', {
          className: 'p-2 hover:bg-white/10 rounded-full transition-colors text-xl'
        }, React.createElement(Heart))
      ),
      React.createElement('div', { className: 'flex items-center gap-4' },
        React.createElement('span', { className: 'text-sm text-gray-400 w-12 text-right' }, formatTime(progress)),
        React.createElement('div', { className: 'flex-1' },
          React.createElement('input', {
            type: 'range',
            min: '0',
            max: currentTrack.duration,
            value: progress,
            onChange: async (e) => {
              const newPosition = Number(e.target.value);
              setProgress(newPosition);
              
              // Seek in Spotify if playing Spotify track
              if ((currentTrack.sources?.includes('spotify') || currentTrack.spotifyUri) && spotifyPlayer) {
                try {
                  await spotifyPlayer.seek(newPosition * 1000); // Convert to milliseconds
                  console.log('Seeked to', newPosition);
                } catch (err) {
                  console.error('Seek error:', err);
                }
              }
            },
            className: 'w-full h-1 bg-white/20 rounded-full appearance-none cursor-pointer'
          })
        ),
        React.createElement('span', { className: 'text-sm text-gray-400 w-12' }, formatTime(currentTrack.duration))
      ),
      React.createElement('div', { className: 'flex items-center justify-center gap-4 mt-2' },
        React.createElement('button', {
          onClick: handlePrevious,
          className: 'p-2 hover:bg-white/10 rounded-full transition-colors text-xl'
        }, React.createElement(SkipBack)),
        React.createElement('button', {
          onClick: handlePlayPause,
          className: 'p-4 bg-purple-600 hover:bg-purple-700 rounded-full transition-colors text-xl'
        }, isPlaying ? React.createElement(Pause) : React.createElement(Play)),
        React.createElement('button', {
          onClick: handleNext,
          className: 'p-2 hover:bg-white/10 rounded-full transition-colors text-xl'
        }, React.createElement(SkipForward)),
        React.createElement('div', { className: 'flex items-center gap-2 ml-8' },
          React.createElement('span', { className: 'text-xl' }, React.createElement(Volume2)),
          React.createElement('input', {
            type: 'range',
            min: '0',
            max: '100',
            value: volume,
            onChange: (e) => setVolume(Number(e.target.value)),
            className: 'w-24 h-1 bg-white/20 rounded-full appearance-none cursor-pointer'
          })
        )
      )
    ),

    // Settings Modal
    showSettings && React.createElement('div', {
      className: 'fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50'
    },
      React.createElement('div', {
        className: 'bg-slate-800 rounded-xl p-6 max-w-2xl w-full mx-4 max-h-[80vh] overflow-y-auto'
      },
        React.createElement('div', {
          className: 'flex items-center justify-between mb-6'
        },
          React.createElement('h2', { className: 'text-2xl font-bold' }, 'Settings'),
          React.createElement('button', {
            onClick: () => setShowSettings(false),
            className: 'p-2 hover:bg-white/10 rounded-lg transition-colors text-xl'
          }, React.createElement(X))
        ),
        
        // Content Resolvers Section
        React.createElement('div', { className: 'space-y-6' },
          React.createElement('div', null,
            React.createElement('h3', { className: 'text-lg font-semibold mb-2' }, 'ðŸ”Œ Resolver Plugins'),
            React.createElement('p', { className: 'text-sm text-gray-400 mb-4' },
              'Drag to reorder priority â€¢ Higher = checked first when resolving tracks'
            ),
            React.createElement('div', { className: 'space-y-2' },
              resolverOrder.map((resolverId, index) => {
                const resolver = allResolvers.find(r => r.id === resolverId);
                if (!resolver) return null;
                
                const isActive = activeResolvers.includes(resolver.id);
                const isDragging = draggedResolver === resolver.id;
                
                return React.createElement('div', {
                  key: resolver.id,
                  draggable: true,
                  onDragStart: (e) => handleResolverDragStart(e, resolver.id),
                  onDragOver: handleResolverDragOver,
                  onDrop: (e) => handleResolverDrop(e, resolver.id),
                  onDragEnd: handleResolverDragEnd,
                  className: `p-4 rounded-lg border transition-all cursor-move ${
                    isDragging 
                      ? 'opacity-50 bg-purple-900/20 border-purple-500' 
                      : isActive
                        ? 'bg-white/10 border-white/20 hover:bg-white/15'
                        : 'bg-white/5 border-white/10 hover:bg-white/8'
                  }`,
                  style: { userSelect: 'none' }
                },
                  React.createElement('div', { className: 'flex items-start gap-3' },
                    // Drag handle
                    React.createElement('div', { className: 'text-gray-500 mt-1 cursor-move' }, 'â‹®â‹®'),
                    
                    // Priority number
                    React.createElement('div', {
                      className: 'w-8 h-8 rounded-full flex items-center justify-center font-bold text-sm flex-shrink-0 mt-0.5',
                      style: { 
                        backgroundColor: isActive ? resolver.color + '40' : '#ffffff10',
                        color: isActive ? resolver.color : '#ffffff40'
                      }
                    }, index + 1),
                    
                    // Resolver info
                    React.createElement('div', { className: 'flex-1 min-w-0' },
                      React.createElement('div', { className: 'flex items-center gap-2 mb-1' },
                        React.createElement('span', { className: 'text-lg' }, resolver.icon),
                        React.createElement('span', { className: 'font-semibold' }, resolver.name),
                        resolver.requiresAuth && React.createElement('span', {
                          className: 'text-xs px-2 py-0.5 bg-yellow-900/30 text-yellow-400 rounded-full'
                        }, 'ðŸ”‘ Auth Required')
                      ),
                      React.createElement('p', { 
                        className: 'text-xs text-gray-400 mb-2'
                      }, resolver.description),
                      
                      // Capabilities
                      React.createElement('div', { className: 'flex flex-wrap gap-1.5' },
                        Object.entries(resolver.capabilities).map(([capability, enabled]) => {
                          const icons = {
                            resolve: 'ðŸŽ¯',
                            search: 'ðŸ”',
                            stream: 'â–¶ï¸',
                            browse: 'ðŸ“',
                            urlLookup: 'ðŸ”—'
                          };
                          return enabled && React.createElement('span', {
                            key: capability,
                            className: 'text-xs px-2 py-0.5 bg-white/10 text-gray-300 rounded-full',
                            title: capability
                          }, icons[capability] || 'âœ“', ' ', capability);
                        })
                      )
                    ),
                    
                    // Toggle
                    React.createElement('label', { className: 'relative inline-block w-12 h-6 flex-shrink-0 mt-1' },
                      React.createElement('input', {
                        type: 'checkbox',
                        checked: isActive,
                        onChange: () => toggleResolver(resolver.id),
                        className: 'sr-only peer'
                      }),
                      React.createElement('div', {
                        className: 'w-full h-full bg-gray-600 rounded-full peer-checked:bg-purple-600 transition-colors'
                      }),
                      React.createElement('div', {
                        className: 'absolute left-1 top-1 w-4 h-4 bg-white rounded-full transition-transform peer-checked:translate-x-6'
                      })
                    )
                  )
                );
              })
            )
          ),
          
          // How It Works Section
          React.createElement('div', null,
            React.createElement('h3', { className: 'text-lg font-semibold mb-4' }, 'ðŸ’¡ How Priority Works'),
            React.createElement('div', { className: 'bg-white/5 rounded-lg p-4 space-y-2 text-sm text-gray-300' },
              React.createElement('p', null,
                React.createElement('strong', null, 'ðŸŽ¯ Resolution Order: '),
                'When resolving a track, Harmonix queries resolvers in priority order (top to bottom). Higher priority resolvers are checked first.'
              ),
              React.createElement('p', null,
                React.createElement('strong', null, 'ðŸ”€ Track Click Behavior: '),
                'When clicking a track row, Harmonix plays from the highest-priority enabled resolver that found a match.'
              ),
              React.createElement('p', null,
                React.createElement('strong', null, 'ðŸŽµ Source Icons: '),
                'Click specific resolver icons to override priority and play from that specific source.'
              ),
              React.createElement('p', null,
                React.createElement('strong', null, 'ðŸ’¾ Drag to Reorder: '),
                'Drag resolvers up or down to change their priority. Changes take effect immediately for new resolutions.'
              )
            )
          ),
          
          // About Section
          React.createElement('div', null,
            React.createElement('h3', { className: 'text-lg font-semibold mb-4' }, 'About'),
            React.createElement('div', { className: 'text-sm text-gray-400 space-y-2' },
              React.createElement('p', null, 'Harmonix Desktop v1.0.0'),
              React.createElement('p', null, 'A modern multi-source music player inspired by Tomahawk.'),
              React.createElement('p', null, 
                'Built with Electron, React, and Tailwind CSS.'
              )
            )
          )
        )
      )
    )
  );
};

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(React.createElement(Harmonix));