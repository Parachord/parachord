// Parachord Desktop App - Electron Version
const { useState, useEffect, useRef, useCallback, useMemo } = React;

// Global Set to track prefetch in-progress state (on window to survive any reloads)
window._prefetchInProgress = window._prefetchInProgress || new Set();
const prefetchInProgress = window._prefetchInProgress;

// Use lucide-react icons if available, otherwise fallback to emoji
const Icons = typeof lucideReact !== 'undefined' ? lucideReact : {
  Play: () => React.createElement('span', null, 'â–¶'),
  Pause: () => React.createElement('span', null, 'â¸'),
  SkipForward: () => React.createElement('span', null, 'â­'),
  SkipBack: () => React.createElement('span', null, 'â®'),
  Volume2: () => React.createElement('span', null, 'ðŸ”Š'),
  Music: () => React.createElement('span', null, 'â™«'),
  List: ({ size = 24 }) => React.createElement('svg', { width: size, height: size, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2, strokeLinecap: 'round', strokeLinejoin: 'round' },
    React.createElement('line', { x1: 4, y1: 6, x2: 20, y2: 6 }),
    React.createElement('line', { x1: 4, y1: 12, x2: 20, y2: 12 }),
    React.createElement('line', { x1: 4, y1: 18, x2: 20, y2: 18 })
  ),
  Users: () => React.createElement('span', null, 'ðŸ‘¥'),
  Radio: () => React.createElement('span', null, 'ðŸ“»'),
  Heart: () => React.createElement('span', null, 'â™¥'),
  Search: () => React.createElement('span', null, 'ðŸ”'),
  Settings: () => React.createElement('span', null, 'âš™'),
  Plus: () => React.createElement('span', null, '+'),
  X: () => React.createElement('span', null, 'âœ•'),
};

const { Play, Pause, SkipForward, SkipBack, Volume2, Search, List, Settings, Plus, Music, Radio, Users, Heart, X } = Icons;

// Function to load built-in resolvers from resolvers/builtin/ directory
const loadBuiltinResolvers = async () => {
  // Check if we're in Electron
  if (window.electron?.resolvers?.loadBuiltin) {
    console.log('ðŸ“ Loading resolvers via Electron IPC...');
    try {
      const resolvers = await window.electron.resolvers.loadBuiltin();
      return resolvers;
    } catch (error) {
      console.error('âŒ Failed to load via Electron IPC:', error);
      return [];
    }
  } else {
    // Fallback for web/dev environment - try fetch
    console.log('ðŸ“ Loading resolvers via fetch (web mode)...');
    const resolverFiles = [
      'resolvers/builtin/spotify.axe',
      'resolvers/builtin/bandcamp.axe',
      'resolvers/builtin/qobuz.axe'
    ];
    
    const resolvers = [];
    
    for (const file of resolverFiles) {
      try {
        const response = await fetch(file);
        if (!response.ok) {
          console.error(`âŒ Failed to load ${file}: ${response.status}`);
          continue;
        }
        const axe = await response.json();
        resolvers.push(axe);
        console.log(`âœ… Loaded ${axe.manifest.name} resolver from ${file}`);
      } catch (error) {
        console.error(`âŒ Error loading ${file}:`, error);
      }
    }
    
    return resolvers;
  }
};

// Fallback embedded resolvers (used if .axe files can't be loaded)
const FALLBACK_RESOLVERS = [
  {"manifest":{"id":"spotify","name":"Spotify","version":"1.0.0","author":"Parachord Team","description":"Stream from Spotify via Spotify Connect API. Requires Spotify Premium for remote playback.","icon":"â™«","color":"#1DB954","homepage":"https://spotify.com","email":"support@harmonix.app"},"capabilities":{"resolve":true,"search":true,"stream":true,"browse":false,"urlLookup":false},"settings":{"requiresAuth":true,"authType":"oauth","scopes":["user-read-playback-state","user-modify-playback-state","user-read-currently-playing"],"configurable":{"clientId":{"type":"text","label":"Client ID","default":"c040c0ee133344b282e6342198bcbeea","readonly":true}}},"implementation":{"search":"async function(query, config) { if (!config.token) return []; try { const response = await fetch(`https://api.spotify.com/v1/search?q=${encodeURIComponent(query)}&type=track&limit=20`, { headers: { 'Authorization': `Bearer ${config.token}` } }); if (!response.ok) { console.error('Spotify search failed:', response.status); return []; } const data = await response.json(); return data.tracks.items.map(track => ({ id: `spotify-${track.id}`, title: track.name, artist: track.artists.map(a => a.name).join(', '), album: track.album.name, duration: Math.floor(track.duration_ms / 1000), sources: ['spotify'], spotifyUri: track.uri, spotifyId: track.id, albumArt: track.album.images[0]?.url })); } catch (error) { console.error('Spotify search error:', error); return []; } }","resolve":"async function(artist, track, album, config) { const query = `artist:${artist} track:${track}`; const results = await this.search(query, config); return results[0] || null; }","play":"async function(track, config) { if (!config.token) { console.error('Spotify not connected'); return false; } try { const devicesResponse = await fetch('https://api.spotify.com/v1/me/player/devices', { headers: { 'Authorization': `Bearer ${config.token}` } }); if (!devicesResponse.ok) return false; const devicesData = await devicesResponse.json(); const devices = devicesData.devices || []; if (devices.length === 0) { console.error('No Spotify devices found'); return false; } const controllable = devices.filter(d => !d.is_restricted); const available = controllable.length > 0 ? controllable : devices; const computer = available.find(d => d.type === 'Computer'); const phone = available.find(d => d.type === 'Smartphone'); const speaker = available.find(d => d.type === 'Speaker'); const nonWebActive = available.find(d => d.is_active && !d.name.toLowerCase().includes('web')); const nonWeb = available.find(d => !d.name.toLowerCase().includes('web')); let activeDevice = computer || phone || speaker || nonWebActive || nonWeb || available[0]; console.log('Selected device:', activeDevice.name, activeDevice.type); if (!activeDevice.is_active) { const transferResponse = await fetch('https://api.spotify.com/v1/me/player', { method: 'PUT', headers: { 'Authorization': `Bearer ${config.token}`, 'Content-Type': 'application/json' }, body: JSON.stringify({ device_ids: [activeDevice.id], play: true }) }); if (!transferResponse.ok && transferResponse.status !== 204) { console.error('Failed to transfer playback'); } await new Promise(resolve => setTimeout(resolve, 1000)); } const playResponse = await fetch(`https://api.spotify.com/v1/me/player/play?device_id=${activeDevice.id}`, { method: 'PUT', headers: { 'Authorization': `Bearer ${config.token}`, 'Content-Type': 'application/json' }, body: JSON.stringify({ uris: [track.spotifyUri] }) }); return playResponse.ok || playResponse.status === 204; } catch (error) { console.error('Spotify play error:', error); return false; } }","init":"async function(config) { console.log('Spotify resolver initialized'); }","cleanup":"async function() { console.log('Spotify resolver cleanup'); }"}},
  {"manifest":{"id":"bandcamp","name":"Bandcamp","version":"1.0.0","author":"Parachord Team","description":"Find and purchase music on Bandcamp. Opens tracks in browser for streaming.","icon":"ðŸŽ¸","color":"#629AA9","homepage":"https://bandcamp.com","email":"support@harmonix.app"},"capabilities":{"resolve":true,"search":true,"stream":false,"browse":false,"urlLookup":true},"settings":{"requiresAuth":false,"authType":"none","configurable":{}},"implementation":{"search":"async function(query, config) { try { console.log('Searching Bandcamp for:', query); const response = await fetch(`https://bandcamp.com/search?q=${encodeURIComponent(query)}&item_type=t`, { method: 'GET', headers: { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36' } }); if (!response.ok) { console.error('Bandcamp search failed:', response.status); return []; } const html = await response.text(); const results = []; const parser = new DOMParser(); const doc = parser.parseFromString(html, 'text/html'); const searchResults = doc.querySelectorAll('.searchresult'); searchResults.forEach((item, index) => { if (index >= 20) return; try { const heading = item.querySelector('.heading'); const subhead = item.querySelector('.subhead'); const itemUrl = item.querySelector('.itemurl'); if (heading && itemUrl) { const title = heading.textContent.trim(); const artistInfo = subhead ? subhead.textContent.trim() : 'Unknown Artist'; const byMatch = artistInfo.match(/by\\\\s+([^,]+)/); const fromMatch = artistInfo.match(/from\\\\s+(.+)/); const artist = byMatch ? byMatch[1].trim() : 'Unknown Artist'; const album = fromMatch ? fromMatch[1].trim() : (byMatch ? byMatch[1].trim() : 'Single'); const url = itemUrl.textContent.trim(); results.push({ id: `bandcamp-${Date.now()}-${index}`, title: title, artist: artist, album: album, duration: 210, sources: ['bandcamp'], bandcampUrl: url }); } } catch (itemError) { console.error('Error parsing Bandcamp result:', itemError); } }); console.log(`Found ${results.length} Bandcamp results`); return results; } catch (error) { console.error('Bandcamp search error:', error); return []; } }","resolve":"async function(artist, track, album, config) { const query = `${artist} ${track}`; const results = await this.search(query, config); return results[0] || null; }","play":"async function(track, config) { if (!track.bandcampUrl) { console.error('No Bandcamp URL found'); return false; } try { if (window.electron?.shell?.openExternal) { const result = await window.electron.shell.openExternal(track.bandcampUrl); return result && result.success; } else { const newWindow = window.open(track.bandcampUrl, '_blank'); return !!newWindow; } } catch (error) { console.error('Failed to open Bandcamp link:', error); return false; } }","init":"async function(config) { console.log('Bandcamp resolver initialized'); }","cleanup":"async function() { console.log('Bandcamp resolver cleanup'); }"}},
  {"manifest":{"id":"qobuz","name":"Qobuz","version":"1.0.0","author":"Parachord Team","description":"High-quality audio streaming with 30-second previews. Subscription required for full playback.","icon":"ðŸŽµ","color":"#0E7EBF","homepage":"https://qobuz.com","email":"support@harmonix.app"},"capabilities":{"resolve":true,"search":true,"stream":true,"browse":false,"urlLookup":false},"settings":{"requiresAuth":false,"authType":"apikey","configurable":{"appId":{"type":"text","label":"App ID","default":"285473059","readonly":true,"description":"Public demo app ID"}}},"implementation":{"search":"async function(query, config) { try { console.log('Searching Qobuz for:', query); const appId = config.appId || '285473059'; const response = await fetch(`https://www.qobuz.com/api.json/0.2/track/search?query=${encodeURIComponent(query)}&limit=20&app_id=${appId}`, { headers: { 'User-Agent': 'Parachord/1.0.0' } }); if (!response.ok) { console.error('Qobuz search failed:', response.status); return []; } const data = await response.json(); if (!data.tracks || !data.tracks.items) { console.log('No Qobuz results found'); return []; } const results = data.tracks.items.map(track => ({ id: `qobuz-${track.id}`, title: track.title, artist: track.performer?.name || track.album?.artist?.name || 'Unknown Artist', album: track.album?.title || 'Unknown Album', duration: track.duration || 180, sources: ['qobuz'], qobuzId: track.id, albumArt: track.album?.image?.small || track.album?.image?.thumbnail, previewUrl: track.preview_url, streamable: track.streamable, quality: track.maximum_bit_depth ? `${track.maximum_bit_depth}bit/${track.maximum_sampling_rate}kHz` : 'CD Quality' })); console.log(`Found ${results.length} Qobuz results`); return results; } catch (error) { console.error('Qobuz search error:', error); return []; } }","resolve":"async function(artist, track, album, config) { const query = `${artist} ${track}`; const results = await this.search(query, config); return results[0] || null; }","play":"async function(track, config) { if (!track.previewUrl) { console.error('No Qobuz preview URL'); return false; } try { const audio = new Audio(track.previewUrl); audio.volume = config.volume || 0.7; await audio.play(); console.log('Playing Qobuz 30-second preview'); return true; } catch (error) { console.error('Failed to play Qobuz preview:', error); return false; } }","init":"async function(config) { console.log('Qobuz resolver initialized'); }","cleanup":"async function() { console.log('Qobuz resolver cleanup'); }"}},
];



// TrackRow component - defined outside to prevent recreation on every render
const TrackRow = React.memo(({ track, isPlaying, handlePlay, onArtistClick, onContextMenu, allResolvers, resolverOrder, activeResolvers }) => {
  // Get available sources (track.sources is an object with resolver IDs as keys)
  // Sort by priority order (left to right = highest to lowest priority)
  const availableSources = track.sources && typeof track.sources === 'object' && !Array.isArray(track.sources)
    ? Object.keys(track.sources).sort((a, b) => {
        const aIndex = resolverOrder?.indexOf(a) ?? 999;
        const bIndex = resolverOrder?.indexOf(b) ?? 999;
        return aIndex - bIndex;
      })
    : [];

  // Resolver metadata for badge display
  const resolverMeta = {
    spotify: { label: 'Spotify', bgColor: 'bg-green-600/20', textColor: 'text-green-400' },
    youtube: { label: 'YouTube', bgColor: 'bg-red-600/20', textColor: 'text-red-400' },
    bandcamp: { label: 'Bandcamp', bgColor: 'bg-cyan-600/20', textColor: 'text-cyan-400' },
    qobuz: { label: 'Qobuz', bgColor: 'bg-blue-600/20', textColor: 'text-blue-400' }
  };

  // Determine which resolver will be used (based on priority)
  const getPrimaryResolver = () => {
    if (!availableSources.length || !resolverOrder || !activeResolvers || !allResolvers) return null;

    const sortedSources = availableSources
      .map(resId => ({
        resolverId: resId,
        priority: resolverOrder.indexOf(resId)
      }))
      .filter(s => activeResolvers.includes(s.resolverId))
      .sort((a, b) => a.priority - b.priority);

    if (sortedSources.length === 0) return null;

    const primaryResolverId = sortedSources[0].resolverId;
    return allResolvers.find(r => r.id === primaryResolverId);
  };

  const primaryResolver = getPrimaryResolver();

  return React.createElement('div', {
    className: 'group flex items-center gap-4 p-3 rounded-lg hover:bg-gray-100 transition-colors no-drag',
    onContextMenu: (e) => {
      e.preventDefault();
      if (onContextMenu) {
        onContextMenu(track);
      }
    }
  },
    // Album art or play button
    React.createElement('div', { className: 'relative w-12 h-12 flex-shrink-0' },
      React.createElement('div', {
        className: 'w-12 h-12 bg-gradient-to-br from-purple-500 to-pink-500 rounded flex items-center justify-center overflow-hidden'
      },
        track.albumArt && React.createElement('img', {
          src: track.albumArt,
          alt: track.album,
          className: 'absolute inset-0 w-full h-full object-cover transition-opacity duration-300',
          style: { opacity: 0 },
          ref: (el) => { if (el && el.complete && el.naturalWidth > 0) el.style.opacity = '1'; },
          onLoad: (e) => { e.target.style.opacity = '1'; },
          onError: (e) => { e.target.style.display = 'none'; }
        }),
        React.createElement(Music)
      ),
      React.createElement('button', {
        onClick: () => handlePlay(track),
        className: 'absolute inset-0 flex items-center justify-center rounded bg-black/60 opacity-0 group-hover:opacity-100 transition-opacity'
      },
        React.createElement('div', { className: 'w-8 h-8 flex items-center justify-center rounded-full bg-purple-600 text-sm' },
          isPlaying ? React.createElement(Pause) : React.createElement(Play)
        )
      )
    ),
    React.createElement('div', { className: 'flex-1 min-w-0' },
      React.createElement('div', { className: `text-xs font-medium truncate ${isPlaying ? 'text-purple-600' : 'text-gray-900'}` }, track.title),
      React.createElement('div', { className: 'flex items-center gap-2' },
        React.createElement('button', {
          onClick: (e) => {
            e.stopPropagation();
            if (onArtistClick) {
              onArtistClick(track.artist);
            }
          },
          className: 'text-xs text-gray-500 truncate hover:text-purple-600 hover:underline cursor-pointer transition-colors',
          title: `View ${track.artist}'s discography`
        }, track.artist),
        // Resolver badges - clickable for manual override
        ...availableSources.map(resolverId => {
          const meta = resolverMeta[resolverId];
          if (!meta) return null;

          return React.createElement('button', {
            key: resolverId,
            onClick: (e) => {
              e.stopPropagation();
              // Play from this specific resolver
              handlePlay(track.sources[resolverId]);
            },
            className: `text-xs px-2 py-0.5 ${meta.bgColor} ${meta.textColor} rounded-full hover:opacity-80 transition-opacity cursor-pointer`,
            title: `Play from ${meta.label} (manual override)`
          }, meta.label);
        })
      ),
      primaryResolver && React.createElement('div', { className: 'text-xs text-gray-400 mt-0.5' }, `via ${primaryResolver.name}`)
    ),
    React.createElement('div', { className: 'text-xs text-gray-500 truncate max-w-[200px]' }, track.album),
    React.createElement('div', { className: 'text-xs text-gray-500 w-12 text-right' },
      `${Math.floor(track.duration / 60)}:${(track.duration % 60).toString().padStart(2, '0')}`
    )
  );
});

// Service logo SVG paths - reusable for different sizes
const SERVICE_LOGO_PATHS = {
  spotify: 'M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.419 1.56-.299.421-1.02.599-1.559.3z',
  bandcamp: 'M0 18.75l7.437-13.5H24l-7.438 13.5H0z',
  qobuz: 'M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 14.5c-2.49 0-4.5-2.01-4.5-4.5S9.51 7.5 12 7.5s4.5 2.01 4.5 4.5-2.01 4.5-4.5 4.5zm0-7c-1.38 0-2.5 1.12-2.5 2.5s1.12 2.5 2.5 2.5 2.5-1.12 2.5-2.5-1.12-2.5-2.5-2.5z',
  youtube: 'M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z',
  localfiles: 'M20 6h-8l-2-2H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm-6 10h-4v-4H8l4-4 4 4h-2v4z',
  applemusic: 'M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z',
  wikipedia: 'M12.09 13.119c-.936 1.932-2.217 4.548-2.853 5.728-.616 1.074-1.127.931-1.532.029-1.406-3.321-4.293-9.144-5.651-12.409-.251-.601-.441-.987-.619-1.139-.181-.15-.554-.24-1.122-.271C.103 5.033 0 4.982 0 4.898v-.455l.052-.045c.924-.005 5.401 0 5.401 0l.051.045v.434c0 .119-.075.176-.225.176l-.564.031c-.485.029-.727.164-.727.436 0 .135.053.33.166.601 1.082 2.646 4.818 10.521 4.818 10.521l2.681-5.476-2.607-5.24c-.237-.477-.42-.752-.545-.825-.126-.073-.437-.123-.934-.147l-.356-.022c-.152 0-.228-.053-.228-.166v-.457c0-.119.085-.17.253-.15l4.834.045.042.045v.447c0 .119-.07.176-.212.176l-.453.022c-.454.022-.681.155-.681.4 0 .106.043.274.133.502l2.008 4.097 1.905-3.971c.09-.183.137-.38.137-.597 0-.243-.233-.383-.7-.424l-.453-.022c-.152 0-.228-.058-.228-.176v-.457c0-.085.058-.134.176-.15l4.063-.045.042.045v.457c0 .106-.07.164-.212.164l-.534.031c-.391.022-.681.142-.863.36-.182.218-.404.573-.668 1.068l-2.388 4.786 2.715 5.455s3.767-7.894 4.916-10.442c.15-.326.223-.586.223-.78 0-.263-.233-.405-.7-.427l-.534-.022c-.152 0-.228-.058-.228-.176v-.457c0-.085.058-.129.176-.129h4.863l.033.045v.457c0 .106-.07.164-.212.164-.609.014-1.055.089-1.34.22-.285.133-.542.398-.767.792-.346.6-4.608 9.075-5.906 11.667-.377.755-.882.939-1.268.047-.54-1.254-2.7-5.471-2.7-5.471l-2.625 5.42c-.27.549-.748.704-1.14.013-.54-1.125-2.841-5.773-2.841-5.773z',
  discogs: 'M12 0C5.372 0 0 5.372 0 12s5.372 12 12 12 12-5.372 12-12S18.628 0 12 0zm0 21.6c-5.304 0-9.6-4.296-9.6-9.6S6.696 2.4 12 2.4s9.6 4.296 9.6 9.6-4.296 9.6-9.6 9.6zm0-16.8c-3.972 0-7.2 3.228-7.2 7.2s3.228 7.2 7.2 7.2 7.2-3.228 7.2-7.2-3.228-7.2-7.2-7.2zm0 12c-2.652 0-4.8-2.148-4.8-4.8s2.148-4.8 4.8-4.8 4.8 2.148 4.8 4.8-2.148 4.8-4.8 4.8zm0-7.2c-1.326 0-2.4 1.074-2.4 2.4s1.074 2.4 2.4 2.4 2.4-1.074 2.4-2.4-1.074-2.4-2.4-2.4z'
};

// Helper to create resolver icon at any size
const ResolverIcon = ({ resolverId, size = 14, fill = 'white' }) => {
  const path = SERVICE_LOGO_PATHS[resolverId];
  if (!path) return null;
  return React.createElement('svg', {
    viewBox: '0 0 24 24',
    width: size,
    height: size,
    fill: fill,
    style: { flexShrink: 0 }
  }, React.createElement('path', { d: path }));
};

// Service logo SVGs - white versions for colored backgrounds
const SERVICE_LOGOS = {
  spotify: React.createElement('svg', { viewBox: '0 0 24 24', className: 'w-16 h-16', fill: 'white' },
    React.createElement('path', { d: 'M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.419 1.56-.299.421-1.02.599-1.559.3z' })
  ),
  bandcamp: React.createElement('svg', { viewBox: '0 0 24 24', className: 'w-16 h-16', fill: 'white' },
    React.createElement('path', { d: 'M0 18.75l7.437-13.5H24l-7.438 13.5H0z' })
  ),
  qobuz: React.createElement('svg', { viewBox: '0 0 24 24', className: 'w-16 h-16', fill: 'white' },
    React.createElement('path', { d: 'M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 14.5c-2.49 0-4.5-2.01-4.5-4.5S9.51 7.5 12 7.5s4.5 2.01 4.5 4.5-2.01 4.5-4.5 4.5zm0-7c-1.38 0-2.5 1.12-2.5 2.5s1.12 2.5 2.5 2.5 2.5-1.12 2.5-2.5-1.12-2.5-2.5-2.5z' })
  ),
  youtube: React.createElement('svg', { viewBox: '0 0 24 24', className: 'w-16 h-16', fill: 'white' },
    React.createElement('path', { d: 'M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z' })
  ),
  soundcloud: React.createElement('svg', { viewBox: '0 0 24 24', className: 'w-16 h-16', fill: 'white' },
    React.createElement('path', { d: 'M1.175 12.225c-.051 0-.094.046-.101.1l-.233 2.154.233 2.105c.007.058.05.098.101.098.05 0 .09-.04.099-.098l.255-2.105-.27-2.154c-.009-.06-.052-.1-.084-.1zm-.899.828c-.06 0-.091.037-.104.094L0 14.479l.165 1.308c.014.057.045.094.09.094.049 0 .084-.037.09-.094l.195-1.308-.196-1.332c-.006-.057-.04-.094-.068-.094zm1.83-1.229c-.06 0-.12.037-.12.1l-.21 2.563.225 2.458c0 .06.045.1.105.1.074 0 .12-.04.12-.1l.24-2.458-.24-2.563c0-.06-.03-.1-.12-.1zm.945-.089c-.075 0-.135.045-.15.105l-.18 2.647.18 2.456c.015.06.075.105.15.105.075 0 .135-.045.15-.105l.21-2.456-.21-2.647c-.015-.06-.075-.105-.15-.105zm1.065.285c-.09 0-.15.045-.165.105l-.15 2.382.15 2.423c.015.075.075.12.165.12.09 0 .15-.045.165-.12l.18-2.423-.195-2.382c-.015-.06-.06-.105-.15-.105zm1.08-1.5c-.09 0-.18.06-.18.135l-.15 3.762.15 2.4c0 .09.09.149.18.149.09 0 .165-.06.18-.135l.165-2.414-.165-3.762c-.015-.09-.09-.135-.18-.135zm1.05-.706c-.105 0-.195.075-.195.165l-.12 4.333.12 2.37c0 .09.09.165.195.165.09 0 .18-.075.195-.165l.135-2.37-.135-4.333c-.015-.09-.09-.165-.195-.165zm1.14-.255c-.105 0-.21.075-.21.165l-.105 4.59.105 2.34c.015.09.105.165.21.165.105 0 .195-.075.21-.165l.12-2.355-.12-4.575c0-.09-.09-.165-.21-.165zm1.11-.165c-.12 0-.225.09-.225.18l-.09 4.74.09 2.31c.015.105.105.18.225.18.12 0 .21-.075.225-.18l.105-2.31-.105-4.74c-.015-.09-.105-.18-.225-.18zm1.17-.225c-.135 0-.24.09-.24.195l-.075 4.785.075 2.28c0 .12.105.21.24.21.12 0 .225-.09.24-.21l.09-2.28-.09-4.785c-.015-.105-.12-.195-.24-.195zm1.2.045c-.135 0-.255.105-.255.21l-.06 4.545.06 2.25c.015.12.12.21.255.21.15 0 .255-.09.27-.21l.075-2.25-.075-4.545c-.015-.105-.12-.21-.27-.21zm1.2.375c-.15 0-.27.105-.285.225l-.045 4.17.045 2.22c.015.12.135.225.285.225.135 0 .27-.105.27-.225l.06-2.22-.06-4.17c0-.12-.12-.225-.27-.225zm3.98-1.62c-.36 0-.705.06-1.035.18-.21-2.37-2.19-4.215-4.59-4.215-.615 0-1.2.135-1.725.36-.195.09-.255.18-.255.36v8.94c0 .18.15.345.33.36h7.275c1.665 0 3.015-1.35 3.015-3.015 0-1.665-1.35-3.015-3.015-3.015v.045z' })
  ),
  applemusic: React.createElement('svg', { viewBox: '0 0 361 361', className: 'w-16 h-16', fill: 'white' },
    React.createElement('path', { d: 'M263.54,234.26c0,4.56-0.04,8.7-1,13.26c-0.93,4.43-2.63,8.6-5.24,12.35c-2.61,3.74-5.95,6.81-9.85,9.11c-3.95,2.33-8.08,3.66-12.5,4.55c-8.3,1.67-13.97,2.05-19.31,0.98c-5.14-1.03-9.5-3.4-12.99-6.6c-5.17-4.74-8.39-11.14-9.09-17.82c-0.82-7.84,1.79-16.21,7.67-22.38c2.97-3.11,6.7-5.57,11.68-7.51c5.21-2.02,10.96-3.23,19.8-5.01c2.33-0.47,4.66-0.94,6.99-1.41c3.06-0.62,5.69-1.4,7.81-3.99c2.13-2.61,2.17-5.78,2.17-8.92l0-79.29c0-6.07-2.72-7.72-8.52-6.61c-4.14,0.81-93.09,18.75-93.09,18.75c-5.02,1.21-6.78,2.85-6.78,9.08l0,116.15c0,4.56-0.24,8.7-1.19,13.26c-0.93,4.43-2.63,8.6-5.24,12.35c-2.61,3.74-5.95,6.81-9.85,9.11c-3.95,2.33-8.08,3.72-12.5,4.61c-8.3,1.67-13.97,2.05-19.31,0.98c-5.14-1.03-9.5-3.47-12.99-6.66c-5.17-4.74-8.17-11.14-8.88-17.82c-0.82-7.84,1.57-16.21,7.46-22.38c2.97-3.11,6.7-5.57,11.68-7.51c5.21-2.02,10.96-3.23,19.8-5.01c2.33-0.47,4.66-0.94,6.99-1.41c3.06-0.62,5.69-1.4,7.81-3.99c2.12-2.59,2.37-5.64,2.37-8.76c0-24.6,0-133.92,0-133.92c0-1.8,0.15-3.02,0.24-3.62c0.43-2.82,1.56-5.24,3.6-6.95c1.7-1.42,3.88-2.41,6.67-3l0.04-0.01l107-21.59c0.93-0.19,8.66-1.56,9.53-1.64c5.78-0.5,9.03,3.3,9.03,9.46V234.26z' })
  ),
  localfiles: React.createElement('svg', { viewBox: '0 0 24 24', className: 'w-16 h-16', fill: 'white' },
    React.createElement('path', { d: 'M20 6h-8l-2-2H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm-6 10h-4v-4H8l4-4 4 4h-2v4z' })
  ),
  musicbrainz: React.createElement('svg', { viewBox: '0 0 24 24', className: 'w-16 h-16', fill: 'white' },
    React.createElement('path', { d: 'M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z' })
  ),
  lastfm: React.createElement('svg', { viewBox: '0 0 24 24', className: 'w-16 h-16', fill: 'white' },
    React.createElement('path', { d: 'M10.584 17.209l-.88-2.392s-1.43 1.595-3.573 1.595c-1.897 0-3.244-1.65-3.244-4.289 0-3.381 1.704-4.591 3.382-4.591 2.419 0 3.188 1.567 3.849 3.574l.88 2.75c.879 2.667 2.528 4.811 7.284 4.811 3.409 0 5.719-1.044 5.719-3.793 0-2.227-1.265-3.381-3.629-3.932l-1.76-.385c-1.209-.275-1.566-.77-1.566-1.594 0-.935.742-1.485 1.952-1.485 1.319 0 2.034.495 2.144 1.677l2.749-.33c-.22-2.474-1.924-3.491-4.729-3.491-2.474 0-4.893.935-4.893 3.931 0 1.87.907 3.052 3.188 3.602l1.869.439c1.402.33 1.869.907 1.869 1.705 0 1.017-.989 1.43-2.858 1.43-2.776 0-3.932-1.457-4.591-3.464l-.907-2.749c-1.155-3.574-2.997-4.894-6.653-4.894-4.041-.001-6.186 2.556-6.186 6.899 0 4.179 2.145 6.433 5.993 6.433 3.107.001 4.591-1.457 4.591-1.457z' })
  ),
  librefm: React.createElement('svg', { viewBox: '0 0 240 80', className: 'w-16 h-16', fill: 'white' },
    React.createElement('path', { d: 'm 19.97125,26.36764 c 0,-1.23526 0.41912,-2.20585 1.25736,-2.91176 0.70587,-0.70585 1.63234,-1.05879 2.77941,-1.05883 0.88234,4e-5 1.76469,0.37504 2.64706,1.125 0.7941,0.70592 1.19116,1.65445 1.19117,2.84559 l -0.46323,23.69118 9.92647,-0.46323 c 1.01468,0 1.8088,0.39706 2.38235,1.19117 0.57351,0.75001 0.86027,1.78677 0.8603,3.1103 -3e-5,1.05882 -0.28679,1.94117 -0.8603,2.64705 -0.52943,0.70589 -1.32355,1.05883 -2.38235,1.05883 l -13.96324,0 c -0.79412,0 -1.56618,-0.30882 -2.31617,-0.92647 -0.70589,-0.57353 -1.05883,-1.27941 -1.05883,-2.11765 l 0,-28.19118 z m 24.90915,27.26471 -0.2647,-26.93382 c -1e-5,-1.27938 0.39705,-2.31615 1.19117,-3.1103 0.75,-0.66173 1.7647,-0.99261 3.04412,-0.99265 1.2794,4e-5 2.27205,0.33092 2.97794,0.99265 0.70587,0.6618 1.05881,1.56621 1.05883,2.71324 l -0.33089,27.33088 c -1e-5,1.2353 -0.37501,2.22794 -1.125,2.97794 -0.75001,0.70588 -1.63236,1.05883 -2.64706,1.05882 -1.14706,1e-5 -2.07353,-0.35294 -2.77941,-1.05882 -0.75,-0.70588 -1.125,-1.69853 -1.125,-2.97794 l 0,0 z m 13.31406,-27.26471 c 0,-0.88232 0.30882,-1.72055 0.92647,-2.5147 0.61764,-0.88232 1.32353,-1.3235 2.11765,-1.32353 l 12.04412,0 c 2.16174,3e-5 4.03674,0.9265 5.625,2.77941 1.58821,1.85297 2.38232,3.9265 2.38235,6.22059 -3e-5,2.86767 -1.27944,5.09561 -3.83823,6.68382 2.24997,0.35296 3.97056,1.36767 5.16176,3.04412 1.0588,1.50001 1.58821,3.35295 1.58824,5.55882 -3e-5,2.82354 -0.79415,5.29413 -2.38236,7.41177 -1.76473,2.33823 -3.97061,3.50735 -6.61764,3.50735 l -13.96324,0 c -0.79412,0 -1.50001,-0.24265 -2.11765,-0.72794 -0.61765,-0.48529 -0.92647,-1.125 -0.92647,-1.91912 l 0,-28.72059 z m 13.89706,15.81618 -5.82353,0 0,8.60294 5.82353,0 c 1.80881,1e-5 3.13233,-0.37499 3.97059,-1.125 0.70586,-0.70587 1.0588,-1.52205 1.05882,-2.44853 -2e-5,-0.57352 -0.11031,-1.30146 -0.33088,-2.18382 -0.22061,-0.88234 -0.48531,-1.47793 -0.79412,-1.78677 -0.7059,-0.70586 -2.00737,-1.0588 -3.90441,-1.05882 l 0,0 z m -1.19117,-11.97794 -4.63236,0 0,7.34559 5.82353,0 c 1.32351,2e-5 1.98528,-0.97057 1.9853,-2.91177 -2e-5,-1.58821 -0.22061,-2.73527 -0.66177,-3.44117 -0.39708,-0.66174 -1.23531,-0.99262 -2.5147,-0.99265 l 0,0 z m 17.02995,-5.09559 c -10e-6,-0.61761 0.2647,-1.30144 0.79412,-2.05147 0.61764,-0.70585 1.23528,-1.05879 1.85294,-1.05882 l 13.10294,0 c 2.60292,3e-5 4.87498,1.08091 6.81618,3.24264 1.89703,2.25003 2.84556,4.6765 2.84559,7.27941 -3e-5,2.02944 -0.61768,3.86032 -1.85295,5.49265 -1.36767,1.72061 -3.4412,3.0662 -6.22058,4.03677 l 7.875,7.94117 c 0.8382,0.9706 1.25732,2.00736 1.25735,3.1103 -3e-5,1.05883 -0.35297,1.94118 -1.05882,2.64706 -0.26474,0.35294 -0.69489,0.79412 -1.29045,1.32353 -0.59561,0.52941 -1.11399,0.79411 -1.55514,0.79411 -1.50003,0 -2.86767,-0.74999 -4.10294,-2.25 l -10.45589,-12.83823 0,10.52206 c -1e-5,1.27941 -0.41913,2.38235 -1.25735,3.30882 -0.79413,0.79412 -1.76472,1.19118 -2.91177,1.19118 -1.10294,0 -2.00735,-0.39706 -2.71323,-1.19118 -0.75001,-0.70588 -1.12501,-1.80882 -1.125,-3.30882 l 0,-28.19118 z m 8.00735,3.77206 0,8.13971 5.88971,0 c 1.63233,2e-5 2.75733,-0.39704 3.375,-1.19118 0.66174,-0.7941 1.01468,-1.85292 1.05882,-3.17647 -2e-5,-0.74998 -0.35296,-1.61027 -1.05882,-2.58088 -0.61767,-0.79409 -1.74267,-1.19115 -3.375,-1.19118 l -5.88971,0 z m 22.69014,-3.04412 c -1e-5,-1.05879 0.30881,-1.89702 0.92647,-2.51471 0.70587,-0.61761 1.52205,-0.92643 2.44853,-0.92647 l 12.83823,0 c 1.19116,4e-5 2.09557,0.44122 2.71324,1.32353 0.61762,0.83827 0.92644,1.7868 0.92647,2.84559 -3e-5,1.19121 -0.24267,2.13974 -0.72794,2.84559 -0.52944,0.70591 -1.27944,1.05885 -2.25,1.05882 l -10.58824,-0.39705 0,6.75 9.92647,-0.39706 c 0.92645,2e-5 1.65439,0.37502 2.18383,1.125 0.5735,0.75002 0.86027,1.78678 0.86029,3.11029 -2e-5,1.05884 -0.22061,1.96325 -0.66176,2.71324 -0.52944,0.70589 -1.21326,1.05883 -2.05148,1.05882 l -10.25735,-0.33088 0,6.22059 9.92647,-0.46324 c 1.23527,1e-5 2.1838,0.39707 2.84559,1.19118 0.66174,0.70589 0.99262,1.74265 0.99265,3.11029 -3e-5,0.92648 -0.26473,1.72059 -0.79412,2.38235 -0.48532,0.70589 -1.12502,1.05883 -1.91912,1.05883 l -14.69118,0 c -0.52941,0 -1.10294,-0.30882 -1.72058,-0.92647 -0.61766,-0.48529 -0.92648,-1.08088 -0.92647,-1.78677 l 0,-29.05147 z m 29.13024,23.42647 c 1.23528,1e-5 2.20587,0.41913 2.91176,1.25736 0.70587,0.92647 1.05881,1.94118 1.05882,3.04411 -1e-5,1.10295 -0.33089,2.05148 -0.99264,2.84559 -0.75001,0.88236 -1.74266,1.32353 -2.97794,1.32353 -1.32354,0 -2.38236,-0.44117 -3.17648,-1.32353 -0.70588,-0.92647 -1.05882,-1.91911 -1.05882,-2.97794 0,-1.10294 0.375,-2.07352 1.125,-2.91176 0.70588,-0.83823 1.74264,-1.25735 3.1103,-1.25736 l 0,0 z m 8.83665,4.63236 0,-27.8603 c 0,-2.29408 0.99264,-3.44114 2.97794,-3.44118 l 13.56618,0 c 1.10292,4e-5 1.98527,0.3971 2.64706,1.19118 0.61762,0.83827 0.92645,1.76474 0.92647,2.77941 -2e-5,1.32356 -0.22061,2.25003 -0.66176,2.77941 -0.48532,0.6618 -1.16915,0.99268 -2.05148,0.99265 l -10.78676,-0.39706 0,5.625 9.52941,-0.39706 c 1.01469,3e-5 1.78674,0.35297 2.31618,1.05883 0.5735,0.7059 0.86027,1.72061 0.86029,3.04412 -2e-5,0.92648 -0.26473,1.7206 -0.79412,2.38235 -0.57355,0.79413 -1.36766,1.19119 -2.38235,1.19117 l -9.52941,0 0,11.05148 c -1e-5,1.23529 -0.39707,2.18382 -1.19118,2.84558 -0.75001,0.66177 -1.63236,0.99265 -2.64706,0.99265 -0.44118,0 -0.76103,-0.0772 -0.95956,-0.23162 -0.19853,-0.15441 -0.43015,-0.40808 -0.69485,-0.76103 -0.75,-0.61764 -1.125,-1.56617 -1.125,-2.84558 l 0,0 z m 37.4617,-27.00001 5.36029,15.88236 5.75736,-15.88236 c 0.52938,-1.32349 1.27938,-2.3382 2.25,-3.04411 0.97055,-0.70585 2.02937,-1.05879 3.17647,-1.05883 1.19114,4e-5 2.24996,0.3971 3.17647,1.19118 1.01466,0.88239 1.65437,2.11768 1.91911,3.70588 l 4.36765,25.94118 0,0.86029 c -4e-5,1.05883 -0.33093,1.91912 -0.99265,2.58089 -0.75004,0.61764 -1.87504,0.92647 -3.375,0.92647 -0.97062,0 -1.83092,-0.30883 -2.58088,-0.92647 -0.48533,-0.39706 -0.99268,-2.22794 -1.52206,-5.49265 l -1.98529,-16.21324 -0.0662,0 c -0.13239,3e-5 -0.2868,0.0441 -0.46323,0.13236 l -5.02941,16.08088 c -1.36768,4.2353 -2.77944,6.35294 -4.2353,6.35294 -1.36767,0 -2.80149,-2.11764 -4.30147,-6.35294 l -5.22794,-15.08824 -0.19853,-0.33088 -0.0662,0 c -0.13237,2e-5 -0.33089,0.0883 -0.59559,0.26471 l -0.99264,13.96323 c -0.26472,1.94118 -0.77207,3.69486 -1.52206,5.26103 -0.75001,1.56618 -1.67648,2.34927 -2.77941,2.34927 -1.85295,0 -3.15442,-0.375 -3.90442,-1.125 -0.79412,-0.70588 -1.19118,-1.61029 -1.19117,-2.71324 l 0,-0.59559 4.5,-25.875 c 0.2647,-1.54408 0.9044,-2.75732 1.91912,-3.6397 1.10293,-0.88232 2.24998,-1.3235 3.44117,-1.32353 2.47057,3e-5 4.19116,1.38974 5.16177,4.16911 l 0,0 z' })
  ),
  listenbrainz: React.createElement('svg', { viewBox: '0 0 146 160', className: 'w-16 h-16', fill: 'white' },
    React.createElement('path', { d: 'm75.354 7.823v144l61-35v-74z' }),
    React.createElement('path', { d: 'm70.354 7.823-61 35v74l61 35z' })
  ),
  chatgpt: React.createElement('svg', { viewBox: '-0.17090198558635983 0.482230148717937 41.14235318283891 40.0339509076386', className: 'w-16 h-16', fill: 'white' },
    React.createElement('path', { d: 'M37.532 16.87a9.963 9.963 0 0 0-.856-8.184 10.078 10.078 0 0 0-10.855-4.835A9.964 9.964 0 0 0 18.306.5a10.079 10.079 0 0 0-9.614 6.977 9.967 9.967 0 0 0-6.664 4.834 10.08 10.08 0 0 0 1.24 11.817 9.965 9.965 0 0 0 .856 8.185 10.079 10.079 0 0 0 10.855 4.835 9.965 9.965 0 0 0 7.516 3.35 10.078 10.078 0 0 0 9.617-6.981 9.967 9.967 0 0 0 6.663-4.834 10.079 10.079 0 0 0-1.243-11.813zM22.498 37.886a7.474 7.474 0 0 1-4.799-1.735c.061-.033.168-.091.237-.134l7.964-4.6a1.294 1.294 0 0 0 .655-1.134V19.054l3.366 1.944a.12.12 0 0 1 .066.092v9.299a7.505 7.505 0 0 1-7.49 7.496zM6.392 31.006a7.471 7.471 0 0 1-.894-5.023c.06.036.162.099.237.141l7.964 4.6a1.297 1.297 0 0 0 1.308 0l9.724-5.614v3.888a.12.12 0 0 1-.048.103l-8.051 4.649a7.504 7.504 0 0 1-10.24-2.744zM4.297 13.62A7.469 7.469 0 0 1 8.2 10.333c0 .068-.004.19-.004.274v9.201a1.294 1.294 0 0 0 .654 1.132l9.723 5.614-3.366 1.944a.12.12 0 0 1-.114.01L7.04 23.856a7.504 7.504 0 0 1-2.743-10.237zm27.658 6.437l-9.724-5.615 3.367-1.943a.121.121 0 0 1 .113-.01l8.052 4.648a7.498 7.498 0 0 1-1.158 13.528v-9.476a1.293 1.293 0 0 0-.65-1.132zm3.35-5.043c-.059-.037-.162-.099-.236-.141l-7.965-4.6a1.298 1.298 0 0 0-1.308 0l-9.723 5.614v-3.888a.12.12 0 0 1 .048-.103l8.05-4.645a7.497 7.497 0 0 1 11.135 7.763zm-21.063 6.929l-3.367-1.944a.12.12 0 0 1-.065-.092v-9.299a7.497 7.497 0 0 1 12.293-5.756 6.94 6.94 0 0 0-.236.134l-7.965 4.6a1.294 1.294 0 0 0-.654 1.132l-.006 11.225zm1.829-3.943l4.33-2.501 4.332 2.5v5l-4.331 2.5-4.331-2.5V18z' })
  ),
  wikipedia: React.createElement('svg', { viewBox: '0 0 24 24', className: 'w-16 h-16', fill: 'white' },
    React.createElement('path', { d: 'M12.09 13.119c-.936 1.932-2.217 4.548-2.853 5.728-.616 1.074-1.127.931-1.532.029-1.406-3.321-4.293-9.144-5.651-12.409-.251-.601-.441-.987-.619-1.139-.181-.15-.554-.24-1.122-.271C.103 5.033 0 4.982 0 4.898v-.455l.052-.045c.924-.005 5.401 0 5.401 0l.051.045v.434c0 .119-.075.176-.225.176l-.564.031c-.485.029-.727.164-.727.436 0 .135.053.33.166.601 1.082 2.646 4.818 10.521 4.818 10.521l2.681-5.476-2.607-5.24c-.237-.477-.42-.752-.545-.825-.126-.073-.437-.123-.934-.147l-.356-.022c-.152 0-.228-.053-.228-.166v-.457c0-.119.085-.17.253-.15l4.834.045.042.045v.447c0 .119-.07.176-.212.176l-.453.022c-.454.022-.681.155-.681.4 0 .106.043.274.133.502l2.008 4.097 1.905-3.971c.09-.183.137-.38.137-.597 0-.243-.233-.383-.7-.424l-.453-.022c-.152 0-.228-.058-.228-.176v-.457c0-.085.058-.134.176-.15l4.063-.045.042.045v.457c0 .106-.07.164-.212.164l-.534.031c-.391.022-.681.142-.863.36-.182.218-.404.573-.668 1.068l-2.388 4.786 2.715 5.455s3.767-7.894 4.916-10.442c.15-.326.223-.586.223-.78 0-.263-.233-.405-.7-.427l-.534-.022c-.152 0-.228-.058-.228-.176v-.457c0-.085.058-.129.176-.129h4.863l.033.045v.457c0 .106-.07.164-.212.164-.609.014-1.055.089-1.34.22-.285.133-.542.398-.767.792-.346.6-4.608 9.075-5.906 11.667-.377.755-.882.939-1.268.047-.54-1.254-2.7-5.471-2.7-5.471l-2.625 5.42c-.27.549-.748.704-1.14.013-.54-1.125-2.841-5.773-2.841-5.773z' })
  ),
  discogs: React.createElement('svg', { viewBox: '0 0 24 24', className: 'w-16 h-16', fill: 'white' },
    React.createElement('path', { d: 'M12 0C5.372 0 0 5.372 0 12s5.372 12 12 12 12-5.372 12-12S18.628 0 12 0zm0 21.6c-5.304 0-9.6-4.296-9.6-9.6S6.696 2.4 12 2.4s9.6 4.296 9.6 9.6-4.296 9.6-9.6 9.6zm0-16.8c-3.972 0-7.2 3.228-7.2 7.2s3.228 7.2 7.2 7.2 7.2-3.228 7.2-7.2-3.228-7.2-7.2-7.2zm0 12c-2.652 0-4.8-2.148-4.8-4.8s2.148-4.8 4.8-4.8 4.8 2.148 4.8 4.8-2.148 4.8-4.8 4.8zm0-7.2c-1.326 0-2.4 1.074-2.4 2.4s1.074 2.4 2.4 2.4 2.4-1.074 2.4-2.4-1.074-2.4-2.4-2.4z' })
  )
};

// ResolverCard component - Tomahawk-style colored card with centered logo
const ResolverCard = React.memo(({
  resolver,
  isActive,
  isInstalled,
  hasUpdate,
  isInstalling,
  priorityNumber,
  onClick,
  onDragStart,
  onDragOver,
  onDragEnter,
  onDragLeave,
  onDrop,
  onDragEnd,
  onContextMenu,
  draggable = false,
  isDragOver = false,
  isDragging = false
}) => {
  // Get the logo SVG or fall back to emoji icon
  const logo = SERVICE_LOGOS[resolver.id];

  return React.createElement('div', {
    className: `flex flex-col items-center relative ${isDragging ? 'opacity-50' : ''}`,
    draggable: draggable,
    onDragStart: draggable ? onDragStart : undefined,
    onDragOver: draggable ? onDragOver : undefined,
    onDragEnter: draggable ? onDragEnter : undefined,
    onDragLeave: draggable ? onDragLeave : undefined,
    onDrop: draggable ? onDrop : undefined,
    onDragEnd: draggable ? onDragEnd : undefined,
    onContextMenu: onContextMenu
  },
    // Drop indicator - shown when dragging over this card
    isDragOver && React.createElement('div', {
      className: 'absolute -left-3 top-0 bottom-6 w-1 bg-purple-500 rounded-full',
      style: {
        boxShadow: '0 0 8px rgba(147, 51, 234, 0.6)',
        zIndex: 10
      }
    }),
    // Card with colored background
    React.createElement('div', {
      className: `relative w-32 h-32 rounded-xl flex items-center justify-center cursor-pointer transition-all hover:scale-105 hover:shadow-lg ${
        isActive === false ? 'opacity-50 grayscale' : ''
      } ${isDragOver ? 'ring-2 ring-purple-500 ring-offset-2' : ''}`,
      style: { backgroundColor: resolver.color || '#6B7280' },
      onClick: onClick
    },
      // Priority number badge (top-left)
      priorityNumber && React.createElement('div', {
        className: 'absolute top-2 left-2 w-6 h-6 bg-white/90 rounded-full flex items-center justify-center text-xs font-bold text-gray-700 shadow-sm'
      }, priorityNumber),
      // Centered logo or emoji fallback
      logo ? logo : React.createElement('span', {
        className: 'text-5xl text-white drop-shadow-md'
      }, resolver.icon),
      // Status overlay for installed/update (marketplace view)
      isInstalled && React.createElement('div', {
        className: `absolute top-2 right-2 w-6 h-6 rounded-full flex items-center justify-center text-xs ${
          hasUpdate ? 'bg-orange-500 text-white' : 'bg-white text-green-600'
        }`
      }, hasUpdate ? 'â†‘' : 'âœ“'),
      // Active checkmark for installed tab (when not in marketplace view and no update)
      !isInstalled && !hasUpdate && React.createElement('div', {
        className: 'absolute top-2 right-2 w-6 h-6 bg-white rounded-full flex items-center justify-center text-xs text-green-600'
      }, 'âœ“'),
      // Update badge for installed tab (top-right, only when not showing installed badge)
      !isInstalled && hasUpdate && React.createElement('div', {
        className: 'absolute top-2 right-2 w-6 h-6 bg-orange-500 rounded-full flex items-center justify-center text-xs text-white'
      }, 'â†‘'),
      // Installing spinner
      isInstalling && React.createElement('div', {
        className: 'absolute inset-0 bg-black/40 rounded-xl flex items-center justify-center'
      },
        React.createElement('span', { className: 'text-white text-2xl animate-spin' }, 'â³')
      )
    ),
    // Name below card
    React.createElement('span', {
      className: 'mt-3 text-sm text-gray-900 font-medium text-center truncate w-32'
    }, resolver.name)
  );
});

// ScrobblerSettingsCard component - Settings card for individual scrobbler services
const ScrobblerSettingsCard = React.memo(({ scrobbler, config, onConfigChange }) => {
  const [connecting, setConnecting] = useState(false);
  const [error, setError] = useState(null);
  const [tokenInput, setTokenInput] = useState('');

  const isConnected = config?.enabled && (config?.sessionKey || config?.userToken);

  const handleConnect = async () => {
    setConnecting(true);
    setError(null);

    try {
      if (scrobbler.id === 'listenbrainz') {
        // Token-based auth
        await scrobbler.connect(tokenInput);
        onConfigChange(scrobbler.id, await scrobbler.getConfig());
        setTokenInput('');
      } else {
        // OAuth flow (Last.fm, Libre.fm)
        const { authUrl } = await scrobbler.startAuth();
        window.electron.shell.openExternal(authUrl);
        // Update config to show pending state
        onConfigChange(scrobbler.id, await scrobbler.getConfig());
      }
    } catch (err) {
      setError(err.message);
    } finally {
      setConnecting(false);
    }
  };

  const handleCompleteAuth = async () => {
    setConnecting(true);
    setError(null);

    try {
      await scrobbler.completeAuth();
      onConfigChange(scrobbler.id, await scrobbler.getConfig());
    } catch (err) {
      setError(err.message);
    } finally {
      setConnecting(false);
    }
  };

  const handleDisconnect = async () => {
    setError(null);
    try {
      await scrobbler.disconnect();
      onConfigChange(scrobbler.id, {});
    } catch (err) {
      setError(err.message);
    }
  };

  const handleToggleEnabled = async () => {
    setError(null);
    try {
      const newConfig = { ...config, enabled: !config?.enabled };
      await scrobbler.setConfig(newConfig);
      onConfigChange(scrobbler.id, newConfig);
    } catch (err) {
      setError(err.message);
    }
  };

  // Get scrobbler-specific styling
  const getScrobblerColor = () => {
    switch (scrobbler.id) {
      case 'lastfm': return 'bg-red-500';
      case 'listenbrainz': return 'bg-orange-500';
      case 'librefm': return 'bg-green-500';
      default: return 'bg-gray-500';
    }
  };

  return React.createElement('div', {
    className: 'bg-white rounded-xl p-4 shadow-sm border border-gray-200 hover:shadow-md hover:border-gray-300 transition-all'
  },
    // Header row with icon, name, and toggle
    React.createElement('div', { className: 'flex items-center justify-between mb-3' },
      React.createElement('div', { className: 'flex items-center gap-3' },
        // Service icon
        React.createElement('div', {
          className: `w-10 h-10 rounded-lg flex items-center justify-center ${getScrobblerColor()}`
        },
          React.createElement('span', { className: 'text-white text-lg font-bold' },
            scrobbler.name[0]
          )
        ),
        // Service name and connection status
        React.createElement('div', null,
          React.createElement('h3', { className: 'font-medium text-gray-900' }, scrobbler.name),
          isConnected && config?.username && React.createElement('p', {
            className: 'text-sm text-gray-500'
          }, `Connected as ${config.username}`)
        )
      ),
      // Enabled toggle (only when connected)
      isConnected && React.createElement('button', {
        onClick: handleToggleEnabled,
        className: `relative w-11 h-6 rounded-full transition-colors ${config?.enabled ? 'bg-purple-600' : 'bg-gray-300'}`
      },
        React.createElement('span', {
          className: `absolute top-0.5 left-0.5 w-5 h-5 bg-white rounded-full shadow transition-transform ${config?.enabled ? 'translate-x-5' : 'translate-x-0'}`
        })
      )
    ),

    // Error message
    error && React.createElement('div', {
      className: 'mb-3 p-2 bg-red-50 text-red-600 text-sm rounded-lg'
    }, error),

    // Connection UI
    !isConnected ? React.createElement('div', { className: 'space-y-3' },
      // ListenBrainz token input
      scrobbler.id === 'listenbrainz' && React.createElement('div', null,
        React.createElement('label', { className: 'block text-sm text-gray-600 mb-1' },
          'User Token',
          React.createElement('a', {
            href: '#',
            onClick: (e) => {
              e.preventDefault();
              window.electron.shell.openExternal('https://listenbrainz.org/settings/');
            },
            className: 'ml-2 text-purple-600 hover:underline'
          }, 'Get token')
        ),
        React.createElement('input', {
          type: 'text',
          value: tokenInput,
          onChange: (e) => setTokenInput(e.target.value),
          placeholder: 'Enter your ListenBrainz token',
          className: 'w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent'
        })
      ),

      // Connect button
      React.createElement('button', {
        onClick: handleConnect,
        disabled: connecting || (scrobbler.id === 'listenbrainz' && !tokenInput),
        className: 'w-full py-2 px-4 bg-purple-600 text-white rounded-lg font-medium hover:bg-purple-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors'
      }, connecting ? 'Connecting...' : 'Connect'),

      // Complete Authorization button (for OAuth services with pending token)
      config?.pendingToken && React.createElement('button', {
        onClick: handleCompleteAuth,
        disabled: connecting,
        className: 'w-full py-2 px-4 bg-green-600 text-white rounded-lg font-medium hover:bg-green-700 disabled:opacity-50 transition-colors'
      }, connecting ? 'Completing...' : 'Complete Authorization')
    ) : (
      // Disconnect button (when connected)
      React.createElement('button', {
        onClick: handleDisconnect,
        className: 'w-full py-2 px-4 bg-gray-100 text-gray-700 rounded-lg font-medium hover:bg-gray-200 transition-colors'
      }, 'Disconnect')
    )
  );
});

// RelatedArtistCard component - Shows artist image with name below
const RelatedArtistCard = ({ artist, getArtistImage, onNavigate }) => {
  const [imageUrl, setImageUrl] = useState(null);
  const [imageLoading, setImageLoading] = useState(true);

  useEffect(() => {
    let cancelled = false;
    const loadImage = async () => {
      setImageLoading(true);
      const result = await getArtistImage(artist.name);
      if (!cancelled && result?.url) {
        setImageUrl(result.url);
      }
      if (!cancelled) {
        setImageLoading(false);
      }
    };
    loadImage();
    return () => { cancelled = true; };
    // Note: getArtistImage excluded from deps - function identity changes but behavior doesn't
  }, [artist.name]);

  return React.createElement('button', {
    onClick: onNavigate,
    className: 'text-left group cursor-grab active:cursor-grabbing',
    draggable: true,
    onDragStart: (e) => {
      e.dataTransfer.effectAllowed = 'copy';
      e.dataTransfer.setData('text/plain', JSON.stringify({
        type: 'artist',
        artist: {
          id: (artist.name || 'unknown').toLowerCase().replace(/[^a-z0-9-]/g, ''),
          name: artist.name,
          image: imageUrl
        }
      }));
    },
    onContextMenu: (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (window.electron?.contextMenu?.showTrackMenu) {
        window.electron.contextMenu.showTrackMenu({
          type: 'artist',
          artist: {
            id: (artist.name || 'unknown').toLowerCase().replace(/[^a-z0-9-]/g, ''),
            name: artist.name,
            image: imageUrl
          }
        });
      }
    }
  },
    // Artist image square (matches SearchArtistCard)
    React.createElement('div', { className: 'w-full aspect-square bg-gray-100 mb-2 relative overflow-hidden' },
      imageLoading && React.createElement('div', {
        className: 'w-full h-full bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
        style: { backgroundSize: '200% 100%' }
      }),
      !imageLoading && imageUrl && React.createElement('img', {
        src: imageUrl,
        alt: artist.name,
        className: 'w-full h-full object-cover transition-opacity duration-300',
        style: { opacity: 0 },
        ref: (el) => { if (el && el.complete && el.naturalWidth > 0) el.style.opacity = '1'; },
        onLoad: (e) => { e.target.style.opacity = '1'; }
      }),
      !imageLoading && !imageUrl && React.createElement('div', {
        className: 'w-full h-full flex items-center justify-center text-gray-300'
      },
        React.createElement('svg', { className: 'w-10 h-10', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor', strokeWidth: 1 },
          React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', d: 'M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z' })
        )
      )
    ),
    // Artist name
    React.createElement('div', { className: 'text-sm font-medium text-gray-900 truncate' }, artist.name)
  );
};

// SearchArtistCard component - for quick search results with circular artist image (matches related artists style)
const SearchArtistCard = ({ artist, getArtistImage, onClick, onContextMenu, itemWidth }) => {
  const [imageUrl, setImageUrl] = useState(null);
  const [imageLoading, setImageLoading] = useState(true);
  const [imageReady, setImageReady] = useState(false);

  useEffect(() => {
    let cancelled = false;
    const loadImage = async () => {
      setImageLoading(true);
      setImageReady(false);
      const result = await getArtistImage(artist.name);
      if (!cancelled && result?.url) {
        setImageUrl(result.url);
        // Preload the image
        const img = new Image();
        img.onload = () => {
          if (!cancelled) setImageReady(true);
        };
        img.src = result.url;
      }
      if (!cancelled) {
        setImageLoading(false);
      }
    };
    loadImage();
    return () => { cancelled = true; };
    // Note: getArtistImage excluded from deps - function identity changes but behavior doesn't
  }, [artist.name]);

  // Calculate image size based on item width (leave room for name below)
  const imageSize = itemWidth ? Math.min(itemWidth - 8, 120) : 96;

  return React.createElement('div', {
    onClick: onClick,
    className: 'flex flex-col items-center cursor-grab active:cursor-grabbing group transition-all duration-300 ease-out',
    style: { width: itemWidth || 130 },
    draggable: true,
    onDragStart: (e) => {
      e.dataTransfer.effectAllowed = 'copy';
      e.dataTransfer.setData('text/plain', JSON.stringify({
        type: 'artist',
        artist: {
          id: (artist.name || 'unknown').toLowerCase().replace(/[^a-z0-9-]/g, ''),
          name: artist.name,
          image: imageUrl
        }
      }));
    },
    onContextMenu: (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (onContextMenu) {
        onContextMenu(artist);
      }
    }
  },
    // Circular artist image (matches related artists style)
    React.createElement('div', {
      className: 'relative rounded-full overflow-hidden mb-2 mx-auto transition-all duration-300 ease-out',
      style: { width: imageSize, height: imageSize }
    },
      React.createElement('div', {
        className: `w-full h-full group-hover:scale-110 transition-all duration-300 ${
          imageReady ? '' : imageLoading ? 'bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer' : 'bg-gradient-to-br from-purple-500 to-pink-500'
        }`,
        style: imageReady ? {
          backgroundImage: `url(${imageUrl})`,
          backgroundSize: 'cover',
          backgroundPosition: 'center'
        } : imageLoading ? {
          backgroundSize: '200% 100%'
        } : {}
      },
        // Fallback icon when no image and not loading
        !imageLoading && !imageUrl && React.createElement('div', {
          className: 'w-full h-full flex items-center justify-center text-white/70'
        },
          React.createElement('svg', {
            className: 'transition-all duration-300',
            style: { width: imageSize * 0.5, height: imageSize * 0.5 },
            fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor', strokeWidth: 1
          },
            React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', d: 'M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z' })
          )
        )
      )
    ),
    // Artist name (centered)
    React.createElement('div', { className: 'text-sm font-medium text-gray-900 truncate text-center px-1 w-full' }, artist.name)
  );
};

// Search history item for empty search page
const SearchHistoryItem = ({ entry, onQueryClick, onResultClick, onRemove }) => {
  const { query, selectedResult, timestamp } = entry;

  // Click handler for the whole row - navigate to result if available, otherwise search
  const handleRowClick = () => {
    if (selectedResult) {
      onResultClick(selectedResult);
    } else {
      onQueryClick(query);
    }
  };

  return React.createElement('div', {
    className: 'flex items-center gap-3 p-3 rounded-lg hover:bg-gray-50 group transition-colors cursor-pointer',
    onClick: handleRowClick
  },
    // Result thumbnail or search icon
    selectedResult?.imageUrl ?
      React.createElement('img', {
        src: selectedResult.imageUrl,
        className: 'w-12 h-12 rounded object-cover',
        onError: (e) => { e.target.style.display = 'none'; }
      }) :
      React.createElement('div', {
        className: 'w-12 h-12 rounded bg-gray-100 flex items-center justify-center'
      },
        React.createElement('svg', {
          className: 'w-5 h-5 text-gray-400',
          fill: 'none',
          stroke: 'currentColor',
          viewBox: '0 0 24 24'
        },
          React.createElement('path', {
            strokeLinecap: 'round',
            strokeLinejoin: 'round',
            strokeWidth: 2,
            d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z'
          })
        )
      ),

    // Query and result info
    React.createElement('div', { className: 'flex-1 min-w-0' },
      React.createElement('button', {
        onClick: (e) => { e.stopPropagation(); onQueryClick(query); },
        className: 'text-sm font-medium text-gray-900 hover:text-blue-600 truncate block text-left w-full'
      }, `"${query}"`),
      selectedResult && React.createElement('button', {
        onClick: (e) => { e.stopPropagation(); onResultClick(selectedResult); },
        className: 'text-xs text-gray-500 hover:text-blue-600 truncate block text-left w-full'
      },
        `${selectedResult.type}: ${selectedResult.name}${selectedResult.artist ? ` â€¢ ${selectedResult.artist}` : ''}`
      )
    ),

    // Remove button
    React.createElement('button', {
      onClick: (e) => { e.stopPropagation(); onRemove(query); },
      className: 'opacity-0 group-hover:opacity-100 p-1 text-gray-400 hover:text-red-500 transition-opacity'
    },
      React.createElement('svg', {
        className: 'w-4 h-4',
        fill: 'none',
        stroke: 'currentColor',
        viewBox: '0 0 24 24'
      },
        React.createElement('path', {
          strokeLinecap: 'round',
          strokeLinejoin: 'round',
          strokeWidth: 2,
          d: 'M6 18L18 6M6 6l12 12'
        })
      )
    )
  );
};

// CollectionArtistCard component - for Collection view artist grid with lazy image loading
const CollectionArtistCard = ({ artist, getArtistImage, onNavigate }) => {
  // States: undefined (fetching), null (no image found), string (URL)
  const [imageUrl, setImageUrl] = useState(undefined);

  useEffect(() => {
    let cancelled = false;
    const loadImage = async () => {
      setImageUrl(undefined); // Loading state
      const result = await getArtistImage(artist.name);
      if (!cancelled) {
        setImageUrl(result?.url || null); // null if not found
      }
    };
    loadImage();
    return () => { cancelled = true; };
  }, [artist.name]);

  return React.createElement('button', {
    onClick: onNavigate,
    className: 'group text-left p-4 rounded-xl bg-white border border-gray-100 hover:border-purple-200 hover:shadow-md transition-all'
  },
    // Artist image (circular) - shimmer while fetching OR loading image, purple placeholder if no image
    React.createElement('div', {
      className: `w-full aspect-square rounded-full mb-3 flex items-center justify-center overflow-hidden ${
        imageUrl === null
          ? 'bg-gradient-to-br from-purple-500 to-pink-500'
          : 'bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer'
      }`,
      style: imageUrl === null ? {} : { backgroundSize: '200% 100%' }
    },
      // Show image when URL exists (fades in when loaded)
      imageUrl && typeof imageUrl === 'string' && React.createElement('img', {
        src: imageUrl,
        alt: artist.name,
        className: 'w-full h-full object-cover transition-opacity duration-300',
        style: { opacity: 0 },
        ref: (el) => { if (el && el.complete && el.naturalWidth > 0) el.style.opacity = '1'; },
        onLoad: (e) => { e.target.style.opacity = '1'; }
      }),
      // Placeholder icon when no image found
      imageUrl === null && React.createElement('svg', {
        className: 'w-12 h-12 text-white/70',
        fill: 'none',
        viewBox: '0 0 24 24',
        stroke: 'currentColor'
      },
        React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 1.5, d: 'M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z' })
      )
    ),
    // Artist name
    React.createElement('h3', {
      className: 'font-medium text-gray-900 truncate group-hover:text-purple-600 transition-colors'
    }, artist.name),
    // Track count (only show if > 0)
    artist.trackCount > 0 && React.createElement('p', {
      className: 'text-sm text-gray-500'
    }, `${artist.trackCount} track${artist.trackCount !== 1 ? 's' : ''}`)
  );
};

// CollectionAlbumCard component - for Collection view album grid with lazy image loading
const CollectionAlbumCard = ({ album, getAlbumArt, onNavigate }) => {
  // States: undefined (fetching), null (no art found), string (URL)
  const [imageUrl, setImageUrl] = useState(album.art || undefined);

  useEffect(() => {
    // If we already have embedded art, don't fetch
    if (album.art) {
      setImageUrl(album.art);
      return;
    }

    let cancelled = false;
    const loadImage = async () => {
      setImageUrl(undefined); // Loading state
      const artUrl = await getAlbumArt(album.artist, album.title);
      if (!cancelled) {
        setImageUrl(artUrl || null); // null if not found
      }
    };
    loadImage();
    return () => { cancelled = true; };
  }, [album.artist, album.title, album.art]);

  return React.createElement('button', {
    onClick: onNavigate,
    className: 'group text-left'
  },
    // Album card
    React.createElement('div', {
      className: 'p-4 rounded-xl bg-white border border-gray-100 hover:border-purple-200 hover:shadow-md transition-all'
    },
      // Album art - shimmer while fetching OR loading image, purple placeholder if no art
      React.createElement('div', {
        className: `w-full aspect-square rounded-lg mb-3 overflow-hidden ${
          imageUrl === null
            ? ''
            : 'bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer'
        }`,
        style: imageUrl === null
          ? { background: 'linear-gradient(135deg, #9333ea 0%, #ec4899 100%)' }
          : { backgroundSize: '200% 100%' }
      },
        // Show image when URL exists (fades in when loaded)
        imageUrl && typeof imageUrl === 'string' && React.createElement('img', {
          src: imageUrl,
          alt: album.title,
          className: 'w-full h-full object-cover transition-opacity duration-300',
          style: { opacity: 0 },
          ref: (el) => { if (el && el.complete && el.naturalWidth > 0) el.style.opacity = '1'; },
          onLoad: (e) => { e.target.style.opacity = '1'; },
          onError: (e) => { e.target.style.display = 'none'; }
        }),
        // Placeholder icon when no art found
        imageUrl === null && React.createElement('div', { className: 'w-full h-full flex items-center justify-center' },
          React.createElement('svg', { className: 'w-12 h-12 text-white/50', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
            React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 1.5, d: 'M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3' })
          )
        )
      ),
      // Album title
      React.createElement('h3', {
        className: 'font-medium text-gray-900 truncate group-hover:text-purple-600 transition-colors text-sm'
      }, album.title),
      // Artist name
      React.createElement('p', {
        className: 'text-sm text-gray-500 truncate'
      }, album.artist),
      // Year and track count
      React.createElement('div', { className: 'flex items-center gap-2 mt-1' },
        album.year && React.createElement('span', {
          className: 'text-xs text-gray-400'
        }, album.year),
        React.createElement('span', {
          className: 'text-xs text-gray-400'
        }, `${album.trackCount} track${album.trackCount !== 1 ? 's' : ''}`)
      )
    )
  );
};

// FriendMiniPlaybar component - shows friend's current track with album art lookup
const FriendMiniPlaybar = ({ track, getAlbumArt, onPlay, onContextMenu }) => {
  // States: undefined (fetching), null (no art found), string (URL)
  const [artUrl, setArtUrl] = useState(track.albumArt || undefined);
  const [isOverflowing, setIsOverflowing] = useState(false);
  const textRef = useRef(null);
  const containerRef = useRef(null);

  useEffect(() => {
    // If we already have art from the service, use it
    if (track.albumArt) {
      setArtUrl(track.albumArt);
      return;
    }

    // No art provided - try to fetch via our cache system
    if (!track.album || !track.artist) {
      setArtUrl(null);
      return;
    }

    let cancelled = false;
    const loadArt = async () => {
      const fetchedArt = await getAlbumArt(track.artist, track.album);
      if (!cancelled) {
        setArtUrl(fetchedArt || null);
      }
    };
    loadArt();
    return () => { cancelled = true; };
  }, [track.name, track.artist, track.album, track.albumArt]);

  // Check if text overflows container (after render completes)
  useEffect(() => {
    // Use requestAnimationFrame to ensure DOM is fully rendered and measured
    const checkOverflow = () => {
      if (textRef.current && containerRef.current) {
        const textWidth = textRef.current.scrollWidth;
        const containerWidth = containerRef.current.clientWidth;
        setIsOverflowing(textWidth > containerWidth);
      }
    };

    // Run after paint to get accurate measurements
    const rafId = requestAnimationFrame(() => {
      requestAnimationFrame(checkOverflow);
    });

    return () => cancelAnimationFrame(rafId);
  }, [track.name, track.artist]);

  return React.createElement('div', {
    className: 'mt-1 flex items-center bg-gray-800 rounded cursor-pointer hover:bg-gray-700 transition-colors',
    style: { maxWidth: '160px', height: '20px' },
    onClick: onPlay,
    onContextMenu: onContextMenu
  },
    // Mini album art
    React.createElement('div', {
      className: 'flex-shrink-0',
      style: { width: '20px', height: '20px' }
    },
      artUrl
        ? React.createElement('img', {
            src: artUrl,
            alt: '',
            className: 'w-full h-full object-cover rounded-l'
          })
        : React.createElement('div', {
            className: 'w-full h-full bg-gray-600 rounded-l flex items-center justify-center'
          },
            React.createElement('span', { className: 'text-gray-400', style: { fontSize: '8px' } }, '\u266A')
          )
    ),
    // Track info - only scrolls if overflowing
    React.createElement('div', {
      ref: containerRef,
      className: `flex-1 min-w-0 px-1.5 flex items-center ${isOverflowing ? 'marquee-container' : ''}`,
      style: { overflow: 'hidden', height: '100%' }
    },
      React.createElement('span', {
        ref: textRef,
        className: `whitespace-nowrap inline-block ${isOverflowing ? 'animate-marquee' : ''}`,
        style: { fontSize: '10px', lineHeight: '20px' }
      },
        React.createElement('span', { className: 'text-white font-medium' }, track.name),
        React.createElement('span', { className: 'text-gray-400' }, ` - ${track.artist}`)
      )
    )
  );
};

// ReleaseCard component - FRESH START - Ultra simple, no complications
const ReleaseCard = ({ release, currentArtist, fetchReleaseData, onContextMenu, onHoverFetch, isVisible = true }) => {
  const year = release.date ? release.date.split('-')[0] : 'Unknown';
  const [imageFailed, setImageFailed] = React.useState(false);
  const [imageLoaded, setImageLoaded] = React.useState(false);

  // Reset image states when album art URL changes
  React.useEffect(() => {
    setImageFailed(false);
    setImageLoaded(false);
  }, [release.albumArt]);

  const handleDragStart = (e) => {
    e.dataTransfer.effectAllowed = 'copy';
    const albumData = {
      type: 'album',
      album: {
        id: `${currentArtist?.name || release.artist?.name || 'unknown'}-${release.title || 'untitled'}`.toLowerCase().replace(/[^a-z0-9-]/g, ''),
        title: release.title,
        artist: currentArtist?.name || release.artist?.name,
        year: year !== 'Unknown' ? parseInt(year) : null,
        art: release.albumArt
      }
    };
    e.dataTransfer.setData('text/plain', JSON.stringify(albumData));
  };

  const cardStyle = {
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
    borderRadius: '12px',
    padding: '16px',
    cursor: 'grab',
    border: '1px solid rgba(255, 255, 255, 0.1)',
    transition: 'transform 0.2s, background-color 0.2s'
  };
  
  const handleClick = () => {
    console.log('ðŸŽµ Card clicked:', release.title);
    fetchReleaseData(release, currentArtist);
  };
  
  return React.createElement('button', {
    className: 'no-drag',
    draggable: true,
    onDragStart: handleDragStart,
    style: {
      ...cardStyle,
      width: '100%',
      textAlign: 'left',
      display: isVisible ? 'block' : 'none'  // Hide with CSS instead of destroying DOM
    },
    onClick: handleClick,
    onContextMenu: (e) => {
      e.preventDefault();
      if (onContextMenu) {
        onContextMenu(release);
      }
    },
    onMouseEnter: (e) => {
      e.currentTarget.style.transform = 'scale(1.05)';
      e.currentTarget.style.backgroundColor = 'rgba(124, 58, 237, 0.2)';
      // Prefetch release tracks on hover
      if (onHoverFetch) {
        onHoverFetch(release);
      }
    },
    onMouseLeave: (e) => {
      e.currentTarget.style.transform = 'scale(1)';
      e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.05)';
    }
  },
    // Album art container
    // States: shimmer (fetching = undefined, or loading image = URL but not loaded), placeholder (no art found = null, or failed)
    React.createElement('div', {
      className: (release.albumArt === null || imageFailed || imageLoaded) ? '' : 'animate-shimmer',
      style: {
        width: '100%',
        aspectRatio: '1',
        borderRadius: '8px',
        // Purple placeholder if no art/failed, otherwise shimmer until image loads
        background: release.albumArt === null || imageFailed
          ? 'linear-gradient(135deg, #9333ea 0%, #ec4899 100%)'  // Purple gradient placeholder
          : imageLoaded
            ? 'transparent'  // No background once image loaded
            : 'linear-gradient(to right, #e5e7eb, #f3f4f6, #e5e7eb)',  // Shimmer gray
        backgroundSize: (release.albumArt === null || imageFailed || imageLoaded) ? undefined : '200% 100%',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        marginBottom: '12px',
        pointerEvents: 'none',
        overflow: 'hidden',
        position: 'relative'
      }
    },
      // Album art image with fade-in
      release.albumArt && !imageFailed && React.createElement('img', {
        src: release.albumArt,
        alt: release.title,
        style: {
          width: '100%',
          height: '100%',
          objectFit: 'cover',
          pointerEvents: 'none',
          position: 'absolute',
          top: 0,
          left: 0,
          opacity: imageLoaded ? 1 : 0,
          transition: 'opacity 0.3s ease-in-out'
        },
        ref: (el) => {
          // Handle cached images that are already loaded
          if (el && el.complete && el.naturalWidth > 0 && !imageLoaded) {
            setImageLoaded(true);
          }
        },
        onLoad: () => setImageLoaded(true),
        onError: () => setImageFailed(true)
      }),

      // Music icon placeholder (only show when no image found = null, or failed - NOT during loading = undefined)
      (release.albumArt === null || imageFailed) && React.createElement('svg', {
        style: {
          width: '48px',
          height: '48px',
          color: 'rgba(255, 255, 255, 0.5)',
          pointerEvents: 'none'
        },
        fill: 'none',
        viewBox: '0 0 24 24',
        stroke: 'currentColor',
        strokeWidth: 2
      },
        React.createElement('path', {
          strokeLinecap: 'round',
          strokeLinejoin: 'round',
          d: 'M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3'
        })
      )
    ),
    
    // Title
    React.createElement('h3', {
      style: {
        fontWeight: '600',
        fontSize: '14px',
        marginBottom: '4px',
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        whiteSpace: 'nowrap',
        color: 'black',
        pointerEvents: 'none'  // KEY FIX!
      },
      title: release.title
    }, release.title),
    
    // Year
    React.createElement('p', {
      style: {
        fontSize: '12px',
        color: '#9ca3af',
        marginBottom: '8px',
        pointerEvents: 'none'  // KEY FIX!
      }
    }, year),
    
    // Badge
    React.createElement('span', {
      style: {
        display: 'inline-block',
        padding: '2px 8px',
        fontSize: '11px',
        borderRadius: '9999px',
        backgroundColor: release.releaseType === 'album' ? 'rgba(37, 99, 235, 0.2)' :
                        release.releaseType === 'ep' ? 'rgba(22, 163, 74, 0.2)' :
                        'rgba(168, 85, 247, 0.2)',
        color: release.releaseType === 'album' ? '#60a5fa' :
              release.releaseType === 'ep' ? '#4ade80' :
              '#a78bfa',
        pointerEvents: 'none'  // KEY FIX!
      }
    }, release.releaseType.toUpperCase())
  );
};

// ReleasePage component - Shows full album/EP/single with tracklist
const ReleasePage = ({
  release,
  handleSearch,
  handlePlay,
  onTrackPlay,
  onTrackContextMenu,
  trackSources = {},
  resolvers = [],
  // Drag and drop props (for adding tracks to playlists)
  onDragStart,
  onDragEnd,
  // Now playing props
  currentTrack,
  playbackContext,
  isPlaying
}) => {
  const formatDuration = (ms) => {
    if (!ms) return '';
    const totalSeconds = Math.floor(ms / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
  };

  // Format full date nicely
  const formatDate = (dateStr) => {
    if (!dateStr) return 'Unknown';
    try {
      const date = new Date(dateStr);
      return date.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
    } catch {
      return dateStr;
    }
  };

  // Use a ref to track container width for responsive layout
  const [containerWidth, setContainerWidth] = React.useState(800);
  const containerRef = React.useRef(null);

  React.useEffect(() => {
    if (!containerRef.current) return;
    const resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        setContainerWidth(entry.contentRect.width);
      }
    });
    resizeObserver.observe(containerRef.current);
    return () => resizeObserver.disconnect();
  }, []);

  // Responsive sizes based on container width
  const isCompact = containerWidth < 700;
  const albumArtSize = isCompact ? 160 : 192; // 160px or 192px (w-40 or w-48)
  const columnWidth = isCompact ? 180 : 240;

  return React.createElement('div', { ref: containerRef, className: 'flex gap-0 p-6' },
    // LEFT COLUMN: Album art and metadata - responsive width with smooth animation
    React.createElement('div', {
      className: 'flex-shrink-0 pr-4 md:pr-8',
      style: {
        width: `${columnWidth}px`,
        transition: 'width 300ms ease'
      }
    },
      // Album art container - make draggable, responsive size with smooth animation
      React.createElement('div', {
        draggable: true,
        onDragStart: (e) => {
          e.dataTransfer.effectAllowed = 'copy';
          const albumData = {
            type: 'album',
            album: {
              id: `${release.artist?.name || 'unknown'}-${release.title || 'untitled'}`.toLowerCase().replace(/[^a-z0-9-]/g, ''),
              title: release.title,
              artist: release.artist?.name,
              year: release.date?.split('-')[0] || null,
              art: release.albumArt
            }
          };
          e.dataTransfer.setData('text/plain', JSON.stringify(albumData));
        },
        className: 'rounded bg-gradient-to-br from-purple-600 to-pink-600 flex items-center justify-center shadow-lg relative overflow-hidden cursor-grab active:cursor-grabbing',
        style: {
          width: `${albumArtSize}px`,
          height: `${albumArtSize}px`,
          transition: 'width 300ms ease, height 300ms ease'
        }
      },
        // Image (absolute positioned, fades in on load, hides on error)
        release.albumArt && React.createElement('img', {
          src: release.albumArt,
          alt: release.title,
          className: 'absolute inset-0 w-full h-full object-cover',
          style: { opacity: 0, transition: 'opacity 300ms ease' },
          ref: (el) => { if (el && el.complete) el.style.opacity = '1'; },
          onLoad: (e) => { e.target.style.opacity = '1'; },
          onError: (e) => { e.target.style.display = 'none'; }
        }),
        // Placeholder icon (always behind)
        React.createElement('svg', {
          className: 'w-16 h-16 text-white/50',
          fill: 'none',
          viewBox: '0 0 24 24',
          stroke: 'currentColor'
        },
          React.createElement('path', {
            strokeLinecap: 'round',
              strokeLinejoin: 'round',
              strokeWidth: 2,
              d: 'M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3'
            })
          )
        ),

      // Album title and metadata - responsive sizing with smooth animation
      React.createElement('div', { className: 'mt-4 space-y-1' },
        React.createElement('h2', {
          className: 'font-bold text-gray-900 leading-tight',
          style: {
            fontSize: isCompact ? '1rem' : '1.125rem',
            transition: 'font-size 300ms ease'
          }
        }, release.title),
        React.createElement('p', {
          className: 'text-gray-500',
          style: {
            fontSize: isCompact ? '0.75rem' : '0.875rem',
            transition: 'font-size 300ms ease'
          }
        }, formatDate(release.date)),
        React.createElement('p', {
          className: 'text-gray-500',
          style: {
            fontSize: isCompact ? '0.75rem' : '0.875rem',
            transition: 'font-size 300ms ease'
          }
        }, `${release.tracks.length.toString().padStart(2, '0')} Songs`)
      )
    ),

    // RIGHT COLUMN: Tracklist
    React.createElement('div', { className: 'flex-1 min-w-0' },
      release.tracks.length > 0 ?
        React.createElement('div', { className: 'space-y-0' },
          release.tracks.map((track, index) => {
            const trackKey = `${track.position}-${track.title}`;
            const sources = trackSources[trackKey] || {};
            const availableResolvers = Object.keys(sources);
            
            // Build track object for drag/drop and playback
            const trackId = `${release.artist.name || 'unknown'}-${track.title || 'untitled'}-${release.title || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
            const trackForDrag = {
              ...track,
              id: trackId,
              artist: release.artist.name,
              album: release.title,
              albumArt: release.albumArt,
              sources: sources
            };

            // Check if this track is currently playing from this album
            const isCurrentTrack = currentTrack?.id === trackId;
            const isNowPlaying = isCurrentTrack && playbackContext?.type === 'album' && playbackContext?.id === release.id;

            // Debug logging for first track only
            if (index === 0) {
              console.log('ðŸŽ¯ ReleasePage highlight check:', {
                trackId,
                currentTrackId: currentTrack?.id,
                isCurrentTrack,
                playbackContextType: playbackContext?.type,
                playbackContextId: playbackContext?.id,
                releaseId: release.id,
                isNowPlaying
              });
            }

            return React.createElement('div', {
              key: index,
              draggable: true,
              onDragStart: (e) => {
                e.dataTransfer.effectAllowed = 'copy';
                e.dataTransfer.setData('text/plain', JSON.stringify({ type: 'track', track: trackForDrag }));
                if (onDragStart) {
                  onDragStart(trackForDrag);
                }
              },
              onDragEnd: () => {
                if (onDragEnd) {
                  onDragEnd();
                }
              },
              className: `flex items-center gap-4 py-2 px-3 border-b border-gray-100 hover:bg-gray-50 cursor-grab active:cursor-grabbing transition-colors no-drag group ${isNowPlaying ? 'bg-purple-50' : ''}`,
              onClick: () => {
                console.log('Track row clicked:', track.title);

                // Play track with sources if resolved
                if (availableResolvers.length > 0) {
                  // Build queue from remaining tracks (after this one)
                  const tracksAfter = release.tracks.slice(index + 1).map((t, i) => {
                    const tKey = `${t.position}-${t.title}`;
                    const tSources = trackSources[tKey] || {};
                    const tId = `${release.artist.name || 'unknown'}-${t.title || 'untitled'}-${release.title || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
                    return {
                      ...t,
                      id: tId,
                      artist: release.artist.name,
                      album: release.title,
                      albumArt: release.albumArt,
                      sources: tSources
                    };
                  });

                  if (onTrackPlay) {
                    onTrackPlay(trackForDrag, tracksAfter);
                  } else {
                    handlePlay(trackForDrag);
                  }
                } else {
                  // No resolved sources yet, fall back to search
                  console.log('No resolved sources, searching...');
                  handleSearch(`${release.artist.name} ${track.title}`);
                }
              },
              onContextMenu: (e) => {
                e.preventDefault();
                if (onTrackContextMenu) {
                  onTrackContextMenu(trackForDrag);
                }
              }
            },
              // Track number or playing indicator
              React.createElement('span', {
                className: `text-sm w-6 flex-shrink-0 text-right ${isNowPlaying ? 'text-purple-500' : 'text-gray-400'}`,
                style: { pointerEvents: 'none' }
              }, isNowPlaying ? 'â–¶' : String(track.position).padStart(2, '0')),

              // Track title
              React.createElement('span', {
                className: `text-sm flex-1 truncate transition-colors ${isNowPlaying ? 'text-purple-600 font-medium' : 'text-gray-700 group-hover:text-gray-900'}`,
                style: { pointerEvents: 'none' }
              }, track.title),

              // Duration
              track.length && React.createElement('span', {
                className: 'text-sm text-gray-400 flex-shrink-0 tabular-nums',
                style: { pointerEvents: 'none' }
              }, formatDuration(track.length)),
              
              // Resolver icons (sources available for this track)
              React.createElement('div', {
                className: 'flex items-center gap-1 flex-shrink-0 ml-auto',
                style: { pointerEvents: 'none', minHeight: '24px', width: '100px', justifyContent: 'flex-end' }
              },
                (() => {
                  const trackKey = `${track.position}-${track.title}`;
                  const sources = trackSources[trackKey] || {};
                  const availableResolverIds = Object.keys(sources);

                  if (availableResolverIds.length === 0) {
                    // Show shimmer skeletons while resolving (match resolver icon size)
                    return React.createElement('div', {
                      className: 'flex items-center gap-1'
                    },
                      React.createElement('div', {
                        className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer',
                        title: 'Resolving track...'
                      }),
                      React.createElement('div', {
                        className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer',
                        style: { animationDelay: '0.1s' }
                      })
                    );
                  }

                  // Sort resolvers by priority order (left to right = highest to lowest priority)
                  const sortedResolverIds = [...availableResolverIds].sort((a, b) => {
                    const aIndex = resolvers.findIndex(r => r.id === a);
                    const bIndex = resolvers.findIndex(r => r.id === b);
                    return aIndex - bIndex;
                  });

                  // Show resolver icons for available sources (only if they support playback)
                  return sortedResolverIds.map(resolverId => {
                    const resolver = resolvers.find(r => r.id === resolverId);
                    if (!resolver || !resolver.play) return null;
                    
                    const source = sources[resolverId];
                    const confidence = source.confidence || 0;
                    
                    return React.createElement('button', {
                      key: resolverId,
                      className: 'no-drag',
                      onClick: (e) => {
                        e.stopPropagation(); // Don't trigger row click
                        console.log(`Playing from ${resolver.name}:`, source);

                        // Create track with preferred resolver
                        const trackWithResolver = { ...trackForDrag, preferredResolver: resolverId };

                        // Build queue from remaining tracks (after this one)
                        const tracksAfter = release.tracks.slice(index + 1).map((t, i) => {
                          const tKey = `${t.position}-${t.title}`;
                          const tSources = trackSources[tKey] || {};
                          const tId = `${release.artist.name || 'unknown'}-${t.title || 'untitled'}-${release.title || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
                          return {
                            ...t,
                            id: tId,
                            artist: release.artist.name,
                            album: release.title,
                            albumArt: release.albumArt,
                            sources: tSources
                          };
                        });

                        if (onTrackPlay) {
                          onTrackPlay(trackWithResolver, tracksAfter);
                        } else {
                          handlePlay(trackWithResolver);
                        }
                      },
                      style: {
                        width: '24px',
                        height: '24px',
                        borderRadius: '4px',
                        backgroundColor: resolver.color,
                        border: 'none',
                        cursor: 'pointer',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        pointerEvents: 'auto',
                        opacity: confidence > 0.8 ? 1 : 0.6,
                        transition: 'transform 0.1s'
                      },
                      onMouseEnter: (e) => e.currentTarget.style.transform = 'scale(1.1)',
                      onMouseLeave: (e) => e.currentTarget.style.transform = 'scale(1)',
                      title: `Play from ${resolver.name} (${Math.round(confidence * 100)}% match)`
                    }, React.createElement(ResolverIcon, { resolverId, size: 14 }));
                  });
                })()
              ),
              
              // Play icon
              React.createElement('svg', {
                className: 'w-5 h-5 text-purple-400 opacity-0 group-hover:opacity-100 transition-opacity flex-shrink-0',
                fill: 'currentColor',
                viewBox: '0 0 24 24',
                style: { pointerEvents: 'none' }
              },
                React.createElement('path', {
                  d: 'M8 5v14l11-7z'
                })
              )
            );
          })
        )
      :
        React.createElement('div', { className: 'text-center py-12 text-gray-400' },
          'No track information available'
        )
    )
  );
};

const Parachord = () => {
  const [currentTrack, setCurrentTrack] = useState(null);
  const [currentQueue, setCurrentQueue] = useState([]); // Current playing queue
  // Playback context - tracks where the current track originated from
  // Shape: { type: 'playlist' | 'album' | 'search' | 'library' | 'recommendations', id?, name?, artist? }
  const [playbackContext, setPlaybackContext] = useState(null);
  // Spinoff mode - radio-like playback of similar tracks
  const [spinoffMode, setSpinoffMode] = useState(false);
  const [spinoffSourceTrack, setSpinoffSourceTrack] = useState(null); // { title, artist } of original track
  const [spinoffLoading, setSpinoffLoading] = useState(false);
  const spinoffTracksRef = useRef([]); // Pool of similar tracks to play
  const [isPlaying, setIsPlaying] = useState(false);
  const [trackLoading, setTrackLoading] = useState(false); // True when loading a track to play
  // Album art crossfade state for smooth transitions in playbar
  const [playbarAlbumArt, setPlaybarAlbumArt] = useState({ current: null, previous: null, isLoaded: false });
  const playbarAlbumArtRef = useRef(null); // Track previous art for comparison
  // Track if currentTrack was restored from saved queue and needs explicit playback start
  const trackNeedsExplicitStart = useRef(false);
  const [progress, setProgress] = useState(0);
  const [volume, setVolume] = useState(70);
  const [isMuted, setIsMuted] = useState(false);
  const preMuteVolumeRef = useRef(70); // Remember volume before muting
  const isMutedRef = useRef(false); // Ref for mute state to avoid stale closures
  const spotifyVolumeTimeoutRef = useRef(null); // Debounce Spotify volume API calls

  // Track main content width for responsive layouts
  const [mainContentWidth, setMainContentWidth] = useState(800);
  const mainContentRef = useRef(null);
  // Per-resolver volume offsets (dB adjustment, applied to base volume)
  // Default offsets: Spotify is normalized at -14 LUFS, others may be louder
  const [resolverVolumeOffsets, setResolverVolumeOffsets] = useState({
    spotify: 0,      // Spotify is already normalized
    localfiles: 0,   // Local files vary, start neutral
    bandcamp: -3,    // Bandcamp tends to be slightly louder
    youtube: -6,     // YouTube videos are often much louder
    qobuz: 0         // Qobuz is typically well mastered
  });
  // Per-track volume adjustments (trackId -> dB offset from resolver default)
  const trackVolumeAdjustments = useRef({});

  // AI Playlist Generation state
  const [aiPromptOpen, setAiPromptOpen] = useState(false);
  const [aiPrompt, setAiPrompt] = useState('');
  const [aiLoading, setAiLoading] = useState(false);
  const [aiIncludeHistory, setAiIncludeHistory] = useState(false);
  const [aiError, setAiError] = useState(null);
  const [selectedAiResolver, setSelectedAiResolver] = useState(null);
  const [aiSaveDialogOpen, setAiSaveDialogOpen] = useState(false);
  const [aiSavePlaylistName, setAiSavePlaylistName] = useState('');

  // Results sidebar state (generic/reusable)
  const [resultsSidebar, setResultsSidebar] = useState(null);
  // Shape: { title, subtitle, tracks: [], source: 'ai' | 'search' | etc }

  const [searchQuery, setSearchQuery] = useState('');
  const [searchResults, setSearchResults] = useState({
    artists: [],
    albums: [],
    tracks: [],
    playlists: []
  });
  const [isSearching, setIsSearching] = useState(false);
  const searchTimeoutRef = useRef(null);
  const searchQueryRef = useRef('');
  const abortControllerRef = useRef(null);
  // Recommendations state
  const [recommendations, setRecommendations] = useState({
    artists: [],
    tracks: [],
    loading: true,
    error: null
  });
  // Pagination state - how many items to show per column
  const [displayLimits, setDisplayLimits] = useState({
    artists: 5,
    albums: 5,
    tracks: 8,
    playlists: 5
  });
  const [searchDetailCategory, setSearchDetailCategory] = useState(null); // null = main view, 'artists'|'tracks'|'albums'|'playlists' = detail view
  const [searchPreviewItem, setSearchPreviewItem] = useState(null); // Currently previewed item in detail view
  const searchResultsContainerRef = useRef(null); // Ref for measuring search results container width
  const [searchContainerWidth, setSearchContainerWidth] = useState(800); // Width of search results container for responsive item count
  const [searchPreviewArtistImage, setSearchPreviewArtistImage] = useState(null); // Artist image for preview pane
  const [searchPreviewArtistBio, setSearchPreviewArtistBio] = useState(null); // Artist bio snippet for preview pane
  const [searchHeaderCollapsed, setSearchHeaderCollapsed] = useState(false); // Search detail header collapse state
  const [searchResultsFilter, setSearchResultsFilter] = useState(''); // Filter text for search results
  const [searchResultsFilterOpen, setSearchResultsFilterOpen] = useState(false); // Filter input open state
  const [searchResultsSort, setSearchResultsSort] = useState('relevance'); // Sort option for search results
  const [searchResultsSortDropdownOpen, setSearchResultsSortDropdownOpen] = useState(false); // Sort dropdown open state
  const [searchHistory, setSearchHistory] = useState([]);
  const [activeView, setActiveView] = useState(null); // null until restored from storage or defaults to 'library'
  const [viewHistory, setViewHistory] = useState([]); // Navigation history for back button
  const [forwardHistory, setForwardHistory] = useState([]); // Navigation history for forward button
  const [artistHistory, setArtistHistory] = useState([]); // Stack of previous artist names for back navigation
  const [playlists, setPlaylists] = useState([]);
  const [playlistsLoading, setPlaylistsLoading] = useState(true); // Loading state for playlists
  const [selectedPlaylist, setSelectedPlaylist] = useState(null);
  const [playlistTracks, setPlaylistTracks] = useState([]);
  const [allPlaylistCovers, setAllPlaylistCovers] = useState({}); // { playlistId: [url1, url2, url3, url4] }
  const [draggedPlaylistTrack, setDraggedPlaylistTrack] = useState(null); // For playlist track reordering
  const [playlistDropTarget, setPlaylistDropTarget] = useState(null); // Index where track will be dropped
  const [playlistEditMode, setPlaylistEditMode] = useState(false); // Edit mode for playlist detail view
  const [editedPlaylistData, setEditedPlaylistData] = useState(null); // Buffered changes: { title, creator, tracks }
  const [currentArtist, setCurrentArtist] = useState(null); // Artist page data
  const [artistImage, setArtistImage] = useState(null); // Artist image from Spotify
  const [artistImagePosition, setArtistImagePosition] = useState('center 25%'); // Face-centered position
  const [artistReleases, setArtistReleases] = useState([]); // Discography
  const [releaseTypeFilter, setReleaseTypeFilter] = useState('album'); // album, ep, single, live, compilation
  const [isHeaderCollapsed, setIsHeaderCollapsed] = useState(false); // Artist page header collapse state
  const [artistPageTab, setArtistPageTab] = useState('music'); // music | biography | related
  const [artistSearchOpen, setArtistSearchOpen] = useState(false);
  const [artistSearch, setArtistSearch] = useState('');
  const [artistSortDropdownOpen, setArtistSortDropdownOpen] = useState(false);
  const [artistSort, setArtistSort] = useState('date-desc'); // date-desc, date-asc, alpha-asc, alpha-desc
  const [artistBio, setArtistBio] = useState(null); // Artist biography from Last.fm
  const [relatedArtists, setRelatedArtists] = useState([]); // Related artists from Last.fm and ListenBrainz
  const [relatedArtistsSourceFilter, setRelatedArtistsSourceFilter] = useState('all'); // 'all' | 'lastfm' | 'listenbrainz' | 'both'
  const [loadingBio, setLoadingBio] = useState(false);
  const [loadingRelated, setLoadingRelated] = useState(false);
  const [loadingArtist, setLoadingArtist] = useState(false);
  const [currentRelease, setCurrentRelease] = useState(null); // Release/Album page data
  const [loadingRelease, setLoadingRelease] = useState(false);
  const [prefetchedReleases, setPrefetchedReleases] = useState({}); // Cache for on-hover prefetched release tracks: { releaseId: { tracks: [...], title, albumArt } }
  const prefetchedReleasesRef = useRef(prefetchedReleases); // Ref to avoid stale closure in context menu handlers
  const prefetchInProgressRef = useRef(new Set()); // Track which releases are currently being prefetched

  // Critic's Picks state
  const [criticsPicks, setCriticsPicks] = useState([]);
  const [criticsPicksLoading, setCriticsPicksLoading] = useState(false);
  const [criticsPicksLoaded, setCriticsPicksLoaded] = useState(false);

  // Charts state
  const [charts, setCharts] = useState([]);
  const [chartsLoading, setChartsLoading] = useState(false);
  const [chartsLoaded, setChartsLoaded] = useState(false);

  const [trackSources, setTrackSources] = useState({}); // Resolved sources for each track: { trackId: { youtube: {...}, soundcloud: {...} } }
  const [activeResolvers, setActiveResolvers] = useState(['spotify', 'bandcamp', 'qobuz', 'youtube']);
  const [resolverOrder, setResolverOrder] = useState(['spotify', 'bandcamp', 'qobuz', 'youtube', 'soundcloud']);
  const resolverSettingsLoaded = useRef(false);  // Track if we've loaded settings from storage
  const activeResolversRef = useRef(activeResolvers);  // Ref to avoid stale closure in save
  const resolverOrderRef = useRef(resolverOrder);  // Ref to avoid stale closure in save
  const [draggedResolver, setDraggedResolver] = useState(null);
  const [dragOverResolver, setDragOverResolver] = useState(null);  // Which resolver is being dragged over
  const [library, setLibrary] = useState([]);
  const [libraryLoading, setLibraryLoading] = useState(true);
  const [resolvingLibraryTracks, setResolvingLibraryTracks] = useState(new Set()); // Track filePaths currently being resolved
  const [audioContext, setAudioContext] = useState(null);
  const [currentSource, setCurrentSource] = useState(null);
  const [startTime, setStartTime] = useState(0);
  const [isExternalPlayback, setIsExternalPlayback] = useState(false);
  const [showExternalPrompt, setShowExternalPrompt] = useState(false);
  const [pendingExternalTrack, setPendingExternalTrack] = useState(null);
  const [pendingExternalResolverId, setPendingExternalResolverId] = useState(null); // Tracks which resolver was selected for external playback
  const [externalTrackCountdown, setExternalTrackCountdown] = useState(15);
  const [skipExternalPrompt, setSkipExternalPrompt] = useState(false); // "Don't show again" preference
  const [skipUnsavedFriendWarning, setSkipUnsavedFriendWarning] = useState(false); // "Don't show again" for unsaved friend unpin warning
  const [unsavedFriendWarningOpen, setUnsavedFriendWarningOpen] = useState(false); // Warning dialog state
  const [pendingUnpinFriend, setPendingUnpinFriend] = useState(null); // Friend being unpinned (for warning dialog)
  const [rememberQueue, setRememberQueue] = useState(false); // Remember queue on app close/reopen
  const externalTrackTimeoutRef = useRef(null);
  const externalTrackIntervalRef = useRef(null);
  const playbackPollerRef = useRef(null);
  const pollingRecoveryRef = useRef(null); // Recovery interval for when Spotify polling fails
  const isAdvancingTrackRef = useRef(false); // Re-entrancy guard for handleNext()
  const waitingForBrowserPlaybackRef = useRef(false); // True when we're waiting for browser to connect after opening external track
  const [settingsTab, setSettingsTab] = useState('marketplace'); // 'marketplace' | 'installed' | 'general' | 'about'
  const [marketplaceManifest, setMarketplaceManifest] = useState(null);
  const [marketplaceLoading, setMarketplaceLoading] = useState(false);
  const [marketplaceSearchQuery, setMarketplaceSearchQuery] = useState('');
  const [marketplaceCategory, setMarketplaceCategory] = useState('all');
  const [installingResolvers, setInstallingResolvers] = useState(new Set());
  const [selectedMarketplaceItem, setSelectedMarketplaceItem] = useState(null); // Marketplace item detail modal
  const [spotifyToken, setSpotifyToken] = useState(null);
  const spotifyTokenRef = useRef(null); // Ref for cleanup on unmount
  const [spotifyConnected, setSpotifyConnected] = useState(false);
  const [spotifyDevice, setSpotifyDevice] = useState(null); // Current Spotify playback device { name, type, supports_volume }
  const [queueDrawerOpen, setQueueDrawerOpen] = useState(false);
  const [queueDrawerHeight, setQueueDrawerHeight] = useState(350); // Default height in pixels
  const [draggedQueueTrack, setDraggedQueueTrack] = useState(null); // For queue reordering
  const [queueDropTarget, setQueueDropTarget] = useState(null); // Index where track will be dropped in queue
  const [droppingFromIndex, setDroppingFromIndex] = useState(null); // Index of clicked track - all tracks at index <= this fall down
  const [insertedTrackId, setInsertedTrackId] = useState(null); // Track ID that was just inserted via "previous"
  const [queueSaveDialogOpen, setQueueSaveDialogOpen] = useState(false); // Save queue as playlist dialog
  const [queueSavePlaylistName, setQueueSavePlaylistName] = useState(''); // Name for saved queue playlist
  const [qobuzToken, setQobuzToken] = useState(null);
  const [qobuzConnected, setQobuzConnected] = useState(false);

  // Meta Services state (Last.fm, ListenBrainz, etc.)
  const [metaServices, setMetaServices] = useState([]); // Loaded meta service plug-ins
  const [metaServiceConfigs, setMetaServiceConfigs] = useState({}); // { lastfm: { username, apiKey }, listenbrainz: { username, userToken } }
  const [lastfmAdvancedOpen, setLastfmAdvancedOpen] = useState(false); // Advanced section accordion state
  const [lastfmUsernameInput, setLastfmUsernameInput] = useState(''); // Input field value
  const [lastfmApiKeyInput, setLastfmApiKeyInput] = useState(''); // Advanced: API key input
  const [lastfmApiSecretInput, setLastfmApiSecretInput] = useState(''); // Advanced: API secret input
  const [lastfmConnecting, setLastfmConnecting] = useState(false); // Loading state during connection

  // ListenBrainz state
  const [listenbrainzAdvancedOpen, setListenbrainzAdvancedOpen] = useState(false); // Advanced section accordion state
  const [listenbrainzUsernameInput, setListenbrainzUsernameInput] = useState(''); // Input field value
  const [listenbrainzTokenInput, setListenbrainzTokenInput] = useState(''); // User token input
  const [listenbrainzConnecting, setListenbrainzConnecting] = useState(false); // Loading state during connection

  // Scrobbler settings state
  const [scrobblersInitialized, setScrobblersInitialized] = useState(false);
  const [scrobblerConfigs, setScrobblerConfigs] = useState({});
  const [scrobblingEnabled, setScrobblingEnabled] = useState(true);

  const [showUrlImportDialog, setShowUrlImportDialog] = useState(false);
  const [urlImportValue, setUrlImportValue] = useState('');
  const [urlImportLoading, setUrlImportLoading] = useState(false);

  // Local Files state
  const [localFilesStats, setLocalFilesStats] = useState({ totalTracks: 0, totalFolders: 0, lastScan: null });
  const [watchFolders, setWatchFolders] = useState([]);

  // Collection page state
  const [collectionTab, setCollectionTab] = useState('tracks'); // 'artists' | 'albums' | 'tracks' | 'friends'
  const [collectionHeaderCollapsed, setCollectionHeaderCollapsed] = useState(false);
  const [collectionSearchOpen, setCollectionSearchOpen] = useState(false);
  const [collectionSearch, setCollectionSearch] = useState('');
  const [collectionSortDropdownOpen, setCollectionSortDropdownOpen] = useState(false);
  const [collectionSort, setCollectionSort] = useState({
    artists: 'alpha-asc',
    albums: 'recent',
    tracks: 'recent',
    friends: 'alpha-asc'
  });

  // Friends state
  const [friends, setFriends] = useState([]);
  const [pinnedFriendIds, setPinnedFriendIds] = useState([]);
  const [currentFriend, setCurrentFriend] = useState(null);
  const [friendHistoryTab, setFriendHistoryTab] = useState('recent');
  const [friendHistoryData, setFriendHistoryData] = useState({
    recent: [],
    topTracks: [],
    topAlbums: [],
    topArtists: []
  });
  const [friendHistoryPeriod, setFriendHistoryPeriod] = useState('7day');
  const [friendHistorySort, setFriendHistorySort] = useState('recent');
  const [friendHistorySortDropdownOpen, setFriendHistorySortDropdownOpen] = useState(false);
  const [friendHistoryLoading, setFriendHistoryLoading] = useState(false);
  const [addFriendModalOpen, setAddFriendModalOpen] = useState(false);
  const [addFriendInput, setAddFriendInput] = useState('');
  const [addFriendLoading, setAddFriendLoading] = useState(false);
  const [friendDragOverSidebar, setFriendDragOverSidebar] = useState(false);
  const friendPollIntervalRef = useRef(null);

  // Playlists page state
  const [playlistsHeaderCollapsed, setPlaylistsHeaderCollapsed] = useState(false);
  const [playlistsSearchOpen, setPlaylistsSearchOpen] = useState(false);
  const [playlistsSearch, setPlaylistsSearch] = useState('');
  const [playlistsSortDropdownOpen, setPlaylistsSortDropdownOpen] = useState(false);
  const [playlistsSort, setPlaylistsSort] = useState('added');
  const [playlistsViewMode, setPlaylistsViewMode] = useState('grid'); // 'grid' | 'table'

  // Charts (Pop of the Tops) page state
  const [chartsHeaderCollapsed, setChartsHeaderCollapsed] = useState(false);
  const [chartsSearchOpen, setChartsSearchOpen] = useState(false);
  const [chartsSearch, setChartsSearch] = useState('');
  const [chartsSortDropdownOpen, setChartsSortDropdownOpen] = useState(false);
  const [chartsSort, setChartsSort] = useState('rank');

  // Critics Picks page state
  const [criticsHeaderCollapsed, setCriticsHeaderCollapsed] = useState(false);
  const [criticsSearchOpen, setCriticsSearchOpen] = useState(false);
  const [criticsSearch, setCriticsSearch] = useState('');
  const [criticsSortDropdownOpen, setCriticsSortDropdownOpen] = useState(false);
  const [criticsSort, setCriticsSort] = useState('recent');

  // Recommendations page state
  const [recommendationsHeaderCollapsed, setRecommendationsHeaderCollapsed] = useState(false);
  const [recommendationsTab, setRecommendationsTab] = useState('artists'); // 'artists' | 'songs'
  const [recommendationsSourceFilter, setRecommendationsSourceFilter] = useState('all'); // 'all' | 'listenbrainz' | 'lastfm'

  // History page state
  const [historyTab, setHistoryTab] = useState('topTracks'); // 'topTracks' | 'topAlbums' | 'topArtists' | 'recent'
  const pendingHistoryLoad = useRef(null); // Track pending history tab load from view restore
  const pendingReleaseLoad = useRef(null); // Track pending release/album load from view restore
  const [pendingPlaylistLoad, setPendingPlaylistLoad] = useState(null); // Track pending playlist load from view restore
  const [pendingFriendLoad, setPendingFriendLoad] = useState(null); // Track pending friend load from view restore
  const [historyPeriod, setHistoryPeriod] = useState('7day'); // 'overall' | '7day' | '1month' | '3month' | '6month' | '12month'
  const [historyPeriodDropdownOpen, setHistoryPeriodDropdownOpen] = useState(false);
  const [historyHeaderCollapsed, setHistoryHeaderCollapsed] = useState(false);
  const [historySearchOpen, setHistorySearchOpen] = useState(false);
  const [historySearch, setHistorySearch] = useState('');
  const [historySortDropdownOpen, setHistorySortDropdownOpen] = useState(false);
  const [historySort, setHistorySort] = useState('recent');
  const [listeningHistory, setListeningHistory] = useState({ tracks: [], loading: true, error: null });
  const [topTracks, setTopTracks] = useState({ tracks: [], loading: false, error: null });
  const [topArtists, setTopArtists] = useState({ artists: [], loading: false, error: null });
  const [topAlbums, setTopAlbums] = useState({ albums: [], loading: false, error: null });

  // Sidebar badge state for visual feedback on additions
  const [sidebarBadges, setSidebarBadges] = useState({
    collection: null,
    playlists: null
  });
  const sidebarBadgeTimeouts = useRef({});

  // Show a "+N" badge on a sidebar item that auto-clears after animation
  const showSidebarBadge = useCallback((item, count = 1) => {
    // Clear any existing timeout for this item
    if (sidebarBadgeTimeouts.current[item]) {
      clearTimeout(sidebarBadgeTimeouts.current[item]);
    }
    // Show the badge
    setSidebarBadges(prev => ({ ...prev, [item]: count }));
    // Clear after animation completes (2s)
    sidebarBadgeTimeouts.current[item] = setTimeout(() => {
      setSidebarBadges(prev => ({ ...prev, [item]: null }));
    }, 2000);
  }, []);

  // Close collection sort dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = () => setCollectionSortDropdownOpen(false);
    if (collectionSortDropdownOpen) {
      document.addEventListener('click', handleClickOutside);
      return () => document.removeEventListener('click', handleClickOutside);
    }
  }, [collectionSortDropdownOpen]);

  // Track main content width for responsive header buttons
  useEffect(() => {
    if (!mainContentRef.current) return;
    const resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        setMainContentWidth(entry.contentRect.width);
      }
    });
    resizeObserver.observe(mainContentRef.current);
    return () => resizeObserver.disconnect();
  }, []);

  // Responsive breakpoints
  const isCompactHeader = mainContentWidth < 700;

  // Close playlists sort dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = () => setPlaylistsSortDropdownOpen(false);
    if (playlistsSortDropdownOpen) {
      document.addEventListener('click', handleClickOutside);
      return () => document.removeEventListener('click', handleClickOutside);
    }
  }, [playlistsSortDropdownOpen]);

  // Close charts sort dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = () => setChartsSortDropdownOpen(false);
    if (chartsSortDropdownOpen) {
      document.addEventListener('click', handleClickOutside);
      return () => document.removeEventListener('click', handleClickOutside);
    }
  }, [chartsSortDropdownOpen]);

  // Close critics sort dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = () => setCriticsSortDropdownOpen(false);
    if (criticsSortDropdownOpen) {
      document.addEventListener('click', handleClickOutside);
      return () => document.removeEventListener('click', handleClickOutside);
    }
  }, [criticsSortDropdownOpen]);

  // Close history sort dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = () => setHistorySortDropdownOpen(false);
    if (historySortDropdownOpen) {
      document.addEventListener('click', handleClickOutside);
      return () => document.removeEventListener('click', handleClickOutside);
    }
  }, [historySortDropdownOpen]);

  // Close friend history sort dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = () => setFriendHistorySortDropdownOpen(false);
    if (friendHistorySortDropdownOpen) {
      document.addEventListener('click', handleClickOutside);
      return () => document.removeEventListener('click', handleClickOutside);
    }
  }, [friendHistorySortDropdownOpen]);

  // Close artist sort dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = () => setArtistSortDropdownOpen(false);
    if (artistSortDropdownOpen) {
      document.addEventListener('click', handleClickOutside);
      return () => document.removeEventListener('click', handleClickOutside);
    }
  }, [artistSortDropdownOpen]);

  // Close search results sort dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = () => setSearchResultsSortDropdownOpen(false);
    if (searchResultsSortDropdownOpen) {
      document.addEventListener('click', handleClickOutside);
      return () => document.removeEventListener('click', handleClickOutside);
    }
  }, [searchResultsSortDropdownOpen]);

  // Reset search results filter/sort when changing categories
  useEffect(() => {
    setSearchResultsFilter('');
    setSearchResultsFilterOpen(false);
    setSearchResultsSort('relevance');
    setSearchResultsSortDropdownOpen(false);
  }, [searchDetailCategory]);

  // Load artist images when artists tab is selected in search results
  useEffect(() => {
    if (searchDetailCategory === 'artists' && searchResults.artists.length > 0) {
      // Check if any artists need images loaded
      const artistsNeedingImages = searchResults.artists.filter(a => !a.image && !a.imageLoaded);
      if (artistsNeedingImages.length > 0) {
        resolveSearchArtistImages(artistsNeedingImages);
      }
    }
  }, [searchDetailCategory, searchResults.artists.length]);

  // Resolve unresolved tracks when songs tab is selected in search results
  useEffect(() => {
    if (searchDetailCategory === 'tracks' && searchResults.tracks.length > 0) {
      // Check if any tracks need resolution (no sources and not already marked resolved)
      const tracksNeedingResolution = searchResults.tracks.filter(t =>
        Object.keys(t.sources || {}).length === 0 && !t.resolved
      );
      if (tracksNeedingResolution.length > 0) {
        resolveSearchTracks(tracksNeedingResolution);
      }
    }
  }, [searchDetailCategory, searchResults.tracks.length]);


  // Track if we're opening a release (to prevent header reset during artist change)
  const openingReleaseRef = useRef(false);
  // Track if we're restoring saved state (to prevent tab reset during restore)
  const restoringStateRef = useRef(false);

  // Playlists page scroll handler for header collapse
  const playlistsCollapseLockedRef = useRef(false);
  const handlePlaylistsScroll = useCallback((e) => {
    const scrollTop = e.target.scrollTop;

    // If locked (during transition), ignore scroll events
    if (playlistsCollapseLockedRef.current) return;

    // Only collapse when scrolled down past threshold
    if (scrollTop > 50 && !playlistsHeaderCollapsed) {
      playlistsCollapseLockedRef.current = true;
      setPlaylistsHeaderCollapsed(true);
      // Unlock after transition completes
      setTimeout(() => { playlistsCollapseLockedRef.current = false; }, 350);
    }
    // Only expand when scrolled to very top
    else if (scrollTop === 0 && playlistsHeaderCollapsed) {
      playlistsCollapseLockedRef.current = true;
      setPlaylistsHeaderCollapsed(false);
      setTimeout(() => { playlistsCollapseLockedRef.current = false; }, 350);
    }
  }, [playlistsHeaderCollapsed]);

  // Charts page scroll handler for header collapse
  const handleChartsScroll = useCallback((e) => {
    const scrollTop = e.target.scrollTop;
    setChartsHeaderCollapsed(prev => {
      if (!prev && scrollTop > 50) return true;
      if (prev && scrollTop === 0) return false;
      return prev;
    });
  }, []);

  // Critics page scroll handler for header collapse
  const handleCriticsScroll = useCallback((e) => {
    const scrollTop = e.target.scrollTop;
    setCriticsHeaderCollapsed(prev => {
      if (!prev && scrollTop > 50) return true;
      if (prev && scrollTop === 0) return false;
      return prev;
    });
  }, []);

  // History page scroll handler for header collapse
  const handleHistoryScroll = useCallback((e) => {
    const scrollTop = e.target.scrollTop;
    setHistoryHeaderCollapsed(prev => {
      if (!prev && scrollTop > 50) return true;
      if (prev && scrollTop === 0) return false;
      return prev;
    });
  }, []);

  // Reset collection header collapse when leaving library view
  useEffect(() => {
    if (activeView !== 'library') {
      setCollectionHeaderCollapsed(false);
      setCollectionSearchOpen(false);
      setCollectionSearch('');
    }
  }, [activeView]);

  // Reset playlists header collapse when leaving playlists view
  useEffect(() => {
    if (activeView !== 'playlists') {
      setPlaylistsHeaderCollapsed(false);
      setPlaylistsSearchOpen(false);
      setPlaylistsSearch('');
    }
  }, [activeView]);

  // Reset charts header collapse when leaving charts view
  useEffect(() => {
    if (activeView !== 'discover') {
      setChartsHeaderCollapsed(false);
      setChartsSearchOpen(false);
      setChartsSearch('');
    }
  }, [activeView]);

  // Reset critics header collapse when leaving critics view
  useEffect(() => {
    if (activeView !== 'critics-picks') {
      setCriticsHeaderCollapsed(false);
      setCriticsSearchOpen(false);
      setCriticsSearch('');
    }
  }, [activeView]);

  // Reset recommendations header collapse and tab when leaving recommendations view
  useEffect(() => {
    if (activeView !== 'recommendations') {
      setRecommendationsHeaderCollapsed(false);
      setRecommendationsTab('artists');
    }
  }, [activeView]);

  // Reset history header collapse when leaving history view
  useEffect(() => {
    if (activeView !== 'history') {
      setHistoryHeaderCollapsed(false);
      setHistorySearchOpen(false);
      setHistorySearch('');
    }
  }, [activeView]);

  // Reset artist page filter bar when leaving artist view
  useEffect(() => {
    if (activeView !== 'artist') {
      setArtistSearchOpen(false);
      setArtistSearch('');
      setArtistSortDropdownOpen(false);
    }
  }, [activeView]);

  // Filter collection items by search query
  const filterCollectionItems = useCallback((items, type) => {
    if (!collectionSearch.trim()) return items;
    const query = collectionSearch.toLowerCase();

    if (type === 'artists') {
      return items.filter(a => a.name.toLowerCase().includes(query));
    }
    if (type === 'albums') {
      return items.filter(a =>
        a.title.toLowerCase().includes(query) ||
        a.artist.toLowerCase().includes(query)
      );
    }
    if (type === 'tracks') {
      return items.filter(t =>
        (t.title || '').toLowerCase().includes(query) ||
        (t.artist || '').toLowerCase().includes(query) ||
        (t.album || '').toLowerCase().includes(query)
      );
    }
    return items;
  }, [collectionSearch]);

  // Sort collection items
  const sortCollectionItems = useCallback((items, type) => {
    const sortKey = collectionSort[type];
    const sorted = [...items];

    if (type === 'artists') {
      switch (sortKey) {
        case 'alpha-asc': return sorted.sort((a, b) => a.name.localeCompare(b.name));
        case 'alpha-desc': return sorted.sort((a, b) => b.name.localeCompare(a.name));
        case 'tracks': return sorted.sort((a, b) => b.trackCount - a.trackCount);
        case 'recent': return sorted.sort((a, b) => (b.addedAt || 0) - (a.addedAt || 0));
        default: return sorted;
      }
    }
    if (type === 'albums') {
      switch (sortKey) {
        case 'alpha-asc': return sorted.sort((a, b) => a.title.localeCompare(b.title));
        case 'alpha-desc': return sorted.sort((a, b) => b.title.localeCompare(a.title));
        case 'artist': return sorted.sort((a, b) => a.artist.localeCompare(b.artist));
        case 'year-new': return sorted.sort((a, b) => (b.year || 0) - (a.year || 0));
        case 'year-old': return sorted.sort((a, b) => (a.year || 9999) - (b.year || 9999));
        case 'recent': return sorted.sort((a, b) => (b.addedAt || 0) - (a.addedAt || 0));
        default: return sorted;
      }
    }
    if (type === 'tracks') {
      switch (sortKey) {
        case 'title-asc': return sorted.sort((a, b) => (a.title || '').localeCompare(b.title || ''));
        case 'title-desc': return sorted.sort((a, b) => (b.title || '').localeCompare(a.title || ''));
        case 'artist': return sorted.sort((a, b) => (a.artist || '').localeCompare(b.artist || ''));
        case 'album': return sorted.sort((a, b) => (a.album || '').localeCompare(b.album || ''));
        case 'duration': return sorted.sort((a, b) => (a.duration || 0) - (b.duration || 0));
        case 'recent': return sorted.sort((a, b) => (b.addedAt || 0) - (a.addedAt || 0));
        default: return sorted;
      }
    }
    return sorted;
  }, [collectionSort]);

  // Get sort options for current tab
  const getCollectionSortOptions = (tab) => {
    if (tab === 'artists') {
      return [
        { value: 'alpha-asc', label: 'A-Z' },
        { value: 'alpha-desc', label: 'Z-A' },
        { value: 'tracks', label: 'Most Tracks' },
        { value: 'recent', label: 'Recently Added' }
      ];
    }
    if (tab === 'albums') {
      return [
        { value: 'alpha-asc', label: 'A-Z' },
        { value: 'alpha-desc', label: 'Z-A' },
        { value: 'artist', label: 'Artist Name' },
        { value: 'year-new', label: 'Year (Newest)' },
        { value: 'year-old', label: 'Year (Oldest)' },
        { value: 'recent', label: 'Recently Added' }
      ];
    }
    if (tab === 'friends') {
      return [
        { value: 'alpha-asc', label: 'A-Z' },
        { value: 'alpha-desc', label: 'Z-A' },
        { value: 'recent', label: 'Recently Added' },
        { value: 'on-air', label: 'On Air Now' }
      ];
    }
    return [
      { value: 'title-asc', label: 'Title A-Z' },
      { value: 'title-desc', label: 'Title Z-A' },
      { value: 'artist', label: 'Artist Name' },
      { value: 'album', label: 'Album Name' },
      { value: 'duration', label: 'Duration' },
      { value: 'recent', label: 'Recently Added' }
    ];
  };

  // Filter and sort playlists
  const filterPlaylists = useCallback((items) => {
    if (!playlistsSearch.trim()) return items;
    const query = playlistsSearch.toLowerCase();
    return items.filter(p => p.title.toLowerCase().includes(query));
  }, [playlistsSearch]);

  const sortPlaylists = useCallback((items) => {
    const sorted = [...items];
    switch (playlistsSort) {
      case 'added':
        // Sort by addedAt descending (newest first), fallback to lastModified, then createdAt
        return sorted.sort((a, b) => {
          const aTime = Number(a.addedAt) || Number(a.lastModified) || Number(a.createdAt) || 0;
          const bTime = Number(b.addedAt) || Number(b.lastModified) || Number(b.createdAt) || 0;
          return bTime - aTime; // Descending (newest first)
        });
      case 'created': return sorted.sort((a, b) => (Number(b.createdAt) || 0) - (Number(a.createdAt) || 0));
      case 'modified': return sorted.sort((a, b) => (Number(b.lastModified) || 0) - (Number(a.lastModified) || 0));
      case 'alpha-asc': return sorted.sort((a, b) => (a.title || '').localeCompare(b.title || ''));
      case 'alpha-desc': return sorted.sort((a, b) => (b.title || '').localeCompare(a.title || ''));
      default: return sorted;
    }
  }, [playlistsSort]);

  const playlistsSortOptions = [
    { value: 'added', label: 'Recently Added' },
    { value: 'created', label: 'Date Created' },
    { value: 'modified', label: 'Recently Modified' },
    { value: 'alpha-asc', label: 'A-Z' },
    { value: 'alpha-desc', label: 'Z-A' }
  ];

  // Filter artist releases by search query
  const filterArtistReleases = useCallback((releases) => {
    if (!artistSearch.trim()) return releases;
    const query = artistSearch.toLowerCase();
    return releases.filter(r => r.title.toLowerCase().includes(query));
  }, [artistSearch]);

  // Sort artist releases
  const sortArtistReleases = useCallback((releases) => {
    const sorted = [...releases];
    switch (artistSort) {
      case 'date-desc': return sorted.sort((a, b) => (b.date || '').localeCompare(a.date || ''));
      case 'date-asc': return sorted.sort((a, b) => (a.date || '').localeCompare(b.date || ''));
      case 'alpha-asc': return sorted.sort((a, b) => a.title.localeCompare(b.title));
      case 'alpha-desc': return sorted.sort((a, b) => b.title.localeCompare(a.title));
      default: return sorted;
    }
  }, [artistSort]);

  const artistSortOptions = [
    { value: 'date-desc', label: 'Newest First' },
    { value: 'date-asc', label: 'Oldest First' },
    { value: 'alpha-asc', label: 'A-Z' },
    { value: 'alpha-desc', label: 'Z-A' }
  ];

  // Set smart default release type filter based on available releases
  const setSmartReleaseTypeFilter = useCallback((releases) => {
    const hasAlbums = releases.some(r => r.releaseType === 'album');
    const hasEPs = releases.some(r => r.releaseType === 'ep');
    const hasSingles = releases.some(r => r.releaseType === 'single');

    if (hasAlbums) {
      setReleaseTypeFilter('album');
    } else if (hasEPs) {
      setReleaseTypeFilter('ep');
    } else if (hasSingles) {
      setReleaseTypeFilter('single');
    } else {
      // Fallback to first available type
      const firstType = releases[0]?.releaseType;
      if (firstType) setReleaseTypeFilter(firstType);
    }
  }, []);

  // Filter and sort charts
  const filterCharts = useCallback((items) => {
    if (!chartsSearch.trim()) return items;
    const query = chartsSearch.toLowerCase();
    return items.filter(c =>
      c.title.toLowerCase().includes(query) ||
      c.artist.toLowerCase().includes(query)
    );
  }, [chartsSearch]);

  const sortCharts = useCallback((items) => {
    const sorted = [...items];
    switch (chartsSort) {
      case 'rank': return sorted.sort((a, b) => (a.rank || 999) - (b.rank || 999));
      case 'alpha-asc': return sorted.sort((a, b) => a.title.localeCompare(b.title));
      case 'alpha-desc': return sorted.sort((a, b) => b.title.localeCompare(a.title));
      case 'artist': return sorted.sort((a, b) => a.artist.localeCompare(b.artist));
      default: return sorted;
    }
  }, [chartsSort]);

  const chartsSortOptions = [
    { value: 'rank', label: 'Chart Rank' },
    { value: 'alpha-asc', label: 'A-Z' },
    { value: 'alpha-desc', label: 'Z-A' },
    { value: 'artist', label: 'Artist Name' }
  ];

  // Filter and sort critics picks
  const filterCriticsPicks = useCallback((items) => {
    if (!criticsSearch.trim()) return items;
    const query = criticsSearch.toLowerCase();
    return items.filter(c =>
      c.title.toLowerCase().includes(query) ||
      c.artist.toLowerCase().includes(query)
    );
  }, [criticsSearch]);

  const sortCriticsPicks = useCallback((items) => {
    const sorted = [...items];
    switch (criticsSort) {
      case 'recent': return sorted; // Keep original order (date added)
      case 'score-desc': return sorted.sort((a, b) => (b.score || 0) - (a.score || 0));
      case 'artist': return sorted.sort((a, b) => a.artist.localeCompare(b.artist));
      default: return sorted;
    }
  }, [criticsSort]);

  const criticsSortOptions = [
    { value: 'recent', label: 'Date Added' },
    { value: 'score-desc', label: 'Score' },
    { value: 'artist', label: 'Artist Name' }
  ];

  // Filter and sort history
  const filterHistory = useCallback((items) => {
    if (!historySearch.trim()) return items;
    const query = historySearch.toLowerCase();
    return items.filter(t =>
      t.title.toLowerCase().includes(query) ||
      t.artist.toLowerCase().includes(query) ||
      (t.album && t.album.toLowerCase().includes(query))
    );
  }, [historySearch]);

  const sortHistory = useCallback((items) => {
    const sorted = [...items];
    switch (historySort) {
      case 'recent': return sorted; // Keep original order (most recent first)
      case 'artist': return sorted.sort((a, b) => a.artist.localeCompare(b.artist));
      case 'title': return sorted.sort((a, b) => a.title.localeCompare(b.title));
      default: return sorted;
    }
  }, [historySort]);

  const historySortOptions = [
    { value: 'recent', label: 'Recent' },
    { value: 'artist', label: 'Artist A-Z' },
    { value: 'title', label: 'Title A-Z' }
  ];

  // Sort friend history
  const sortFriendHistory = useCallback((items) => {
    const sorted = [...items];
    switch (friendHistorySort) {
      case 'recent': return sorted; // Keep original order (most recent first)
      case 'artist': return sorted.sort((a, b) => a.artist.localeCompare(b.artist));
      case 'title': return sorted.sort((a, b) => a.title.localeCompare(b.title));
      default: return sorted;
    }
  }, [friendHistorySort]);

  const [isScanning, setIsScanning] = useState(false);
  const [scanProgress, setScanProgress] = useState({ current: 0, total: 0, file: '' });

  // ID3 Tag Editor state
  const [id3EditorOpen, setId3EditorOpen] = useState(false);
  const [id3EditorTrack, setId3EditorTrack] = useState(null);
  const [id3EditorValues, setId3EditorValues] = useState({
    title: '',
    artist: '',
    album: '',
    trackNumber: '',
    year: ''
  });
  const [id3EditorSaving, setId3EditorSaving] = useState(false);
  const [id3ArtSuggestions, setId3ArtSuggestions] = useState([]);
  const [id3ArtLoading, setId3ArtLoading] = useState(false);
  const [id3SelectedArt, setId3SelectedArt] = useState(null);
  const [id3ArtFetchKey, setId3ArtFetchKey] = useState(''); // Track last fetch to avoid duplicates

  // Add to Playlist panel state
  const [addToPlaylistPanel, setAddToPlaylistPanel] = useState({
    open: false,
    tracks: [], // Tracks to add
    sourceName: '', // Name of source (track title, album name, or playlist name)
    sourceType: '' // 'track', 'album', 'playlist'
  });
  const [selectedPlaylistsForAdd, setSelectedPlaylistsForAdd] = useState([]); // Selected playlist IDs for multi-select
  const [newPlaylistFormOpen, setNewPlaylistFormOpen] = useState(false); // Accordion state for new playlist form
  const [newPlaylistName, setNewPlaylistName] = useState(''); // Input value for new playlist name
  const [draggingTrackForPlaylist, setDraggingTrackForPlaylist] = useState(null); // Track being dragged that could be dropped on playlist
  const [toast, setToast] = useState(null); // { message: string, type: 'success' | 'error' }
  const [collectionData, setCollectionData] = useState({ tracks: [], albums: [], artists: [] });
  const [collectionLoading, setCollectionLoading] = useState(true);
  const [collectionDropHighlight, setCollectionDropHighlight] = useState(false);
  const [dropTargetPlaylistId, setDropTargetPlaylistId] = useState(null); // Playlist being hovered during drag
  const [dropTargetNewPlaylist, setDropTargetNewPlaylist] = useState(false); // Hovering over "+ NEW" button during drag
  const [droppedTrackForNewPlaylist, setDroppedTrackForNewPlaylist] = useState(null); // Track dropped on "+ NEW" to be added after creating playlist

  // Confirmation dialog state
  const [confirmDialog, setConfirmDialog] = useState({
    show: false,
    type: 'success', // 'success' | 'error' | 'info'
    title: '',
    message: '',
    onConfirm: null
  });

  // Helper to show styled confirmation dialogs
  const showConfirmDialog = (options) => {
    setConfirmDialog({
      show: true,
      type: options.type || 'info',
      title: options.title || '',
      message: options.message || '',
      onConfirm: options.onConfirm || null
    });
  };

  const closeConfirmDialog = () => {
    setConfirmDialog(prev => ({ ...prev, show: false }));
  };
  const [refreshingPlaylist, setRefreshingPlaylist] = useState(null); // Track which playlist is refreshing

  // Drag & drop URL state
  const [isDraggingUrl, setIsDraggingUrl] = useState(false);
  const [dropZoneTarget, setDropZoneTarget] = useState(null); // 'now-playing' | 'queue' | null
  const queueAnimationRef = useRef(null);
  const [queueAnimating, setQueueAnimating] = useState(false);
  const queueContentRef = useRef(null); // Ref for queue content scrolling
  const resolverLoaderRef = useRef(null);

  // Browser extension state
  const [extensionConnected, setExtensionConnected] = useState(false);
  const [browserPlaybackActive, setBrowserPlaybackActive] = useState(false);
  const [activeExtensionTabId, setActiveExtensionTabId] = useState(null);
  const pendingCloseTabIdRef = useRef(null);
  const streamingPlaybackActiveRef = useRef(false); // Track when playing via Spotify/streaming to ignore browser events

  // Refs to keep current values available in event handlers (avoids stale closure issues)
  const currentQueueRef = useRef([]);
  const currentTrackRef = useRef(null);
  const handleNextRef = useRef(null);
  const playHistoryRef = useRef([]); // Stack of previously played tracks for "previous" navigation
  // Friend function refs (for use in early useEffects before functions are defined)
  const navigateToFriendRef = useRef(null);
  const pinFriendRef = useRef(null);
  const unpinFriendRef = useRef(null);
  const removeFriendRef = useRef(null);
  const saveFriendToCollectionRef = useRef(null);
  const removeFriendFromCollectionRef = useRef(null);
  const artistPageScrollRef = useRef(null); // Ref for artist page scroll container
  const audioRef = useRef(null); // HTML5 Audio element for local file playback
  const localFilePlaybackTrackRef = useRef(null); // Track being played for fallback handling
  const localFileFallbackInProgressRef = useRef(false); // Prevent duplicate error dialogs during fallback
  const queueResolutionActiveRef = useRef(false); // When true, queue resolution takes priority over page resolution
  const pageResolutionAbortRef = useRef(null); // AbortController for cancelling page resolution
  const [selectedResolver, setSelectedResolver] = useState(null); // Resolver detail modal

  // Keep refs in sync with state
  useEffect(() => { currentQueueRef.current = currentQueue; }, [currentQueue]);
  useEffect(() => { currentTrackRef.current = currentTrack; }, [currentTrack]);
  useEffect(() => { spotifyTokenRef.current = spotifyToken; }, [spotifyToken]);
  useEffect(() => { isMutedRef.current = isMuted; }, [isMuted]);

  // Handle album art crossfade transitions in playbar
  useEffect(() => {
    const newArt = currentTrack?.albumArt || null;
    const prevArt = playbarAlbumArtRef.current;

    if (newArt !== prevArt) {
      // Album art changed - trigger crossfade
      setPlaybarAlbumArt({
        current: newArt,
        previous: prevArt,
        isLoaded: !newArt // If no new art, mark as loaded immediately
      });
      playbarAlbumArtRef.current = newArt;

      // Clear previous art after transition completes to free memory
      if (prevArt) {
        const clearPrevious = setTimeout(() => {
          setPlaybarAlbumArt(prev => ({ ...prev, previous: null }));
        }, 400); // Slightly longer than transition duration
        return () => clearTimeout(clearPrevious);
      }
    }
  }, [currentTrack?.albumArt]);

  // Scroll queue to bottom when opened (so track 1 is visible at the bottom)
  useEffect(() => {
    if (queueDrawerOpen && queueContentRef.current) {
      // Small delay to ensure the drawer has animated open
      setTimeout(() => {
        if (queueContentRef.current) {
          queueContentRef.current.scrollTop = queueContentRef.current.scrollHeight;
        }
      }, 50);
    }
  }, [queueDrawerOpen]);

  // Artist page scroll handler for header collapse
  const artistCollapseLockedRef = useRef(false);
  const artistLastScrollTopRef = useRef(0);
  const handleArtistPageScroll = useCallback((e) => {
    const scrollTop = e.target.scrollTop;
    const lastScrollTop = artistLastScrollTopRef.current;
    const isScrollingUp = scrollTop < lastScrollTop;
    artistLastScrollTopRef.current = scrollTop;

    // If locked (during transition), ignore scroll events
    if (artistCollapseLockedRef.current) return;

    // Collapse when scrolled down past threshold
    if (scrollTop > 50 && !isHeaderCollapsed && !isScrollingUp) {
      artistCollapseLockedRef.current = true;
      setIsHeaderCollapsed(true);
      // Unlock after transition completes
      setTimeout(() => { artistCollapseLockedRef.current = false; }, 350);
    }
    // Expand when scrolling up near the top (within 100px) or at very top
    else if (isHeaderCollapsed && isScrollingUp && scrollTop < 100) {
      artistCollapseLockedRef.current = true;
      setIsHeaderCollapsed(false);
      setTimeout(() => { artistCollapseLockedRef.current = false; }, 350);
    }
  }, [isHeaderCollapsed]);

  // Search detail page scroll handler for header collapse and infinite scroll
  const handleSearchDetailScroll = useCallback((e) => {
    const { scrollTop, scrollHeight, clientHeight } = e.target;
    // Header collapse
    setSearchHeaderCollapsed(scrollTop > 100);
    // Infinite scroll - load more when within 200px of bottom
    if (scrollHeight - scrollTop - clientHeight < 200 && searchDetailCategory) {
      handleLoadMore(searchDetailCategory);
    }
  }, [searchDetailCategory]);

  // Reset search header collapse when leaving detail view
  useEffect(() => {
    if (!searchDetailCategory) {
      setSearchHeaderCollapsed(false);
    }
  }, [searchDetailCategory]);

  // Reset header collapse and tab when navigating to a new artist (but not when opening a release or restoring state)
  useEffect(() => {
    // Don't reset header if we're opening a release - it should stay collapsed
    if (openingReleaseRef.current) {
      openingReleaseRef.current = false;
    } else {
      setIsHeaderCollapsed(false);
    }
    // Don't reset tab or clear data if we're restoring saved state
    if (restoringStateRef.current) {
      restoringStateRef.current = false;
    } else {
      setArtistPageTab('music');
      setArtistBio(null);
      setRelatedArtists([]);
    }
  }, [currentArtist]);

  // Fetch tab data when restored to biography or related artists tab
  useEffect(() => {
    if (!currentArtist) return;

    if (artistPageTab === 'biography' && !artistBio && !loadingBio) {
      (async () => {
        const bioData = await getArtistBio(currentArtist.name, currentArtist.mbid);
        setArtistBio(bioData); // Set even if null to prevent refetching
      })();
    }

    if (artistPageTab === 'related' && relatedArtists.length === 0 && !loadingRelated) {
      (async () => {
        const related = await getRelatedArtists(currentArtist.name, currentArtist.mbid);
        if (related.length > 0) {
          setRelatedArtists(related);
          resolveRelatedArtistImages(related);
        }
      })();
    }
  }, [artistPageTab, currentArtist]);

  // Load local files data when resolver modal is opened
  useEffect(() => {
    if (selectedResolver?.id === 'localfiles' && window.electron?.localFiles) {
      window.electron.localFiles.getStats().then(setLocalFilesStats);
      window.electron.localFiles.getWatchFolders().then(setWatchFolders);
    }
  }, [selectedResolver]);

  // Listen for local files scan progress and library changes
  useEffect(() => {
    if (window.electron?.localFiles?.onScanProgress) {
      window.electron.localFiles.onScanProgress((data) => {
        setScanProgress(data);
      });
    }
    if (window.electron?.localFiles?.onLibraryChanged) {
      window.electron.localFiles.onLibraryChanged((changes) => {
        // Refresh stats when library changes
        if (window.electron?.localFiles) {
          window.electron.localFiles.getStats().then(setLocalFilesStats);
          window.electron.localFiles.getWatchFolders().then(setWatchFolders);
        }
      });
    }
  }, []);

  // URL drag & drop helpers
  const isValidUrl = (string) => {
    try {
      const url = new URL(string);
      return url.protocol === 'http:' || url.protocol === 'https:' || string.startsWith('spotify:');
    } catch {
      return false;
    }
  };

  const extractUrlFromDrop = (dataTransfer) => {
    // Try text/uri-list first (standard for URL drops)
    let url = dataTransfer.getData('text/uri-list');
    if (url && isValidUrl(url.split('\n')[0])) {
      return url.split('\n')[0].trim();
    }

    // Fallback to text/plain
    url = dataTransfer.getData('text/plain');
    if (url && isValidUrl(url.trim())) {
      return url.trim();
    }

    return null;
  };

  const getUrlDomain = (url) => {
    try {
      if (url.startsWith('spotify:')) return 'spotify.com';
      const urlObj = new URL(url);
      return urlObj.hostname.replace(/^www\./, '');
    } catch {
      return 'unknown';
    }
  };

  // Convert raw track metadata to a proper track object with sources
  const createTrackFromMeta = (trackMeta, resolverId, sourceUrl = null) => {
    const trackId = `${trackMeta.artist}-${trackMeta.title}-${trackMeta.album || 'Single'}`.toLowerCase().replace(/[^a-z0-9]/g, '-');
    const track = {
      id: trackId,
      status: 'ready',
      title: trackMeta.title,
      artist: trackMeta.artist,
      album: trackMeta.album || 'Single',
      duration: trackMeta.duration || 180,
      albumArt: trackMeta.albumArt,
      sourceUrl: sourceUrl,
      sources: {}
    };

    // Add source-specific data
    const sourceData = {};
    if (trackMeta.spotifyId) sourceData.spotifyId = trackMeta.spotifyId;
    if (trackMeta.spotifyUri) sourceData.spotifyUri = trackMeta.spotifyUri;
    if (trackMeta.youtubeId) sourceData.youtubeId = trackMeta.youtubeId;
    if (trackMeta.bandcampUrl) sourceData.bandcampUrl = trackMeta.bandcampUrl;
    if (trackMeta.appleMusicId) sourceData.appleMusicId = trackMeta.appleMusicId;
    if (trackMeta.previewUrl) sourceData.previewUrl = trackMeta.previewUrl;

    if (Object.keys(sourceData).length > 0) {
      track.sources[resolverId] = {
        ...sourceData,
        confidence: 1.0
      };
    }

    return track;
  };

  // Handle URL drop - main entry point
  const handleUrlDrop = async (url, zone) => {
    console.log(`ðŸ”— URL dropped on ${zone}:`, url);

    // Find resolver for this URL
    const resolverId = resolverLoaderRef.current?.findResolverForUrl(url);
    if (!resolverId) {
      console.error('âŒ No resolver found for URL:', url);
      return;
    }

    console.log(`ðŸ“Ž Matched resolver: ${resolverId}`);

    // Detect URL type (track, album, or playlist)
    const urlType = resolverLoaderRef.current.getUrlType(url);
    console.log(`ðŸ“Ž URL type: ${urlType}`);

    // Handle album/playlist URLs
    if (urlType === 'album' || urlType === 'playlist') {
      await handleCollectionUrlDrop(url, resolverId, urlType, zone);
      return;
    }

    // Handle single track URL (existing logic)
    await handleSingleTrackUrlDrop(url, zone, resolverId);
  };

  // Handle album or playlist URL drop
  const handleCollectionUrlDrop = async (url, resolverId, urlType, zone) => {
    console.log(`ðŸ“€ Loading ${urlType} from URL (zone: ${zone}):`, url);

    try {
      const config = await getResolverConfig(resolverId);
      let result;

      if (urlType === 'album') {
        result = await resolverLoaderRef.current.lookupAlbum(url, config);
        if (!result || !result.album) {
          throw new Error('Could not load album');
        }
      } else {
        result = await resolverLoaderRef.current.lookupPlaylist(url, config);
        if (!result || !result.playlist) {
          throw new Error('Could not load playlist');
        }
      }

      const collection = result.album || result.playlist;
      const collectionResolverId = result.resolverId;
      const tracks = collection.tracks || [];

      if (tracks.length === 0) {
        console.error(`âŒ ${urlType} has no tracks`);
        return;
      }

      console.log(`âœ… ${urlType} "${collection.name}" loaded with ${tracks.length} tracks`);

      // Create context for this collection (include source URL for external navigation)
      const context = urlType === 'album'
        ? { type: 'album', id: collection.id, name: collection.name, artist: collection.artist, url: url }
        : { type: 'playlist', id: collection.id, name: collection.name, url: url };

      // Convert all tracks to proper track objects with context
      const resolvedTracks = tracks.map(trackMeta => ({
        ...createTrackFromMeta(trackMeta, collectionResolverId, url),
        _playbackContext: context
      }));

      const hasCurrentTrack = currentTrackRef.current !== null;

      // If dropped on now-playing zone, play first track immediately
      // and add remaining tracks to the BEGINNING of the queue (play next)
      if (zone === 'now-playing') {
        const firstTrack = resolvedTracks[0];
        const remainingTracks = resolvedTracks.slice(1);

        // Show toast notification
        showToast(`Playing "${collection.name}" (${tracks.length} tracks)`);

        // Add remaining tracks to the BEGINNING of the queue (so they play next)
        if (remainingTracks.length > 0) {
          setCurrentQueue(prev => [...remainingTracks, ...prev]);
        }

        // Set context and play first track immediately
        setPlaybackContext(context);
        setCurrentTrack(firstTrack);
        handlePlay(firstTrack);

        // Trigger queue animation if we added tracks
        if (remainingTracks.length > 0) {
          triggerQueueAnimation();
        }
      } else {
        // Default behavior: add all tracks to queue
        showToast(`Added ${tracks.length} tracks from "${collection.name}" to queue`);

        setCurrentQueue(prev => [...prev, ...resolvedTracks]);
        triggerQueueAnimation();

        // If nothing is playing, start the first track
        if (!hasCurrentTrack && resolvedTracks.length > 0) {
          const firstTrack = resolvedTracks[0];
          // Remove from queue and set as current
          setCurrentQueue(prev => prev.slice(1));
          setPlaybackContext(context);
          setCurrentTrack(firstTrack);
          handlePlay(firstTrack);
        }
      }

      // Background resolution: resolve all tracks across all enabled resolvers
      // This happens asynchronously so tracks are playable immediately but will
      // have all sources available for priority-based playback
      resolveTracksInBackground(resolvedTracks);

    } catch (error) {
      console.error(`âŒ ${urlType} lookup failed:`, error);
      showToast(`Could not load ${urlType}: ${error.message}`, 'error');
    }
  };

  // Resolve tracks across all enabled resolvers in the background
  const resolveTracksInBackground = async (tracks) => {
    console.log(`ðŸ” Background resolution: resolving ${tracks.length} tracks across all sources...`);

    // Use ref to avoid stale closure issues
    const currentResolvers = loadedResolversRef.current;
    const enabledResolvers = resolverOrder
      .filter(id => activeResolvers.includes(id))
      .map(id => currentResolvers.find(r => r.id === id))
      .filter(r => r && r.capabilities.resolve);

    // Process tracks in batches to avoid overwhelming APIs
    const BATCH_SIZE = 5;
    for (let i = 0; i < tracks.length; i += BATCH_SIZE) {
      const batch = tracks.slice(i, i + BATCH_SIZE);

      await Promise.all(batch.map(async (track) => {
        // Skip if track already has multiple sources
        if (Object.keys(track.sources).length >= enabledResolvers.length) {
          return;
        }

        const resolvePromises = enabledResolvers.map(async (resolver) => {
          // Skip if we already have this source
          if (track.sources[resolver.id]) return;

          try {
            const config = await getResolverConfig(resolver.id);
            const result = await resolver.resolve(track.artist, track.title, track.album, config);
            if (result) {
              track.sources[resolver.id] = {
                ...result,
                confidence: 0.9
              };
              console.log(`  âœ… ${resolver.name}: Found "${track.title}"`);
            }
          } catch (error) {
            // Silently fail - background resolution is best-effort
          }
        });

        await Promise.all(resolvePromises);
      }));

      // Small delay between batches to be nice to APIs
      if (i + BATCH_SIZE < tracks.length) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }

    // Update queue state with resolved sources
    setCurrentQueue(prev => prev.map(queueTrack => {
      const resolvedTrack = tracks.find(t => t.id === queueTrack.id);
      if (resolvedTrack && Object.keys(resolvedTrack.sources).length > Object.keys(queueTrack.sources).length) {
        return { ...queueTrack, sources: resolvedTrack.sources };
      }
      return queueTrack;
    }));

    console.log(`âœ… Background resolution complete for ${tracks.length} tracks`);
  };

  // Handle single track URL drop (original handleUrlDrop logic)
  const handleSingleTrackUrlDrop = async (url, zone, resolverId) => {
    // Create context for this URL drop
    const context = { type: 'url', url: url, name: getUrlDomain(url) };

    // Create placeholder track
    const placeholderId = `pending-${Date.now()}`;
    const placeholder = {
      id: placeholderId,
      status: 'loading',
      sourceUrl: url,
      sourceDomain: getUrlDomain(url),
      title: null,
      artist: null,
      album: null,
      duration: null,
      albumArt: null,
      sources: {},
      errorMessage: null,
      _playbackContext: context
    };

    // Determine where to insert - use refs to avoid stale closure issues
    // (especially when called from extension message handler in useEffect)
    const hasQueue = currentQueueRef.current.length > 0;
    const hasCurrentTrack = currentTrackRef.current !== null;
    // Play immediately only if explicitly requested OR if nothing is playing/queued
    const shouldPlayImmediately = zone === 'now-playing' || (!hasQueue && !hasCurrentTrack);
    console.log(`ðŸ“ handleUrlDrop: hasQueue=${hasQueue}, hasCurrentTrack=${hasCurrentTrack}, shouldPlayImmediately=${shouldPlayImmediately}`);

    if (shouldPlayImmediately) {
      // Set as current track (loading state)
      setCurrentTrack(placeholder);
    } else {
      // Add to queue - insert at position 1 if queue has items, otherwise at position 0
      setCurrentQueue(prev => {
        const newQueue = [...prev];
        const insertPosition = prev.length > 0 ? 1 : 0;
        newQueue.splice(insertPosition, 0, placeholder);
        return newQueue;
      });
      // Trigger queue icon animation
      triggerQueueAnimation();
    }

    // Look up track metadata
    try {
      // Pass resolver config so Spotify has access to token
      const config = await getResolverConfig(resolverId);
      const result = await resolverLoaderRef.current.lookupUrl(url, config);

      if (!result || !result.track) {
        throw new Error('Could not load track metadata');
      }

      const { track: trackMeta, resolverId: lookupResolverId } = result;
      console.log(`âœ… URL lookup success:`, trackMeta.title, '-', trackMeta.artist);

      // Create proper track object with playback context
      const resolvedTrack = {
        ...createTrackFromMeta(trackMeta, lookupResolverId, url),
        _playbackContext: context
      };

      // Now resolve across all enabled resolvers for playable sources
      console.log(`ðŸ” Resolving playable sources...`);
      // Use ref to avoid stale closure issues when called from extension message handler
      const currentResolvers = loadedResolversRef.current;
      const enabledResolvers = resolverOrder
        .filter(id => activeResolvers.includes(id))
        .map(id => currentResolvers.find(r => r.id === id))
        .filter(r => r && r.capabilities.resolve);

      const resolvePromises = enabledResolvers.map(async (resolver) => {
        try {
          const config = await getResolverConfig(resolver.id);
          const result = await resolver.resolve(trackMeta.artist, trackMeta.title, trackMeta.album, config);
          if (result) {
            resolvedTrack.sources[resolver.id] = {
              ...result,
              confidence: 0.9
            };
            console.log(`  âœ… ${resolver.name}: Found match`);
          }
        } catch (error) {
          console.error(`  âŒ ${resolver.name} resolve error:`, error);
        }
      });

      await Promise.all(resolvePromises);

      // Update the placeholder with resolved data
      if (shouldPlayImmediately) {
        setCurrentTrack(prev => {
          if (prev?.id === placeholderId) {
            return resolvedTrack;
          }
          return prev;
        });
        // Set playback context and actually play it
        setPlaybackContext(context);
        handlePlay(resolvedTrack);
      } else {
        setCurrentQueue(prev => prev.map(t =>
          t.id === placeholderId ? resolvedTrack : t
        ));
      }

    } catch (error) {
      console.error('âŒ URL lookup failed:', error);

      // Update placeholder to error state
      const errorTrack = {
        ...placeholder,
        status: 'error',
        errorMessage: error.message || 'Could not load track'
      };

      if (shouldPlayImmediately) {
        setCurrentTrack(prev => {
          if (prev?.id === placeholderId) {
            return errorTrack;
          }
          return prev;
        });
      } else {
        setCurrentQueue(prev => prev.map(t =>
          t.id === placeholderId ? errorTrack : t
        ));
      }
    }
  };

  // Queue animation trigger
  const triggerQueueAnimation = () => {
    setQueueAnimating(true);
    if (queueAnimationRef.current) {
      clearTimeout(queueAnimationRef.current);
    }
    queueAnimationRef.current = setTimeout(() => {
      setQueueAnimating(false);
    }, 300);
  };

  // Drag event handlers for URL drops
  const handleDragEnter = (e, zone) => {
    e.preventDefault();
    e.stopPropagation();

    const url = extractUrlFromDrop(e.dataTransfer);
    if (!url) return;

    // Check if any resolver can handle this URL
    const resolverId = resolverLoaderRef.current?.findResolverForUrl(url);
    if (resolverId) {
      setIsDraggingUrl(true);
      setDropZoneTarget(zone);
    }
  };

  const handleDragOver = (e, zone) => {
    e.preventDefault();
    e.stopPropagation();

    // Update target if moving between zones
    if (isDraggingUrl && dropZoneTarget !== zone) {
      setDropZoneTarget(zone);
    }
  };

  const handleDragLeave = (e) => {
    e.preventDefault();
    e.stopPropagation();

    // Only clear if leaving the app entirely
    const relatedTarget = e.relatedTarget;
    if (!relatedTarget || !e.currentTarget.contains(relatedTarget)) {
      setIsDraggingUrl(false);
      setDropZoneTarget(null);
    }
  };

  const handleDrop = (e, zone) => {
    e.preventDefault();
    e.stopPropagation();

    setIsDraggingUrl(false);
    setDropZoneTarget(null);

    // First, try to parse as internal JSON object (track, album, playlist)
    const plainText = e.dataTransfer.getData('text/plain');
    if (plainText) {
      try {
        const data = JSON.parse(plainText);
        if (data.type === 'track' && data.track) {
          console.log(`ðŸŽµ Internal track dropped on ${zone}:`, data.track.title);
          if (zone === 'now-playing') {
            // Play immediately
            setCurrentTrack(data.track);
            handlePlay(data.track);
          } else {
            // Add to queue
            setCurrentQueue(prev => [...prev, data.track]);
            triggerQueueAnimation();
          }
          return;
        }
        if (data.type === 'album' && data.album) {
          console.log(`ðŸ“€ Internal album dropped on ${zone}:`, data.album.title);
          // Fetch album tracks and handle like a collection drop
          handleInternalAlbumDrop(data.album, zone);
          return;
        }
        if (data.type === 'playlist' && data.playlist) {
          console.log(`ðŸ“‹ Internal playlist dropped on ${zone}:`, data.playlist.title);
          // Handle playlist tracks
          handleInternalPlaylistDrop(data.playlist, zone);
          return;
        }
      } catch (parseError) {
        // Not JSON, continue to URL handling
      }
    }

    // Fall back to URL drop handling
    const url = extractUrlFromDrop(e.dataTransfer);
    if (!url) {
      console.log('No valid URL or internal object in drop');
      return;
    }

    handleUrlDrop(url, zone);
  };

  // Handle internal album drop (from within the app)
  const handleInternalAlbumDrop = async (album, zone) => {
    // If album has tracks array, use it directly
    if (album.tracks && album.tracks.length > 0) {
      const tracks = album.tracks;
      const context = { type: 'album', id: album.id, name: album.title, artist: album.artist };
      const taggedTracks = tracks.map(t => ({ ...t, _playbackContext: context }));
      if (zone === 'now-playing') {
        showToast(`Playing "${album.title}" (${tracks.length} tracks)`);
        const firstTrack = taggedTracks[0];
        const remainingTracks = taggedTracks.slice(1);
        // Add remaining tracks to BEGINNING of queue (play next)
        if (remainingTracks.length > 0) {
          setCurrentQueue(prev => [...remainingTracks, ...prev]);
        }
        setPlaybackContext(context);
        setCurrentTrack(firstTrack);
        handlePlay(firstTrack);
        if (remainingTracks.length > 0) {
          triggerQueueAnimation();
        }
      } else {
        showToast(`Added ${tracks.length} tracks from "${album.title}" to queue`);
        setCurrentQueue(prev => [...prev, ...taggedTracks]);
        triggerQueueAnimation();
      }
      return;
    }

    // Otherwise, need to fetch the album tracks (e.g., from release page cache)
    const releaseId = album.id;
    const cachedRelease = prefetchedReleasesRef.current[releaseId];
    if (cachedRelease && cachedRelease.tracks) {
      const tracks = cachedRelease.tracks;
      const context = { type: 'album', id: album.id, name: album.title, artist: album.artist };
      const taggedTracks = tracks.map(t => ({ ...t, _playbackContext: context }));
      if (zone === 'now-playing') {
        showToast(`Playing "${album.title}" (${tracks.length} tracks)`);
        const firstTrack = taggedTracks[0];
        const remainingTracks = taggedTracks.slice(1);
        // Add remaining tracks to BEGINNING of queue (play next)
        if (remainingTracks.length > 0) {
          setCurrentQueue(prev => [...remainingTracks, ...prev]);
        }
        setPlaybackContext(context);
        setCurrentTrack(firstTrack);
        handlePlay(firstTrack);
        if (remainingTracks.length > 0) {
          triggerQueueAnimation();
        }
      } else {
        showToast(`Added ${tracks.length} tracks from "${album.title}" to queue`);
        setCurrentQueue(prev => [...prev, ...taggedTracks]);
        triggerQueueAnimation();
      }
    } else {
      showToast(`Could not load tracks for "${album.title}"`, 'error');
    }
  };

  // Handle internal playlist drop (from within the app)
  const handleInternalPlaylistDrop = async (playlist, zone) => {
    const tracks = playlist.tracks || [];
    if (tracks.length === 0) {
      showToast(`Playlist "${playlist.title}" has no tracks`, 'error');
      return;
    }

    const context = { type: 'playlist', id: playlist.id, name: playlist.title };
    const taggedTracks = tracks.map(t => ({ ...t, _playbackContext: context }));

    if (zone === 'now-playing') {
      showToast(`Playing "${playlist.title}" (${tracks.length} tracks)`);
      const firstTrack = taggedTracks[0];
      const remainingTracks = taggedTracks.slice(1);
      // Add remaining tracks to BEGINNING of queue (play next)
      if (remainingTracks.length > 0) {
        setCurrentQueue(prev => [...remainingTracks, ...prev]);
      }
      setPlaybackContext(context);
      setCurrentTrack(firstTrack);
      handlePlay(firstTrack);
      if (remainingTracks.length > 0) {
        triggerQueueAnimation();
      }
    } else {
      showToast(`Added ${tracks.length} tracks from "${playlist.title}" to queue`);
      setCurrentQueue(prev => [...prev, ...taggedTracks]);
      triggerQueueAnimation();
    }
  };

  // Drop zone overlay component
  const DropZoneOverlay = ({ zone, isActive }) => {
    if (!isActive) return null;

    const isNowPlaying = zone === 'now-playing';
    const icon = isNowPlaying ? 'â–¶' : 'ðŸ“‹';
    const text = isNowPlaying ? 'Drop to Play Now' : 'Drop to Play Next';

    return React.createElement('div', {
      style: {
        position: 'absolute',
        inset: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.8)',
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        zIndex: 100,
        borderRadius: '8px',
        border: '2px dashed rgba(147, 51, 234, 0.5)',
        pointerEvents: 'none'
      }
    },
      React.createElement('div', {
        style: {
          fontSize: '48px',
          marginBottom: '16px'
        }
      }, icon),
      React.createElement('div', {
        style: {
          fontSize: '18px',
          fontWeight: '600',
          color: '#a855f7'
        }
      }, text)
    );
  };

  // Resolver plugin system
  const resolverLoader = useRef(null);
  const [loadedResolvers, setLoadedResolvers] = useState([]);
  const loadedResolversRef = useRef([]);

  // Cleanup polling interval, external track timeout, and stop playback on unmount
  useEffect(() => {
    // Also handle beforeunload for when window closes
    const handleBeforeUnload = () => {
      if (spotifyTokenRef.current) {
        // Use sendBeacon for reliable delivery during page unload
        const url = 'https://api.spotify.com/v1/me/player/pause';
        // sendBeacon doesn't support PUT, so fall back to fetch with keepalive
        fetch(url, {
          method: 'PUT',
          headers: { 'Authorization': `Bearer ${spotifyTokenRef.current}` },
          keepalive: true
        }).catch(() => {});
      }
    };

    window.addEventListener('beforeunload', handleBeforeUnload);

    return () => {
      window.removeEventListener('beforeunload', handleBeforeUnload);
      if (playbackPollerRef.current) {
        clearInterval(playbackPollerRef.current);
        playbackPollerRef.current = null;
      }
      if (pollingRecoveryRef.current) {
        clearInterval(pollingRecoveryRef.current);
        pollingRecoveryRef.current = null;
      }
      if (externalTrackTimeoutRef.current) {
        clearTimeout(externalTrackTimeoutRef.current);
        externalTrackTimeoutRef.current = null;
      }
      // Stop Spotify playback on app shutdown
      if (spotifyTokenRef.current) {
        fetch('https://api.spotify.com/v1/me/player/pause', {
          method: 'PUT',
          headers: { 'Authorization': `Bearer ${spotifyTokenRef.current}` },
          keepalive: true
        }).catch(() => {}); // Ignore errors on shutdown
      }
    };
  }, []);

  // Helper to determine resolver ID from track properties
  const determineResolverIdFromTrack = (track) => {
    if (!track) return null;
    // Check for resolver-specific properties at top level OR nested in sources
    if (track.spotifyUri || track.spotifyId || track.sources?.spotify) return 'spotify';
    if (track.bandcampUrl || track.sources?.bandcamp) return 'bandcamp';
    if (track.youtubeUrl || track.youtubeId || track.sources?.youtube) return 'youtube';
    if (track.qobuzId || track.sources?.qobuz) return 'qobuz';
    if (track.filePath || track.fileUrl || track.sources?.localfiles) return 'localfiles';
    return null;
  };

  // Calculate effective volume with resolver offset and per-track adjustment
  // Returns volume as 0-100 percentage
  const getEffectiveVolume = (baseVolume, resolverId, trackId) => {
    // Get resolver offset (dB)
    const resolverOffset = resolverVolumeOffsets[resolverId] || 0;
    // Get per-track adjustment (dB)
    const trackOffset = trackId ? (trackVolumeAdjustments.current[trackId] || 0) : 0;
    // Total dB adjustment
    const totalOffsetDb = resolverOffset + trackOffset;
    // Convert dB to linear multiplier: 10^(dB/20)
    const multiplier = Math.pow(10, totalOffsetDb / 20);
    // Apply to base volume and clamp to 0-100
    const effectiveVolume = Math.max(0, Math.min(100, baseVolume * multiplier));
    return effectiveVolume;
  };

  // Set Spotify playback volume via API (with normalization)
  const setSpotifyVolume = async (volumePercent, applyNormalization = true) => {
    if (!spotifyTokenRef.current) return;
    try {
      // Apply normalization if enabled
      let effectiveVolume = volumePercent;
      if (applyNormalization && currentTrackRef.current) {
        effectiveVolume = getEffectiveVolume(volumePercent, 'spotify', currentTrackRef.current.id);
      }
      const response = await fetch(`https://api.spotify.com/v1/me/player/volume?volume_percent=${Math.round(effectiveVolume)}`, {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${spotifyTokenRef.current}`
        }
      });
      if (!response.ok && response.status !== 204) {
        console.error('Failed to set Spotify volume:', response.status);
      }
    } catch (error) {
      console.error('Error setting Spotify volume:', error);
    }
  };

  // Debounced version for slider dragging (prevents rate limiting)
  const setSpotifyVolumeDebounced = (volumePercent, applyNormalization = true) => {
    if (spotifyVolumeTimeoutRef.current) {
      clearTimeout(spotifyVolumeTimeoutRef.current);
    }
    spotifyVolumeTimeoutRef.current = setTimeout(() => {
      setSpotifyVolume(volumePercent, applyNormalization);
    }, 150); // 150ms debounce
  };

  // Apply normalized volume for local file playback
  const applyLocalFileVolume = (baseVolume, trackId) => {
    if (!audioRef.current) return;
    const effectiveVolume = getEffectiveVolume(baseVolume, 'localfiles', trackId);
    audioRef.current.volume = effectiveVolume / 100;
  };

  // Cache for album art URLs (releaseId -> { url, timestamp })
  const albumArtCache = useRef({});
  const [cacheLoaded, setCacheLoaded] = useState(false); // Track when persistent cache is loaded

  // Cache for artist data (artistName -> { data, timestamp })
  const artistDataCache = useRef({});

  // Cache for track sources (trackKey -> { sources, timestamp })
  // trackKey format: "artist|title|album"
  const trackSourcesCache = useRef({});

  // Cache for artist images from Last.fm (artistName -> { url, timestamp })
  const artistImageCache = useRef({});

  // Cache for playlist cover art (playlistId -> { covers: [url1, url2, url3, url4], timestamp })
  const playlistCoverCache = useRef({});

  // API keys loaded from environment via IPC
  const lastfmApiKey = useRef(null);

  // Cache TTLs (in milliseconds)
  const CACHE_TTL = {
    albumArt: 90 * 24 * 60 * 60 * 1000,    // 90 days
    artistData: 30 * 24 * 60 * 60 * 1000,  // 30 days
    trackSources: 7 * 24 * 60 * 60 * 1000, // 7 days (track availability changes)
    artistImage: 90 * 24 * 60 * 60 * 1000, // 90 days
    playlistCover: 30 * 24 * 60 * 60 * 1000 // 30 days
  };

  // Get meta services with AI generation capability
  const getAiServices = () => {
    // AI services are meta-services loaded into the resolver loader
    if (!resolverLoaderRef.current) return [];
    return resolverLoaderRef.current.getAllResolvers().filter(r =>
      r.capabilities?.generate
    );
  };

  // Check if a scrobbler service (Last.fm or ListenBrainz) is connected
  const hasScrobblerConnected = () => {
    const lastfmConfig = metaServiceConfigs.lastfm;
    const listenbrainzConfig = metaServiceConfigs.listenbrainz;
    return !!(lastfmConfig?.username || listenbrainzConfig?.username);
  };

  // Get the name of the connected scrobbler service
  const getScrobblerName = () => {
    const lastfmConfig = metaServiceConfigs.lastfm;
    if (lastfmConfig?.username) return 'Last.fm';
    const listenbrainzConfig = metaServiceConfigs.listenbrainz;
    if (listenbrainzConfig?.username) return 'ListenBrainz';
    return null;
  };

  // Generate a hash of current resolver settings for cache invalidation
  const getResolverSettingsHash = () => {
    const sortedActive = [...activeResolvers].sort().join(',');
    const sortedOrder = [...resolverOrder].join(',');
    return `${sortedActive}|${sortedOrder}`;
  };

  const sampleTracks = [
    { id: 1, title: 'Midnight Dreams', artist: 'Luna Echo', album: 'Nocturnal', duration: 245, sources: ['youtube', 'soundcloud'] },
    { id: 2, title: 'Electric Pulse', artist: 'Neon Waves', album: 'Synthwave', duration: 198, sources: ['youtube'] },
    { id: 3, title: 'Ocean Breeze', artist: 'Coastal Drift', album: 'Tides', duration: 267, sources: ['soundcloud', 'youtube'] },
    { id: 4, title: 'Urban Nights', artist: 'City Lights', album: 'Metropolitan', duration: 223, sources: ['youtube'] },
    { id: 5, title: 'Forest Path', artist: 'Nature Sound', album: 'Wilderness', duration: 301, sources: ['youtube', 'soundcloud'] },
  ];

  // Initialize resolver plugin system and load config
  useEffect(() => {
    const initResolvers = async () => {
      console.log('ðŸ”Œ Initializing resolver plugin system...');

      // Load API keys from environment via IPC
      if (window.electron?.config?.get) {
        try {
          const lfmKey = await window.electron.config.get('LASTFM_API_KEY');
          if (lfmKey) {
            lastfmApiKey.current = lfmKey;
            console.log('ðŸ”‘ Last.fm API key loaded from environment');
          } else {
            console.warn('âš ï¸ LASTFM_API_KEY not found in .env file');
          }
        } catch (error) {
          console.error('âŒ Failed to load API keys from config:', error);
        }
      }

      // Check if ResolverLoader is available
      if (typeof ResolverLoader === 'undefined') {
        console.error('âŒ ResolverLoader not found! Make sure resolver-loader.js is loaded.');
        return;
      }
      
      // Create resolver loader
      resolverLoader.current = new ResolverLoader();
      
      try {
        // Try to load built-in resolvers from resolvers/builtin/ directory
        console.log('ðŸ“ Loading resolver .axe files from resolvers/builtin/...');
        const builtinAxeFiles = await loadBuiltinResolvers();
        
        let resolversToLoad = builtinAxeFiles;
        
        if (builtinAxeFiles.length === 0) {
          console.warn('âš ï¸  No .axe files found in resolvers/builtin/');
          console.log('ðŸ’¾ Using embedded fallback resolvers');
          resolversToLoad = FALLBACK_RESOLVERS;
        } else {
          console.log(`âœ… Loaded ${builtinAxeFiles.length} .axe files from disk`);
        }

        // Separate content resolvers from meta services by manifest type
        const contentResolverAxes = resolversToLoad.filter(axe =>
          !axe.manifest.type || axe.manifest.type === 'resolver'
        );
        const metaServiceAxes = resolversToLoad.filter(axe =>
          axe.manifest.type === 'meta-service'
        );
        // Meta services that have URL lookup capabilities need to be loaded for URL pattern matching
        const metaServicesWithUrlLookup = metaServiceAxes.filter(axe =>
          axe.capabilities?.urlLookup && axe.urlPatterns?.length > 0
        );
        // Meta services with generate capability need implementation functions loaded
        const metaServicesWithGenerate = metaServiceAxes.filter(axe =>
          axe.capabilities?.generate && axe.implementation?.generate
        );

        console.log(`ðŸ“¦ Found ${contentResolverAxes.length} content resolvers, ${metaServiceAxes.length} meta services (${metaServicesWithGenerate.length} with AI generate)`);

        // Load content resolvers through the resolver loader
        const resolvers = await resolverLoader.current.loadResolvers(contentResolverAxes);
        setLoadedResolvers(resolvers);
        resolverLoaderRef.current = resolverLoader.current;
        console.log(`âœ… Loaded ${resolvers.length} resolver plugins:`, resolvers.map(r => r.name).join(', '));

        // Also load meta services with URL lookup into the resolver loader (for URL pattern matching)
        if (metaServicesWithUrlLookup.length > 0) {
          await resolverLoader.current.loadResolvers(metaServicesWithUrlLookup);
          console.log(`ðŸ“Ž Loaded ${metaServicesWithUrlLookup.length} meta service(s) with URL lookup:`, metaServicesWithUrlLookup.map(s => s.manifest.name).join(', '));
        }

        // Load meta services with generate capability (AI playlist generation)
        if (metaServicesWithGenerate.length > 0) {
          const loadedAiServices = await resolverLoader.current.loadResolvers(metaServicesWithGenerate);
          console.log(`ðŸ¤– Loaded ${loadedAiServices.length} AI service(s):`, loadedAiServices.map(s => s.name).join(', '));
        }

        // Set meta services directly (they don't need the resolver pipeline for playback)
        if (metaServiceAxes.length > 0) {
          const metaServicesData = metaServiceAxes.map(axe => ({
            id: axe.manifest.id,
            name: axe.manifest.name,
            type: axe.manifest.type,
            version: axe.manifest.version,
            author: axe.manifest.author,
            description: axe.manifest.description,
            icon: axe.manifest.icon,
            color: axe.manifest.color,
            homepage: axe.manifest.homepage,
            capabilities: axe.capabilities,
            settings: axe.settings,
            _filename: axe._filename
          }));
          setMetaServices(metaServicesData);
          console.log(`âœ… Loaded ${metaServicesData.length} meta services:`, metaServicesData.map(s => s.name).join(', '));
        }
      } catch (error) {
        console.error('âŒ Failed to load resolvers:', error);
        console.log('ðŸ’¾ Attempting to use fallback resolvers...');
        
        try {
          const resolvers = await resolverLoader.current.loadResolvers(FALLBACK_RESOLVERS);
          setLoadedResolvers(resolvers);
          resolverLoaderRef.current = resolverLoader.current;
          console.log(`âœ… Loaded ${resolvers.length} fallback resolvers`);
        } catch (fallbackError) {
          console.error('âŒ Even fallback resolvers failed:', fallbackError);
        }
      }
    };
    
    initResolvers();
  }, []);

  // Initialize scrobblers (ListenBrainz, Last.fm, Libre.fm)
  useEffect(() => {
    const initScrobblers = async () => {
      if (typeof window.initializeScrobblers === 'function') {
        try {
          // Load Last.fm API credentials from main process environment
          let config = {};
          if (window.electron?.getScrobblerConfig) {
            config = await window.electron.getScrobblerConfig();
            if (config.lastfmApiKey) {
              console.log('[App] Last.fm API credentials loaded from environment');
            }
          }
          await window.initializeScrobblers(config);
          console.log('[App] Scrobblers initialized');
          setScrobblersInitialized(true);
        } catch (error) {
          console.error('[App] Failed to initialize scrobblers:', error);
        }
      } else {
        console.log('[App] Scrobbler loader not available');
      }
    };
    initScrobblers();
  }, []);

  // Load scrobbler configurations (runs after scrobblers are initialized)
  useEffect(() => {
    const loadScrobblerConfigs = async () => {
      if (!scrobblersInitialized || !window.scrobblers) return;

      const configs = {};
      for (const scrobbler of window.scrobblers) {
        configs[scrobbler.id] = await scrobbler.getConfig();
      }
      setScrobblerConfigs(configs);

      // Load global scrobbling enabled state
      if (window.electron?.store) {
        const enabled = await window.electron.store.get('scrobbling-enabled');
        setScrobblingEnabled(enabled !== false);
      }
    };
    loadScrobblerConfigs();
  }, [scrobblersInitialized]);

  // Sync meta service configs with scrobblers when both are available
  // This ensures Last.fm API credentials and ListenBrainz tokens are applied to scrobblers
  useEffect(() => {
    const syncScrobblersWithMetaServices = async () => {
      if (!scrobblersInitialized || !window.scrobblers || Object.keys(metaServiceConfigs).length === 0) return;

      // Sync Last.fm API credentials
      const lastfmConfig = metaServiceConfigs.lastfm;
      if (lastfmConfig?.apiKey && lastfmConfig?.apiSecret && window.lastfmScrobbler) {
        window.lastfmScrobbler.setApiCredentials(lastfmConfig.apiKey, lastfmConfig.apiSecret);
        console.log('[App] Synced Last.fm API credentials with scrobbler');
      }

      // Sync ListenBrainz token if scrobbler isn't already enabled
      const listenbrainzConfig = metaServiceConfigs.listenbrainz;
      if (listenbrainzConfig?.userToken && window.listenbrainzScrobbler) {
        const scrobblerConfig = await window.listenbrainzScrobbler.getConfig();
        if (!scrobblerConfig?.enabled) {
          try {
            await window.listenbrainzScrobbler.connect(listenbrainzConfig.userToken);
            const newConfig = await window.listenbrainzScrobbler.getConfig();
            setScrobblerConfigs(prev => ({ ...prev, listenbrainz: newConfig }));
            console.log('[App] Auto-connected ListenBrainz scrobbler from meta service token');
          } catch (err) {
            console.warn('[App] Failed to auto-connect ListenBrainz scrobbler:', err.message);
          }
        }
      }
    };
    syncScrobblersWithMetaServices();
  }, [scrobblersInitialized, metaServiceConfigs]);

  // Keep ref updated with latest resolver list
  useEffect(() => {
    loadedResolversRef.current = loadedResolvers;
  }, [loadedResolvers]);

  // Auto-add newly loaded resolvers to activeResolvers and resolverOrder
  // This runs when both resolvers are loaded AND settings are loaded from storage
  useEffect(() => {
    if (loadedResolvers.length === 0) return;
    if (!cacheLoaded) return; // Wait for settings to load first

    // Find resolvers that are loaded but not in resolverOrder
    const newResolverIds = loadedResolvers
      .map(r => r.id)
      .filter(id => !resolverOrder.includes(id));

    if (newResolverIds.length > 0) {
      console.log(`ðŸ“‹ Adding new resolvers to order/active: ${newResolverIds.join(', ')}`);
      setResolverOrder(prev => [...prev, ...newResolverIds]);
      setActiveResolvers(prev => [...prev, ...newResolverIds]);
    }
  }, [loadedResolvers, cacheLoaded, resolverOrder]);

  // Handle "Send to Parachord" from browser extension
  const handleSendToParachord = async (url) => {
    console.log('ðŸŒ Processing URL from browser:', url);

    // Get friendly domain name for display
    const domain = getUrlDomain(url);
    const serviceName = domain.includes('spotify') ? 'Spotify' :
                       domain.includes('apple') ? 'Apple Music' :
                       domain.includes('youtube') ? 'YouTube' :
                       domain.includes('bandcamp') ? 'Bandcamp' : domain;

    // Show toast notification
    showToast(`Adding ${serviceName} to queue...`, 'info');

    // Always add to queue - handleUrlDrop will insert at position 1 (next up)
    // If queue is empty, it will play immediately
    await handleUrlDrop(url, 'queue');
  };

  // Browser extension event handlers
  useEffect(() => {
    console.log('ðŸ”Œ Setting up browser extension event handlers...');

    // Connection state handlers
    window.electron.extension.onConnected(() => {
      console.log('âœ… Browser extension connected');
      setExtensionConnected(true);
    });

    window.electron.extension.onDisconnected(() => {
      console.log('âŒ Browser extension disconnected');
      setExtensionConnected(false);
      setBrowserPlaybackActive(false);
      setActiveExtensionTabId(null);
    });

    // Message handler for extension events
    window.electron.extension.onMessage((message) => {
      console.log('ðŸ“¨ Extension message received:', message.type, message.event || message.url || '');
      if (message.type === 'event') {
        switch (message.event) {
          case 'connected':
            // Ignore when local file is playing
            if (audioRef.current && !audioRef.current.paused) {
              console.log('ðŸŽ¬ Browser connected (ignored - local file playing)');
              break;
            }
            // Browser tab with media content connected
            console.log(`ðŸŽ¬ Browser playback connected: ${message.site}`);
            setActiveExtensionTabId(message.tabId);
            setBrowserPlaybackActive(true);
            setIsExternalPlayback(true);

            // Clear the waiting flag - browser is now connected and handling playback
            if (waitingForBrowserPlaybackRef.current) {
              console.log('âœ… Browser playback connected, clearing wait flag');
              waitingForBrowserPlaybackRef.current = false;
              // Also ensure streaming flag is false so browser events aren't ignored
              streamingPlaybackActiveRef.current = false;
            }

            // Stop Spotify polling - browser is now handling playback
            if (playbackPollerRef.current) {
              console.log('â¹ï¸ Stopping Spotify polling - browser playback connected');
              clearInterval(playbackPollerRef.current);
              playbackPollerRef.current = null;
            }
            if (pollingRecoveryRef.current) {
              clearInterval(pollingRecoveryRef.current);
              pollingRecoveryRef.current = null;
            }

            // Close previous tab if one was pending
            if (pendingCloseTabIdRef.current && pendingCloseTabIdRef.current !== message.tabId) {
              window.electron.extension.sendCommand({
                type: 'command',
                action: 'closeTab',
                tabId: pendingCloseTabIdRef.current
              });
              pendingCloseTabIdRef.current = null;
            }
            break;

          case 'playing':
            // Ignore browser events when streaming playback (Spotify) is active
            if (streamingPlaybackActiveRef.current) {
              console.log('â–¶ï¸ Browser playback playing (ignored - streaming active)');
              break;
            }
            // Ignore when local file is playing
            if (audioRef.current && !audioRef.current.paused) {
              console.log('â–¶ï¸ Browser playback playing (ignored - local file playing)');
              break;
            }
            console.log('â–¶ï¸ Browser playback playing');
            setIsPlaying(true);
            // Also ensure browser playback state is set (handles race condition where playing arrives before connected)
            setBrowserPlaybackActive(true);
            setIsExternalPlayback(true);
            break;

          case 'paused':
            // Ignore browser events when streaming playback (Spotify) is active
            if (streamingPlaybackActiveRef.current) {
              console.log('â¸ï¸ Browser playback paused (ignored - streaming active)');
              break;
            }
            // Ignore when local file is playing
            if (audioRef.current && !audioRef.current.paused) {
              console.log('â¸ï¸ Browser playback paused (ignored - local file playing)');
              break;
            }
            console.log('â¸ï¸ Browser playback paused');
            setIsPlaying(false);
            break;

          case 'ended':
            // Ignore browser events when streaming playback (Spotify) is active
            if (streamingPlaybackActiveRef.current) {
              console.log('â¹ï¸ Browser playback ended (ignored - streaming active)');
              break;
            }
            // Ignore when local file is playing
            if (audioRef.current && !audioRef.current.paused) {
              console.log('â¹ï¸ Browser playback ended (ignored - local file playing)');
              break;
            }
            console.log('â¹ï¸ Browser playback ended');
            // Store tab ID to close when next track connects
            pendingCloseTabIdRef.current = message.tabId;
            setBrowserPlaybackActive(false);
            // Auto-advance to next track (use ref to avoid stale closure)
            if (handleNextRef.current) handleNextRef.current();
            break;

          case 'tabClosed':
            // Ignore browser events when streaming playback (Spotify) is active
            if (streamingPlaybackActiveRef.current) {
              console.log('ðŸšª Browser tab closed (ignored - streaming active)');
              setBrowserPlaybackActive(false);
              setActiveExtensionTabId(null);
              break;
            }
            // Ignore when local file is playing
            if (audioRef.current && !audioRef.current.paused) {
              console.log('ðŸšª Browser tab closed (ignored - local file playing)');
              break;
            }
            setBrowserPlaybackActive(false);
            setActiveExtensionTabId(null);
            // Check if this was a programmatic close (switching tracks)
            if (pendingCloseTabIdRef.current && message.tabId === pendingCloseTabIdRef.current) {
              console.log('ðŸ”„ Browser tab closed programmatically (switching tracks)');
              pendingCloseTabIdRef.current = null;
              // Don't call handleNext() - we're already loading the selected track
            } else {
              console.log('ðŸšª Browser tab closed by user');
              // Treat as skip to next (use ref to avoid stale closure)
              if (handleNextRef.current) handleNextRef.current();
            }
            break;

          case 'heartbeat':
            // Keep-alive from extension - only update tab ID, don't set playback state
            // The 'connected' and 'playing' events are responsible for setting browserPlaybackActive
            // Heartbeats just maintain the tab reference when browser playback is already active
            if (message.tabId && browserPlaybackActive) {
              setActiveExtensionTabId(message.tabId);
            }
            break;
        }
      } else if (message.type === 'sendToParachord') {
        // Handle URL sent from browser extension context menu
        console.log('ðŸŒ Received URL from browser extension:', message.url);
        handleSendToParachord(message.url);
      }
    });

    // Check initial connection status
    window.electron.extension.getStatus().then(status => {
      setExtensionConnected(status.connected);
    });

    // Playback window event handlers (for Bandcamp embedded player, etc.)
    if (window.electron?.playbackWindow?.onEvent) {
      window.electron.playbackWindow.onEvent((eventType) => {
        // Ignore playback window events when local file is playing
        if (audioRef.current && !audioRef.current.paused) {
          console.log(`ðŸŽµ Playback window event: ${eventType} (ignored - local file playing)`);
          return;
        }
        console.log(`ðŸŽµ Playback window event: ${eventType}`);
        switch (eventType) {
          case 'playing':
            setIsPlaying(true);
            setBrowserPlaybackActive(true);
            setIsExternalPlayback(true);
            break;
          case 'paused':
            setIsPlaying(false);
            break;
          case 'ended':
            console.log('ðŸŽµ Playback window track ended, advancing to next');
            setBrowserPlaybackActive(false);
            // Use ref to avoid stale closure in useEffect
            if (handleNextRef.current) handleNextRef.current();
            break;
        }
      });
    }

    if (window.electron?.playbackWindow?.onClosed) {
      window.electron.playbackWindow.onClosed(() => {
        // Ignore when local file is playing
        if (audioRef.current && !audioRef.current.paused) {
          console.log('ðŸŽµ Playback window closed (ignored - local file playing)');
          return;
        }
        console.log('ðŸŽµ Playback window closed');
        setBrowserPlaybackActive(false);
        // Don't auto-advance, just stop playback
        setIsPlaying(false);
      });
    }
  }, []);

  // Listen for context menu actions (only set up once)
  useEffect(() => {
    if (window.electron?.resolvers?.onContextMenuAction) {
      window.electron.resolvers.onContextMenuAction(async (data) => {
        console.log('Context menu action received:', data);
        if (data.action === 'uninstall') {
          await handleUninstallResolver(data.resolverId);
        }
      });
    }
  }, []);

  // Use loaded resolvers or fallback to empty array
  const allResolvers = loadedResolvers.length > 0 ? loadedResolvers : [];

  // Sync loaded resolvers with resolverOrder - add any new resolvers not yet in the order
  // This runs after both resolvers are loaded AND cache/settings are loaded from storage
  useEffect(() => {
    if (loadedResolvers.length === 0) return;
    if (!cacheLoaded) return; // Wait until storage settings are loaded

    const loadedIds = loadedResolvers.map(r => r.id);
    const missingIds = loadedIds.filter(id => !resolverOrder.includes(id));

    if (missingIds.length > 0) {
      console.log('ðŸ“¦ Adding new resolvers to order:', missingIds);
      // Use functional update to ensure we don't add duplicates
      setResolverOrder(prev => {
        const newIds = missingIds.filter(id => !prev.includes(id));
        return newIds.length > 0 ? [...prev, ...newIds] : prev;
      });
      // Also enable new resolvers by default
      setActiveResolvers(prev => {
        const newIds = missingIds.filter(id => !prev.includes(id));
        return newIds.length > 0 ? [...prev, ...newIds] : prev;
      });
    }
  }, [loadedResolvers, cacheLoaded]);

  // Get resolvers in priority order
  const resolvers = resolverOrder
    .map(id => allResolvers.find(r => r.id === id))
    .filter(Boolean);

  // Helper function to get resolver config (async for Spotify to ensure fresh token)
  const getResolverConfig = async (resolverId) => {
    // For Spotify, always get a fresh token from the IPC handler
    // This ensures we use a valid token even if the React state is stale
    if (resolverId === 'spotify') {
      let token = spotifyToken;

      // Always check with the IPC handler which will refresh if needed
      if (window.electron?.spotify) {
        const tokenData = await window.electron.spotify.checkToken();
        if (tokenData && tokenData.token) {
          token = tokenData.token;
          // Update React state if token changed
          if (token !== spotifyToken) {
            console.log('ðŸ”„ Token was refreshed, updating state');
            setSpotifyToken(token);
          }
        } else {
          token = null;
        }
      }

      console.log('ðŸ”‘ Spotify token status:', {
        hasToken: !!token,
        tokenLength: token?.length,
        tokenPreview: token ? token.substring(0, 20) + '...' : 'null'
      });

      return { token };
    }

    const configs = {
      qobuz: { appId: '285473059', volume: volume / 100 },
      bandcamp: {}
    };
    return configs[resolverId] || {};
  };

  const SPOTIFY_CLIENT_ID = 'c040c0ee133344b282e6342198bcbeea';

  useEffect(() => {
    // Load local files into library instead of placeholder tracks
    const loadLocalFilesLibrary = async () => {
      setLibraryLoading(true);
      try {
        if (window.electron?.localFiles?.search) {
          const localTracks = await window.electron.localFiles.search('');
          if (localTracks && localTracks.length > 0) {
            console.log(`ðŸ“š Loaded ${localTracks.length} local tracks into library`);
            setLibrary(localTracks);
            // Mark all tracks as resolving immediately so LO + skeletons show together
            const trackKeys = localTracks
              .filter(t => {
                const sources = t.sources || {};
                return !Object.keys(sources).some(id => id !== 'localfiles');
              })
              .map(t => t.filePath || t.id);
            if (trackKeys.length > 0) {
              setResolvingLibraryTracks(new Set(trackKeys));
            }
          } else {
            console.log('ðŸ“š No local files found - library is empty');
            setLibrary([]);
          }
        } else {
          console.log('ðŸ“š Local Files API not available');
          setLibrary([]);
        }
      } catch (error) {
        console.error('Failed to load local files library:', error);
        setLibrary([]);
      } finally {
        setLibraryLoading(false);
      }
    };

    loadLocalFilesLibrary();

    const context = new (window.AudioContext || window.webkitAudioContext)();
    setAudioContext(context);
    
    // Load playlists from electron-store
    const loadPlaylistsFromStore = async () => {
      try {
        const loadedPlaylists = await window.electron.playlists.load();
        console.log(`ðŸ“‹ Loaded ${loadedPlaylists.length} playlist(s) from local storage`);

        if (loadedPlaylists.length > 0) {
          // Playlists are already stored as full objects, just use them directly
          setPlaylists(loadedPlaylists);
        } else {
          console.log('ðŸ“‹ No playlists found in local storage');
        }

        // Check if there are hosted playlists to load
        const hostedPlaylistUrls = await window.electron?.store?.get('hosted_playlists') || [];
        if (hostedPlaylistUrls.length === 0) {
          setPlaylistsLoading(false);
        }
      } catch (error) {
        console.error('Failed to load playlists:', error);
        setPlaylistsLoading(false);
      }
    };

    loadPlaylistsFromStore();

    // Load search history
    loadSearchHistory();

    // Listen for local files library changes
    let libraryChangeCleanup = null;
    if (window.electron?.localFiles?.onLibraryChanged) {
      libraryChangeCleanup = window.electron.localFiles.onLibraryChanged((changes) => {
        console.log('ðŸ“š Library changed, reloading...', changes);
        loadLocalFilesLibrary();
      });
    }

    return () => {
      context.close();
      if (libraryChangeCleanup) libraryChangeCleanup();
    };
  }, []);

  // Load collection data on startup
  useEffect(() => {
    const loadCollection = async () => {
      if (window.electron?.collection?.load) {
        try {
          const data = await window.electron.collection.load();

          // Clean up corrupted sources data (e.g., numeric keys like "0" instead of resolver IDs)
          const validResolverIds = ['spotify', 'youtube', 'bandcamp', 'qobuz', 'soundcloud', 'localfiles'];
          let cleanedCount = 0;
          const cleanedTracks = data.tracks?.map(track => {
            if (track.sources && typeof track.sources === 'object') {
              const cleanedSources = {};
              for (const [key, value] of Object.entries(track.sources)) {
                if (validResolverIds.includes(key)) {
                  cleanedSources[key] = value;
                } else {
                  cleanedCount++;
                }
              }
              return { ...track, sources: cleanedSources };
            }
            return track;
          }) || [];

          if (cleanedCount > 0) {
            console.log(`ðŸ§¹ Cleaned ${cleanedCount} corrupted source entries from collection`);
            const cleanedData = { ...data, tracks: cleanedTracks };
            setCollectionData(cleanedData);
            // Save the cleaned data
            if (window.electron?.collection?.save) {
              await window.electron.collection.save(cleanedData);
            }
          } else {
            setCollectionData(data);
          }
        } catch (error) {
          console.error('Failed to load collection:', error);
        }
      }
      setCollectionLoading(false);
    };
    loadCollection();
  }, []);

  useEffect(() => {
    // Skip progress tracking for streaming tracks (Spotify) - they have their own polling
    // Skip for local files - they use HTML5 Audio with timeupdate event
    // Also skip if duration is 0 or missing to prevent infinite handleNext loop
    const isStreamingTrack = currentTrack?.sources?.spotify || currentTrack?.spotifyUri;
    const isLocalFile = currentTrack?.filePath || currentTrack?.sources?.localfiles;
    const hasValidDuration = currentTrack?.duration && currentTrack.duration > 0;

    if (isPlaying && audioContext && currentTrack && !isStreamingTrack && !isLocalFile && hasValidDuration) {
      const interval = setInterval(() => {
        const elapsed = (audioContext.currentTime - startTime);
        if (elapsed >= currentTrack.duration) {
          // Use ref to avoid stale closure in interval callback
          if (handleNextRef.current) handleNextRef.current();
        } else {
          setProgress(elapsed);
          // Notify scrobble manager of progress for scrobble threshold checking
          if (window.scrobbleManager) {
            window.scrobbleManager.onProgressUpdate(elapsed);
          }
        }
      }, 100);
      return () => clearInterval(interval);
    }
  }, [isPlaying, audioContext, currentTrack, startTime]);

  // Smooth progress interpolation for Spotify tracks
  // API polling happens every 5 seconds, but we want smooth 1-second visual updates
  // The baseline is ONLY set by API polls (in getCurrentPlaybackState), not by this effect
  const spotifyProgressBaselineRef = useRef({ progress: 0, timestamp: 0, isPlaying: false });

  useEffect(() => {
    const isStreamingTrack = currentTrack?.sources?.spotify || currentTrack?.spotifyUri;
    const hasValidDuration = currentTrack?.duration && currentTrack.duration > 0;

    if (isPlaying && isStreamingTrack && hasValidDuration && !browserPlaybackActive) {
      const interval = setInterval(() => {
        const baseline = spotifyProgressBaselineRef.current;

        // Only interpolate if:
        // 1. We have a valid baseline (timestamp > 0 means API has set it)
        // 2. Spotify reports that playback is actually happening (isPlaying from API)
        if (baseline.timestamp > 0 && baseline.isPlaying) {
          const elapsed = (Date.now() - baseline.timestamp) / 1000;
          const interpolatedProgress = baseline.progress + elapsed;

          // Don't exceed track duration and don't go backwards
          if (interpolatedProgress < currentTrack.duration && interpolatedProgress >= 0) {
            setProgress(interpolatedProgress);
            // Notify scrobble manager of progress for scrobble threshold checking
            if (window.scrobbleManager) {
              window.scrobbleManager.onProgressUpdate(interpolatedProgress);
            }
          }
        }
      }, 1000); // Update every second for smooth progress bar

      return () => clearInterval(interval);
    }
  }, [isPlaying, currentTrack, browserPlaybackActive]);

  // Auto-dismiss toast after 3 seconds
  useEffect(() => {
    if (toast) {
      const timer = setTimeout(() => setToast(null), 3000);
      return () => clearTimeout(timer);
    }
  }, [toast]);

  const showToast = useCallback((message, type = 'success') => {
    setToast({ message, type });
  }, []);

  // Save collection to disk
  const saveCollection = useCallback(async (newData) => {
    if (window.electron?.collection?.save) {
      try {
        const result = await window.electron.collection.save(newData);
        if (!result?.success) {
          console.error('Collection save failed:', result?.error);
        }
      } catch (error) {
        console.error('Collection save error:', error);
      }
    }
  }, []);

  // Add track to collection
  const addTrackToCollection = useCallback((track) => {
    const trackId = `${track.artist || 'unknown'}-${track.title || 'untitled'}-${track.album || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');

    setCollectionData(prev => {
      // Check for duplicate
      if (prev.tracks.some(t => t.id === trackId)) {
        showToast(`${track.title} is already in your collection`);
        return prev;
      }

      const newTrack = {
        id: trackId,
        title: track.title,
        artist: track.artist,
        album: track.album,
        duration: track.duration,
        albumArt: track.albumArt,
        sources: track.sources || {},
        addedAt: Date.now()
      };

      const newData = { ...prev, tracks: [...prev.tracks, newTrack] };
      // Save async (don't block state update)
      saveCollection(newData);
      showToast(`Added ${track.title} to Collection`);
      showSidebarBadge('collection');
      return newData;
    });
  }, [saveCollection, showToast, showSidebarBadge]);

  // Add album to collection
  const addAlbumToCollection = useCallback((album) => {
    const albumId = `${album.artist || 'unknown'}-${album.title || 'untitled'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');

    setCollectionData(prev => {
      // Check for duplicate
      if (prev.albums.some(a => a.id === albumId)) {
        showToast(`${album.title} is already in your collection`);
        return prev;
      }

      const newAlbum = {
        id: albumId,
        title: album.title,
        artist: album.artist,
        year: album.year || null,
        art: album.art || album.albumArt || null,
        addedAt: Date.now()
      };

      const newData = { ...prev, albums: [...prev.albums, newAlbum] };
      // Save async (don't block state update)
      saveCollection(newData);
      showToast(`Added ${album.title} to Collection`);
      showSidebarBadge('collection');
      return newData;
    });
  }, [saveCollection, showToast, showSidebarBadge]);

  // Add artist to collection
  const addArtistToCollection = useCallback((artist) => {
    const artistId = (artist.name || 'unknown').toLowerCase().replace(/[^a-z0-9-]/g, '');

    setCollectionData(prev => {
      // Check for duplicate
      if (prev.artists.some(a => a.id === artistId)) {
        showToast(`${artist.name} is already in your collection`);
        return prev;
      }

      const newArtist = {
        id: artistId,
        name: artist.name,
        image: artist.image || null,
        addedAt: Date.now()
      };

      const newData = { ...prev, artists: [...prev.artists, newArtist] };
      // Save async (don't block state update)
      saveCollection(newData);
      showToast(`Added ${artist.name} to Collection`);
      showSidebarBadge('collection');
      return newData;
    });
  }, [saveCollection, showToast, showSidebarBadge]);

  // Listen for track/playlist context menu actions
  useEffect(() => {
    if (window.electron?.contextMenu?.onAction) {
      window.electron.contextMenu.onAction(async (data) => {
        console.log('Track context menu action received:', data);
        if (data.action === 'add-to-queue' && data.tracks) {
          // Build context from source info if available
          let context = null;
          if (data.sourceType === 'playlist' && data.sourceId) {
            context = { type: 'playlist', id: data.sourceId, name: data.sourceName };
          } else if ((data.sourceType === 'album' || data.sourceType === 'release') && data.sourceName) {
            context = { type: 'album', id: data.sourceId, name: data.sourceName, artist: data.artistName };
          }
          addToQueue(data.tracks, context);
        } else if (data.action === 'add-to-queue' && data.track) {
          // Single track from friend's now playing - no context for single tracks
          addToQueue([data.track]);
        } else if (data.action === 'add-to-playlist' && data.track) {
          // Single track from friend's now playing
          setAddToPlaylistPanel({
            open: true,
            tracks: [data.track],
            sourceName: `${data.track.artist} - ${data.track.title}`,
            sourceType: 'track'
          });
          setSelectedPlaylistsForAdd([]);
        } else if (data.action === 'add-track-to-collection' && data.track) {
          // Add single track to collection
          addTrackToCollection(data.track);
        } else if (data.action === 'go-to-artist' && data.artistName) {
          // Navigate to artist page
          fetchArtistData(data.artistName);
        } else if (data.action === 'add-to-playlist' && data.tracks) {
          // Open the Add to Playlist panel
          console.log(`ðŸ“‹ Add to Playlist: ${data.tracks.length} track(s) - "${data.sourceName}" (type: ${data.sourceType})`);
          if (data.tracks.length > 0) {
            console.log(`   First track: ${data.tracks[0]?.artist} - ${data.tracks[0]?.title}`);
          }
          setAddToPlaylistPanel({
            open: true,
            tracks: data.tracks,
            sourceName: data.sourceName || 'Selected tracks',
            sourceType: data.sourceType || 'track'
          });
          setSelectedPlaylistsForAdd([]); // Reset selection
        } else if (data.action === 'remove-from-playlist' && data.playlistId !== undefined) {
          // Remove track from playlist
          const trackIndex = data.trackIndex;
          console.log(`ðŸ—‘ï¸ Removing track at index ${trackIndex} from playlist ${data.playlistId}`);

          // Update playlistTracks state (the displayed tracks)
          setPlaylistTracks(prev => {
            const newTracks = [...prev];
            newTracks.splice(trackIndex, 1);
            return newTracks;
          });

          // Update the playlist in playlists state and save to disk
          setPlaylists(prev => {
            const updatedPlaylists = prev.map(p => {
              if (p.id === data.playlistId) {
                const newTracks = [...(p.tracks || [])];
                newTracks.splice(trackIndex, 1);
                const updatedPlaylist = {
                  ...p,
                  tracks: newTracks,
                  lastModified: Date.now()
                };
                // Save to disk (async, non-blocking)
                savePlaylistToStore(updatedPlaylist);
                return updatedPlaylist;
              }
              return p;
            });
            return updatedPlaylists;
          });

          // Update selectedPlaylist if viewing this playlist
          if (selectedPlaylist?.id === data.playlistId) {
            setSelectedPlaylist(prev => ({
              ...prev,
              lastModified: Date.now()
            }));
          }
        } else if (data.action === 'delete-playlist' && data.playlistId) {
          // Show confirmation alert
          const confirmed = window.confirm(`Are you sure you want to delete "${data.name}"?`);
          if (confirmed) {
            const result = await window.electron.playlists.delete(data.playlistId);
            if (result.success) {
              // Remove from state
              setPlaylists(prev => prev.filter(p => p.id !== data.playlistId));
              // Clear cover cache for deleted playlist
              delete playlistCoverCache.current[data.playlistId];
              setAllPlaylistCovers(prev => {
                const updated = { ...prev };
                delete updated[data.playlistId];
                return updated;
              });
            } else {
              alert(`Failed to delete playlist: ${result.error}`);
            }
          }
        } else if (data.action === 'edit-id3-tags' && data.track) {
          // Open ID3 tag editor modal
          console.log('ðŸ·ï¸ Opening ID3 tag editor for:', data.track.title);
          setId3EditorTrack(data.track);
          // Filter out "Unknown Album" placeholder - treat as empty
          const albumValue = data.track.album === 'Unknown Album' ? '' : (data.track.album || '');
          const newValues = {
            title: data.track.title || '',
            artist: data.track.artist || '',
            album: albumValue,
            trackNumber: data.track.trackNumber ? String(data.track.trackNumber) : '',
            year: data.track.year ? String(data.track.year) : ''
          };
          setId3EditorValues(newValues);
          setId3ArtSuggestions([]);
          setId3SelectedArt(null);
          setId3EditorOpen(true);

          // Auto-fetch album art if we have artist and album
          if (newValues.artist && newValues.album) {
            fetchAlbumArtSuggestions(newValues.artist, newValues.album);
          }
        } else if (data.action === 'add-to-collection') {
          // Add to collection based on type
          if (data.type === 'track' && data.track) {
            addTrackToCollection(data.track);
          } else if (data.type === 'album' && data.album) {
            addAlbumToCollection(data.album);
          } else if (data.type === 'artist' && data.artist) {
            addArtistToCollection(data.artist);
          }
        } else if (data.action === 'view-friend-history' && data.friend) {
          if (navigateToFriendRef.current) navigateToFriendRef.current(data.friend);
        } else if (data.action === 'pin-friend' && data.friendId) {
          if (pinFriendRef.current) pinFriendRef.current(data.friendId);
        } else if (data.action === 'unpin-friend' && data.friendId) {
          if (unpinFriendRef.current) unpinFriendRef.current(data.friendId);
        } else if (data.action === 'remove-friend' && data.friendId) {
          if (removeFriendRef.current) removeFriendRef.current(data.friendId);
        } else if (data.action === 'save-friend-to-collection' && data.friendId) {
          if (saveFriendToCollectionRef.current) saveFriendToCollectionRef.current(data.friendId);
        } else if (data.action === 'remove-friend-from-collection' && data.friendId) {
          if (removeFriendFromCollectionRef.current) removeFriendFromCollectionRef.current(data.friendId);
        }
      });
    }
  }, [addTrackToCollection, addAlbumToCollection, addArtistToCollection]);

  // Add multiple tracks to collection
  const addTracksToCollection = useCallback((tracks) => {
    let addedCount = 0;

    setCollectionData(prev => {
      const newTracks = [...prev.tracks];

      tracks.forEach(track => {
        const trackId = `${track.artist || 'unknown'}-${track.title || 'untitled'}-${track.album || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');

        if (!newTracks.some(t => t.id === trackId)) {
          newTracks.push({
            id: trackId,
            title: track.title,
            artist: track.artist,
            album: track.album,
            duration: track.duration,
            albumArt: track.albumArt,
            sources: track.sources || {},
            addedAt: Date.now()
          });
          addedCount++;
        }
      });

      if (addedCount === 0) {
        showToast('Tracks are already in your collection');
        return prev;
      }

      const newData = { ...prev, tracks: newTracks };
      // Save async (don't block state update)
      saveCollection(newData);
      showToast(`Added ${addedCount} track${addedCount !== 1 ? 's' : ''} to Collection`);
      return newData;
    });
  }, [saveCollection, showToast]);

  // Handle drop on collection sidebar
  const handleCollectionDrop = useCallback((e) => {
    e.preventDefault();
    setCollectionDropHighlight(false);

    try {
      const data = e.dataTransfer.getData('text/plain');
      if (!data) return;

      const parsed = JSON.parse(data);

      if (parsed.type === 'track') {
        addTrackToCollection(parsed.track);
      } else if (parsed.type === 'album') {
        addAlbumToCollection(parsed.album);
      } else if (parsed.type === 'artist') {
        addArtistToCollection(parsed.artist);
      } else if (parsed.type === 'tracks') {
        addTracksToCollection(parsed.tracks);
      }
    } catch (error) {
      console.error('Failed to parse drop data:', error);
    }
  }, [addTrackToCollection, addAlbumToCollection, addArtistToCollection, addTracksToCollection]);

  // Re-resolve tracks when resolver settings change (enabled/priority)
  useEffect(() => {
    // Skip on initial mount (when both are empty)
    if (activeResolvers.length === 0 && resolverOrder.length === 0) return;

    // Re-resolve release tracks if viewing an artist release
    if (currentRelease && currentRelease.tracks) {
      console.log('ðŸ”„ Resolver settings changed, re-resolving release tracks...');
      const artistName = currentArtist?.name || 'Unknown Artist';
      currentRelease.tracks.forEach(track => {
        // Force refresh to bypass cache
        resolveTrack(track, artistName, true);
      });
    }

    // Re-resolve playlist tracks if viewing a playlist
    if (selectedPlaylist && playlistTracks.length > 0) {
      console.log('ðŸ”„ Resolver settings changed, re-resolving playlist tracks...');

      // Re-resolve each playlist track with new resolver settings
      const reResolvePlaylistTracks = async () => {
        const updatedTracks = [];

        for (const track of playlistTracks) {
          const trackWithSources = { ...track, sources: {} };

          // Query enabled resolvers in priority order
          for (const resolverId of activeResolvers) {
            const resolver = allResolvers.find(r => r.id === resolverId);
            if (!resolver || !resolver.capabilities.resolve) continue;

            try {
              const config = await getResolverConfig(resolverId);
              const resolved = await resolver.resolve(track.artist, track.title, track.album, config);

              if (resolved) {
                trackWithSources.sources[resolverId] = resolved;
              }
            } catch (error) {
              console.error(`Error resolving with ${resolver.name}:`, error);
            }
          }

          updatedTracks.push(trackWithSources);
        }

        setPlaylistTracks(updatedTracks);
        console.log('âœ… Playlist tracks re-resolved');
      };

      reResolvePlaylistTracks();
    }
  }, [activeResolvers, resolverOrder]);

  // Save resolver settings when they change
  useEffect(() => {
    // Skip until we've loaded settings from storage to avoid overwriting saved settings
    if (!resolverSettingsLoaded.current) return;

    // Skip until resolvers are loaded and synced - this prevents saving before
    // new resolvers (like localfiles) are added to the settings
    if (loadedResolvers.length === 0) return;
    const loadedIds = loadedResolvers.map(r => r.id);
    const allResolversInOrder = loadedIds.every(id => resolverOrder.includes(id));
    if (!allResolversInOrder) {
      console.log('â³ Waiting for resolver sync before saving...');
      return;
    }

    // Debounce the save to avoid saving too frequently
    const timeoutId = setTimeout(() => {
      saveCacheToStore();
    }, 500);

    return () => clearTimeout(timeoutId);
  }, [activeResolvers, resolverOrder, loadedResolvers]);

  // Keep refs updated for unmount save
  useEffect(() => {
    activeResolversRef.current = activeResolvers;
    resolverOrderRef.current = resolverOrder;
  }, [activeResolvers, resolverOrder]);


  // Save queue when it changes (if remember queue is enabled)
  // Include currentTrack so it can be restored as the playing track
  useEffect(() => {
    // Skip until settings are loaded to avoid overwriting saved queue
    if (!resolverSettingsLoaded.current) return;
    if (!rememberQueue) return;

    // Debounce the save to avoid saving too frequently
    const timeoutId = setTimeout(async () => {
      if (window.electron?.store) {
        // Save currentTrack + queue together so we restore the correct playing track
        const fullQueue = currentTrack ? [currentTrack, ...currentQueue] : currentQueue;
        await window.electron.store.set('saved_queue', fullQueue);
        // Also save playback context
        await window.electron.store.set('saved_playback_context', playbackContext);
        console.log(`ðŸ’¾ Saved queue: ${currentTrack ? `"${currentTrack.title}" playing + ` : ''}${currentQueue.length} tracks in queue${playbackContext ? ` (from ${playbackContext.type})` : ''}`);
      }
    }, 500);

    return () => clearTimeout(timeoutId);
  }, [currentTrack, currentQueue, rememberQueue, playbackContext]);

  // Persist friends to storage (only after cache is loaded to avoid overwriting)
  useEffect(() => {
    if (cacheLoaded && window.electron?.store) {
      window.electron.store.set('friends', friends);
    }
  }, [friends, cacheLoaded]);

  // Persist pinned friend IDs to storage (only after cache is loaded to avoid overwriting)
  useEffect(() => {
    if (cacheLoaded && window.electron?.store) {
      window.electron.store.set('pinnedFriendIds', pinnedFriendIds);
    }
  }, [pinnedFriendIds, cacheLoaded]);

  // Persist AI include history preference (only after cache is loaded to avoid overwriting)
  useEffect(() => {
    if (cacheLoaded && window.electron?.store) {
      window.electron.store.set('ai_include_history', aiIncludeHistory);
    }
  }, [aiIncludeHistory, cacheLoaded]);

  // Keep prefetchedReleasesRef in sync for context menu handlers
  useEffect(() => {
    prefetchedReleasesRef.current = prefetchedReleases;
  }, [prefetchedReleases]);

  // Local Files handlers
  const handleAddWatchFolder = async () => {
    if (!window.electron?.localFiles) return;

    setIsScanning(true);
    try {
      const result = await window.electron.localFiles.addWatchFolder();
      if (result?.success) {
        setWatchFolders(await window.electron.localFiles.getWatchFolders());
        setLocalFilesStats(await window.electron.localFiles.getStats());
      }
    } finally {
      setIsScanning(false);
    }
  };

  const handleRemoveWatchFolder = async (folderPath) => {
    if (!window.electron?.localFiles) return;

    await window.electron.localFiles.removeWatchFolder(folderPath);
    setWatchFolders(await window.electron.localFiles.getWatchFolders());
    setLocalFilesStats(await window.electron.localFiles.getStats());
  };

  const handleRescanFolder = async (folderPath) => {
    if (!window.electron?.localFiles) return;

    setIsScanning(true);
    try {
      await window.electron.localFiles.rescanFolder(folderPath);
      setWatchFolders(await window.electron.localFiles.getWatchFolders());
      setLocalFilesStats(await window.electron.localFiles.getStats());
    } finally {
      setIsScanning(false);
    }
  };

  const handleRescanAll = async () => {
    if (!window.electron?.localFiles) return;

    setIsScanning(true);
    try {
      await window.electron.localFiles.rescanAll();
      setWatchFolders(await window.electron.localFiles.getWatchFolders());
      setLocalFilesStats(await window.electron.localFiles.getStats());
    } finally {
      setIsScanning(false);
    }
  };

  // Fetch playlist covers when viewing playlists page
  useEffect(() => {
    if (activeView !== 'playlists' || playlists.length === 0) return;

    // Fetch covers for playlists that don't have cached covers yet
    const fetchMissingCovers = async () => {
      for (const playlist of playlists) {
        // Skip if we already have covers for this playlist
        if (allPlaylistCovers[playlist.id]) continue;

        // Get tracks from playlist
        let tracks = playlist.tracks || [];

        // If no tracks array but has XSPF, parse it
        if (tracks.length === 0 && playlist.xspf) {
          const parsed = parseXSPF(playlist.xspf);
          if (parsed) {
            tracks = parsed.tracks;
          }
        }

        if (tracks.length === 0) continue;

        // Fetch covers using the existing function (which handles caching)
        const covers = await getPlaylistCovers(playlist.id, tracks);
        if (covers.length > 0) {
          setAllPlaylistCovers(prev => ({
            ...prev,
            [playlist.id]: covers
          }));
        }
      }
    };

    fetchMissingCovers();
  }, [activeView, playlists]);

  // Keyboard shortcuts - Escape navigates back from search view
  useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.key === 'Escape' && activeView === 'search') {
        navigateBack();
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [activeView]);

  const playDemoAudio = (track) => {
    if (!audioContext) return;
    if (currentSource) {
      try { currentSource.stop(); } catch (e) {}
    }
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    oscillator.type = 'sine';
    oscillator.frequency.setValueAtTime(440 + (track.id * 100), audioContext.currentTime);
    gainNode.gain.setValueAtTime(volume / 100, audioContext.currentTime);
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    oscillator.start();
    setCurrentSource(oscillator);
    setStartTime(audioContext.currentTime);
  };

  const handlePlay = async (trackOrSource) => {
    console.log('ðŸŽµ Playing track:', trackOrSource.title, 'by', trackOrSource.artist);
    setTrackLoading(true); // Show loading state in playbar

    // Use ref to avoid stale closure issues when called from extension message handler
    const currentResolvers = loadedResolversRef.current;

    // Determine if we were passed a track with multiple sources or a specific source
    let resolverId;
    let sourceToPlay = trackOrSource;

    if (trackOrSource.sources && typeof trackOrSource.sources === 'object' && !Array.isArray(trackOrSource.sources)) {
      // We have a track with multiple sources - select the best one
      let availableResolvers = Object.keys(trackOrSource.sources);

      if (availableResolvers.length === 0) {
        // No sources available - try resolving on-demand
        console.log('ðŸ”„ No sources found, attempting on-demand resolution...');

        const enabledResolvers = resolverOrder
          .filter(id => activeResolvers.includes(id))
          .map(id => currentResolvers.find(r => r.id === id))
          .filter(Boolean);

        const resolverPromises = enabledResolvers.map(async (resolver) => {
          if (!resolver.capabilities.resolve) return;

          try {
            const config = await getResolverConfig(resolver.id);
            const result = await resolver.resolve(
              trackOrSource.artist,
              trackOrSource.title,
              trackOrSource.album || null,
              config
            );

            if (result) {
              trackOrSource.sources[resolver.id] = {
                ...result,
                confidence: calculateConfidence(trackOrSource, result)
              };
              console.log(`  âœ… ${resolver.name}: Found match`);
            }
          } catch (error) {
            console.error(`  âŒ ${resolver.name} resolve error:`, error);
          }
        });

        await Promise.all(resolverPromises);

        // Update availableResolvers after resolution
        availableResolvers = Object.keys(trackOrSource.sources);
        if (availableResolvers.length === 0) {
          console.error('âŒ No resolver found for track after on-demand resolution');
          setTrackLoading(false); // Clear loading state
          showConfirmDialog({
            type: 'error',
            title: 'No Source Found',
            message: 'Could not find a playable source for this track. Try enabling more resolvers in settings.'
          });
          return;
        }
      }

      // Sort sources by: 1) preferred resolver (if specified), 2) resolver priority, 3) confidence
      const preferredResolver = trackOrSource.preferredResolver;
      const sortedSources = availableResolvers.map(resId => ({
        resolverId: resId,
        source: trackOrSource.sources[resId],
        priority: resolverOrder.indexOf(resId),
        confidence: trackOrSource.sources[resId].confidence || 0
      }))
      .filter(s => activeResolvers.includes(s.resolverId)) // Only enabled resolvers
      .sort((a, b) => {
        // If a preferred resolver is specified, prioritize it
        if (preferredResolver) {
          if (a.resolverId === preferredResolver) return -1;
          if (b.resolverId === preferredResolver) return 1;
        }
        // Then sort by priority (lower index = higher priority)
        if (a.priority !== b.priority) {
          return a.priority - b.priority;
        }
        // If same priority, sort by confidence (higher = better)
        return b.confidence - a.confidence;
      });

      if (sortedSources.length === 0) {
        console.error('âŒ No enabled resolvers found for track');
        setTrackLoading(false); // Clear loading state
        return;
      }

      const best = sortedSources[0];
      resolverId = best.resolverId;
      sourceToPlay = best.source;

      console.log(`ðŸŽµ Selected ${resolverId} (priority #${best.priority + 1}, confidence: ${(best.confidence * 100).toFixed(0)}%)`);
    } else {
      // We were passed a specific source object - detect resolver from it
      // Check which resolver this source came from by examining resolver-specific fields
      if (trackOrSource.spotifyId) resolverId = 'spotify';
      else if (trackOrSource.youtubeId) resolverId = 'youtube';
      else if (trackOrSource.bandcampUrl) resolverId = 'bandcamp';
      else if (trackOrSource.qobuzId) resolverId = 'qobuz';
      else if (trackOrSource.filePath || trackOrSource.fileUrl) resolverId = 'localfiles';
      else {
        console.error('âŒ Could not determine resolver for source');
        setTrackLoading(false); // Clear loading state
        return;
      }
    }

    const resolver = currentResolvers.find(r => r.id === resolverId);
    if (!resolver) {
      console.error(`âŒ Resolver ${resolverId} not found`);
      console.error(`   Available resolvers:`, currentResolvers.map(r => r.id));
      setTrackLoading(false); // Clear loading state
      return;
    }

    // YouTube embedding is blocked in Electron, use resolver's play method instead
    // (which opens in external browser)

    // Handle local file playback directly with HTML5 Audio
    if (resolverId === 'localfiles') {
      console.log('ðŸŽµ Playing local file:', sourceToPlay.filePath || sourceToPlay.fileUrl);
      console.log('ðŸŽµ Source details:', JSON.stringify(sourceToPlay, null, 2));

      // Stop Spotify polling when switching to local file playback
      if (playbackPollerRef.current) {
        console.log('â¹ï¸ Stopping Spotify polling for local file playback');
        clearInterval(playbackPollerRef.current);
        playbackPollerRef.current = null;
      }
      if (pollingRecoveryRef.current) {
        clearInterval(pollingRecoveryRef.current);
        pollingRecoveryRef.current = null;
      }

      // Pause Spotify if it's playing
      if (spotifyPlayer && streamingPlaybackActiveRef.current) {
        console.log('â¹ï¸ Pausing Spotify for local file playback');
        try {
          spotifyPlayer.pause();
        } catch (e) {
          console.error('Failed to pause Spotify:', e);
        }
      }

      // Create audio element if needed
      if (!audioRef.current) {
        console.log('ðŸŽµ Creating new Audio element');
        audioRef.current = new Audio();
        audioRef.current.addEventListener('timeupdate', () => {
          if (audioRef.current) {
            const currentTime = audioRef.current.currentTime;
            setProgress(currentTime);
            // Notify scrobble manager of progress for scrobble threshold checking
            if (window.scrobbleManager) {
              window.scrobbleManager.onProgressUpdate(currentTime);
            }
          }
        });
        audioRef.current.addEventListener('loadedmetadata', () => {
          // Update current track duration from audio element once metadata loads
          const audioDuration = audioRef.current?.duration;
          if (audioDuration && !isNaN(audioDuration) && isFinite(audioDuration)) {
            console.log('ðŸŽµ Audio metadata loaded, duration:', audioDuration);
            setCurrentTrack(prev => prev ? { ...prev, duration: audioDuration } : prev);
          }
        });
        audioRef.current.addEventListener('durationchange', () => {
          // Also listen for duration changes (some formats report duration later)
          const audioDuration = audioRef.current?.duration;
          if (audioDuration && !isNaN(audioDuration) && isFinite(audioDuration)) {
            console.log('ðŸŽµ Audio duration changed:', audioDuration);
            setCurrentTrack(prev => prev ? { ...prev, duration: audioDuration } : prev);
          }
        });
        audioRef.current.addEventListener('ended', () => {
          console.log('ðŸŽµ Local file playback ended');
          handleNextRef.current?.();
        });
        audioRef.current.addEventListener('error', (e) => {
          console.error('ðŸŽµ Audio error:', e.target.error);
          // Don't show error dialog if fallback is in progress (it will be handled by the catch block)
          if (localFileFallbackInProgressRef.current) {
            console.log('ðŸ”„ Audio error during fallback attempt, skipping dialog');
            return;
          }
          showConfirmDialog({
            type: 'error',
            title: 'Playback Error',
            message: 'Could not play this file. It may have been moved or deleted.'
          });
        });
      }

      // Store the track for potential fallback handling
      localFilePlaybackTrackRef.current = trackOrSource;
      localFileFallbackInProgressRef.current = false;

      // Use custom local-audio:// protocol for secure local file playback
      const filePath = sourceToPlay.filePath || sourceToPlay.fileUrl?.replace('file://', '');
      const audioUrl = `local-audio://${filePath}`;
      console.log('ðŸŽµ Audio URL:', audioUrl);
      audioRef.current.src = audioUrl;
      // Apply normalized volume for local files (respect mute state)
      const volumeToApply = isMutedRef.current ? 0 : volume;
      const effectiveVolume = getEffectiveVolume(volumeToApply, 'localfiles', sourceToPlay.id || trackOrSource.id);
      audioRef.current.volume = effectiveVolume / 100;
      console.log(`ðŸ”Š Applied volume: ${volumeToApply}% -> ${effectiveVolume.toFixed(1)}% (offset: ${resolverVolumeOffsets.localfiles || 0}dB)${isMutedRef.current ? ' [MUTED]' : ''}`);

      // Explicitly load to trigger metadata events
      audioRef.current.load();

      try {
        await audioRef.current.play();

        // Set current track state
        // Duration from local files is already in seconds
        const duration = sourceToPlay.duration || trackOrSource.duration || 0;
        console.log('ðŸŽµ Track duration from source:', duration, 'sourceToPlay.duration:', sourceToPlay.duration, 'trackOrSource.duration:', trackOrSource.duration);
        const trackToSet = trackOrSource.sources ? {
          ...sourceToPlay,
          id: trackOrSource.id,
          artist: trackOrSource.artist,
          title: trackOrSource.title,
          album: trackOrSource.album,
          duration: duration,
          albumArt: sourceToPlay.albumArt || trackOrSource.albumArt,
          sources: trackOrSource.sources,
          _playbackContext: trackOrSource._playbackContext // Preserve playback context
        } : { ...sourceToPlay, _playbackContext: trackOrSource._playbackContext };

        setCurrentTrack(trackToSet);
        setIsPlaying(true);
        setProgress(0);
        setTrackLoading(false); // Clear loading state
        streamingPlaybackActiveRef.current = false;
        setBrowserPlaybackActive(false);
        setIsExternalPlayback(false);
        // Clear explicit start flag since we're playing a new track
        trackNeedsExplicitStart.current = false;

        console.log('âœ… Local file playing');

        // Notify scrobble manager of track start
        if (window.scrobbleManager) {
          window.scrobbleManager.onTrackStart(trackToSet);
        }

        // If audio element has duration now, update the track
        const audioDuration = audioRef.current?.duration;
        if (audioDuration && !isNaN(audioDuration) && isFinite(audioDuration) && audioDuration > 0) {
          console.log('ðŸŽµ Setting duration from audio element:', audioDuration);
          setCurrentTrack(prev => prev ? { ...prev, duration: audioDuration } : prev);
        }
      } catch (error) {
        console.error('âŒ Local file playback failed:', error);

        // Try fallback to next available source if we have the original track with sources
        if (trackOrSource.sources && Object.keys(trackOrSource.sources).length > 1) {
          const otherSources = Object.keys(trackOrSource.sources).filter(id => id !== 'localfiles');
          if (otherSources.length > 0) {
            console.log('ðŸ”„ Falling back to next available source...');
            // Set flag to prevent error event listener from showing duplicate dialog
            localFileFallbackInProgressRef.current = true;
            // Create a modified track without localfiles source to trigger fallback
            const fallbackTrack = {
              ...trackOrSource,
              sources: Object.fromEntries(
                Object.entries(trackOrSource.sources).filter(([id]) => id !== 'localfiles')
              )
            };
            handlePlay(fallbackTrack);
            return;
          }
        }

        localFileFallbackInProgressRef.current = false;
        setTrackLoading(false); // Clear loading state on error
        showConfirmDialog({
          type: 'error',
          title: 'Playback Error',
          message: 'Could not play this file: ' + error.message
        });
      }
      return;
    }

    // Check if resolver can stream
    if (!resolver.capabilities.stream) {
      // For non-streaming resolvers (Bandcamp, YouTube), show prompt first
      console.log('ðŸŒ External browser track detected, showing prompt...');
      streamingPlaybackActiveRef.current = false; // Allow browser events for external playback

      // Stop any playing local audio before switching to browser playback
      if (audioRef.current && !audioRef.current.paused) {
        console.log('â¹ï¸ Stopping local audio before browser playback');
        audioRef.current.pause();
        audioRef.current.currentTime = 0;
      }

      // Stop Spotify polling when switching to external browser playback
      if (playbackPollerRef.current) {
        console.log('â¹ï¸ Stopping Spotify polling for external browser playback');
        clearInterval(playbackPollerRef.current);
        playbackPollerRef.current = null;
      }
      if (pollingRecoveryRef.current) {
        clearInterval(pollingRecoveryRef.current);
        pollingRecoveryRef.current = null;
      }
      // CRITICAL: Update currentTrack BEFORE showing prompt so handleNext() can find it in queue
      // Merge source with original track, explicitly preserving queue-essential properties
      const trackToSet = trackOrSource.sources ?
        {
          ...sourceToPlay,
          id: trackOrSource.id,  // MUST preserve queue ID
          artist: trackOrSource.artist,
          title: trackOrSource.title,
          album: trackOrSource.album,
          duration: sourceToPlay.duration || trackOrSource.duration,
          sources: trackOrSource.sources,
          _playbackContext: trackOrSource._playbackContext // Preserve playback context
        } :
        { ...sourceToPlay, _playbackContext: trackOrSource._playbackContext };
      console.log(`ðŸ” trackToSet.id="${trackToSet.id}", trackOrSource.id="${trackOrSource.id}", sourceToPlay.id="${sourceToPlay.id}"`);
      setCurrentTrack(trackToSet);
      setTrackLoading(false); // Clear loading state when showing prompt
      // Clear explicit start flag since we're playing a new track
      trackNeedsExplicitStart.current = false;
      showExternalTrackPromptUI(trackToSet, resolverId);
      return; // Don't play yet, wait for user confirmation
    }

    // Use resolver's play method
    try {
      // Stop any playing local audio before switching to streaming resolver
      if (audioRef.current && !audioRef.current.paused) {
        console.log('â¹ï¸ Stopping local audio before streaming playback');
        audioRef.current.pause();
        audioRef.current.currentTime = 0;
      }

      const config = await getResolverConfig(resolverId);
      console.log(`â–¶ï¸ Using ${resolver.name} to play track...`);

      const success = await resolver.play(sourceToPlay, config);

      if (success) {
        console.log(`âœ… Playing on ${resolver.name}`);

        // Apply normalized volume for Spotify (respect mute state)
        if (resolverId === 'spotify') {
          const trackId = sourceToPlay.id || trackOrSource.id;
          const volumeToApply = isMutedRef.current ? 0 : volume;
          const effectiveVolume = getEffectiveVolume(volumeToApply, 'spotify', trackId);
          console.log(`ðŸ”Š Applied Spotify volume: ${volumeToApply}% -> ${effectiveVolume.toFixed(1)}% (offset: ${resolverVolumeOffsets.spotify || 0}dB)${isMutedRef.current ? ' [MUTED]' : ''}`);
          setSpotifyVolume(volumeToApply, !isMutedRef.current); // Apply with normalization only if not muted
        }

        // Reset browser playback state when playing via streaming resolver (Spotify, etc.)
        // This ensures we don't show "Playing in browser" for Spotify Connect playback
        if (resolver.capabilities.stream) {
          streamingPlaybackActiveRef.current = true; // Mark streaming active to ignore browser events
          setBrowserPlaybackActive(false);
          setIsExternalPlayback(false);
        }

        // Merge source with original track, explicitly preserving queue-essential properties
        const trackToSet = trackOrSource.sources ?
          {
            ...sourceToPlay,
            id: trackOrSource.id,  // MUST preserve queue ID
            artist: trackOrSource.artist,
            title: trackOrSource.title,
            album: trackOrSource.album,
            duration: sourceToPlay.duration || trackOrSource.duration,
            sources: trackOrSource.sources,
            _playbackContext: trackOrSource._playbackContext // Preserve playback context
          } :
          { ...sourceToPlay, _playbackContext: trackOrSource._playbackContext };
        setCurrentTrack(trackToSet);
        setIsPlaying(true);
        setProgress(0);
        setTrackLoading(false); // Clear loading state on success
        // Clear explicit start flag since we're playing a new track
        trackNeedsExplicitStart.current = false;
        // Reset baseline for smooth progress interpolation
        spotifyProgressBaselineRef.current = { progress: 0, timestamp: Date.now(), isPlaying: true };

        // Notify scrobble manager of track start
        if (window.scrobbleManager) {
          window.scrobbleManager.onTrackStart(trackToSet);
        }

        if (audioContext) {
          setStartTime(audioContext.currentTime);
        }
      }

      // Start auto-advance polling for streaming tracks
      if (resolver.capabilities.stream && success) {
        startAutoAdvancePolling(resolverId, sourceToPlay, config);
      }

      if (!success) {
        setTrackLoading(false); // Clear loading state on failure
        console.error(`âŒ ${resolver.name} playback failed`);

        // For Spotify, retry once after a short delay (device may need to wake up)
        if (resolverId === 'spotify' && !sourceToPlay._spotifyRetried) {
          console.log('ðŸ”„ Spotify playback failed, retrying in 2 seconds...');
          await new Promise(resolve => setTimeout(resolve, 2000));

          // Mark as retried to prevent infinite loop
          const retrySource = { ...sourceToPlay, _spotifyRetried: true };
          const retryTrack = trackOrSource.sources ? {
            ...trackOrSource,
            sources: { ...trackOrSource.sources, spotify: retrySource }
          } : retrySource;

          console.log('ðŸ”„ Retrying Spotify playback...');
          const retrySuccess = await resolver.play(retrySource, config);

          if (retrySuccess) {
            console.log('âœ… Spotify retry successful');
            streamingPlaybackActiveRef.current = true;
            setBrowserPlaybackActive(false);
            setIsExternalPlayback(false);

            const trackToSet = trackOrSource.sources ? {
              ...sourceToPlay,
              id: trackOrSource.id,
              artist: trackOrSource.artist,
              title: trackOrSource.title,
              album: trackOrSource.album,
              duration: sourceToPlay.duration || trackOrSource.duration,
              sources: trackOrSource.sources,
              _playbackContext: trackOrSource._playbackContext // Preserve playback context
            } : { ...sourceToPlay, _playbackContext: trackOrSource._playbackContext };
            setCurrentTrack(trackToSet);
            setIsPlaying(true);
            setProgress(0);
            // Reset baseline for smooth progress interpolation
            spotifyProgressBaselineRef.current = { progress: 0, timestamp: Date.now(), isPlaying: true };

            // Notify scrobble manager of track start
            if (window.scrobbleManager) {
              window.scrobbleManager.onTrackStart(trackToSet);
            }

            if (audioContext) {
              setStartTime(audioContext.currentTime);
            }
            startAutoAdvancePolling(resolverId, sourceToPlay, config);
            return; // Success on retry, don't fall through to re-resolve
          }
          console.error('âŒ Spotify retry also failed');
        }

        // Playback failed - cached source may be invalid
        // Try to re-resolve and find alternative sources
        if (sourceToPlay.artist && sourceToPlay.title) {
          console.log('ðŸ”„ Attempting to re-resolve track with fresh sources...');
          const artistName = sourceToPlay.artist;
          const trackData = { position: sourceToPlay.position || 1, title: sourceToPlay.title, length: sourceToPlay.duration };

          // Force refresh to bypass cache
          await resolveTrack(trackData, artistName, true);

          showConfirmDialog({
            type: 'info',
            title: 'Track Re-resolved',
            message: 'Playback failed. Track has been re-resolved. Please try playing again.'
          });
        }
      }
    } catch (error) {
      console.error(`âŒ Error playing with ${resolver.name}:`, error);
      setTrackLoading(false); // Clear loading state on error

      // On error, also try to re-resolve
      if (sourceToPlay.artist && sourceToPlay.title) {
        console.log('ðŸ”„ Playback error - attempting to re-resolve...');
        const artistName = sourceToPlay.artist;
        const trackData = { position: sourceToPlay.position || 1, title: sourceToPlay.title, length: sourceToPlay.duration };
        await resolveTrack(trackData, artistName, true);
      }
    }
  };

  // Auto-advance: Start polling for track completion
  const startAutoAdvancePolling = (resolverId, track, config) => {
    // Clear any existing poller
    if (playbackPollerRef.current) {
      clearInterval(playbackPollerRef.current);
      playbackPollerRef.current = null;
    }
    // Clear recovery interval if we're starting fresh polling
    if (pollingRecoveryRef.current) {
      clearInterval(pollingRecoveryRef.current);
      pollingRecoveryRef.current = null;
    }

    if (resolverId === 'spotify' && config.token) {
      const trackUri = track.spotifyUri || track.uri;
      console.log(`ðŸ”„ Starting Spotify playback polling for auto-advance (5s interval)...`);
      console.log(`   Track: ${track.title} by ${track.artist}`);
      console.log(`   Expected URI: ${trackUri}`);
      console.log(`   spotifyUri: ${track.spotifyUri}, uri: ${track.uri}`);

      if (!trackUri) {
        console.warn('âš ï¸ No Spotify URI found on track, auto-advance may not work');
      }

      let errorCount = 0; // Track consecutive polling errors
      let lastTrackUri = trackUri; // Track what we started playing
      let stuckAtZeroCount = 0; // Track how many times we've been stuck at 0% with is_playing=false
      const MAX_STUCK_AT_ZERO = 3; // After 15 seconds (3 * 5s polls) of being stuck at 0%, give up
      let pollCount = 0; // Track poll number for first-poll grace period
      let pendingTrackChange = null; // Track URI from potential external change, needs confirmation
      let lastProgressMs = 0; // Track previous progress to detect track-end-then-reset scenario
      let lastKnownDurationMs = 0; // Track the duration when we last had valid progress

      const pollInterval = setInterval(async () => {
        pollCount++; // Increment poll counter
        try {
          const response = await fetch('https://api.spotify.com/v1/me/player', {
            headers: {
              'Authorization': `Bearer ${config.token}`
            }
          });

          if (!response.ok) {
            if (response.status === 401) {
              // Token expired
              console.error('Spotify token expired during polling');
              clearInterval(pollInterval);
              playbackPollerRef.current = null;
              return;
            }
            throw new Error(`Spotify API error: ${response.status}`);
          }

          const data = await response.json();
          errorCount = 0; // Reset on success

          if (!data.item) {
            // No track playing - playback stopped or track ended naturally
            // Check if we have more tracks in queue - if so, this likely means the track ended
            const queue = currentQueueRef.current;
            clearInterval(pollInterval);
            playbackPollerRef.current = null;

            if (queue && queue.length > 0) {
              // Track likely ended naturally, advance to next
              console.log('ðŸŽµ Spotify playback ended (no item), advancing to next track...');
              if (handleNextRef.current) handleNextRef.current();
            } else {
              // No queue, playback genuinely stopped
              console.log('â¹ï¸ Spotify playback stopped (no queue)');
            }
            return;
          }

          const currentUri = data.item.uri;
          const progressMs = data.progress_ms;
          const durationMs = data.item.duration_ms;
          const isPlaying = data.is_playing;

          // Check if we're still playing the same track we started with
          if (currentUri === lastTrackUri) {
            // Calculate if we're at or near the end of the track
            const isNearEnd = progressMs >= durationMs - 1000;
            const isAtEnd = progressMs >= durationMs - 100; // Within 100ms of end
            const percentComplete = (progressMs / durationMs) * 100;

            // If playing and near end, or if stopped and at end, trigger next
            if (isNearEnd && isPlaying) {
              console.log('ðŸŽµ Track ending, auto-advancing to next...');
              clearInterval(pollInterval);
              playbackPollerRef.current = null;
              if (handleNextRef.current) handleNextRef.current();
            } else if (!isPlaying && (isAtEnd || percentComplete >= 98)) {
              // Track finished playing (is_playing=false and at end of track)
              console.log(`ðŸŽµ Track finished (${percentComplete.toFixed(1)}% complete), auto-advancing to next...`);
              clearInterval(pollInterval);
              playbackPollerRef.current = null;
              if (handleNextRef.current) handleNextRef.current();
            } else if (!isPlaying) {
              // Track is paused - could be user pause or playback never started
              if (progressMs === 0) {
                // Check if we were previously near the end - this means track finished and reset
                // Use lastKnownDurationMs if available (more reliable than current durationMs which might be stale)
                const effectiveDuration = lastKnownDurationMs > 0 ? lastKnownDurationMs : durationMs;
                const lastPercentComplete = effectiveDuration > 0 ? (lastProgressMs / effectiveDuration) * 100 : 0;
                console.log(`ðŸ” Track at 0%: lastProgressMs=${lastProgressMs}, effectiveDuration=${effectiveDuration}, lastPercentComplete=${lastPercentComplete.toFixed(1)}%`);
                if (lastProgressMs > 0 && lastPercentComplete >= 90) {
                  // We were at 90%+ and now at 0% - track finished naturally
                  console.log(`ðŸŽµ Track finished (was at ${lastPercentComplete.toFixed(1)}%, now reset to 0%), auto-advancing to next...`);
                  clearInterval(pollInterval);
                  playbackPollerRef.current = null;
                  if (handleNextRef.current) handleNextRef.current();
                } else {
                  // Stuck at 0% - playback may have failed to start
                  stuckAtZeroCount++;
                  if (stuckAtZeroCount >= MAX_STUCK_AT_ZERO) {
                    // Been stuck at 0% for too long - playback failed to start
                    console.error(`âŒ Spotify playback stuck at 0% for ${stuckAtZeroCount * 5}s - device may not be active`);
                    clearInterval(pollInterval);
                    playbackPollerRef.current = null;

                    // Check if queue has more tracks and advance
                    const queue = currentQueueRef.current;
                    if (queue && queue.length > 0) {
                      console.log('â­ï¸ Auto-advancing to next track due to playback failure...');
                      if (handleNextRef.current) handleNextRef.current();
                    }
                  } else {
                    console.log(`â¸ï¸ Spotify playback paused at 0% (${stuckAtZeroCount}/${MAX_STUCK_AT_ZERO}), waiting for playback to start...`);
                  }
                }
              } else {
                // User paused mid-playback (progress > 0) - reset stuck counter
                stuckAtZeroCount = 0;
                lastProgressMs = progressMs; // Track progress even when paused
                lastKnownDurationMs = durationMs; // Track duration for accurate percentage calculation
                console.log(`â¸ï¸ Spotify playback paused at ${percentComplete.toFixed(1)}%, continuing to poll...`);
              }
            } else {
              // Playing normally - reset stuck counter and log progress periodically
              stuckAtZeroCount = 0;
              lastProgressMs = progressMs; // Track progress for end-of-track detection
              lastKnownDurationMs = durationMs; // Track duration for accurate percentage calculation
              pendingTrackChange = null; // Clear any pending track change since we're on the right track
              // Log every poll to confirm polling is working
              console.log(`â–¶ï¸ Spotify playing: ${percentComplete.toFixed(1)}% (${Math.floor(progressMs / 1000)}s / ${Math.floor(durationMs / 1000)}s)`);
            }
          } else {
            // Track changed - Spotify advanced on its own or user changed track
            // But wait! On the first few polls, Spotify might not have caught up yet
            // Give it a grace period before assuming the track truly changed
            console.log(`ðŸ”„ Detected potential track change (poll #${pollCount})...`);
            console.log(`   Expected URI: ${lastTrackUri}`);
            console.log(`   Current URI:  ${currentUri}`);
            console.log(`   Spotify says: ${data.item?.name} by ${data.item?.artists?.[0]?.name}`);

            // If this is one of the first 2 polls, check if Spotify is still catching up
            if (pollCount <= 2) {
              // Check if Spotify is playing the track we intended (by comparing track IDs)
              const expectedId = lastTrackUri?.split(':').pop();
              const currentId = currentUri?.split(':').pop();

              if (pendingTrackChange === null) {
                // First time seeing a mismatch - store it and wait for confirmation
                console.log(`   â³ First mismatch on poll #${pollCount}, waiting for confirmation...`);
                pendingTrackChange = currentUri;
              } else if (pendingTrackChange === currentUri) {
                // Confirmed - the track really changed
                console.log(`   âœ… Track change confirmed after grace period`);
                clearInterval(pollInterval);
                playbackPollerRef.current = null;
                if (handleNextRef.current) handleNextRef.current();
              } else {
                // Different URI than pending - reset and wait
                console.log(`   ðŸ”„ URI changed again, resetting confirmation...`);
                pendingTrackChange = currentUri;
              }
            } else {
              // After grace period, trust the mismatch and advance
              console.log(`   âœ… Track change detected after grace period, advancing queue...`);
              clearInterval(pollInterval);
              playbackPollerRef.current = null;
              if (handleNextRef.current) handleNextRef.current();
            }
          }
        } catch (error) {
          console.error('Spotify polling error:', error);

          // Track consecutive errors
          errorCount = (errorCount || 0) + 1;

          if (errorCount >= 3) {
            // After 3 consecutive errors, stop polling but start recovery
            console.error('âŒ Too many Spotify polling errors, stopping auto-advance');
            clearInterval(pollInterval);
            playbackPollerRef.current = null;
            // Start recovery interval to retry when API becomes available
            startPollingRecovery(config);
          }
        }
      }, 5000); // Poll every 5 seconds (consistent with existing playback polling)

      playbackPollerRef.current = pollInterval;
    }
    // For future HTML5 audio resolvers, add event listener logic here
  };

  // Start recovery polling when Spotify auto-advance fails
  // Periodically checks if we should restart polling (queue has tracks, nothing playing)
  const startPollingRecovery = (config) => {
    // Clear any existing recovery interval
    if (pollingRecoveryRef.current) {
      clearInterval(pollingRecoveryRef.current);
      pollingRecoveryRef.current = null;
    }

    console.log('ðŸ”„ Starting polling recovery interval (20s)...');

    const recoveryInterval = setInterval(async () => {
      const queue = currentQueueRef.current;
      const track = currentTrackRef.current;

      // Stop recovery if queue is empty
      if (!queue || queue.length === 0) {
        console.log('ðŸ”„ Recovery: Queue empty, stopping recovery');
        clearInterval(recoveryInterval);
        pollingRecoveryRef.current = null;
        return;
      }

      // Stop recovery if no current track (nothing to monitor)
      if (!track) {
        console.log('ðŸ”„ Recovery: No current track, stopping recovery');
        clearInterval(recoveryInterval);
        pollingRecoveryRef.current = null;
        return;
      }

      // Try to check Spotify playback state
      try {
        const response = await fetch('https://api.spotify.com/v1/me/player', {
          headers: {
            'Authorization': `Bearer ${config.token}`
          }
        });

        if (response.ok) {
          const data = await response.json();

          // If Spotify is playing, restart proper polling
          if (data.is_playing && data.item) {
            console.log('ðŸ”„ Recovery: Spotify responding, restarting auto-advance polling');
            clearInterval(recoveryInterval);
            pollingRecoveryRef.current = null;
            startAutoAdvancePolling('spotify', track, config);
          } else if (!data.is_playing && queue.length > 0) {
            // Spotify not playing but we have queue - advance to next track
            console.log('ðŸ”„ Recovery: Spotify not playing, queue has tracks - advancing');
            clearInterval(recoveryInterval);
            pollingRecoveryRef.current = null;
            if (handleNextRef.current) handleNextRef.current();
          }
        } else if (response.status === 401) {
          // Token expired - stop recovery, user needs to re-auth
          console.log('ðŸ”„ Recovery: Token expired, stopping recovery');
          clearInterval(recoveryInterval);
          pollingRecoveryRef.current = null;
        }
        // Other errors: keep trying
      } catch (error) {
        console.log('ðŸ”„ Recovery: API still unavailable, will retry...', error.message);
        // Keep recovery interval running
      }
    }, 20000); // Check every 20 seconds

    pollingRecoveryRef.current = recoveryInterval;
  };

  // Stop Spotify playback (used when switching to external browser track)
  const stopSpotifyPlayback = async () => {
    if (!spotifyToken) return;

    try {
      const response = await fetch('https://api.spotify.com/v1/me/player/pause', {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${spotifyToken}`
        }
      });

      if (response.ok || response.status === 204) {
        console.log('â¸ï¸ Stopped Spotify playback');
        setIsPlaying(false);
      }
    } catch (error) {
      console.error('Failed to stop Spotify playback:', error);
    }
  };

  // Show prompt for external browser track
  const showExternalTrackPromptUI = async (track, resolverId) => {
    console.log('ðŸŒ Showing external track prompt for:', track.title, 'via', resolverId);

    // Stop any currently playing Spotify track before prompting
    await stopSpotifyPlayback();

    // Store the selected resolver ID for when user confirms
    setPendingExternalResolverId(resolverId);

    // If user has opted to skip the prompt, auto-open directly
    if (skipExternalPrompt) {
      console.log('ðŸš€ Skip prompt enabled, auto-opening external track');
      setPendingExternalTrack(track);
      handleOpenExternalTrack(track, resolverId);
      return;
    }

    setPendingExternalTrack(track);
    setShowExternalPrompt(true);
    setExternalTrackCountdown(15);

    // Set countdown interval
    const interval = setInterval(() => {
      setExternalTrackCountdown(prev => {
        if (prev <= 1) {
          clearInterval(interval);
          return 0;
        }
        return prev - 1;
      });
    }, 1000);
    externalTrackIntervalRef.current = interval;

    // Set 15-second auto-skip timeout
    const timeout = setTimeout(() => {
      console.log('â±ï¸ External track prompt timeout, auto-skipping...');
      if (externalTrackIntervalRef.current) {
        clearInterval(externalTrackIntervalRef.current);
        externalTrackIntervalRef.current = null;
      }
      handleSkipExternalTrack();
    }, 15000);

    externalTrackTimeoutRef.current = timeout;
  };

  // User confirmed opening external browser
  // resolverIdOverride is used when called from showExternalTrackPromptUI with skip prompt enabled
  const handleOpenExternalTrack = async (track, resolverIdOverride = null) => {
    console.log('âœ… User confirmed, opening external track:', track.title);

    // Clear timeout and interval FIRST
    if (externalTrackTimeoutRef.current) {
      clearTimeout(externalTrackTimeoutRef.current);
      externalTrackTimeoutRef.current = null;
    }
    if (externalTrackIntervalRef.current) {
      clearInterval(externalTrackIntervalRef.current);
      externalTrackIntervalRef.current = null;
    }

    // Use the stored resolver ID from when the prompt was shown, or override if provided
    // This preserves the SELECTED resolver rather than re-determining from track properties
    const resolverId = resolverIdOverride || pendingExternalResolverId || determineResolverIdFromTrack(track);
    if (!resolverId) {
      console.error('âŒ Could not determine resolver for external track');
      setIsExternalPlayback(false);
      setPendingExternalTrack(null);
      setPendingExternalResolverId(null);
      setShowExternalPrompt(false);
      handleNext();
      return;
    }

    const resolver = allResolvers.find(r => r.id === resolverId);
    if (!resolver) {
      console.error(`âŒ Resolver ${resolverId} not found`);
      setIsExternalPlayback(false);
      setPendingExternalTrack(null);
      setPendingExternalResolverId(null);
      setShowExternalPrompt(false);
      handleNext();
      return;
    }

    // Close previous browser tab if one is active
    if (activeExtensionTabId && extensionConnected) {
      console.log('ðŸ”„ Closing previous browser tab:', activeExtensionTabId);
      // Mark this as a programmatic close so tabClosed handler doesn't call handleNext()
      pendingCloseTabIdRef.current = activeExtensionTabId;
      window.electron.extension.sendCommand({
        type: 'command',
        action: 'closeTab',
        tabId: activeExtensionTabId
      });
      setActiveExtensionTabId(null);
      setBrowserPlaybackActive(false);
    }

    // Close previous playback window if one is active (for Bandcamp, etc.)
    if (window.electron?.playbackWindow?.close) {
      console.log('ðŸ”„ Closing previous playback window');
      await window.electron.playbackWindow.close();
    }

    // Open in external browser FIRST
    try {
      // Mark that we're waiting for browser to connect - prevents premature handleNext() calls
      waitingForBrowserPlaybackRef.current = true;
      console.log('â³ Waiting for browser playback to connect...');

      // Safety timeout: Clear the waiting flag after 10 seconds if browser never connects
      // This prevents getting stuck if the browser extension isn't responding
      const safetyTimeout = setTimeout(() => {
        if (waitingForBrowserPlaybackRef.current) {
          console.log('âš ï¸ Browser playback timeout - clearing wait flag after 10s');
          waitingForBrowserPlaybackRef.current = false;
        }
      }, 10000);

      const config = await getResolverConfig(resolverId);
      await resolver.play(track, config);
      console.log(`ðŸŒ Opened ${track.title} in browser via ${resolver.name}`);

      // Clear safety timeout if browser opens successfully (the 'connected' event will clear the wait flag)
      clearTimeout(safetyTimeout);

      // Only update state AFTER successful browser open
      setShowExternalPrompt(false);
      setPendingExternalTrack(null);
      setPendingExternalResolverId(null);
      setIsExternalPlayback(true);
      setIsPlaying(true);
      setCurrentTrack(track);
    } catch (error) {
      console.error('âŒ Failed to open external track:', error);
      // Clear the waiting flag on error
      waitingForBrowserPlaybackRef.current = false;
      showConfirmDialog({
        type: 'error',
        title: 'Browser Error',
        message: `Failed to open browser: ${error.message}`
      });
      setIsExternalPlayback(false);
      setPendingExternalTrack(null);
      setPendingExternalResolverId(null);
      setShowExternalPrompt(false);
      handleNext();
    }
  };

  // Skip external track (manual or auto-timeout)
  const handleSkipExternalTrack = () => {
    console.log('â­ï¸ Skipping external track');

    // Clear waiting flag since we're skipping
    waitingForBrowserPlaybackRef.current = false;

    // Clear timeout and interval if exists
    if (externalTrackTimeoutRef.current) {
      clearTimeout(externalTrackTimeoutRef.current);
      externalTrackTimeoutRef.current = null;
    }
    if (externalTrackIntervalRef.current) {
      clearInterval(externalTrackIntervalRef.current);
      externalTrackIntervalRef.current = null;
    }

    setShowExternalPrompt(false);
    setPendingExternalTrack(null);
    setPendingExternalResolverId(null);

    // Show toast notification
    // (Simplified - full toast system out of scope)
    console.log('â„¹ï¸ Skipped external track');

    // Use refs to get current values (avoids stale closure when called from event handlers)
    const queue = currentQueueRef.current;
    const track = currentTrackRef.current;

    // Find next track BEFORE removing current from queue
    if (queue.length === 0) {
      console.log('Queue is empty, cannot skip');
      return;
    }

    const currentIndex = queue.findIndex(t => t.id === track?.id);
    console.log(`ðŸ” Skip: currentIndex=${currentIndex}, queueLength=${queue.length}`);
    console.log(`ðŸ” currentTrack.id="${track?.id}", title="${track?.title}"`);
    console.log(`ðŸ” Queue track IDs:`, queue.map(t => `"${t.id}"`));
    console.log(`ðŸ” Queue track titles:`, queue.map(t => t.title));

    let nextTrack;
    if (currentIndex === -1) {
      // Track not found, play first
      nextTrack = queue[0];
    } else if (currentIndex === queue.length - 1) {
      // Last track, loop to first
      nextTrack = queue[0];
    } else {
      // Play next track
      nextTrack = queue[currentIndex + 1];
    }

    // Remove current track from queue
    const newQueue = queue.filter(t => t.id !== track?.id);
    setCurrentQueue(newQueue);
    console.log(`ðŸ“‹ Removed track. New queue length: ${newQueue.length}`);

    // Play the next track directly
    if (nextTrack) {
      handlePlay(nextTrack);
    }
  };

  // User finished with external track, move to next
  const handleDoneWithExternalTrack = () => {
    console.log('âœ… User done with external track, moving to next');
    // Clear waiting flag
    waitingForBrowserPlaybackRef.current = false;
    setIsExternalPlayback(false);
    setShowExternalPrompt(false);
    setPendingExternalTrack(null);
    setPendingExternalResolverId(null);

    // Use refs to get current values (avoids stale closure when called from event handlers)
    const queue = currentQueueRef.current;
    const track = currentTrackRef.current;

    // Find next track BEFORE removing current from queue
    if (queue.length === 0) {
      console.log('Queue is empty, nothing to play');
      return;
    }

    const currentIndex = queue.findIndex(t => t.id === track?.id);
    console.log(`ðŸ” Done: currentIndex=${currentIndex}, queueLength=${queue.length}`);
    console.log(`ðŸ” currentTrack.id="${track?.id}", title="${track?.title}"`);
    console.log(`ðŸ” Queue track IDs:`, queue.map(t => `"${t.id}"`));
    console.log(`ðŸ” Queue track titles:`, queue.map(t => t.title));

    let nextTrack;
    if (currentIndex === -1) {
      // Track not found, play first
      nextTrack = queue[0];
    } else if (currentIndex === queue.length - 1) {
      // Last track, loop to first
      nextTrack = queue[0];
    } else {
      // Play next track
      nextTrack = queue[currentIndex + 1];
    }

    // Remove current track from queue
    const newQueue = queue.filter(t => t.id !== track?.id);
    setCurrentQueue(newQueue);
    console.log(`ðŸ“‹ Removed track. New queue length: ${newQueue.length}`);

    // Play the next track directly
    if (nextTrack) {
      handlePlay(nextTrack);
    }
  };

  const handlePlayPause = async () => {
    if (!currentTrack) return;

    // Check if browser extension is controlling playback
    if (browserPlaybackActive && extensionConnected) {
      console.log('ðŸŒ Sending play/pause to browser extension');
      window.electron.extension.sendCommand({
        type: 'command',
        action: isPlaying ? 'pause' : 'play'
      });
      // State will be updated when extension sends back playing/paused event
      return;
    }

    // Handle external playback window (Bandcamp embed)
    if (isExternalPlayback && window.electron?.playbackWindow?.toggle) {
      console.log('ðŸŽ¸ Toggling playback window play/pause');
      const result = await window.electron.playbackWindow.toggle();
      if (result.success) {
        if (result.state === 'playing') {
          setIsPlaying(true);
        } else if (result.state === 'paused') {
          setIsPlaying(false);
        } else {
          // For 'clicked' fallback, just toggle the state
          setIsPlaying(!isPlaying);
        }
      }
      return;
    }

    // Handle local file playback
    if (audioRef.current && currentTrack?.sources?.localfiles) {
      if (isPlaying) {
        audioRef.current.pause();
        setIsPlaying(false);
      } else {
        audioRef.current.play();
        setIsPlaying(true);
      }
      return;
    }

    const isSpotifyTrack = currentTrack.sources?.spotify || currentTrack.spotifyUri;

    if (isSpotifyTrack && spotifyToken) {
      // Control Spotify playback
      const attemptSpotifyControl = async (token, isRetry = false) => {
        try {
          if (isPlaying) {
            // Pausing - simple pause request
            const response = await fetch('https://api.spotify.com/v1/me/player/pause', {
              method: 'PUT',
              headers: {
                'Authorization': `Bearer ${token}`
              }
            });

            if (response.ok || response.status === 204) {
              setIsPlaying(false);
              console.log('Paused Spotify playback');
              return true;
            } else if (response.status === 401 && !isRetry) {
              // Token expired - try to refresh
              console.log('ðŸ”„ Spotify token expired on pause, attempting refresh...');
              const newToken = await refreshSpotifyToken();
              if (newToken) {
                return attemptSpotifyControl(newToken, true);
              }
            }
            // If we can't control Spotify, at least update UI to reflect user intent
            // This prevents the "can't pause" issue
            if (!isRetry) {
              console.log('âš ï¸ Could not pause Spotify, updating UI state anyway');
              setIsPlaying(false);
              // Stop polling since we're trying to pause
              if (playbackPollerRef.current) {
                clearInterval(playbackPollerRef.current);
                playbackPollerRef.current = null;
              }
            }
          } else {
            // Playing - check if we need to explicitly start this track
            // (e.g., restored from saved queue, Spotify may have different track loaded)
            if (trackNeedsExplicitStart.current) {
              // Use handlePlay to properly start the track with device handling
              // This ensures device discovery and wake-up logic is used
              console.log('ðŸ”„ Starting restored track via handlePlay:', currentTrack.title);
              trackNeedsExplicitStart.current = false;
              handlePlay(currentTrack);
              return true;
            } else {
              // Normal resume
              const response = await fetch('https://api.spotify.com/v1/me/player/play', {
                method: 'PUT',
                headers: {
                  'Authorization': `Bearer ${token}`
                }
              });

              if (response.ok || response.status === 204) {
                setIsPlaying(true);
                console.log('Resumed Spotify playback');
                return true;
              } else if (response.status === 401 && !isRetry) {
                // Token expired - try to refresh
                console.log('ðŸ”„ Spotify token expired on play, attempting refresh...');
                const newToken = await refreshSpotifyToken();
                if (newToken) {
                  return attemptSpotifyControl(newToken, true);
                }
              }
            }
          }
          return false;
        } catch (error) {
          console.error('Spotify play/pause error:', error);
          return false;
        }
      };

      await attemptSpotifyControl(spotifyToken);
    } else {
      // Toggle local playback
      if (!audioContext) return;
      if (isPlaying) {
        setIsPlaying(false);
        if (currentSource) {
          try { currentSource.stop(); setCurrentSource(null); } catch (e) {}
        }
      } else {
        if (audioContext.state === 'suspended') await audioContext.resume();
        setIsPlaying(true);
        playDemoAudio(currentTrack);
      }
    }
  };

  const handleNext = async () => {
    // BROWSER PLAYBACK GUARD: Block handleNext while waiting for browser to connect
    // This prevents race conditions when opening external tracks (YouTube, Bandcamp, etc.)
    if (waitingForBrowserPlaybackRef.current) {
      console.log('â³ handleNext() blocked - waiting for browser playback to connect');
      return;
    }

    // RE-ENTRANCY GUARD: Prevent multiple simultaneous handleNext() calls
    // This can happen when events fire in rapid succession (e.g., tab close + ended event)
    if (isAdvancingTrackRef.current) {
      console.log('âš ï¸ handleNext() already in progress, skipping duplicate call');
      return;
    }
    isAdvancingTrackRef.current = true;

    try {
      // FIRST: Clean up any active polling to prevent race conditions
      // This must happen BEFORE any async operations to prevent duplicate handleNext calls
      if (playbackPollerRef.current) {
        clearInterval(playbackPollerRef.current);
        playbackPollerRef.current = null;
      }
      if (pollingRecoveryRef.current) {
        clearInterval(pollingRecoveryRef.current);
        pollingRecoveryRef.current = null;
      }

      // Notify scrobble manager that current track is ending
      if (window.scrobbleManager) {
        window.scrobbleManager.onTrackEnd();
      }

      // CRITICAL: Reset streaming playback flag when advancing tracks
      // This ensures browser extension events are not ignored when switching
      // from a streaming track (Spotify) to a browser track (YouTube/Bandcamp)
      streamingPlaybackActiveRef.current = false;

      // Stop browser extension playback if active (YouTube external browser)
      if (browserPlaybackActive && activeExtensionTabId) {
        console.log('â¹ï¸ Stopping browser playback before next track');
        window.electron.extension.sendCommand({
          type: 'command',
          action: 'pause'
        });
        // Store the tab ID to close when next track connects
        pendingCloseTabIdRef.current = activeExtensionTabId;
        setBrowserPlaybackActive(false);
        setActiveExtensionTabId(null);
      }

      // Close playback window if active (Bandcamp embedded player)
      if (window.electron?.playbackWindow?.close) {
        console.log('â¹ï¸ Closing playback window before next track');
        await window.electron.playbackWindow.close();
      }

      // Clean up external track timeouts
      if (externalTrackTimeoutRef.current) {
        clearTimeout(externalTrackTimeoutRef.current);
        externalTrackTimeoutRef.current = null;
      }
      if (externalTrackIntervalRef.current) {
        clearInterval(externalTrackIntervalRef.current);
        externalTrackIntervalRef.current = null;
      }
      setIsExternalPlayback(false);
      setShowExternalPrompt(false);
      setPendingExternalTrack(null);
      setPendingExternalResolverId(null);

      // Always use our local queue for navigation
      // (Spotify doesn't know about our queue - tracks may resolve to different services)
      // Use refs to get current values (avoids stale closure when called from event handlers)
      const queue = currentQueueRef.current;
      const track = currentTrackRef.current;

      if (queue.length === 0) {
        console.log('No queue set, cannot go to next track');
        return;
      }

      console.log(`ðŸ” Queue navigation: currentTrack.id="${track?.id}", queueLength=${queue.length}`);

      // Queue represents upcoming tracks - current track is NOT in the queue
      // Find the first playable track in the queue
      const nextTrackIndex = queue.findIndex(t => t.status !== 'error');

      if (nextTrackIndex === -1) {
        console.log('âš ï¸ No playable tracks in queue');
        return;
      }

      const nextTrack = queue[nextTrackIndex];

      // Push current track to history before moving to next (for "previous" navigation)
      if (track) {
        playHistoryRef.current = [...playHistoryRef.current, track];
        console.log(`ðŸ“š Added "${track.title}" to play history (${playHistoryRef.current.length} tracks)`);
      }

      // Remove the track we're about to play from the queue
      const newQueue = queue.filter((_, index) => index !== nextTrackIndex);
      setCurrentQueue(newQueue);

      // Update playback context if the next track has a different context
      console.log(`ðŸŽ¯ Next track context:`, nextTrack._playbackContext);
      if (nextTrack._playbackContext) {
        setPlaybackContext(nextTrack._playbackContext);
        console.log(`ðŸŽ¯ Updated playback context to:`, nextTrack._playbackContext.type);
      }

      console.log(`âž¡ï¸ Playing next track: "${nextTrack.title}", remaining queue: ${newQueue.length}`);
      handlePlay(nextTrack);
    } finally {
      // Reset re-entrancy guard after a delay to allow state updates and async operations to complete
      // This prevents re-entry from race conditions (e.g., in-flight Spotify polls, browser events)
      setTimeout(() => {
        isAdvancingTrackRef.current = false;
      }, 500);
    }
  };

  // Keep handleNextRef in sync so event handlers always call the latest version
  useEffect(() => { handleNextRef.current = handleNext; });

  const handlePrevious = async () => {
    // Use refs to get current values (avoids stale closure when called from event handlers)
    const track = currentTrackRef.current;

    if (!track) return;

    // Notify scrobble manager that current track is ending
    if (window.scrobbleManager) {
      window.scrobbleManager.onTrackEnd();
    }

    // CRITICAL: Reset streaming playback flag when changing tracks
    streamingPlaybackActiveRef.current = false;

    // Stop browser playback if active
    if (browserPlaybackActive && activeExtensionTabId) {
      console.log('â¹ï¸ Stopping browser playback before restarting track');
      window.electron.extension.sendCommand({
        type: 'command',
        action: 'pause'
      });
      pendingCloseTabIdRef.current = activeExtensionTabId;
      setBrowserPlaybackActive(false);
      setActiveExtensionTabId(null);
    }

    // Close playback window if active (for Bandcamp, etc.)
    if (window.electron?.playbackWindow?.close) {
      console.log('â¹ï¸ Closing playback window before restarting track');
      await window.electron.playbackWindow.close();
    }

    // Clean up any active polling or timeouts
    if (playbackPollerRef.current) {
      clearInterval(playbackPollerRef.current);
      playbackPollerRef.current = null;
    }
    if (pollingRecoveryRef.current) {
      clearInterval(pollingRecoveryRef.current);
      pollingRecoveryRef.current = null;
    }
    if (externalTrackTimeoutRef.current) {
      clearTimeout(externalTrackTimeoutRef.current);
      externalTrackTimeoutRef.current = null;
    }
    if (externalTrackIntervalRef.current) {
      clearInterval(externalTrackIntervalRef.current);
      externalTrackIntervalRef.current = null;
    }
    setIsExternalPlayback(false);
    setShowExternalPrompt(false);
    setPendingExternalTrack(null);
    setPendingExternalResolverId(null);

    // Check if we have history to go back to
    const history = playHistoryRef.current;
    if (history.length > 0) {
      // Pop the previous track from history
      const previousTrack = history[history.length - 1];
      playHistoryRef.current = history.slice(0, -1);

      // Put current track at the front of the queue so it plays next after the previous track
      // This maintains proper playback order: previous -> current -> rest of queue
      if (track) {
        // Check if track is already in queue before inserting
        const queue = currentQueueRef.current;
        const isDuplicate = queue.some(t =>
          t.title === track.title && t.artist === track.artist
        );

        if (isDuplicate) {
          console.log(`â­ï¸ Track "${track.title}" already in queue, skipping duplicate`);
        } else {
          setCurrentQueue(prev => [track, ...prev]);
          console.log(`ðŸ“¥ Returned "${track.title}" to front of queue`);
          // Trigger insert animation
          setInsertedTrackId(track.id);
          setTimeout(() => setInsertedTrackId(null), 1000); // Clear after animation
        }
      }

      console.log(`â¬…ï¸ Going back to previous track: "${previousTrack.title}" (${playHistoryRef.current.length} tracks remaining in history)`);
      handlePlay(previousTrack);
    } else {
      // No history - restart current track
      console.log(`â¬…ï¸ No history, restarting current track: "${track.title}"`);
      handlePlay(track);
    }
  };

  // Queue management functions
  const removeFromQueue = (trackId) => {
    setCurrentQueue(prev => prev.filter(t => t.id !== trackId));
    console.log(`ðŸ—‘ï¸ Removed track ${trackId} from queue`);
  };

  const moveInQueue = (fromIndex, toIndex) => {
    if (fromIndex === toIndex) return;
    setCurrentQueue(prev => {
      const newQueue = [...prev];
      const [removed] = newQueue.splice(fromIndex, 1);
      newQueue.splice(toIndex, 0, removed);
      console.log(`ðŸ”€ Moved track from index ${fromIndex} to ${toIndex}`);
      return newQueue;
    });
  };

  const moveInPlaylist = (fromIndex, toIndex) => {
    if (fromIndex === toIndex) return;

    // Update displayed tracks
    setPlaylistTracks(prev => {
      const newTracks = [...prev];
      const [removed] = newTracks.splice(fromIndex, 1);
      newTracks.splice(toIndex, 0, removed);
      console.log(`ðŸ”€ Moved playlist track from index ${fromIndex} to ${toIndex}`);
      return newTracks;
    });

    // Update lastModified on the selected playlist and save to disk
    if (selectedPlaylist) {
      setSelectedPlaylist(prev => ({ ...prev, lastModified: Date.now() }));
      setPlaylists(prev => prev.map(p => {
        if (p.id === selectedPlaylist.id) {
          // Reorder tracks in the playlist data
          const newTracks = [...(p.tracks || [])];
          const [removed] = newTracks.splice(fromIndex, 1);
          newTracks.splice(toIndex, 0, removed);
          const updatedPlaylist = {
            ...p,
            tracks: newTracks,
            lastModified: Date.now()
          };
          // Save to disk
          savePlaylistToStore(updatedPlaylist);
          return updatedPlaylist;
        }
        return p;
      }));
    }
  };

  // Move track in buffered edit data (for edit mode)
  const moveInEditedPlaylist = (fromIndex, toIndex) => {
    if (fromIndex === toIndex) return;
    setEditedPlaylistData(prev => {
      if (!prev) return prev;
      const newTracks = [...prev.tracks];
      const [removed] = newTracks.splice(fromIndex, 1);
      newTracks.splice(toIndex, 0, removed);
      console.log(`ðŸ”€ Moved track in edit buffer from index ${fromIndex} to ${toIndex}`);
      return { ...prev, tracks: newTracks };
    });
  };

  const clearQueue = () => {
    setCurrentQueue([]);
    setPlaybackContext(null);
    console.log('ðŸ—‘ï¸ Cleared queue');
  };

  // Helper to set queue with playback context tagged on each track
  // This allows the context to update when tracks from different sources come up
  const setQueueWithContext = (tracks, context) => {
    const taggedTracks = tracks.map(track => ({
      ...track,
      _playbackContext: context
    }));
    console.log(`ðŸ·ï¸ Tagged ${taggedTracks.length} tracks with context:`, context.type);
    setCurrentQueue(taggedTracks);
    setPlaybackContext(context);
  };

  // Helper to add tracks to existing queue with context
  const addToQueueWithContext = (tracks, context) => {
    const taggedTracks = tracks.map(track => ({
      ...track,
      _playbackContext: context
    }));
    setCurrentQueue(prev => [...prev, ...taggedTracks]);
  };

  // Open save dialog for queue as playlist
  const handleSaveQueueAsPlaylist = () => {
    // Build track list: currently playing + queue
    const tracksToSave = currentTrack ? [currentTrack, ...currentQueue] : currentQueue;
    if (tracksToSave.length === 0) return;

    // Generate default name based on first track artist
    const firstTrack = tracksToSave[0];
    const defaultName = firstTrack?.artist
      ? `${firstTrack.artist} Mix`
      : 'My Queue';

    setQueueSavePlaylistName(defaultName);
    setQueueSaveDialogOpen(true);
  };

  // Actually save the queue as a playlist
  const handleSaveQueueConfirm = async () => {
    const tracksToSave = currentTrack ? [currentTrack, ...currentQueue] : currentQueue;
    if (tracksToSave.length === 0 || !queueSavePlaylistName.trim()) return;

    const playlistId = `queue-${Date.now()}`;

    const newPlaylist = {
      id: playlistId,
      title: queueSavePlaylistName.trim(),
      creator: 'Queue',
      tracks: tracksToSave,
      createdAt: Date.now(),
      addedAt: Date.now(),
      lastModified: Date.now()
    };

    // Add to playlists state (prepend so it appears at top immediately)
    setPlaylists(prev => [newPlaylist, ...prev]);

    // Save to unified local storage (electron-store)
    await savePlaylistToStore(newPlaylist);

    // Close dialog
    setQueueSaveDialogOpen(false);
    showToast(`Saved playlist: ${queueSavePlaylistName.trim()}`);
  };

  // Fetch listening context from Last.fm or ListenBrainz for AI prompt enrichment
  const fetchListeningContext = async () => {
    const lastfmConfig = metaServiceConfigs.lastfm;
    const listenbrainzConfig = metaServiceConfigs.listenbrainz;

    // Try Last.fm first
    if (lastfmConfig?.username) {
      const apiKey = lastfmApiKey.current;
      if (apiKey) {
        try {
          console.log('ðŸŽµ Fetching listening context from Last.fm...');

          // Fetch top artists (10) and top tracks (25) in parallel
          const [artistsRes, tracksRes] = await Promise.all([
            fetch(`https://ws.audioscrobbler.com/2.0/?method=user.gettopartists&user=${encodeURIComponent(lastfmConfig.username)}&api_key=${apiKey}&format=json&period=3month&limit=10`),
            fetch(`https://ws.audioscrobbler.com/2.0/?method=user.gettoptracks&user=${encodeURIComponent(lastfmConfig.username)}&api_key=${apiKey}&format=json&period=3month&limit=25`)
          ]);

          if (artistsRes.ok && tracksRes.ok) {
            const [artistsData, tracksData] = await Promise.all([artistsRes.json(), tracksRes.json()]);

            const topArtists = (artistsData.topartists?.artist || []).map(a => a.name);
            const topTracks = (tracksData.toptracks?.track || []).map(t => ({
              artist: t.artist?.name || 'Unknown',
              title: t.name
            }));

            console.log(`ðŸŽµ Got ${topArtists.length} artists and ${topTracks.length} tracks from Last.fm`);

            return {
              source: 'Last.fm',
              window: 'last_3_months',
              top_artists: topArtists,
              top_tracks: topTracks
            };
          }
        } catch (err) {
          console.error('Failed to fetch Last.fm context:', err);
        }
      }
    }

    // Fall back to ListenBrainz
    if (listenbrainzConfig?.username) {
      try {
        console.log('ðŸŽµ Fetching listening context from ListenBrainz...');

        // Fetch top artists (10) and top tracks (25) in parallel
        const [artistsRes, tracksRes] = await Promise.all([
          fetch(`https://api.listenbrainz.org/1/stats/user/${encodeURIComponent(listenbrainzConfig.username)}/artists?range=quarter&count=10`),
          fetch(`https://api.listenbrainz.org/1/stats/user/${encodeURIComponent(listenbrainzConfig.username)}/recordings?range=quarter&count=25`)
        ]);

        // Handle 204 No Content
        if (artistsRes.status === 204 || tracksRes.status === 204) {
          console.log('ðŸŽµ No ListenBrainz stats available for this period');
          return null;
        }

        if (artistsRes.ok && tracksRes.ok) {
          const [artistsData, tracksData] = await Promise.all([artistsRes.json(), tracksRes.json()]);

          const topArtists = (artistsData.payload?.artists || []).map(a => a.artist_name);
          const topTracks = (tracksData.payload?.recordings || []).map(t => ({
            artist: t.artist_name || 'Unknown',
            title: t.track_name
          }));

          console.log(`ðŸŽµ Got ${topArtists.length} artists and ${topTracks.length} tracks from ListenBrainz`);

          return {
            source: 'ListenBrainz',
            window: 'last_3_months',
            top_artists: topArtists,
            top_tracks: topTracks
          };
        }
      } catch (err) {
        console.error('Failed to fetch ListenBrainz context:', err);
      }
    }

    return null;
  };

  // AI Playlist Generation
  const handleAiGenerate = async (prompt) => {
    const aiServices = getAiServices();
    // Filter to only enabled services with API keys
    const enabledServices = aiServices.filter(s => {
      const config = metaServiceConfigs[s.id] || {};
      return config.enabled && config.apiKey;
    });

    if (enabledServices.length === 0) {
      setAiError('No AI plugins configured. Enable OpenAI or Gemini and add your API key in Settings â†’ General.');
      return;
    }

    // Use selected service or first available
    const service = selectedAiResolver
      ? enabledServices.find(s => s.id === selectedAiResolver) || enabledServices[0]
      : enabledServices[0];

    setAiLoading(true);
    setAiError(null);

    // Open sidebar immediately with loading state
    setResultsSidebar({
      title: 'âœ¨ AI Playlist',
      subtitle: `"${prompt.length > 50 ? prompt.substring(0, 50) + '...' : prompt}"`,
      tracks: [],
      source: 'ai',
      prompt: prompt,
      provider: { id: service.id, name: service.name },
      loading: true
    });

    // Close prompt input immediately
    setAiPromptOpen(false);
    setAiPrompt('');

    try {
      // Get service config from metaServiceConfigs
      const config = metaServiceConfigs[service.id] || {};

      // Fetch listening context if toggle is enabled
      let listeningContext = null;
      if (aiIncludeHistory) {
        listeningContext = await fetchListeningContext();
        if (!listeningContext) {
          console.log('ðŸŽµ No listening context available, proceeding without');
        }
      }

      // Call the service's generate function
      const tracks = await service.generate(prompt, config, listeningContext);

      if (!tracks || tracks.length === 0) {
        throw new Error('No tracks returned. Try a different prompt.');
      }

      // Update sidebar with the generated tracks
      setResultsSidebar({
        title: 'âœ¨ AI Playlist',
        subtitle: `"${prompt.length > 50 ? prompt.substring(0, 50) + '...' : prompt}"`,
        tracks: tracks.map((t, i) => ({
          id: `ai-${Date.now()}-${i}`,
          title: t.title,
          artist: t.artist,
          album: t.album || '',
          sources: {} // Will be resolved when added to queue
        })),
        source: 'ai',
        prompt: prompt,
        provider: { id: service.id, name: service.name },
        loading: false
      });
    } catch (error) {
      console.error('AI generation error:', error);
      setAiError(error.message || 'Failed to generate playlist');
      // Close sidebar on error, reopen prompt
      setResultsSidebar(null);
      setAiPromptOpen(true);
    } finally {
      setAiLoading(false);
    }
  };

  // Handle adding AI results to queue
  const handleAiAddToQueue = () => {
    if (!resultsSidebar?.tracks) return;
    addToQueue(resultsSidebar.tracks);
    setResultsSidebar(null);
    showToast(`Added ${resultsSidebar.tracks.length} tracks to queue`);
  };
  const addToQueue = (tracks, context = null) => {
    const tracksArray = Array.isArray(tracks) ? tracks : [tracks];

    // Tag tracks with context if provided
    const taggedTracks = context
      ? tracksArray.map(track => ({ ...track, _playbackContext: context }))
      : tracksArray;

    // Check if nothing is currently playing BEFORE updating queue
    const nothingPlaying = !currentTrackRef.current;

    setCurrentQueue(prev => [...prev, ...taggedTracks]);
    // Trigger queue animation
    setQueueAnimating(true);
    setTimeout(() => setQueueAnimating(false), 600);
    console.log(`âž• Added ${tracksArray.length} track(s) to queue`);

    // Resolve queue tracks with priority over page resolution
    // Filter to only tracks that need resolution
    const tracksNeedingResolution = tracksArray.filter(track =>
      !track.sources || Object.keys(track.sources).length === 0
    );
    if (tracksNeedingResolution.length > 0) {
      resolveQueueTracks(tracksNeedingResolution);
    }

    // If nothing is playing, auto-start the first track
    if (nothingPlaying && tracksArray.length > 0) {
      const firstTrack = tracksArray[0];
      console.log(`â–¶ï¸ Auto-starting playback: "${firstTrack.title}" by ${firstTrack.artist}`);
      // Remove from queue and play
      setCurrentQueue(prev => prev.slice(1));
      handlePlay(firstTrack);
    }
  };

  const handleSearchInput = (value) => {
    setSearchQuery(value);
    searchQueryRef.current = value;

    // Clear existing timeout
    if (searchTimeoutRef.current) {
      clearTimeout(searchTimeoutRef.current);
    }

    // Clear results if search cleared
    if (!value) {
      setSearchResults({ artists: [], albums: [], tracks: [], playlists: [] });
      setIsSearching(false);
      setDisplayLimits({ artists: 5, albums: 5, tracks: 8, playlists: 5 });
      return;
    }

    // Show loading state for responsive feel
    if (value.length >= 2) {
      setIsSearching(true);
    }

    // Reset pagination on new search
    setDisplayLimits({ artists: 5, albums: 5, tracks: 8, playlists: 5 });

    // Debounce search by 400ms
    searchTimeoutRef.current = setTimeout(() => {
      if (value.length >= 2) {
        performSearch(value);
      }
    }, 400);
  };

  // Load search history from electron-store
  const loadSearchHistory = async () => {
    try {
      const history = await window.electron.invoke('search-history-load');
      setSearchHistory(history || []);
    } catch (error) {
      console.error('Failed to load search history:', error);
    }
  };

  // Save a search history entry when user clicks a result
  const saveSearchHistory = async (query, selectedResult) => {
    if (!query || query.trim().length < 2) return;

    const entry = {
      query: query.trim(),
      selectedResult: selectedResult ? {
        type: selectedResult.type,
        id: selectedResult.id,
        name: selectedResult.name || selectedResult.title,
        artist: selectedResult.artist,
        imageUrl: selectedResult.imageUrl || selectedResult.albumArt
      } : null
    };

    try {
      await window.electron.invoke('search-history-save', entry);
      // Reload history to reflect update
      loadSearchHistory();
    } catch (error) {
      console.error('Failed to save search history:', error);
    }
  };

  // Clear search history (single entry or all)
  const clearSearchHistory = async (entryQuery = null) => {
    try {
      await window.electron.invoke('search-history-clear', entryQuery);
      loadSearchHistory();
    } catch (error) {
      console.error('Failed to clear search history:', error);
    }
  };

  // Load more results for a specific category
  const handleLoadMore = (category) => {
    setDisplayLimits(prev => ({
      ...prev,
      [category]: prev[category] + (category === 'tracks' ? 8 : 5)
    }));
  };

  // Re-rank search results using fuzzy matching + MusicBrainz popularity score
  const reRankResults = (items, query, nameKey = 'name') => {
    if (!items || items.length === 0 || !query) return items;

    // Configure Fuse.js for fuzzy matching
    const fuse = new Fuse(items, {
      keys: [nameKey],
      includeScore: true,
      threshold: 0.6,
      ignoreLocation: true,
      useExtendedSearch: false
    });

    const fuzzyResults = fuse.search(query);

    // Create a map of fuzzy scores (Fuse score is 0-1 where 0 is perfect match)
    const fuzzyScoreMap = new Map();
    fuzzyResults.forEach(result => {
      // Convert Fuse score (0=best, 1=worst) to 0-100 (100=best)
      fuzzyScoreMap.set(result.item, (1 - result.score) * 100);
    });

    // Score and sort all items
    return items
      .map(item => {
        const fuzzyScore = fuzzyScoreMap.get(item) || 0;
        const mbScore = item.score || 50; // MusicBrainz popularity score (0-100)
        // Blend: 60% fuzzy relevance, 40% popularity
        const finalScore = (fuzzyScore * 0.6) + (mbScore * 0.4);
        return { ...item, _finalScore: finalScore };
      })
      .sort((a, b) => b._finalScore - a._finalScore);
  };

  const resolveRecording = async (recording) => {
    const track = {
      id: recording.id,
      title: recording.title,
      artist: recording['artist-credit']?.[0]?.name || 'Unknown',
      duration: Math.floor((recording.length || 180000) / 1000), // Convert ms to seconds
      album: recording.releases?.[0]?.title || '',
      releaseId: recording.releases?.[0]?.id || null, // Store release ID for album art
      length: recording.length, // Keep original length in ms for confidence calculation
      sources: {}
    };

    console.log(`ðŸ” Resolving recording: ${track.artist} - ${track.title}`);

    // Query all enabled resolvers in priority order
    const enabledResolvers = resolverOrder
      .filter(id => activeResolvers.includes(id))
      .map(id => allResolvers.find(r => r.id === id))
      .filter(Boolean);

    // Parallel resolution with confidence scoring
    const resolverPromises = enabledResolvers.map(async (resolver) => {
      // Skip resolvers that can't resolve or can't play (no point resolving if we can't play)
      if (!resolver.capabilities.resolve || !resolver.play) return;

      try {
        const config = await getResolverConfig(resolver.id);
        const result = await resolver.resolve(track.artist, track.title, track.album, config);

        if (result) {
          track.sources[resolver.id] = {
            ...result,
            confidence: calculateConfidence(track, result)
          };
          console.log(`  âœ… ${resolver.name}: Found match (confidence: ${(track.sources[resolver.id].confidence * 100).toFixed(0)}%)`);
        }
      } catch (error) {
        console.error(`  âŒ ${resolver.name} resolve error:`, error);
      }
    });

    // Wait for all resolvers to complete
    await Promise.all(resolverPromises);

    if (Object.keys(track.sources).length > 0) {
      console.log(`âœ… Found ${Object.keys(track.sources).length} source(s) for: ${track.title}`);
    }

    return track;
  };

  // ResizeObserver to track search results container width for responsive item count
  useEffect(() => {
    const container = searchResultsContainerRef.current;
    if (!container) return;

    const resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        setSearchContainerWidth(entry.contentRect.width);
      }
    });

    resizeObserver.observe(container);
    // Set initial width
    setSearchContainerWidth(container.offsetWidth);

    return () => resizeObserver.disconnect();
  }, [activeView]); // Re-attach when view changes

  // Calculate how many items fit in a row based on container width and item size
  const getItemsPerRow = (minItemWidth, gap = 16) => {
    const availableWidth = searchContainerWidth;
    // Calculate how many items fit: (width + gap) * n - gap <= availableWidth
    // n <= (availableWidth + gap) / (minItemWidth + gap)
    return Math.max(1, Math.floor((availableWidth + gap) / (minItemWidth + gap)));
  };

  // Preprocess search query for MusicBrainz Lucene syntax
  // Maps user-friendly filters to MusicBrainz field names
  const preprocessQuery = (query, endpoint) => {
    let processed = query;

    // Map album: to appropriate field based on endpoint
    if (endpoint === 'release-group') {
      processed = processed.replace(/\balbum:/gi, 'releasegroup:');
    } else if (endpoint === 'recording') {
      processed = processed.replace(/\balbum:/gi, 'release:');
    } else if (endpoint === 'artist') {
      // For artist endpoint, album: doesn't make sense - strip it
      // Pattern handles both quoted values (album:"dark side") and unquoted (album:thriller)
      processed = processed.replace(/\balbum:(?:"[^"]*"|[^\s]*)/gi, '').trim();
    }

    // Map track:/song: to recording: (only for recording endpoint)
    if (endpoint === 'recording') {
      processed = processed.replace(/\b(track|song):/gi, 'recording:');
    } else {
      // Strip track:/song: from non-recording endpoints
      // Pattern handles both quoted values (track:"let it be") and unquoted (track:yesterday)
      processed = processed.replace(/\b(track|song):(?:"[^"]*"|[^\s]*)/gi, '').trim();
    }

    // Clean up any double spaces from removals
    processed = processed.replace(/\s+/g, ' ').trim();

    return processed;
  };

  const performSearch = async (query) => {
    // Cancel any in-flight request
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    abortControllerRef.current = new AbortController();
    const signal = abortControllerRef.current.signal;

    setIsSearching(true);
    const results = {
      artists: [],
      albums: [],
      tracks: [],
      playlists: []
    };

    try {
      const fetchOptions = {
        headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' },
        signal
      };

      // Search MusicBrainz for artists (fetch more than we initially display)
      const artistQuery = preprocessQuery(query, 'artist');
      const artistResponse = await fetch(
        `https://musicbrainz.org/ws/2/artist?query=${encodeURIComponent(artistQuery)}&fmt=json&limit=25`,
        fetchOptions
      );
      if (artistResponse.ok) {
        const data = await artistResponse.json();
        const rawArtists = data.artists || [];

        // Deduplicate artists by name (case-insensitive)
        const seenArtists = new Set();
        results.artists = rawArtists.filter(artist => {
          const name = artist.name?.toLowerCase() || '';
          if (seenArtists.has(name)) return false;
          seenArtists.add(name);
          return true;
        });

        // Re-rank artists with fuzzy matching + popularity
        results.artists = reRankResults(results.artists, query, 'name');
      }

      // Check if query is still current before continuing
      if (query !== searchQueryRef.current) return;

      // Search MusicBrainz for albums (release-groups)
      const albumQuery = preprocessQuery(query, 'release-group');
      const albumResponse = await fetch(
        `https://musicbrainz.org/ws/2/release-group?query=${encodeURIComponent(albumQuery)}&fmt=json&limit=30`,
        fetchOptions
      );
      if (albumResponse.ok) {
        const data = await albumResponse.json();
        const rawAlbums = data['release-groups'] || [];

        // Deduplicate albums by artist + title (case-insensitive)
        const seen = new Set();
        results.albums = rawAlbums.filter(album => {
          const artist = album['artist-credit']?.[0]?.name?.toLowerCase() || '';
          const title = album.title?.toLowerCase() || '';
          const key = `${artist}|${title}`;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        });

        // Re-rank albums with fuzzy matching + popularity
        results.albums = reRankResults(results.albums, query, 'title');
      }

      // Check if query is still current before continuing
      if (query !== searchQueryRef.current) return;

      // Search MusicBrainz for tracks (recordings)
      const trackQuery = preprocessQuery(query, 'recording');
      const trackResponse = await fetch(
        `https://musicbrainz.org/ws/2/recording?query=${encodeURIComponent(trackQuery)}&fmt=json&limit=50`,
        fetchOptions
      );
      if (trackResponse.ok) {
        const data = await trackResponse.json();
        const recordings = data.recordings || [];

        // Only resolve the first batch of tracks for performance
        // Rest will be resolved on-demand when "Load more" is clicked or when played
        const initialBatchSize = 8;
        const trackPromises = recordings.slice(0, initialBatchSize).map(recording => resolveRecording(recording));
        const resolvedTracks = await Promise.all(trackPromises);

        // Check if query is still current after track resolution
        if (query !== searchQueryRef.current) return;

        // Store unresolved tracks without sources (will resolve on-demand)
        const unresolvedTracks = recordings.slice(initialBatchSize).map(recording => ({
          id: recording.id,
          title: recording.title,
          artist: recording['artist-credit']?.[0]?.name || 'Unknown',
          duration: Math.floor((recording.length || 180000) / 1000),
          album: recording.releases?.[0]?.title || '',
          releaseId: recording.releases?.[0]?.id || null,
          length: recording.length,
          sources: {}
        }));

        results.tracks = [...resolvedTracks, ...unresolvedTracks];

        // Re-rank tracks with fuzzy matching + popularity
        results.tracks = reRankResults(results.tracks, query, 'title');
      }

      // Search local playlists
      results.playlists = playlists.filter(p =>
        p.title.toLowerCase().includes(query.toLowerCase())
      );

      // Final check: only update results if query is still current
      if (query !== searchQueryRef.current) return;

      setSearchResults(results);
      console.log('ðŸ” Search results:', results);

      // Fetch album art lazily in background (don't block search results)
      fetchSearchAlbumArt(results.albums, results.tracks);
    } catch (error) {
      // Ignore abort errors - these are expected when cancelling stale requests
      if (error.name === 'AbortError') {
        console.log('ðŸ” Search request cancelled (newer query in progress)');
        return;
      }
      console.error('Search error:', error);
    } finally {
      // Only clear loading state if this query is still current
      if (query === searchQueryRef.current) {
        setIsSearching(false);
      }
    }
  };

  // Fetch album art for search results (albums and tracks) - leverages albumArtCache
  const fetchSearchAlbumArt = async (albums, tracks) => {
    // Fetch album art for albums (release-groups need to be converted to releases first)
    for (const album of albums.slice(0, 10)) { // Limit to first 10 for performance
      if (album.albumArt) continue; // Skip if already has art

      const albumId = album.id;

      // Check albumArtCache first (keyed by release-group ID)
      const cachedArt = albumArtCache.current[albumId];
      if (cachedArt?.url) {
        setSearchResults(prev => ({
          ...prev,
          albums: prev.albums.map(a => a.id === albumId ? { ...a, albumArt: cachedArt.url } : a)
        }));
        continue;
      }

      try {
        // Get first release for this release-group
        const releaseResponse = await fetch(
          `https://musicbrainz.org/ws/2/release?release-group=${albumId}&status=official&fmt=json&limit=1`,
          { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }}
        );

        if (releaseResponse.ok) {
          const releaseData = await releaseResponse.json();
          if (releaseData.releases && releaseData.releases.length > 0) {
            const releaseId = releaseData.releases[0].id;

            // Check cache for release ID as well
            const cachedReleaseArt = albumArtCache.current[releaseId];
            if (cachedReleaseArt?.url) {
              // Also cache under release-group ID for future lookups
              albumArtCache.current[albumId] = cachedReleaseArt;
              setSearchResults(prev => ({
                ...prev,
                albums: prev.albums.map(a => a.id === albumId ? { ...a, albumArt: cachedReleaseArt.url } : a)
              }));
              continue;
            }

            // Fetch album art for this release
            const artResponse = await fetch(
              `https://coverartarchive.org/release/${releaseId}`,
              { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }}
            );

            if (artResponse.ok) {
              const artData = await artResponse.json();
              const frontCover = artData.images.find(img => img.front);
              if (frontCover) {
                const artUrl = frontCover.thumbnails?.['250'] || frontCover.thumbnails?.['500'] || frontCover.image;

                // Cache under both release-group ID and release ID
                const cacheEntry = { url: artUrl, timestamp: Date.now() };
                albumArtCache.current[albumId] = cacheEntry;
                albumArtCache.current[releaseId] = cacheEntry;

                // Update search results with new album art - create new object reference
                setSearchResults(prev => ({
                  ...prev,
                  albums: prev.albums.map(a => a.id === albumId ? { ...a, albumArt: artUrl } : a)
                }));
              }
            }
          }
        }
      } catch (error) {
        // Silently fail - album art is optional
      }
    }

    // Fetch album art for tracks (from their releases) - check cache first
    for (const track of tracks.slice(0, 10)) { // Limit to first 10 for performance
      if (track.albumArt || !track.releaseId) continue; // Skip if already has art or no release ID

      const trackId = track.id;
      const releaseId = track.releaseId;

      // Check albumArtCache first
      const cachedArt = albumArtCache.current[releaseId];
      if (cachedArt?.url) {
        setSearchResults(prev => ({
          ...prev,
          tracks: prev.tracks.map(t => t.id === trackId ? { ...t, albumArt: cachedArt.url } : t)
        }));
        continue;
      }

      try {
        const artResponse = await fetch(
          `https://coverartarchive.org/release/${releaseId}`,
          { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }}
        );

        if (artResponse.ok) {
          const artData = await artResponse.json();
          const frontCover = artData.images.find(img => img.front);
          if (frontCover) {
            const artUrl = frontCover.thumbnails?.['250'] || frontCover.thumbnails?.['500'] || frontCover.image;

            // Also cache it for future use
            albumArtCache.current[releaseId] = { url: artUrl, timestamp: Date.now() };

            // Update search results with new album art - create new object reference
            setSearchResults(prev => ({
              ...prev,
              tracks: prev.tracks.map(t => t.id === trackId ? { ...t, albumArt: artUrl } : t)
            }));
          }
        }
      } catch (error) {
        // Silently fail - album art is optional
      }
    }
  };

  // Cache utility functions
  const loadCacheFromStore = async () => {
    if (!window.electron?.store) return;

    try {
      // Load album art cache (keep full { url, timestamp } structure)
      const albumArtData = await window.electron.store.get('cache_album_art');
      if (albumArtData) {
        // Filter out expired entries
        const now = Date.now();
        const validEntries = Object.entries(albumArtData).filter(
          ([_, entry]) => entry && entry.timestamp && (now - entry.timestamp) < CACHE_TTL.albumArt
        );
        albumArtCache.current = Object.fromEntries(validEntries);
        console.log(`ðŸ“¦ Loaded ${validEntries.length} album art entries from cache`);
      }

      // Load artist data cache
      // Cache version 2: Added release-group categorization (live, compilation)
      const ARTIST_CACHE_VERSION = 2;
      const artistData = await window.electron.store.get('cache_artist_data');
      if (artistData) {
        // Filter out expired entries and entries from old cache versions
        const now = Date.now();
        const validEntries = Object.entries(artistData).filter(
          ([_, entry]) => entry.cacheVersion === ARTIST_CACHE_VERSION &&
                         now - entry.timestamp < CACHE_TTL.artistData
        );
        artistDataCache.current = Object.fromEntries(validEntries);
        const invalidated = Object.keys(artistData).length - validEntries.length;
        console.log(`ðŸ“¦ Loaded ${validEntries.length} artist data entries from cache${invalidated > 0 ? ` (${invalidated} invalidated due to version change)` : ''}`);
      }

      // Load track sources cache
      const trackSourcesData = await window.electron.store.get('cache_track_sources');
      if (trackSourcesData) {
        // Filter out expired entries
        const now = Date.now();
        const validEntries = Object.entries(trackSourcesData).filter(
          ([_, entry]) => now - entry.timestamp < CACHE_TTL.trackSources
        );
        trackSourcesCache.current = Object.fromEntries(validEntries);
        console.log(`ðŸ“¦ Loaded ${validEntries.length} track source entries from cache`);
      }

      // Load artist image cache
      const artistImageData = await window.electron.store.get('cache_artist_images');
      if (artistImageData) {
        // Filter out expired entries
        const now = Date.now();
        const validEntries = Object.entries(artistImageData).filter(
          ([_, entry]) => now - entry.timestamp < CACHE_TTL.artistImage
        );
        artistImageCache.current = Object.fromEntries(validEntries);
        console.log(`ðŸ“¦ Loaded ${validEntries.length} artist image entries from cache`);
      }

      // Load album-to-release-ID mapping cache (for Critic's Picks and track art lookups)
      const albumReleaseIdData = await window.electron.store.get('cache_album_release_ids');
      if (albumReleaseIdData) {
        albumToReleaseIdCache.current = albumReleaseIdData;
        console.log(`ðŸ“¦ Loaded ${Object.keys(albumReleaseIdData).length} album-to-release-ID mappings from cache`);
      }

      // Load playlist cover cache
      const playlistCoverData = await window.electron.store.get('cache_playlist_covers');
      if (playlistCoverData) {
        // Filter out expired entries
        const now = Date.now();
        const validEntries = Object.entries(playlistCoverData).filter(
          ([_, entry]) => now - entry.timestamp < CACHE_TTL.playlistCover
        );
        playlistCoverCache.current = Object.fromEntries(validEntries);
        console.log(`ðŸ“¦ Loaded ${validEntries.length} playlist cover entries from cache`);
      }

      // Load resolver settings
      const savedActiveResolvers = await window.electron.store.get('active_resolvers');
      const savedResolverOrder = await window.electron.store.get('resolver_order');

      if (savedActiveResolvers) {
        // Deduplicate in case of corrupted data
        const dedupedActive = [...new Set(savedActiveResolvers)];
        setActiveResolvers(dedupedActive);
        console.log(`ðŸ“¦ Loaded ${dedupedActive.length} active resolvers from storage`);
      }

      if (savedResolverOrder) {
        // Deduplicate in case of corrupted data (preserving order of first occurrence)
        const dedupedOrder = [...new Set(savedResolverOrder)];
        setResolverOrder(dedupedOrder);
        console.log(`ðŸ“¦ Loaded resolver order from storage (${dedupedOrder.length} resolvers)`);
      }

      // Load meta service configs (Last.fm, AI services, etc.)
      const savedMetaServiceConfigs = await window.electron.store.get('meta_service_configs');
      if (savedMetaServiceConfigs) {
        setMetaServiceConfigs(savedMetaServiceConfigs);
        console.log('ðŸ“¦ Loaded meta service configs:', Object.keys(savedMetaServiceConfigs).join(', '));
      }

      // Load friends from storage
      const savedFriends = await window.electron.store.get('friends');
      if (savedFriends && Array.isArray(savedFriends)) {
        // Migrate friends that have savedToCollection: false to true
        const migratedFriends = savedFriends.map(f =>
          f.savedToCollection === false ? { ...f, savedToCollection: true } : f
        );
        // Save migrated friends back if any were changed
        if (migratedFriends.some((f, i) => f !== savedFriends[i])) {
          await window.electron.store.set('friends', migratedFriends);
          console.log('ðŸ‘¥ Migrated friends to savedToCollection: true');
        }
        setFriends(migratedFriends);
        console.log(`ðŸ‘¥ Loaded ${migratedFriends.length} friends from storage`);
      }

      const savedPinnedFriendIds = await window.electron.store.get('pinnedFriendIds');
      if (savedPinnedFriendIds && Array.isArray(savedPinnedFriendIds)) {
        setPinnedFriendIds(savedPinnedFriendIds);
        console.log(`ðŸ“Œ Loaded ${savedPinnedFriendIds.length} pinned friends from storage`);
      }

      // Load volume normalization offsets
      const savedVolumeOffsets = await window.electron.store.get('resolver_volume_offsets');
      if (savedVolumeOffsets) {
        setResolverVolumeOffsets(prev => ({ ...prev, ...savedVolumeOffsets }));
        console.log('ðŸ“¦ Loaded volume normalization offsets');
      }

      // Load skip external prompt preference
      const savedSkipExternalPrompt = await window.electron.store.get('skip_external_prompt');
      if (savedSkipExternalPrompt !== undefined) {
        setSkipExternalPrompt(savedSkipExternalPrompt);
        console.log('ðŸ“¦ Loaded skip external prompt preference:', savedSkipExternalPrompt);
      }

      // Load skip unsaved friend warning preference
      const savedSkipUnsavedFriendWarning = await window.electron.store.get('skip_unsaved_friend_warning');
      if (savedSkipUnsavedFriendWarning !== undefined) {
        setSkipUnsavedFriendWarning(savedSkipUnsavedFriendWarning);
        console.log('ðŸ“¦ Loaded skip unsaved friend warning preference:', savedSkipUnsavedFriendWarning);
      }

      // Load remember queue preference
      const savedRememberQueue = await window.electron.store.get('remember_queue');
      if (savedRememberQueue !== undefined) {
        setRememberQueue(savedRememberQueue);
        console.log('ðŸ“¦ Loaded remember queue preference:', savedRememberQueue);
      }

      // Load playlists view mode preference
      const savedPlaylistsViewMode = await window.electron.store.get('playlists_view_mode');
      if (savedPlaylistsViewMode) {
        setPlaylistsViewMode(savedPlaylistsViewMode);
        console.log('ðŸ“¦ Loaded playlists view mode:', savedPlaylistsViewMode);
      }

      // Load AI include history preference
      const savedAiIncludeHistory = await window.electron.store.get('ai_include_history');
      if (savedAiIncludeHistory !== undefined) {
        setAiIncludeHistory(savedAiIncludeHistory);
        console.log('ðŸ“¦ Loaded AI include history preference:', savedAiIncludeHistory);
      }

      // Load saved queue if remember queue is enabled
      if (savedRememberQueue) {
        const savedQueue = await window.electron.store.get('saved_queue');
        if (savedQueue && Array.isArray(savedQueue) && savedQueue.length > 0) {
          // Move first track to playbar (paused), rest stays in queue
          const [firstTrack, ...remainingQueue] = savedQueue;
          setCurrentTrack(firstTrack);
          setCurrentQueue(remainingQueue);
          setIsPlaying(false); // Ensure it starts paused
          // Mark that this track needs explicit start (not just resume) when played
          trackNeedsExplicitStart.current = true;
          console.log(`ðŸ“¦ Restored queue: "${firstTrack.title}" ready in playbar, ${remainingQueue.length} tracks in queue`);
        }
        // Restore playback context
        const savedPlaybackContext = await window.electron.store.get('saved_playback_context');
        if (savedPlaybackContext) {
          setPlaybackContext(savedPlaybackContext);
          console.log(`ðŸ“¦ Restored playback context: ${savedPlaybackContext.type}`);
        }
      }

      // Load last active view
      const savedLastView = await window.electron.store.get('last_active_view');
      if (savedLastView) {
        const validViews = ['library', 'search', 'artist', 'playlists', 'playlist-view', 'discover', 'critics-picks', 'recommendations', 'history', 'settings', 'friends', 'friendHistory', 'new-releases'];
        if (validViews.includes(savedLastView.view)) {
          // For artist view, we need to restore the artist data
          if (savedLastView.view === 'artist' && savedLastView.artistName) {
            // Set the view first, then fetch artist data
            setActiveView('artist');
            setViewHistory(['library', 'artist']);
            // Restore artist page tab if saved
            if (savedLastView.artistPageTab) {
              setArtistPageTab(savedLastView.artistPageTab);
              // Mark that we're restoring state so useEffect doesn't reset the tab
              restoringStateRef.current = true;
            }
            // If a release/album was open, save it to load after artist data is fetched
            if (savedLastView.releaseId) {
              pendingReleaseLoad.current = {
                id: savedLastView.releaseId,
                title: savedLastView.releaseTitle,
                releaseType: savedLastView.releaseType,
                date: savedLastView.releaseDate
              };
            }
            // Fetch the artist data (this will populate currentArtist)
            setTimeout(() => fetchArtistData(savedLastView.artistName), 100);
            console.log(`ðŸ“¦ Restoring last view: artist (${savedLastView.artistName})${savedLastView.artistPageTab ? ` [${savedLastView.artistPageTab}]` : ''}${savedLastView.releaseTitle ? ` -> ${savedLastView.releaseTitle}` : ''}`);
          } else if (savedLastView.view === 'history') {
            // Restore history view with tab
            setActiveView('history');
            setViewHistory(['library', 'history']);
            const tab = savedLastView.historyTab || 'topTracks';
            setHistoryTab(tab);
            // Mark that we need to load data once metaServiceConfigs is ready
            pendingHistoryLoad.current = tab;
            console.log(`ðŸ“¦ Restoring last view: history [${tab}]`);
          } else if (savedLastView.view === 'settings') {
            // Restore settings view with tab
            setActiveView('settings');
            setViewHistory(['library', 'settings']);
            if (savedLastView.settingsTab) {
              setSettingsTab(savedLastView.settingsTab);
            }
            console.log(`ðŸ“¦ Restoring last view: settings [${savedLastView.settingsTab || 'installed'}]`);
          } else if (savedLastView.view === 'library') {
            // Restore library view with tab
            setActiveView('library');
            if (savedLastView.collectionTab) {
              setCollectionTab(savedLastView.collectionTab);
            }
            console.log(`ðŸ“¦ Restoring last view: library [${savedLastView.collectionTab || 'tracks'}]`);
          } else if (savedLastView.view === 'recommendations') {
            // Restore recommendations view with tab
            setActiveView('recommendations');
            setViewHistory(['library', 'recommendations']);
            if (savedLastView.recommendationsTab) {
              setRecommendationsTab(savedLastView.recommendationsTab);
            }
            console.log(`ðŸ“¦ Restoring last view: recommendations [${savedLastView.recommendationsTab || 'artists'}]`);
          } else if (savedLastView.view === 'playlist-view' && savedLastView.playlistId) {
            // Restore playlist detail view - need to find the playlist by ID
            setActiveView('playlist-view');
            setViewHistory(['library', 'playlists', 'playlist-view']);
            // Store pending playlist load - will be processed once playlists are loaded
            setPendingPlaylistLoad({
              id: savedLastView.playlistId,
              title: savedLastView.playlistTitle
            });
            console.log(`ðŸ“¦ Restoring last view: playlist-view (${savedLastView.playlistTitle})`);
          } else if (savedLastView.view === 'discover') {
            // Restore discover view - charts will be loaded by useEffect when cacheLoaded is true
            setActiveView('discover');
            setViewHistory(['library', 'discover']);
            console.log(`ðŸ“¦ Restoring last view: discover (Pop of the Tops)`);
          } else if (savedLastView.view === 'critics-picks') {
            // Restore critics-picks view - data will be loaded by useEffect when cacheLoaded is true
            setActiveView('critics-picks');
            setViewHistory(['library', 'critics-picks']);
            console.log(`ðŸ“¦ Restoring last view: critics-picks (Critical Darlings)`);
          } else if (savedLastView.view === 'friendHistory' && savedLastView.friendId) {
            // Restore friend history view - need to find the friend and load their data
            setActiveView('friendHistory');
            setViewHistory(['library', 'friendHistory']);
            // Store pending friend load - will be processed once friends are loaded
            setPendingFriendLoad({
              id: savedLastView.friendId,
              tab: savedLastView.friendHistoryTab || 'recent'
            });
            console.log(`ðŸ“¦ Restoring last view: friendHistory (${savedLastView.friendId})`);
          } else if (savedLastView.view !== 'artist') {
            // For other views, just set the view directly
            setActiveView(savedLastView.view);
            setViewHistory(['library', savedLastView.view]);
            console.log(`ðŸ“¦ Restoring last view: ${savedLastView.view}`);
          }
        } else {
          // No saved view or invalid - default to library
          setActiveView('library');
          setViewHistory(['library']);
        }
      } else {
        // No saved view data - default to library
        setActiveView('library');
        setViewHistory(['library']);
      }

      // Mark settings as loaded so save useEffect knows it's safe to save
      resolverSettingsLoaded.current = true;
      setCacheLoaded(true);
      console.log('ðŸ“¦ All caches loaded from persistent storage');
    } catch (error) {
      console.error('Failed to load cache from store:', error);
      // Even on error, mark as loaded so app can function
      resolverSettingsLoaded.current = true;
      setCacheLoaded(true);
      // Default to library view on error
      if (activeView === null) {
        setActiveView('library');
        setViewHistory(['library']);
      }
    }
  };

  const saveCacheToStore = async () => {
    if (!window.electron?.store) return;

    try {
      // Save album art cache (already has timestamps from when items were added)
      await window.electron.store.set('cache_album_art', albumArtCache.current);

      // Save artist data cache (already has timestamps)
      await window.electron.store.set('cache_artist_data', artistDataCache.current);

      // Save track sources cache (already has timestamps)
      await window.electron.store.set('cache_track_sources', trackSourcesCache.current);

      // Save artist image cache (already has timestamps)
      await window.electron.store.set('cache_artist_images', artistImageCache.current);

      // Save album-to-release-ID mapping cache
      await window.electron.store.set('cache_album_release_ids', albumToReleaseIdCache.current);

      // Save playlist cover cache
      await window.electron.store.set('cache_playlist_covers', playlistCoverCache.current);

      // Save resolver settings (use refs to ensure we have current values, not stale closure)
      await window.electron.store.set('active_resolvers', activeResolversRef.current);
      await window.electron.store.set('resolver_order', resolverOrderRef.current);

      // Save volume normalization offsets
      await window.electron.store.set('resolver_volume_offsets', resolverVolumeOffsets);

      // Save playlists view mode
      await window.electron.store.set('playlists_view_mode', playlistsViewMode);

      // Note: Meta service configs are saved immediately when changed, not in periodic save

      console.log('ðŸ’¾ Cache and resolver settings saved to persistent storage');
      console.log('   Saved resolver order:', resolverOrderRef.current);
    } catch (error) {
      console.error('Failed to save cache to store:', error);
    }
  };

  // Load cache on mount
  useEffect(() => {
    loadCacheFromStore();

    // Save cache periodically (every 5 minutes)
    const cacheInterval = setInterval(saveCacheToStore, 5 * 60 * 1000);

    // Save cache on unmount
    return () => {
      clearInterval(cacheInterval);
      saveCacheToStore();
    };
  }, []);

  // Save last active view when it changes
  useEffect(() => {
    if (!resolverSettingsLoaded.current || !window.electron?.store) return;

    const viewData = { view: activeView };
    // For artist view, also save the artist name so we can restore it
    if (activeView === 'artist' && currentArtist?.name) {
      viewData.artistName = currentArtist.name;
      viewData.artistPageTab = artistPageTab;
      // Also save current release/album if viewing one
      if (currentRelease) {
        viewData.releaseId = currentRelease.id;
        viewData.releaseTitle = currentRelease.title;
        viewData.releaseType = currentRelease.releaseType;
        viewData.releaseDate = currentRelease.date;
      }
    }
    // Save tab state for views with tabs
    if (activeView === 'history') {
      viewData.historyTab = historyTab;
    }
    if (activeView === 'settings') {
      viewData.settingsTab = settingsTab;
    }
    if (activeView === 'library') {
      viewData.collectionTab = collectionTab;
    }
    if (activeView === 'recommendations') {
      viewData.recommendationsTab = recommendationsTab;
    }
    if (activeView === 'playlist-view' && selectedPlaylist) {
      viewData.playlistId = selectedPlaylist.id;
      viewData.playlistTitle = selectedPlaylist.title;
    }
    if (activeView === 'friendHistory' && currentFriend) {
      viewData.friendId = currentFriend.id;
      viewData.friendHistoryTab = friendHistoryTab;
    }

    window.electron.store.set('last_active_view', viewData);
    console.log(`ðŸ“¦ Saved last view: ${activeView}${viewData.artistName ? ` (${viewData.artistName})` : ''}${viewData.releaseTitle ? ` -> ${viewData.releaseTitle}` : ''}${viewData.historyTab ? ` [${viewData.historyTab}]` : ''}${viewData.settingsTab ? ` [${viewData.settingsTab}]` : ''}${viewData.collectionTab ? ` [${viewData.collectionTab}]` : ''}${viewData.recommendationsTab ? ` [${viewData.recommendationsTab}]` : ''}${viewData.playlistTitle ? ` (${viewData.playlistTitle})` : ''}${viewData.friendId ? ` (friend: ${viewData.friendId})` : ''}`);
  }, [activeView, currentArtist?.name, artistPageTab, currentRelease?.id, historyTab, settingsTab, collectionTab, recommendationsTab, selectedPlaylist?.id, currentFriend?.id, friendHistoryTab]);

  // Load pending history data once cache is fully loaded
  useEffect(() => {
    const hasMetaService = metaServiceConfigs.lastfm?.username || metaServiceConfigs.listenbrainz?.username;
    if (cacheLoaded && pendingHistoryLoad.current && hasMetaService) {
      const tab = pendingHistoryLoad.current;
      pendingHistoryLoad.current = null; // Clear pending load
      console.log(`ðŸ“¦ Loading history data for restored tab: ${tab}`);
      if (tab === 'topTracks') loadTopTracks();
      else if (tab === 'topAlbums') loadTopAlbums();
      else if (tab === 'topArtists') loadTopArtists();
      else if (tab === 'recent') loadListeningHistory();
    }
  }, [cacheLoaded, metaServiceConfigs.lastfm?.username, metaServiceConfigs.listenbrainz?.username]);

  // Load pending release/album once artist data is available
  useEffect(() => {
    if (currentArtist && pendingReleaseLoad.current) {
      const release = pendingReleaseLoad.current;
      pendingReleaseLoad.current = null; // Clear pending load
      console.log(`ðŸ“¦ Loading release for restored view: ${release.title}`);
      // fetchReleaseData expects a release object and artist object
      fetchReleaseData(release, currentArtist);
    }
  }, [currentArtist]);

  // Load pending playlist once playlists are loaded
  useEffect(() => {
    if (pendingPlaylistLoad) {
      const playlist = playlists.find(p => p.id === pendingPlaylistLoad.id);
      if (playlist) {
        console.log(`ðŸ“¦ Loading playlist for restored view: ${playlist.title}`);
        setPendingPlaylistLoad(null); // Clear only when found
        // Use loadPlaylist to properly parse XSPF and populate playlistTracks
        // Skip navigation since we already set activeView to 'playlist-view'
        loadPlaylist(playlist, { skipNavigation: true });
      }
      // Don't clear pending or fall back yet - hosted playlists may still be loading
    }
  }, [playlists, pendingPlaylistLoad]);

  // Give up on pending playlist load after timeout (hosted playlists should be loaded by then)
  useEffect(() => {
    if (pendingPlaylistLoad) {
      const timer = setTimeout(() => {
        if (pendingPlaylistLoad) {
          console.log(`ðŸ“¦ Playlist not found after timeout: ${pendingPlaylistLoad.title}, falling back to playlists view`);
          setPendingPlaylistLoad(null);
          setActiveView('playlists');
          setViewHistory(['library', 'playlists']);
        }
      }, 5000); // 5 second timeout to allow hosted playlists to load
      return () => clearTimeout(timer);
    }
  }, [pendingPlaylistLoad]);

  // Load pending friend once friends are loaded
  useEffect(() => {
    if (pendingFriendLoad && friends.length > 0) {
      const friend = friends.find(f => f.id === pendingFriendLoad.id);
      if (friend) {
        console.log(`ðŸ“¦ Loading friend for restored view: ${friend.displayName}`);
        setCurrentFriend(friend);
        setFriendHistoryTab(pendingFriendLoad.tab || 'recent');
        setPendingFriendLoad(null);
        // Load the appropriate data
        if (pendingFriendLoad.tab === 'topTracks') loadFriendTopTracks(friend);
        else if (pendingFriendLoad.tab === 'topAlbums') loadFriendTopAlbums(friend);
        else if (pendingFriendLoad.tab === 'topArtists') loadFriendTopArtists(friend);
        else loadFriendRecentTracks(friend);
      } else {
        // Friend not found, fall back to library
        console.log(`ðŸ“¦ Friend not found: ${pendingFriendLoad.id}, falling back to library`);
        setPendingFriendLoad(null);
        setActiveView('library');
        setViewHistory(['library']);
      }
    }
  }, [friends, pendingFriendLoad]);

  // Fetch artist data and discography from MusicBrainz
  const fetchArtistData = async (artistName) => {
    console.log('Fetching artist data for:', artistName);

    // Clear any current release view when navigating to a new artist
    setCurrentRelease(null);

    // Only add to artist history if we're already on the artist view
    // This prevents search results from building up history
    if (activeView === 'artist' && currentArtist && currentArtist.name !== artistName) {
      setArtistHistory(prev => [...prev, currentArtist.name]);
    } else if (activeView !== 'artist') {
      // Clear artist history when coming from a different view (like search)
      setArtistHistory([]);
    }

    // Check cache first BEFORE clearing state
    const cacheKey = artistName.toLowerCase();
    const cachedData = artistDataCache.current[cacheKey];
    const now = Date.now();

    // Cache is valid if data exists and not expired
    // Note: Resolver settings don't affect artist/release metadata - tracks are re-resolved when loading a release
    const cacheValid = cachedData &&
                      (now - cachedData.timestamp) < CACHE_TTL.artistData;

    // Also check if artist image is in cache
    const normalizedName = artistName.trim().toLowerCase();
    const cachedImage = artistImageCache.current[normalizedName];
    const imageCacheValid = cachedImage && (now - cachedImage.timestamp) < CACHE_TTL.artistImage;

    if (cacheValid) {
      console.log('ðŸ“¦ Using cached artist data for:', artistName);

      // Set artist image immediately from cache if available
      if (imageCacheValid) {
        console.log('ðŸ“¦ Using cached artist image for:', artistName);
        setArtistImage(cachedImage.url);
        setArtistImagePosition(cachedImage.facePosition || 'center 25%');
      } else {
        // Clear image and fetch fresh
        setArtistImage(null);
        setArtistImagePosition('center 25%');
        getArtistImage(artistName).then(result => {
          if (result) {
            setArtistImage(result.url);
            setArtistImagePosition(result.facePosition || 'center 25%');
          }
        });
      }

      setCurrentArtist(cachedData.artist);

      // Pre-populate releases with cached album art
      const releasesWithCache = cachedData.releases.map(release => ({
        ...release,
        // Use cached URL if available, undefined if needs fetch (shows shimmer), null handled by fetchAlbumArtLazy
        albumArt: albumArtCache.current[release.id]?.url !== undefined
          ? albumArtCache.current[release.id]?.url
          : undefined
      }));

      setArtistReleases(releasesWithCache);
      setSmartReleaseTypeFilter(releasesWithCache);
      setLoadingArtist(false);
      navigateTo('artist');

      // Still fetch album art in background for any missing covers
      fetchAlbumArtLazy(cachedData.releases);
      return;
    }

    // No valid cache - set minimal artist data immediately so header/tabs show
    // while releases are loading
    setCurrentArtist({ name: artistName });
    setArtistReleases([]);
    setLoadingArtist(true);
    setArtistImage(null);
    setArtistImagePosition('center 25%');
    navigateTo('artist');

    if (cachedData && cachedData.resolverHash !== currentResolverHash) {
      console.log('ðŸ”„ Resolver settings changed, invalidating cache for:', artistName);
    }

    console.log('ðŸŒ Fetching fresh artist data from MusicBrainz...');

    try {
      // Step 1: Search for artist by name to get MBID
      // Helper function to fetch with retry on rate limit
      const fetchWithRetry = async (url, maxRetries = 3) => {
        for (let attempt = 0; attempt < maxRetries; attempt++) {
          const response = await fetch(url, {
            headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }
          });

          if (response.ok) {
            return response;
          }

          if (response.status === 503 || response.status === 429) {
            const delay = Math.pow(2, attempt) * 1000; // Exponential backoff: 1s, 2s, 4s
            console.log(`Rate limited (${response.status}), retrying in ${delay}ms... (attempt ${attempt + 1}/${maxRetries})`);
            await new Promise(resolve => setTimeout(resolve, delay));
          } else {
            // Non-retryable error
            return response;
          }
        }
        // Return last response after all retries exhausted
        return fetch(url, {
          headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }
        });
      };

      const searchResponse = await fetchWithRetry(
        `https://musicbrainz.org/ws/2/artist?query=${encodeURIComponent(artistName)}&fmt=json&limit=1`
      );

      if (!searchResponse.ok) {
        console.error('Artist search failed:', searchResponse.status);
        if (searchResponse.status === 503 || searchResponse.status === 429) {
          showConfirmDialog({
            type: 'error',
            title: 'Service Busy',
            message: 'MusicBrainz is temporarily unavailable. Please try again in a few seconds.'
          });
        }
        setLoadingArtist(false);
        return;
      }
      
      const searchData = await searchResponse.json();
      
      if (!searchData.artists || searchData.artists.length === 0) {
        console.log('Artist not found');
        showConfirmDialog({
          type: 'info',
          title: 'Artist Not Found',
          message: `"${artistName}" was not found in MusicBrainz`
        });
        setLoadingArtist(false);
        return;
      }
      
      const artist = searchData.artists[0];
      console.log('Found artist:', artist.name, 'MBID:', artist.id);

      // Set artist name immediately so header shows while releases load
      setCurrentArtist({
        name: artist.name,
        mbid: artist.id,
        country: artist.country,
        disambiguation: artist.disambiguation,
        type: artist.type
      });

      // Start fetching artist image early (non-blocking) with fallbacks
      (async () => {
        // Try Spotify first
        const spotifyResult = await getArtistImage(artistName);
        if (spotifyResult) {
          setArtistImage(spotifyResult.url);
          setArtistImagePosition(spotifyResult.facePosition || 'center 25%');
          return;
        }

        // Try Wikipedia fallback
        const wikiImage = await getWikipediaArtistImage(artist.id);
        if (wikiImage) {
          setArtistImage(wikiImage);
          setArtistImagePosition('center 25%');
          return;
        }

        // Try Discogs fallback
        const discogsImage = await getDiscogsArtistImage(artist.id, artistName);
        if (discogsImage) {
          setArtistImage(discogsImage);
          setArtistImagePosition('center 25%');
        }
      })();

      // Step 2: Fetch artist's release-groups (albums, EPs, singles) with staggered requests
      // Using release-groups instead of releases to avoid duplicates (each album appears once)
      // MusicBrainz rate limits to ~1 req/sec, so we stagger by 500ms to stay under limit
      const releaseTypes = ['album', 'ep', 'single'];

      const releasePromises = releaseTypes.map(async (type, index) => {
        // Stagger requests by 500ms each to avoid rate limiting
        if (index > 0) {
          await new Promise(resolve => setTimeout(resolve, index * 500));
        }
        try {
          const releasesResponse = await fetchWithRetry(
            `https://musicbrainz.org/ws/2/release-group?artist=${artist.id}&type=${type}&fmt=json&limit=100`
          );

          if (releasesResponse.ok) {
            const releasesData = await releasesResponse.json();
            if (releasesData['release-groups']) {
              return releasesData['release-groups'].map(rg => {
                // Determine release type based on primary-type and secondary-types
                const primaryType = (rg['primary-type'] || '').toLowerCase();
                const secondaryTypes = (rg['secondary-types'] || []).map(t => t.toLowerCase());

                // Categorize: studio album, live, compilation, or the primary type (ep/single)
                let releaseType = primaryType || type;
                if (secondaryTypes.includes('live')) {
                  releaseType = 'live';
                } else if (secondaryTypes.includes('compilation')) {
                  releaseType = 'compilation';
                } else if (primaryType === 'album' && secondaryTypes.length === 0) {
                  releaseType = 'album'; // Studio album (no secondary types)
                }

                return {
                  id: rg.id,
                  title: rg.title,
                  date: rg['first-release-date'] || null,
                  releaseType: releaseType,
                  secondaryTypes: secondaryTypes,
                  disambiguation: rg.disambiguation
                };
              });
            }
          }
          return [];
        } catch (error) {
          console.error(`Error fetching ${type} release-groups:`, error);
          return [];
        }
      });

      const releaseResults = await Promise.all(releasePromises);
      const allReleases = releaseResults.flat();

      console.log(`Found ${allReleases.length} release-groups for ${artist.name}`);

      // Sort by date (newest first)
      const uniqueReleases = [...allReleases].sort((a, b) => {
        const dateA = a.date || '0000';
        const dateB = b.date || '0000';
        return dateB.localeCompare(dateA);
      });
      
      const artistData = {
        name: artist.name,
        mbid: artist.id,
        country: artist.country,
        disambiguation: artist.disambiguation,
        type: artist.type
      };

      // Cache the artist data (version 2: release-group categorization)
      artistDataCache.current[cacheKey] = {
        artist: artistData,
        releases: uniqueReleases,
        timestamp: Date.now(),
        cacheVersion: 2
      };
      console.log('ðŸ’¾ Cached artist data for:', artistName);

      // Pre-populate releases with cached album art
      const releasesWithCache = uniqueReleases.map(release => ({
        ...release,
        // Use cached URL if available, undefined if needs fetch (shows shimmer)
        albumArt: albumArtCache.current[release.id]?.url !== undefined
          ? albumArtCache.current[release.id]?.url
          : undefined
      }));

      // Show page immediately (with cached album art if available)
      setArtistReleases(releasesWithCache);
      setSmartReleaseTypeFilter(releasesWithCache);
      setLoadingArtist(false);

      // Fetch album art in background (lazy loading) - only for releases without cache
      fetchAlbumArtLazy(uniqueReleases);
      
    } catch (error) {
      console.error('Error fetching artist data:', error);
      showConfirmDialog({
        type: 'error',
        title: 'Load Failed',
        message: 'Failed to load artist data. Please try again.'
      });
      setLoadingArtist(false);
    }
  };

  // Fetch release data (album/EP/single) with full track listing
  const fetchReleaseData = async (release, artist) => {
    setLoadingRelease(true);
    setCurrentRelease(null);
    // Collapse header smoothly when opening a release
    setIsHeaderCollapsed(true);

    // Helper to fetch with retry on rate limiting
    const fetchWithRetry = async (url, options, maxRetries = 3) => {
      for (let attempt = 0; attempt < maxRetries; attempt++) {
        const response = await fetch(url, options);
        if (response.status === 503 || response.status === 429) {
          // Rate limited - wait and retry
          const delay = Math.pow(2, attempt) * 1000; // 1s, 2s, 4s
          console.log(`Rate limited, retrying in ${delay}ms...`);
          await new Promise(resolve => setTimeout(resolve, delay));
          continue;
        }
        return response;
      }
      // Final attempt
      return fetch(url, options);
    };

    try {
      console.log('Fetching release data for:', release.title);

      // Try fetching as a direct release ID first (for artist discography)
      let releaseId = release.id;
      let releaseDetailsResponse = await fetchWithRetry(
        `https://musicbrainz.org/ws/2/release/${releaseId}?inc=recordings+artist-credits&fmt=json`,
        { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }}
      );

      // If that fails (404), it might be a release-group ID (from search)
      // Try converting release-group to release ID
      if (!releaseDetailsResponse.ok && releaseDetailsResponse.status === 404) {
        console.log('Not a release ID, trying as release-group...');

        const releaseGroupResponse = await fetchWithRetry(
          `https://musicbrainz.org/ws/2/release?release-group=${release.id}&status=official&fmt=json&limit=1`,
          { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }}
        );

        if (!releaseGroupResponse.ok) {
          throw new Error(`Failed to fetch release or release-group (HTTP ${releaseGroupResponse.status})`);
        }

        const releaseGroupData = await releaseGroupResponse.json();

        if (!releaseGroupData.releases || releaseGroupData.releases.length === 0) {
          throw new Error('No official releases found for this release-group');
        }

        // Use the first official release ID
        releaseId = releaseGroupData.releases[0].id;
        console.log('Converted release-group to release ID:', releaseId);

        // Fetch again with the converted ID
        releaseDetailsResponse = await fetchWithRetry(
          `https://musicbrainz.org/ws/2/release/${releaseId}?inc=recordings+artist-credits&fmt=json`,
          { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }}
        );
      }

      if (!releaseDetailsResponse.ok) {
        throw new Error('Release not found');
      }

      const releaseData = await releaseDetailsResponse.json();
      
      // Extract track listing from media
      const tracks = [];
      if (releaseData.media && releaseData.media.length > 0) {
        releaseData.media.forEach((medium, mediumIndex) => {
          if (medium.tracks) {
            medium.tracks.forEach(track => {
              tracks.push({
                position: track.position,
                title: track.title || track.recording?.title || 'Unknown Track',
                length: track.length,
                recording: track.recording,
                mediumIndex: mediumIndex + 1,
                mediumTitle: medium.title
              });
            });
          }
        });
      }
      
      // Try to fetch album art
      let albumArt = null;
      // Keep track of the original ID (release-group ID from artist page) for caching
      const originalReleaseGroupId = release.id;
      try {
        const artResponse = await fetch(
          `https://coverartarchive.org/release/${releaseId}`,
          { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }}
        );

        if (artResponse.ok) {
          const artData = await artResponse.json();
          const frontCover = artData.images.find(img => img.front);
          if (frontCover) {
            albumArt = frontCover.thumbnails?.['500'] || frontCover.image;

            // Cache the album art using the release-group ID so artist page can use it
            // Use a smaller thumbnail (250) for the cache like fetchAlbumArtLazy does
            const cacheUrl = frontCover.thumbnails?.['250'] || albumArt;
            albumArtCache.current[originalReleaseGroupId] = { url: cacheUrl, timestamp: Date.now() };

            // Update artistReleases so the art shows immediately when returning to artist page
            setArtistReleases(prev =>
              prev.map(r =>
                r.id === originalReleaseGroupId
                  ? { ...r, albumArt: cacheUrl }
                  : r
              )
            );

            // Update criticsPicks so the art shows when returning to Critics Picks page
            setCriticsPicks(prev =>
              prev.map(a => {
                // Match by release title (case-insensitive) and check artist contains match
                const titleMatch = a.title.toLowerCase() === release.title.toLowerCase();
                const artistMatch = artist?.name && a.artist.toLowerCase().includes(artist.name.toLowerCase());
                if (titleMatch && artistMatch) {
                  return { ...a, albumArt: cacheUrl };
                }
                return a;
              })
            );

            // Update charts (Pop of the Tops) so the art shows when returning
            setCharts(prev =>
              prev.map(a => {
                const titleMatch = a.title.toLowerCase() === release.title.toLowerCase();
                const artistMatch = artist?.name && a.artist.toLowerCase().includes(artist.name.toLowerCase());
                if (titleMatch && artistMatch) {
                  return { ...a, albumArt: cacheUrl };
                }
                return a;
              })
            );

            // Update topAlbums (History page) so the art shows when returning
            setTopAlbums(prev => ({
              ...prev,
              albums: prev.albums.map(a => {
                const titleMatch = a.name.toLowerCase() === release.title.toLowerCase();
                const artistMatch = artist?.name && a.artist.toLowerCase().includes(artist.name.toLowerCase());
                if (titleMatch && artistMatch) {
                  return { ...a, image: cacheUrl };
                }
                return a;
              })
            }));

            // Save cache to persist
            saveCacheToStore();
          }
        }
      } catch (error) {
        console.log('No album art found');
      }
      
      const releaseInfo = {
        id: releaseData.id,
        title: releaseData.title,
        artist: artist,
        date: releaseData.date || release.date,
        releaseType: release.releaseType,
        tracks: tracks,
        albumArt: albumArt,
        barcode: releaseData.barcode,
        country: releaseData.country,
        label: releaseData['label-info']?.[0]?.label?.name
      };
      
      console.log('Release data loaded:', tracks.length, 'tracks');
      setCurrentRelease(releaseInfo);
      setLoadingRelease(false);
      
      // Start resolving tracks in background
      resolveAllTracks(releaseInfo, artist.name);
      
    } catch (error) {
      console.error('Error fetching release data:', error);
      showConfirmDialog({
        type: 'error',
        title: 'Load Failed',
        message: 'Failed to load release data. Please try again.'
      });
      setLoadingRelease(false);
    }
  };

  // Prefetch release tracks on hover (for context menu "Add All to Queue")
  const prefetchReleaseTracks = async (release, artist) => {
    // Skip if already prefetched or currently loaded
    if (prefetchedReleases[release.id] || currentRelease?.id === release.id) {
      return;
    }

    try {
      console.log('ðŸ” Prefetching tracks for:', release.title);

      // Try fetching as a direct release ID first
      let releaseId = release.id;
      let releaseDetailsResponse = await fetch(
        `https://musicbrainz.org/ws/2/release/${releaseId}?inc=recordings+artist-credits&fmt=json`,
        { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }}
      );

      // If that fails (404), it might be a release-group ID
      if (!releaseDetailsResponse.ok && releaseDetailsResponse.status === 404) {
        const releaseGroupResponse = await fetch(
          `https://musicbrainz.org/ws/2/release?release-group=${release.id}&status=official&fmt=json&limit=1`,
          { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }}
        );

        if (!releaseGroupResponse.ok) return;

        const releaseGroupData = await releaseGroupResponse.json();
        if (!releaseGroupData.releases || releaseGroupData.releases.length === 0) return;

        releaseId = releaseGroupData.releases[0].id;
        releaseDetailsResponse = await fetch(
          `https://musicbrainz.org/ws/2/release/${releaseId}?inc=recordings+artist-credits&fmt=json`,
          { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }}
        );
      }

      if (!releaseDetailsResponse.ok) return;

      const releaseData = await releaseDetailsResponse.json();

      // Extract tracks
      const tracks = [];
      if (releaseData.media && releaseData.media.length > 0) {
        releaseData.media.forEach((medium) => {
          if (medium.tracks) {
            medium.tracks.forEach(track => {
              const trackId = `${artist?.name || 'unknown'}-${track.title || 'untitled'}-${release.title || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
              tracks.push({
                id: trackId,
                position: track.position,
                title: track.title || track.recording?.title || 'Unknown Track',
                length: track.length,
                recordingId: track.recording?.id,
                artist: artist?.name,
                album: release.title,
                albumArt: release.albumArt,
                sources: {}
              });
            });
          }
        });
      }

      // Cache the prefetched tracks
      setPrefetchedReleases(prev => ({
        ...prev,
        [release.id]: {
          tracks,
          title: release.title,
          albumArt: release.albumArt,
          artist: artist?.name
        }
      }));

      console.log(`âœ… Prefetched ${tracks.length} tracks for ${release.title}`);
    } catch (error) {
      console.error('Error prefetching release tracks:', error);
    }
  };

  // Prefetch search album tracks on hover (for context menu "Add All to Queue")
  const prefetchSearchAlbumTracks = (album) => {
    // Skip if already prefetched or in progress (use module-level Set to avoid stale closure)
    if (prefetchedReleasesRef.current[album.id] || prefetchInProgress.has(album.id)) {
      return;
    }

    // Mark as in progress SYNCHRONOUSLY before any async work
    prefetchInProgress.add(album.id);

    // Run the actual fetch asynchronously
    (async () => {
    try {
      const artistName = album['artist-credit']?.[0]?.name || 'Unknown Artist';

      // Search albums use release-group IDs, so fetch the first release from the group
      const releaseGroupResponse = await fetch(
        `https://musicbrainz.org/ws/2/release?release-group=${album.id}&status=official&fmt=json&limit=1`,
        { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }}
      );

      if (!releaseGroupResponse.ok) return;

      const releaseGroupData = await releaseGroupResponse.json();
      if (!releaseGroupData.releases || releaseGroupData.releases.length === 0) return;

      const releaseId = releaseGroupData.releases[0].id;

      // Fetch the release details with tracks
      const releaseDetailsResponse = await fetch(
        `https://musicbrainz.org/ws/2/release/${releaseId}?inc=recordings+artist-credits&fmt=json`,
        { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }}
      );

      if (!releaseDetailsResponse.ok) return;

      const releaseData = await releaseDetailsResponse.json();

      // Extract tracks
      const tracks = [];
      if (releaseData.media && releaseData.media.length > 0) {
        releaseData.media.forEach((medium) => {
          if (medium.tracks) {
            medium.tracks.forEach(track => {
              const trackId = `${artistName}-${track.title || 'untitled'}-${album.title || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
              // Get album art - could be on album.albumArt (quick search) or in searchAlbumArt state (detail view)
              const albumArt = album.albumArt || (typeof searchAlbumArt !== 'undefined' ? searchAlbumArt[album.id] : null) || null;
              tracks.push({
                id: trackId,
                position: track.position,
                title: track.title || track.recording?.title || 'Unknown Track',
                length: track.length,
                recordingId: track.recording?.id,
                artist: artistName,
                album: album.title,
                albumArt: albumArt,
                sources: {}
              });
            });
          }
        });
      }

      // Get album art - could be on album.albumArt (quick search) or in searchAlbumArt state (detail view)
      const cachedAlbumArt = album.albumArt || (typeof searchAlbumArt !== 'undefined' ? searchAlbumArt[album.id] : null) || null;

      // Cache the prefetched tracks using the release-group ID
      setPrefetchedReleases(prev => ({
        ...prev,
        [album.id]: {
          tracks,
          title: album.title,
          albumArt: cachedAlbumArt,
          artist: artistName
        }
      }));

    } catch (error) {
      // Silently fail - prefetch is optional optimization
    } finally {
      // Remove from in-progress set
      prefetchInProgress.delete(album.id);
    }
    })();
  };

  // Handle album click from search - fetch release data by release-group ID
  const handleAlbumClick = async (album) => {
    try {
      console.log('Fetching album from search:', album.title);

      // Get artist name from album
      const artistName = album['artist-credit']?.[0]?.name || 'Unknown Artist';

      // Create artist object
      const artist = {
        name: artistName,
        id: album['artist-credit']?.[0]?.artist?.id || null
      };

      // Mark that we're opening a release so header stays collapsed when artist changes
      openingReleaseRef.current = true;

      // Set artist context
      setCurrentArtist(artist);

      // Check for cached artist image first for instant display
      const normalizedName = artistName.trim().toLowerCase();
      const cachedImage = artistImageCache.current[normalizedName];
      const now = Date.now();
      const imageCacheValid = cachedImage && (now - cachedImage.timestamp) < CACHE_TTL.artistImage;

      if (imageCacheValid) {
        setArtistImage(cachedImage.url);
        setArtistImagePosition(cachedImage.facePosition || 'center 25%');
      } else {
        // Fetch artist image (don't clear current image to avoid gray flash)
        getArtistImage(artistName).then(result => {
          if (result) {
            setArtistImage(result.url);
            setArtistImagePosition(result.facePosition || 'center 25%');
          }
        });
      }

      // Start loading release FIRST (sets loadingRelease=true), then navigate
      // This prevents the header from flashing because loadingRelease=true hides it
      fetchReleaseData({
        id: album.id,
        title: album.title,
        releaseType: album['primary-type']?.toLowerCase() || 'album'
      }, artist);
      navigateTo('artist');
    } catch (error) {
      console.error('Error fetching album from search:', error);
      showConfirmDialog({
        type: 'error',
        title: 'Load Failed',
        message: 'Failed to load album. Please try again.'
      });
    }
  };

  // Handle playlist click from search
  const handlePlaylistClick = (playlist) => {
    loadPlaylist(playlist);
  };

  // Handle collection album click - search and navigate to album page
  const handleCollectionAlbumClick = async (album) => {
    try {
      console.log('Loading collection album:', album.title, 'by', album.artist);

      // Skip if already viewing this album (avoid unnecessary reloads)
      if (activeView === 'artist' && currentRelease?.title === album.title && currentArtist?.name === album.artist) {
        console.log('ðŸ“€ Already viewing album:', album.title);
        return;
      }

      // Show loading state immediately - set artist and navigate before search
      const artist = {
        name: album.artist,
        id: null
      };

      openingReleaseRef.current = true;
      setCurrentArtist(artist);
      setLoadingRelease(true);

      // Load artist image from cache if available
      const normalizedName = album.artist.trim().toLowerCase();
      const cachedImage = artistImageCache.current[normalizedName];
      const now = Date.now();
      const imageCacheValid = cachedImage && (now - cachedImage.timestamp) < CACHE_TTL.artistImage;

      if (imageCacheValid) {
        setArtistImage(cachedImage.url);
        setArtistImagePosition(cachedImage.facePosition || 'center 25%');
      } else {
        getArtistImage(album.artist).then(result => {
          if (result) {
            setArtistImage(result.url);
            setArtistImagePosition(result.facePosition || 'center 25%');
          }
        });
      }

      navigateTo('artist');

      // Search MusicBrainz for the album
      const searchQuery = encodeURIComponent(`${album.artist} ${album.title}`);
      const response = await fetch(
        `https://musicbrainz.org/ws/2/release-group?query=${searchQuery}&limit=5&fmt=json`,
        { headers: { 'User-Agent': 'Parachord/0.1 (https://parachord.com)' } }
      );

      if (!response.ok) throw new Error('Search failed');

      const data = await response.json();
      const results = data['release-groups'] || [];

      if (results.length === 0) {
        showToast('Album not found');
        setLoadingRelease(false);
        return;
      }

      // Find best match (prefer exact artist match)
      const match = results.find(r =>
        r['artist-credit']?.[0]?.name?.toLowerCase() === album.artist?.toLowerCase()
      ) || results[0];

      // Fetch release data (don't call handleAlbumClick to avoid duplicate state setting)
      fetchReleaseData({
        id: match.id,
        title: match.title,
        releaseType: match['primary-type']?.toLowerCase() || 'album'
      }, artist);
    } catch (error) {
      console.error('Error loading collection album:', error);
      showToast('Failed to load album');
      setLoadingRelease(false);
    }
  };

  // Validate cached sources in background and update if changed
  const validateCachedSources = async (track, artistName, cachedSources, cacheKey, trackKey) => {
    console.log(`ðŸ” Validating cached sources for: ${track.title}`);

    const freshSources = {};

    // Query enabled resolvers in priority order
    const enabledResolvers = resolverOrder
      .filter(id => activeResolvers.includes(id))
      .map(id => allResolvers.find(r => r.id === id))
      .filter(Boolean);

    const resolverPromises = enabledResolvers.map(async (resolver) => {
      // Skip resolvers that can't resolve or can't play (no point resolving if we can't play)
      if (!resolver.capabilities.resolve || !resolver.play) return;

      try {
        const config = await getResolverConfig(resolver.id);
        const result = await resolver.resolve(artistName, track.title, null, config);

        if (result) {
          freshSources[resolver.id] = {
            ...result,
            confidence: calculateConfidence(track, result)
          };
        }
      } catch (error) {
        console.error(`  âŒ ${resolver.name} validation error:`, error);
      }
    });

    await Promise.all(resolverPromises);

    // Compare with cached sources
    const cachedResolverIds = Object.keys(cachedSources).sort();
    const freshResolverIds = Object.keys(freshSources).sort();
    const sourcesChanged = JSON.stringify(cachedResolverIds) !== JSON.stringify(freshResolverIds);

    if (sourcesChanged) {
      console.log(`âš ï¸ Sources changed for: ${track.title}`);
      console.log(`  Old: ${cachedResolverIds.join(', ') || 'none'}`);
      console.log(`  New: ${freshResolverIds.join(', ') || 'none'}`);

      // Update cache with fresh data
      if (Object.keys(freshSources).length > 0) {
        trackSourcesCache.current[cacheKey] = {
          sources: freshSources,
          timestamp: Date.now(),
          resolverHash: getResolverSettingsHash()
        };

        // Update UI with fresh sources
        setTrackSources(prev => ({
          ...prev,
          [trackKey]: freshSources
        }));

        console.log(`âœ… Cache updated with ${Object.keys(freshSources).length} fresh source(s)`);
      } else {
        // No sources found - invalidate cache
        delete trackSourcesCache.current[cacheKey];
        console.log(`âŒ No sources found - cache invalidated`);
      }
    } else {
      console.log(`âœ… Sources still valid, refreshing timestamp`);
      // Sources unchanged, just refresh timestamp and resolver hash
      trackSourcesCache.current[cacheKey].timestamp = Date.now();
      trackSourcesCache.current[cacheKey].resolverHash = getResolverSettingsHash();
    }
  };

  // Resolve a single track across all active resolvers
  // isQueueResolution: when true, this is a priority queue resolution that won't yield
  const resolveTrack = async (track, artistName, forceRefresh = false, isQueueResolution = false) => {
    const trackKey = `${track.position}-${track.title}`;
    const cacheKey = `${artistName.toLowerCase()}|${track.title.toLowerCase()}|${track.position}`;
    const currentResolverHash = getResolverSettingsHash();

    // If this is a page resolution and queue resolution is active, skip to let queue take priority
    if (!isQueueResolution && queueResolutionActiveRef.current) {
      console.log(`â¸ï¸ Yielding page resolution for "${track.title}" - queue resolution has priority`);
      return;
    }

    // Check cache first (unless force refresh)
    const cachedData = trackSourcesCache.current[cacheKey];
    const now = Date.now();

    // Cache is valid if:
    // 1. Not forcing refresh
    // 2. Data exists and not expired
    // 3. Resolver settings haven't changed
    const cacheValid = !forceRefresh &&
                      cachedData &&
                      (now - cachedData.timestamp) < CACHE_TTL.trackSources &&
                      cachedData.resolverHash === currentResolverHash;

    // Check if there are active resolvers that weren't queried in the cached data
    const cachedResolverIds = cachedData ? Object.keys(cachedData.sources) : [];
    const missingResolvers = activeResolvers.filter(id =>
      !cachedResolverIds.includes(id) &&
      allResolvers.find(r => r.id === id)?.capabilities?.resolve
    );

    if (cachedData) {
      console.log(`  ðŸ” Cache check for "${track.title}": hash match=${cachedData.resolverHash === currentResolverHash}, missing resolvers: ${missingResolvers.join(', ') || 'none'}`);
    }

    if (cacheValid && missingResolvers.length === 0) {
      const cacheAge = Math.floor((now - cachedData.timestamp) / (1000 * 60 * 60)); // hours
      console.log(`ðŸ“¦ Using cached sources for: ${track.title} (age: ${cacheAge}h, sources: ${Object.keys(cachedData.sources).join(', ')})`);

      // Use cached sources immediately for fast UI
      setTrackSources(prev => ({
        ...prev,
        [trackKey]: cachedData.sources
      }));

      // Background validation: if cache is > 24 hours old, validate in background
      if (cacheAge >= 24) {
        console.log(`ðŸ”„ Cache > 24h old, validating in background...`);
        setTimeout(() => validateCachedSources(track, artistName, cachedData.sources, cacheKey, trackKey), 1000);
      }

      return;
    }

    // If cache is valid but missing resolvers, query only the missing ones
    if (cacheValid && missingResolvers.length > 0) {
      console.log(`ðŸ” Cache valid but missing ${missingResolvers.length} resolver(s), querying: ${missingResolvers.join(', ')}`);

      // Start with cached sources
      const sources = { ...cachedData.sources };

      // Query only missing resolvers
      const missingResolverInstances = missingResolvers
        .map(id => allResolvers.find(r => r.id === id))
        .filter(Boolean);

      const resolverPromises = missingResolverInstances.map(async (resolver) => {
        if (!resolver.capabilities.resolve || !resolver.play) return;

        try {
          const config = await getResolverConfig(resolver.id);
          console.log(`  ðŸ”Ž Trying ${resolver.id}...`);
          const result = await resolver.resolve(artistName, track.title, null, config);

          if (result) {
            sources[resolver.id] = {
              ...result,
              confidence: calculateConfidence(track, result)
            };
            console.log(`  âœ… ${resolver.name}: Found match (confidence: ${(sources[resolver.id].confidence * 100).toFixed(0)}%)`);
            if (resolver.id === 'localfiles') {
              console.log(`  ðŸ“ LocalFiles source structure:`, JSON.stringify(sources[resolver.id], null, 2));
            }
          } else {
            console.log(`  âšª ${resolver.name}: No match found`);
          }
        } catch (error) {
          console.error(`  âŒ ${resolver.name} resolve error:`, error);
        }
      });

      await Promise.all(resolverPromises);

      // Update state with combined sources
      setTrackSources(prev => ({
        ...prev,
        [trackKey]: sources
      }));

      // Update cache with new sources
      trackSourcesCache.current[cacheKey] = {
        sources: sources,
        timestamp: Date.now(),
        resolverHash: getResolverSettingsHash()
      };

      return;
    }

    if (cachedData && cachedData.resolverHash !== currentResolverHash) {
      console.log(`ðŸ”„ Resolver settings changed, re-resolving: ${track.title}`);
    }

    console.log(`ðŸ” Resolving: ${artistName} - ${track.title}${forceRefresh ? ' (forced refresh)' : ''}`);

    const sources = {};

    // Query enabled resolvers in priority order
    const enabledResolvers = resolverOrder
      .filter(id => activeResolvers.includes(id))
      .map(id => allResolvers.find(r => r.id === id))
      .filter(Boolean);

    console.log(`  ðŸ“‹ Active resolvers: ${activeResolvers.join(', ')}`);
    console.log(`  ðŸ“‹ Resolver order: ${resolverOrder.join(', ')}`);
    console.log(`  ðŸ“‹ Enabled resolvers: ${enabledResolvers.map(r => r.id).join(', ')}`);

    const resolverPromises = enabledResolvers.map(async (resolver) => {
      // Skip resolvers that can't resolve or can't play (no point resolving if we can't play)
      if (!resolver.capabilities.resolve || !resolver.play) {
        console.log(`  â­ï¸ Skipping ${resolver.id}: resolve=${resolver.capabilities.resolve}, play=${!!resolver.play}`);
        return;
      }

      try {
        const config = await getResolverConfig(resolver.id);
        console.log(`  ðŸ”Ž Trying ${resolver.id}...`);
        const result = await resolver.resolve(artistName, track.title, null, config);

        if (result) {
          sources[resolver.id] = {
            ...result,
            confidence: calculateConfidence(track, result)
          };
          console.log(`  âœ… ${resolver.name}: Found match (confidence: ${(sources[resolver.id].confidence * 100).toFixed(0)}%)`);
        } else {
          console.log(`  âšª ${resolver.name}: No match found`);
        }
      } catch (error) {
        console.error(`  âŒ ${resolver.name} resolve error:`, error);
      }
    });

    // Wait for all resolvers to complete
    await Promise.all(resolverPromises);

    // Update state with found sources
    if (Object.keys(sources).length > 0) {
      setTrackSources(prev => ({
        ...prev,
        [trackKey]: sources
      }));

      // Cache the resolved sources with resolver settings hash
      trackSourcesCache.current[cacheKey] = {
        sources: sources,
        timestamp: Date.now(),
        resolverHash: getResolverSettingsHash()
      };

      console.log(`âœ… Found ${Object.keys(sources).length} source(s) for: ${track.title} (cached)`);
    }
  };
  
  // Calculate confidence score for a match (0-1)
  const calculateConfidence = (originalTrack, foundTrack) => {
    // If the resolver already provided a confidence score, use it
    if (foundTrack.confidence && typeof foundTrack.confidence === 'number') {
      return foundTrack.confidence;
    }

    // Otherwise calculate based on title and duration match
    const originalTitle = originalTrack.title?.toLowerCase() || '';
    const foundTitle = foundTrack.title?.toLowerCase() || '';
    const titleMatch = originalTitle && foundTitle && originalTitle === foundTitle;
    const durationMatch = originalTrack.length && foundTrack.duration
      ? Math.abs(originalTrack.length / 1000 - foundTrack.duration) < 10 // Within 10 seconds
      : false;

    if (titleMatch && durationMatch) return 0.95;
    if (titleMatch) return 0.85;
    if (durationMatch) return 0.70;
    return 0.50;
  };

  // Resolve all tracks in a release
  const resolveAllTracks = async (release, artistName, forceRefresh = false) => {
    console.log(`ðŸ” Starting resolution for ${release.tracks.length} tracks...${forceRefresh ? ' (force refresh)' : ''}`);

    // Clear previous track sources only if force refresh
    if (forceRefresh) {
      setTrackSources({});
    }

    // Resolve tracks one at a time with small delay
    for (const track of release.tracks) {
      // Check if queue resolution has priority - if so, pause page resolution
      if (queueResolutionActiveRef.current) {
        console.log(`â¸ï¸ Pausing page resolution - queue resolution has priority`);
        // Wait for queue resolution to complete before continuing
        while (queueResolutionActiveRef.current) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
        console.log(`â–¶ï¸ Resuming page resolution`);
      }

      await resolveTrack(track, artistName, forceRefresh);
      // Small delay to avoid rate limiting
      await new Promise(resolve => setTimeout(resolve, 200));
    }

    console.log('âœ… Track resolution complete');
  };

  // Resolve queue tracks with priority over page resolution
  // This ensures queue tracks get resolved first when user adds tracks to queue
  const resolveQueueTracks = async (queueTracks) => {
    if (!queueTracks || queueTracks.length === 0) return;

    // Filter to tracks that need resolution (no sources or empty sources)
    const tracksNeedingResolution = queueTracks.filter(track =>
      !track.sources || Object.keys(track.sources).length === 0
    );

    if (tracksNeedingResolution.length === 0) {
      console.log('âœ… All queue tracks already have sources');
      return;
    }

    console.log(`ðŸŽ¯ Queue resolution: ${tracksNeedingResolution.length} tracks need sources (priority mode)`);

    // Set priority flag to pause page resolution
    queueResolutionActiveRef.current = true;

    try {
      // Get enabled resolvers
      const enabledResolvers = resolverOrder
        .filter(id => activeResolvers.includes(id))
        .map(id => allResolvers.find(r => r.id === id))
        .filter(Boolean);

      if (enabledResolvers.length === 0) {
        console.log('âš ï¸ No active resolvers for queue resolution');
        return;
      }

      // Resolve each queue track
      for (const track of tracksNeedingResolution) {
        const artistName = track.artist || 'Unknown Artist';
        const sources = {};

        console.log(`ðŸŽ¯ Queue resolving: ${artistName} - ${track.title}`);

        // Query all resolvers in parallel
        const resolverPromises = enabledResolvers.map(async (resolver) => {
          if (!resolver.capabilities?.resolve || !resolver.play) return;

          try {
            const config = await getResolverConfig(resolver.id);
            const result = await resolver.resolve(artistName, track.title, track.album || null, config);

            if (result) {
              sources[resolver.id] = {
                ...result,
                confidence: typeof result.confidence === 'number' ? result.confidence : 0.85
              };
              console.log(`  âœ… ${resolver.name}: Found match for queue track`);
            }
          } catch (error) {
            console.error(`  âŒ ${resolver.name} queue resolve error:`, error);
          }
        });

        await Promise.all(resolverPromises);

        // Update the queue track with resolved sources
        if (Object.keys(sources).length > 0) {
          setCurrentQueue(prevQueue =>
            prevQueue.map(queueTrack =>
              queueTrack.id === track.id
                ? { ...queueTrack, sources: { ...queueTrack.sources, ...sources } }
                : queueTrack
            )
          );
          console.log(`âœ… Queue track resolved: ${track.title} (${Object.keys(sources).length} sources)`);
        }

        // Small delay between tracks to avoid rate limiting
        await new Promise(resolve => setTimeout(resolve, 150));
      }

      console.log('âœ… Queue resolution complete');
    } finally {
      // Always clear priority flag
      queueResolutionActiveRef.current = false;
    }
  };

  // Resolve library tracks against active resolvers (for local files)
  const resolveLibraryTracks = async () => {
    if (!allResolvers || allResolvers.length === 0) return;
    if (!activeResolvers || activeResolvers.length === 0) return;

    // Merge local files and collection tracks for resolution
    const allTracks = [...library, ...collectionData.tracks];
    if (allTracks.length === 0) return;

    console.log(`ðŸ” Resolving ${allTracks.length} tracks (${library.length} local + ${collectionData.tracks.length} collection) against active resolvers...`);

    // Get enabled resolvers (excluding localfiles since tracks already have that source)
    const enabledResolvers = resolverOrder
      .filter(id => activeResolvers.includes(id) && id !== 'localfiles')
      .map(id => allResolvers.find(r => r.id === id))
      .filter(Boolean);

    if (enabledResolvers.length === 0) {
      console.log('ðŸ“š No external resolvers active, skipping library resolution');
      return;
    }

    // Mark all tracks that need resolving as "resolving"
    const tracksToResolve = allTracks.filter(track => {
      const existingSources = track.sources || {};
      return !Object.keys(existingSources).some(id => id !== 'localfiles');
    });

    if (tracksToResolve.length > 0) {
      setResolvingLibraryTracks(new Set(tracksToResolve.map(t => t.filePath || t.id)));
    }

    // Resolve tracks one at a time with delay to avoid rate limiting
    for (let i = 0; i < allTracks.length; i++) {
      const track = allTracks[i];
      const trackKey = track.filePath || track.id;
      const artistName = track.artist || 'Unknown Artist';
      const isCollectionTrack = !track.filePath;

      // Skip if track already has sources from external resolvers
      // Only consider valid resolver IDs (not numeric keys like "0" from corrupted data)
      const existingSources = track.sources || {};
      const validResolverIds = ['spotify', 'youtube', 'bandcamp', 'qobuz', 'soundcloud', 'localfiles'];
      const hasExternalSources = Object.keys(existingSources).some(id =>
        validResolverIds.includes(id) && id !== 'localfiles'
      );
      if (hasExternalSources) {
        console.log(`  â­ï¸ Skipping "${track.title}" - already has sources: ${Object.keys(existingSources).join(', ')}`);
        continue;
      }

      console.log(`  ðŸ”Ž Resolving: "${track.title}" by ${artistName}${track.album ? ` (${track.album})` : ''}`);
      const sources = { ...existingSources };

      // Query enabled resolvers
      const resolverPromises = enabledResolvers.map(async (resolver) => {
        if (!resolver.capabilities?.resolve || !resolver.play) return;

        try {
          const config = await getResolverConfig(resolver.id);
          const result = await resolver.resolve(artistName, track.title, track.album || null, config);

          if (result) {
            const confidence = calculateLibraryConfidence(track, result);
            sources[resolver.id] = {
              ...result,
              confidence
            };
            console.log(`  âœ… ${resolver.name}: Found match for "${track.title}" (${(confidence * 100).toFixed(0)}%)`);
          }
        } catch (error) {
          // Silently ignore resolver errors for library tracks
        }
      });

      await Promise.all(resolverPromises);

      // Store updated sources if we found new ones
      const hasNewSources = Object.keys(sources).length > Object.keys(existingSources).length;
      if (hasNewSources) {
        if (isCollectionTrack) {
          // Update collection data for this track and persist
          setCollectionData(prev => {
            const newData = {
              ...prev,
              tracks: prev.tracks.map(t => {
                if (t.id === trackKey) {
                  return { ...t, sources: sources };
                }
                return t;
              })
            };
            // Save async (don't block)
            saveCollection(newData);
            return newData;
          });
        } else {
          // Update library for this track
          setLibrary(prev => prev.map(t => {
            const tKey = t.filePath || t.id;
            if (tKey === trackKey) {
              return { ...t, sources: sources };
            }
            return t;
          }));
        }
      }

      // Mark this track as done resolving (after update if there were new sources)
      setResolvingLibraryTracks(prev => {
        const next = new Set(prev);
        next.delete(trackKey);
        return next;
      });

      // Small delay between tracks to avoid rate limiting
      await new Promise(resolve => setTimeout(resolve, 150));
    }

    // Clear any remaining resolving state
    setResolvingLibraryTracks(new Set());

    console.log('âœ… Library track resolution complete');
  };

  // Calculate confidence for library track matches
  const calculateLibraryConfidence = (originalTrack, foundTrack) => {
    const titleMatch = originalTrack.title?.toLowerCase() === foundTrack.title?.toLowerCase();
    const artistMatch = originalTrack.artist?.toLowerCase() === foundTrack.artist?.toLowerCase();
    const durationMatch = originalTrack.duration && foundTrack.duration
      ? Math.abs(originalTrack.duration - foundTrack.duration) < 10
      : false;

    if (titleMatch && artistMatch && durationMatch) return 0.98;
    if (titleMatch && artistMatch) return 0.90;
    if (titleMatch && durationMatch) return 0.85;
    if (titleMatch) return 0.75;
    return 0.50;
  };

  // Fetch album art suggestions from MusicBrainz/Cover Art Archive
  const fetchAlbumArtSuggestions = async (artist, album) => {
    if (!artist || !album) {
      setId3ArtSuggestions([]);
      return;
    }

    setId3ArtLoading(true);
    setId3ArtSuggestions([]);

    try {
      // Search MusicBrainz for releases matching artist and album
      const query = encodeURIComponent(`artist:"${artist}" AND release:"${album}"`);
      const searchUrl = `https://musicbrainz.org/ws/2/release?query=${query}&fmt=json&limit=5`;

      console.log('ðŸŽ¨ Searching MusicBrainz for album art:', artist, '-', album);

      const response = await fetch(searchUrl, {
        headers: {
          'User-Agent': 'Parachord/1.0.0 (https://github.com/parachord)'
        }
      });

      if (!response.ok) {
        throw new Error(`MusicBrainz search failed: ${response.status}`);
      }

      const data = await response.json();
      const releases = data.releases || [];

      console.log(`ðŸŽ¨ Found ${releases.length} releases`);

      // For each release, check if Cover Art Archive has artwork
      const artPromises = releases.slice(0, 5).map(async (release) => {
        try {
          const artUrl = `https://coverartarchive.org/release/${release.id}`;
          const artResponse = await fetch(artUrl, {
            headers: {
              'User-Agent': 'Parachord/1.0.0 (https://github.com/parachord)'
            }
          });

          if (artResponse.ok) {
            const artData = await artResponse.json();
            const frontArt = artData.images?.find(img => img.front) || artData.images?.[0];

            if (frontArt) {
              return {
                releaseId: release.id,
                releaseName: release.title,
                artistName: release['artist-credit']?.[0]?.name || artist,
                year: release.date?.split('-')[0] || '',
                thumbnailUrl: frontArt.thumbnails?.small || frontArt.thumbnails?.['250'] || frontArt.image,
                fullUrl: frontArt.image
              };
            }
          }
          return null;
        } catch (err) {
          // Silently fail for individual releases
          return null;
        }
      });

      const artResults = (await Promise.all(artPromises)).filter(Boolean);
      console.log(`ðŸŽ¨ Found ${artResults.length} releases with artwork`);

      setId3ArtSuggestions(artResults);
    } catch (error) {
      console.error('Error fetching album art suggestions:', error);
      setId3ArtSuggestions([]);
    } finally {
      setId3ArtLoading(false);
    }
  };

  // Auto-fetch album art suggestions when artist or album changes in ID3 editor
  useEffect(() => {
    // Only run when editor is open
    if (!id3EditorOpen) return;

    const artist = id3EditorValues.artist?.trim();
    const album = id3EditorValues.album?.trim();

    // Need both artist and album
    if (!artist || !album) {
      return;
    }

    // Create a key to track what we've already fetched
    const fetchKey = `${artist}|${album}`;
    if (fetchKey === id3ArtFetchKey) {
      return; // Already fetched for this combination
    }

    // Clear selection when search criteria change
    setId3SelectedArt(null);

    // Debounce the fetch
    const timer = setTimeout(() => {
      setId3ArtFetchKey(fetchKey);
      fetchAlbumArtSuggestions(artist, album);
    }, 500);

    return () => clearTimeout(timer);
  }, [id3EditorOpen, id3EditorValues.artist, id3EditorValues.album]);

  // Reset fetch key when editor closes
  useEffect(() => {
    if (!id3EditorOpen) {
      setId3ArtFetchKey('');
    }
  }, [id3EditorOpen]);

  // Effect to resolve library and collection tracks when they or resolvers change
  useEffect(() => {
    const totalTracks = library.length + collectionData.tracks.length;
    if (totalTracks > 0 && allResolvers.length > 0 && activeResolvers.length > 0) {
      // Delay to let UI render first, then resolve in background
      const timer = setTimeout(() => {
        resolveLibraryTracks();
      }, 1000);
      return () => clearTimeout(timer);
    }
  }, [library.length, collectionData.tracks.length, allResolvers.length, activeResolvers.length]);

  // Lazy load album art after page is displayed
  const fetchAlbumArtLazy = async (releases) => {
    console.log('Starting lazy album art loading...');
    let loadedCount = 0;
    let skippedCount = 0;
    
    // Fetch album art one at a time to update UI progressively
    for (const release of releases) {
      // Skip if already in cache
      if (albumArtCache.current[release.id]) {
        skippedCount++;
        continue;
      }
      
      try {
        let albumArtUrl = null;

        // First try release-group endpoint
        const artResponse = await fetch(
          `https://coverartarchive.org/release-group/${release.id}`,
          {
            headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }
          }
        );

        if (artResponse.ok) {
          const artData = await artResponse.json();
          const frontCover = artData.images.find(img => img.front);
          if (frontCover && frontCover.thumbnails && frontCover.thumbnails['250']) {
            albumArtUrl = frontCover.thumbnails['250'];
          }
        }

        // If release-group has no art, try getting a specific release and its art
        if (!albumArtUrl) {
          // Get the first release in this release-group
          const releaseResponse = await fetch(
            `https://musicbrainz.org/ws/2/release?release-group=${release.id}&status=official&fmt=json&limit=1`,
            { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' } }
          );

          if (releaseResponse.ok) {
            const releaseData = await releaseResponse.json();
            if (releaseData.releases && releaseData.releases.length > 0) {
              const specificReleaseId = releaseData.releases[0].id;

              // Try fetching art from the specific release
              const releaseArtResponse = await fetch(
                `https://coverartarchive.org/release/${specificReleaseId}`,
                { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' } }
              );

              if (releaseArtResponse.ok) {
                const releaseArtData = await releaseArtResponse.json();
                const frontCover = releaseArtData.images.find(img => img.front);
                if (frontCover && frontCover.thumbnails && frontCover.thumbnails['250']) {
                  albumArtUrl = frontCover.thumbnails['250'];
                }
              }
            }
          }
        }

        if (albumArtUrl) {
          // Store in cache with timestamp
          albumArtCache.current[release.id] = { url: albumArtUrl, timestamp: Date.now() };

          // Update just this release with album art
          setArtistReleases(prev =>
            prev.map(r =>
              r.id === release.id
                ? { ...r, albumArt: albumArtUrl }
                : r
            )
          );
          loadedCount++;
        } else {
          // No art found - set to null to show placeholder instead of shimmer
          setArtistReleases(prev =>
            prev.map(r =>
              r.id === release.id
                ? { ...r, albumArt: null }
                : r
            )
          );
        }
      } catch (error) {
        // On error, set to null to show placeholder
        setArtistReleases(prev =>
          prev.map(r =>
            r.id === release.id
              ? { ...r, albumArt: null }
              : r
          )
        );
      }
      
      // Small delay to avoid rate limiting
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    console.log(`Album art: ${loadedCount} loaded, ${skippedCount} from cache, ${releases.length - loadedCount - skippedCount} not found`);

    // Save cache immediately after loading album art so it persists on navigation
    if (loadedCount > 0) {
      saveCacheToStore();
    }
  };

  // Remove a resolver's sources from all track data (trackSources, playlistTracks, queue, library)
  const removeResolverSources = (resolverId) => {
    console.log(`ðŸ§¹ Removing sources for disabled/uninstalled resolver: ${resolverId}`);

    // Remove from trackSources (release/album view)
    setTrackSources(prev => {
      const updated = {};
      for (const [trackKey, sources] of Object.entries(prev)) {
        const { [resolverId]: removed, ...remainingSources } = sources;
        if (Object.keys(remainingSources).length > 0) {
          updated[trackKey] = remainingSources;
        }
      }
      return updated;
    });

    // Remove from playlistTracks
    setPlaylistTracks(prev =>
      prev.map(track => {
        if (track.sources && track.sources[resolverId]) {
          const { [resolverId]: removed, ...remainingSources } = track.sources;
          return { ...track, sources: remainingSources };
        }
        return track;
      })
    );

    // Remove from currentQueue
    setCurrentQueue(prev =>
      prev.map(track => {
        if (track.sources && track.sources[resolverId]) {
          const { [resolverId]: removed, ...remainingSources } = track.sources;
          return { ...track, sources: remainingSources };
        }
        return track;
      })
    );

    // Remove from library
    setLibrary(prev =>
      prev.map(track => {
        if (track.sources && track.sources[resolverId]) {
          const { [resolverId]: removed, ...remainingSources } = track.sources;
          return { ...track, sources: remainingSources };
        }
        return track;
      })
    );

    // Also clean up the cache
    if (trackSourcesCache.current) {
      for (const [cacheKey, cacheEntry] of Object.entries(trackSourcesCache.current)) {
        if (cacheEntry.sources && cacheEntry.sources[resolverId]) {
          const { [resolverId]: removed, ...remainingSources } = cacheEntry.sources;
          trackSourcesCache.current[cacheKey] = {
            ...cacheEntry,
            sources: remainingSources
          };
        }
      }
    }
  };

  const toggleResolver = (resolverId) => {
    const isCurrentlyActive = activeResolvers.includes(resolverId);

    // If disabling, remove the resolver's sources from all tracks
    if (isCurrentlyActive) {
      removeResolverSources(resolverId);
    }

    setActiveResolvers(prev =>
      prev.includes(resolverId)
        ? prev.filter(id => id !== resolverId)
        : [...prev, resolverId]
    );
  };

  // Drag and drop handlers for resolver reordering
  const handleResolverDragStart = (e, resolverId) => {
    setDraggedResolver(resolverId);
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/html', e.target);
  };

  const handleResolverDragOver = (e) => {
    if (e.preventDefault) {
      e.preventDefault();
    }
    e.dataTransfer.dropEffect = 'move';
    return false;
  };

  const handleResolverDragEnter = (e, resolverId) => {
    e.preventDefault();
    if (draggedResolver && draggedResolver !== resolverId) {
      setDragOverResolver(resolverId);
    }
  };

  const handleResolverDragLeave = (e) => {
    e.preventDefault();
    // Only clear if we're leaving the card entirely (not entering a child)
    const relatedTarget = e.relatedTarget;
    if (!relatedTarget || !e.currentTarget.contains(relatedTarget)) {
      setDragOverResolver(null);
    }
  };

  const handleResolverDrop = (e, targetResolverId) => {
    if (e.stopPropagation) {
      e.stopPropagation();
    }

    if (draggedResolver !== targetResolverId) {
      const newOrder = [...resolverOrder];
      const draggedIndex = newOrder.indexOf(draggedResolver);
      const targetIndex = newOrder.indexOf(targetResolverId);

      // Remove dragged item and insert at target position
      newOrder.splice(draggedIndex, 1);
      newOrder.splice(targetIndex, 0, draggedResolver);

      setResolverOrder(newOrder);
      console.log('Resolver order updated:', newOrder);
    }

    setDraggedResolver(null);
    setDragOverResolver(null);
    return false;
  };

  const handleResolverDragEnd = () => {
    setDraggedResolver(null);
    setDragOverResolver(null);
  };

  // Install new resolver from .axe file (hot-reload, no restart)
  const handleInstallResolver = async () => {
    if (!window.electron?.resolvers?.pickFile) {
      showConfirmDialog({
        type: 'error',
        title: 'Not Available',
        message: 'File picker not available. Make sure you are running in Electron.'
      });
      return;
    }

    console.log('ðŸ“¦ Opening file picker for resolver...');

    try {
      const result = await window.electron.resolvers.pickFile();

      if (!result) {
        console.log('User cancelled file picker');
        return;
      }

      if (result.error) {
        showConfirmDialog({
          type: 'error',
          title: 'File Error',
          message: result.error
        });
        return;
      }
      
      const { content, filename } = result;
      
      // Parse to validate and get info
      const axe = JSON.parse(content);
      const resolverName = axe.manifest.name;
      const resolverId = axe.manifest.id;
      
      // Check if already installed
      const existing = allResolvers.find(r => r.id === resolverId);
      if (existing) {
        const shouldOverwrite = confirm(
          `Resolver "${resolverName}" (${resolverId}) is already installed.\n\n` +
          `Do you want to overwrite it with the new version?`
        );
        if (!shouldOverwrite) {
          return;
        }
      }
      
      console.log(`Installing resolver: ${resolverName}`);
      
      // Install via IPC
      const installResult = await window.electron.resolvers.install(content, filename);
      
      if (!installResult.success) {
        showConfirmDialog({
          type: 'error',
          title: 'Installation Failed',
          message: installResult.error
        });
        return;
      }
      
      console.log(`âœ… Installed ${resolverName}`);
      
      // Hot-reload: Load the new resolver without restarting
      try {
                axe._filename = filename;
        const newResolverInstance = await resolverLoader.current.loadResolver(axe);
        
        if (existing) {
          // Replace existing resolver
          setLoadedResolvers(prev => prev.map(r => 
            r.id === resolverId ? newResolverInstance : r
          ));
          console.log(`ðŸ”„ Updated resolver: ${resolverName}`);
          showConfirmDialog({
            type: 'success',
            title: 'Resolver Updated',
            message: resolverName
          });
        } else {
          // Add new resolver
          setLoadedResolvers(prev => [...prev, newResolverInstance]);

          // Add to resolver order
          setResolverOrder(prev => [...prev, resolverId]);

          // Enable by default
          setActiveResolvers(prev => [...prev, resolverId]);

          console.log(`âž• Added resolver: ${resolverName}`);
          showConfirmDialog({
            type: 'success',
            title: 'Resolver Installed',
            message: resolverName
          });
        }
      } catch (error) {
        console.error('Failed to hot-load resolver:', error);
        showConfirmDialog({
          type: 'error',
          title: 'Load Failed',
          message: `Resolver installed but failed to load. Please restart the app.\n\n${error.message}`
        });
      }
    } catch (error) {
      console.error('Error installing resolver:', error);
      showConfirmDialog({
        type: 'error',
        title: 'Installation Error',
        message: error.message
      });
    }
  };

  // Uninstall resolver (permanently delete from disk)
  const handleUninstallResolver = async (resolverId) => {
    console.log('=== handleUninstallResolver called ===');
    console.log('  Resolver ID:', resolverId);
    console.log('  Loaded resolvers count (ref):', loadedResolversRef.current.length);
    console.log('  Loaded resolver IDs (ref):', loadedResolversRef.current.map(r => r.id));

    const resolver = loadedResolversRef.current.find(r => r.id === resolverId);

    if (!resolver) {
      console.error('âŒ Resolver not found:', resolverId);
      showConfirmDialog({
        type: 'error',
        title: 'Resolver Not Found',
        message: `Resolver "${resolverId}" not found. This might be a bug.`
      });
      return;
    }

    console.log('  Found resolver:', resolver.name);

    const confirmMessage = `Are you sure you want to uninstall "${resolver.name}"?\n\nThis will permanently remove the resolver from your system.`;

    const shouldUninstall = confirm(confirmMessage);

    if (!shouldUninstall) {
      return;
    }

    console.log(`ðŸ—‘ï¸ Uninstalling resolver: ${resolver.name}`);

    try {
      // Delete the resolver file from disk
      const result = await window.electron.resolvers.uninstall(resolverId);

      if (!result.success) {
        showConfirmDialog({
          type: 'error',
          title: 'Uninstall Failed',
          message: result.error
        });
        return;
      }

      console.log(`âœ… Uninstalled ${resolver.name}`);

      // Remove the resolver's sources from all displayed tracks
      removeResolverSources(resolverId);

      // Hot-reload: Remove from state without restarting
      setLoadedResolvers(prev => prev.filter(r => r.id !== resolverId));
      setResolverOrder(prev => prev.filter(id => id !== resolverId));
      setActiveResolvers(prev => prev.filter(id => id !== resolverId));

      showConfirmDialog({
        type: 'success',
        title: 'Resolver Uninstalled',
        message: resolver.name
      });
    } catch (error) {
      console.error('Error uninstalling resolver:', error);
      showConfirmDialog({
        type: 'error',
        title: 'Uninstall Error',
        message: error.message
      });
    }
  };

  // Marketplace functions
  const loadMarketplaceManifest = async () => {
    if (!window.electron?.resolvers?.getMarketplaceManifest) {
      console.error('Marketplace not available');
      return;
    }

    setMarketplaceLoading(true);

    try {
      const result = await window.electron.resolvers.getMarketplaceManifest();

      if (result.success) {
        setMarketplaceManifest(result.manifest);
        console.log(`âœ… Loaded marketplace with ${result.manifest.resolvers.length} resolvers`);
      } else {
        console.error('Failed to load marketplace:', result.error);
        setMarketplaceManifest({ version: '1.0.0', resolvers: [] });
      }
    } catch (error) {
      console.error('Marketplace load error:', error);
      setMarketplaceManifest({ version: '1.0.0', resolvers: [] });
    } finally {
      setMarketplaceLoading(false);
    }
  };

  // Install resolver from marketplace
  const handleInstallFromMarketplace = async (marketplaceResolver) => {
    const { id, name, downloadUrl } = marketplaceResolver;

    // Check if already installing
    if (installingResolvers.has(id)) {
      return;
    }

    setInstallingResolvers(prev => new Set(prev).add(id));

    console.log(`ðŸ“¦ Installing ${name} from marketplace...`);

    try {
      // Download resolver from URL
      const downloadResult = await window.electron.resolvers.downloadResolver(downloadUrl);

      if (!downloadResult.success) {
        showConfirmDialog({
          type: 'error',
          title: 'Download Failed',
          message: `Failed to download ${name}: ${downloadResult.error}`
        });
        return;
      }

      const { content, filename, resolver: axe } = downloadResult;
      const resolverName = axe.manifest.name;
      const resolverId = axe.manifest.id;

      // Check if already installed
      const existing = allResolvers.find(r => r.id === resolverId);
      if (existing) {
        const shouldOverwrite = confirm(
          `Resolver "${resolverName}" is already installed.\n\n` +
          `Installed version: ${existing.version}\n` +
          `Marketplace version: ${axe.manifest.version}\n\n` +
          `Do you want to update it?`
        );
        if (!shouldOverwrite) {
          return;
        }
      }

      // Install via IPC (reuse existing install handler)
      const installResult = await window.electron.resolvers.install(content, filename);

      if (!installResult.success) {
        showConfirmDialog({
          type: 'error',
          title: 'Installation Failed',
          message: `Failed to install ${resolverName}: ${installResult.error}`
        });
        return;
      }

      // Hot-reload
            axe._filename = filename;
      const newResolverInstance = await resolverLoader.current.loadResolver(axe);

      if (existing) {
        setLoadedResolvers(prev => prev.map(r =>
          r.id === resolverId ? newResolverInstance : r
        ));
        showConfirmDialog({
          type: 'success',
          title: 'Resolver Updated',
          message: resolverName
        });
      } else {
        setLoadedResolvers(prev => [...prev, newResolverInstance]);
        setResolverOrder(prev => [...prev, resolverId]);
        setActiveResolvers(prev => [...prev, resolverId]);
        showConfirmDialog({
          type: 'success',
          title: 'Resolver Installed',
          message: resolverName
        });
      }
    } catch (error) {
      console.error('Marketplace install error:', error);
      showConfirmDialog({
        type: 'error',
        title: 'Installation Failed',
        message: error.message
      });
    } finally {
      setInstallingResolvers(prev => {
        const next = new Set(prev);
        next.delete(id);
        return next;
      });
    }
  };

  // Load marketplace when settings page opens to marketplace tab
  useEffect(() => {
    if (activeView === 'settings' && settingsTab === 'marketplace' && !marketplaceManifest) {
      loadMarketplaceManifest();
    }
  }, [activeView, settingsTab, marketplaceManifest]);

  // Playlist functions
  const parseXSPF = (xspfString) => {
    try {
      const parser = new DOMParser();
      const xml = parser.parseFromString(xspfString, 'text/xml');

      // Parse date from XSPF (ISO 8601 format)
      const dateStr = xml.querySelector('playlist > date')?.textContent;
      const parsedDate = dateStr ? new Date(dateStr).getTime() : null;

      const playlist = {
        title: xml.querySelector('playlist > title')?.textContent || 'Untitled Playlist',
        creator: xml.querySelector('playlist > creator')?.textContent || 'Unknown',
        date: parsedDate, // Original creation date from XSPF
        tracks: []
      };
      
      const trackElements = xml.querySelectorAll('track');
      trackElements.forEach(trackEl => {
        const track = {
          title: trackEl.querySelector('title')?.textContent || 'Unknown Track',
          artist: trackEl.querySelector('creator')?.textContent || 'Unknown Artist',
          album: trackEl.querySelector('album')?.textContent || '',
          duration: parseInt(trackEl.querySelector('duration')?.textContent || '0') / 1000, // Convert ms to seconds
          location: trackEl.querySelector('location')?.textContent || ''
        };
        playlist.tracks.push(track);
      });
      
      return playlist;
    } catch (error) {
      console.error('Error parsing XSPF:', error);
      return null;
    }
  };

  // Generate XSPF content from playlist object
  const generateXSPF = (playlist) => {
    const escapeXml = (str) => {
      if (!str) return '';
      return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&apos;');
    };

    const tracks = (playlist.tracks || []).map(track => `    <track>
      <title>${escapeXml(track.title)}</title>
      <creator>${escapeXml(track.artist)}</creator>
      <album>${escapeXml(track.album || '')}</album>
      <duration>${Math.round((track.duration || 0) * 1000)}</duration>
    </track>`).join('\n');

    const date = playlist.createdAt ? new Date(playlist.createdAt).toISOString() : new Date().toISOString();

    return `<?xml version="1.0" encoding="UTF-8"?>
<playlist version="1" xmlns="http://xspf.org/ns/0/">
  <title>${escapeXml(playlist.title)}</title>
  <creator>${escapeXml(playlist.creator || 'Parachord')}</creator>
  <date>${date}</date>
  <trackList>
${tracks}
  </trackList>
</playlist>`;
  };

  // Open save dialog for AI playlist
  const handleAiSavePlaylist = () => {
    if (!resultsSidebar?.tracks) return;

    // Set default name based on prompt
    const defaultName = resultsSidebar.prompt
      ? resultsSidebar.prompt.substring(0, 50)
      : 'AI Generated Playlist';

    setAiSavePlaylistName(defaultName);
    setAiSaveDialogOpen(true);
  };

  // Actually save the AI playlist with the chosen name
  const handleAiSavePlaylistConfirm = async () => {
    if (!resultsSidebar?.tracks || !aiSavePlaylistName.trim()) return;

    const playlistId = `ai-${Date.now()}`;
    const providerName = resultsSidebar.provider?.name || 'AI';

    const newPlaylist = {
      id: playlistId,
      title: aiSavePlaylistName.trim(),
      creator: providerName,
      tracks: resultsSidebar.tracks,
      createdAt: Date.now(),
      addedAt: Date.now(),
      lastModified: Date.now()
    };

    // Add to playlists state (prepend so it appears at top immediately)
    setPlaylists(prev => [newPlaylist, ...prev]);

    // Save to unified local storage (electron-store)
    await savePlaylistToStore(newPlaylist);

    // Close dialogs
    setAiSaveDialogOpen(false);
    setResultsSidebar(null);
    showToast(`Saved playlist: ${aiSavePlaylistName.trim()}`);
  };

  // Save playlist to local storage (electron-store)
  const savePlaylistToStore = async (playlist) => {
    if (!playlist || !playlist.id) return;

    // Don't save hosted playlists (they come from URLs)
    if (playlist.sourceUrl) {
      console.log(`â­ï¸ Skipping save for hosted playlist: ${playlist.title}`);
      return;
    }

    // Invalidate playlist cover cache when tracks change
    // This ensures the 2x2 cover grid regenerates with new tracks
    if (playlistCoverCache.current[playlist.id]) {
      delete playlistCoverCache.current[playlist.id];
      // Also clear from UI state so it re-fetches
      setAllPlaylistCovers(prev => {
        const updated = { ...prev };
        delete updated[playlist.id];
        return updated;
      });
    }

    try {
      // Generate XSPF content for the playlist
      const xspfContent = generateXSPF(playlist);

      // Create playlist data object for storage
      const playlistData = {
        id: playlist.id,
        title: playlist.title,
        creator: playlist.creator,
        tracks: playlist.tracks,
        xspf: xspfContent,
        createdAt: playlist.createdAt || Date.now(),
        addedAt: playlist.addedAt || Date.now(),
        lastModified: Date.now(),
        isAiPlaylist: playlist.isAiPlaylist || false
      };

      const result = await window.electron.playlists.save(playlistData);

      if (result.success) {
        console.log(`ðŸ’¾ Saved playlist: ${playlist.title}`);
      } else {
        console.error(`âŒ Failed to save playlist: ${result.error}`);
      }
    } catch (error) {
      console.error(`âŒ Error saving playlist:`, error);
    }
  };

  // Parse Critic's Picks RSS feed
  const parseCriticsPicksRSS = (rssString) => {
    try {
      const parser = new DOMParser();
      const xml = parser.parseFromString(rssString, 'text/xml');

      const items = xml.querySelectorAll('item');
      const albums = [];

      items.forEach(item => {
        const titleText = item.querySelector('title')?.textContent || '';
        const link = item.querySelector('link')?.textContent || '';
        const descriptionRaw = item.querySelector('description')?.textContent || '';
        const pubDate = item.querySelector('pubDate')?.textContent || '';

        // Extract Spotify URL from description before stripping HTML
        const spotifyMatch = descriptionRaw.match(/href="(https:\/\/open\.spotify\.com\/album\/[^"]+)"/);
        const spotifyUrl = spotifyMatch ? spotifyMatch[1] : null;

        // Strip HTML tags and remove any remaining Spotify URLs from the synopsis
        let description = descriptionRaw.replace(/<[^>]*>/g, '').trim();
        // Remove plain text Spotify URLs that might remain after HTML stripping
        description = description.replace(/https:\/\/open\.spotify\.com\/album\/\S+/g, '').trim();

        // Parse "Album by Artist" format
        // Examples: "Valentine by Courtney Marie Andrews", "Tragic Magic by Julianna Barwick & Mary Lattimore"
        let artist = '';
        let album = '';

        const byMatch = titleText.match(/^(.+?)\s+by\s+(.+)$/i);
        if (byMatch) {
          album = byMatch[1].trim();
          artist = byMatch[2].trim();
        } else {
          // Fallback: use full title as album name
          artist = 'Unknown Artist';
          album = titleText;
        }

        if (album) {
          albums.push({
            id: `critics-${artist}-${album}`.toLowerCase().replace(/[^a-z0-9-]/g, '-'),
            artist: artist,
            title: album,
            link: link,
            description: description,
            spotifyUrl: spotifyUrl,
            pubDate: pubDate ? new Date(pubDate) : null,
            albumArt: undefined // undefined = loading, null = no art found, string = art URL
          });
        }
      });

      return albums;
    } catch (error) {
      console.error('Error parsing Critic\'s Picks RSS:', error);
      return [];
    }
  };

  // Parse Apple Music Charts JSON feed
  const parseChartsJSON = (data) => {
    try {
      const results = data?.feed?.results || [];
      const albums = [];

      results.forEach((item, index) => {
        const album = item.name || '';
        const artist = item.artistName || '';
        const artworkUrl = item.artworkUrl100 || '';
        const link = item.url || '';
        const genres = (item.genres || [])
          .map(g => g.name)
          .filter(g => g !== 'Music');

        if (album && artist) {
          albums.push({
            id: `charts-${index}-${artist}-${album}`.toLowerCase().replace(/[^a-z0-9-]/g, '-'),
            artist: artist,
            title: album,
            rank: index + 1,
            link: link,
            genres: genres,
            pubDate: item.releaseDate ? new Date(item.releaseDate) : null,
            // Use artwork URL directly from JSON (higher quality available)
            albumArt: artworkUrl ? artworkUrl.replace('100x100bb', '300x300bb') : null
          });
        }
      });

      return albums;
    } catch (error) {
      console.error('Error parsing Charts JSON:', error);
      return [];
    }
  };

  // Parse Apple Music Charts RSS feed (legacy fallback)
  const parseChartsRSS = (rssString) => {
    try {
      const parser = new DOMParser();
      const xml = parser.parseFromString(rssString, 'text/xml');

      const items = xml.querySelectorAll('item');
      const albums = [];

      items.forEach((item, index) => {
        const titleText = item.querySelector('title')?.textContent || '';
        const link = item.querySelector('link')?.textContent || '';
        const description = item.querySelector('description')?.textContent || '';
        const pubDate = item.querySelector('pubDate')?.textContent || '';

        // Get artist from category with domain attribute
        const categories = item.querySelectorAll('category');
        let artist = '';
        let genres = [];

        categories.forEach(cat => {
          if (cat.getAttribute('domain')) {
            // Category with domain is the artist link
            artist = cat.textContent || '';
          } else {
            // Categories without domain are genres
            genres.push(cat.textContent);
          }
        });

        // Title format is "Album Name - Artist Name"
        // But we already have artist from category, so extract album from title
        let album = titleText;
        if (titleText.includes(' - ') && artist) {
          album = titleText.replace(` - ${artist}`, '').trim();
        }

        // Fallback: if no artist from category, try parsing from title
        if (!artist && titleText.includes(' - ')) {
          const parts = titleText.split(' - ');
          album = parts[0].trim();
          artist = parts.slice(1).join(' - ').trim();
        }

        if (album && artist) {
          albums.push({
            id: `charts-${index}-${artist}-${album}`.toLowerCase().replace(/[^a-z0-9-]/g, '-'),
            artist: artist,
            title: album,
            rank: index + 1,
            link: link,
            genres: genres.filter(g => g !== 'Music'),
            pubDate: pubDate ? new Date(pubDate) : null,
            albumArt: null
          });
        }
      });

      return albums;
    } catch (error) {
      console.error('Error parsing Charts RSS:', error);
      return [];
    }
  };

  // Load Critic's Picks from RSS feed
  const loadCriticsPicks = async () => {
    if (criticsPicksLoading || criticsPicksLoaded) return;

    setCriticsPicksLoading(true);
    console.log('ðŸ“° Loading Critic\'s Picks...');

    try {
      const response = await fetch('https://www.rssground.com/p/uncoveries');
      if (!response.ok) {
        throw new Error(`Failed to fetch RSS: ${response.status}`);
      }

      const rssText = await response.text();
      const albums = parseCriticsPicksRSS(rssText);

      console.log(`ðŸ“° Parsed ${albums.length} albums from Critic's Picks`);

      // Set albums immediately (without album art)
      setCriticsPicks(albums);
      setCriticsPicksLoaded(true);

      // Fetch album art in background
      fetchCriticsPicksAlbumArt(albums);

    } catch (error) {
      console.error('Failed to load Critic\'s Picks:', error);
      showConfirmDialog({
        type: 'error',
        title: 'Load Failed',
        message: 'Failed to load Critic\'s Picks. Please try again.'
      });
    } finally {
      setCriticsPicksLoading(false);
    }
  };

  // Load Charts from Apple Music JSON feed
  const loadCharts = async () => {
    if (chartsLoading || chartsLoaded) return;

    setChartsLoading(true);
    console.log('ðŸ“Š Loading Charts...');

    try {
      // Use JSON endpoint instead of RSS (RSS returns 500 intermittently)
      const response = await fetch('https://rss.applemarketingtools.com/api/v2/us/music/most-played/50/albums.json');
      if (!response.ok) {
        throw new Error(`Failed to fetch charts: ${response.status}`);
      }

      const data = await response.json();
      const albums = parseChartsJSON(data);

      console.log(`ðŸ“Š Parsed ${albums.length} albums from Charts`);

      setCharts(albums);
      setChartsLoaded(true);

      // Wait for cache to be loaded before fetching album art
      if (cacheLoaded) {
        fetchChartsAlbumArt(albums);
      } else {
        // If cache not ready, wait a bit and try again
        const waitForCache = setInterval(() => {
          if (cacheLoaded) {
            clearInterval(waitForCache);
            fetchChartsAlbumArt(albums);
          }
        }, 100);
      }

    } catch (error) {
      console.error('Failed to load Charts:', error);
      showConfirmDialog({
        type: 'error',
        title: 'Load Failed',
        message: 'Failed to load Charts. Please try again.'
      });
    } finally {
      setChartsLoading(false);
    }
  };

  // Fetch album art for Charts in background
  const fetchChartsAlbumArt = async (albums) => {
    const albumsNeedingFetch = [];
    const cachedUpdates = [];

    for (const album of albums) {
      // Skip albums that already have artwork from the JSON feed
      if (album.albumArt) continue;

      const lookupKey = `${album.artist}-${album.title}`.toLowerCase();
      const cachedReleaseId = albumToReleaseIdCache.current[lookupKey];

      if (cachedReleaseId && albumArtCache.current[cachedReleaseId]?.url) {
        cachedUpdates.push({ id: album.id, albumArt: albumArtCache.current[cachedReleaseId].url });
      } else if (cachedReleaseId !== null) {
        albumsNeedingFetch.push(album);
      }
    }

    if (cachedUpdates.length > 0) {
      console.log(`ðŸ“Š Using cached art for ${cachedUpdates.length} Charts albums`);
      setCharts(prev => prev.map(a => {
        const cached = cachedUpdates.find(u => u.id === a.id);
        return cached ? { ...a, albumArt: cached.albumArt } : a;
      }));
    }

    for (const album of albumsNeedingFetch) {
      try {
        const artUrl = await getAlbumArt(album.artist, album.title);
        if (artUrl) {
          setCharts(prev => prev.map(a =>
            a.id === album.id ? { ...a, albumArt: artUrl } : a
          ));
        }
      } catch (error) {
        console.log(`Could not fetch art for: ${album.artist} - ${album.title}`);
      }
      // MusicBrainz rate limit: 1 request per second
      await new Promise(resolve => setTimeout(resolve, 1100));
    }
  };

  // Navigate to a Charts album release page
  const openChartsAlbum = async (album) => {
    console.log(`ðŸŽµ Opening Chart Album: ${album.artist} - ${album.title}`);

    try {
      // Search MusicBrainz for the release
      const searchQuery = encodeURIComponent(`release:"${album.title}" AND artist:"${album.artist}"`);
      const mbResponse = await fetch(
        `https://musicbrainz.org/ws/2/release/?query=${searchQuery}&fmt=json&limit=1`,
        { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' } }
      );

      if (!mbResponse.ok) {
        throw new Error('MusicBrainz search failed');
      }

      const mbData = await mbResponse.json();

      if (!mbData.releases || mbData.releases.length === 0) {
        // Fallback: just navigate to artist page
        console.log('Release not found in MusicBrainz, navigating to artist page');
        fetchArtistData(album.artist);
        return;
      }

      const release = mbData.releases[0];
      const artistCredit = release['artist-credit']?.[0];

      // Create artist object for the release page
      const artist = {
        id: artistCredit?.artist?.id,
        name: artistCredit?.artist?.name || album.artist
      };

      // Create release object matching the expected format
      const releaseObj = {
        id: release.id,
        title: release.title,
        date: release.date,
        releaseType: release['release-group']?.['primary-type']?.toLowerCase() || 'album',
        albumArt: album.albumArt
      };

      // Set artist context and fetch release data
      // Mark that we're opening a release so header stays collapsed
      openingReleaseRef.current = true;
      setCurrentArtist(artist);
      navigateTo('artist');
      fetchReleaseData(releaseObj, artist);

    } catch (error) {
      console.error('Error opening chart album:', error);
      // Fallback: navigate to artist page
      fetchArtistData(album.artist);
    }
  };

  // Prefetch tracks for a Charts album on hover
  const prefetchChartsTracks = async (album) => {
    // Skip if already prefetched
    if (prefetchedReleases[album.id]) {
      return;
    }

    try {
      const searchQuery = encodeURIComponent(`release:"${album.title}" AND artist:"${album.artist}"`);
      const mbResponse = await fetch(
        `https://musicbrainz.org/ws/2/release/?query=${searchQuery}&fmt=json&limit=1`,
        { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' } }
      );

      if (!mbResponse.ok) return;

      const mbData = await mbResponse.json();
      if (!mbData.releases || mbData.releases.length === 0) return;

      const releaseId = mbData.releases[0].id;

      // Fetch release details with tracks
      const releaseDetailsResponse = await fetch(
        `https://musicbrainz.org/ws/2/release/${releaseId}?inc=recordings&fmt=json`,
        { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' } }
      );

      if (!releaseDetailsResponse.ok) return;

      const releaseData = await releaseDetailsResponse.json();
      const tracks = [];

      releaseData.media?.forEach(medium => {
        medium.tracks?.forEach(track => {
          tracks.push({
            id: track.recording?.id || track.id,
            title: track.title,
            artist: album.artist,
            duration: track.length ? Math.round(track.length / 1000) : null,
            albumArt: album.albumArt
          });
        });
      });

      if (tracks.length > 0) {
        setPrefetchedReleases(prev => ({
          ...prev,
          [album.id]: {
            tracks,
            title: album.title,
            albumArt: album.albumArt
          }
        }));
      }
    } catch (error) {
      // Silent fail for prefetch
    }
  };

  // Add all tracks from a Charts album to the queue
  const addChartsToQueue = async (album) => {
    console.log(`âž• Adding chart album to queue: ${album.artist} - ${album.title}`);

    try {
      const searchQuery = encodeURIComponent(`release:"${album.title}" AND artist:"${album.artist}"`);
      const mbResponse = await fetch(
        `https://musicbrainz.org/ws/2/release/?query=${searchQuery}&fmt=json&limit=1`,
        { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' } }
      );

      if (!mbResponse.ok) throw new Error('MusicBrainz search failed');

      const mbData = await mbResponse.json();
      if (!mbData.releases?.[0]) {
        showConfirmDialog({
          type: 'error',
          title: 'Album Not Found',
          message: `Could not find tracks for "${album.title}"`
        });
        return;
      }

      const releaseId = mbData.releases[0].id;
      const tracksResponse = await fetch(
        `https://musicbrainz.org/ws/2/release/${releaseId}?inc=recordings&fmt=json`,
        { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' } }
      );

      if (!tracksResponse.ok) throw new Error('Failed to fetch tracks');

      const releaseData = await tracksResponse.json();
      const tracks = [];

      releaseData.media?.forEach(medium => {
        medium.tracks?.forEach(track => {
          tracks.push({
            id: track.recording?.id || track.id,
            title: track.title,
            artist: album.artist,
            duration: track.length ? Math.round(track.length / 1000) : null,
            albumArt: album.albumArt
          });
        });
      });

      if (tracks.length > 0) {
        const context = { type: 'album', id: album.id, name: album.title, artist: album.artist };
        addToQueue(tracks, context);
        showConfirmDialog({
          type: 'success',
          title: 'Added to Queue',
          message: `Added ${tracks.length} tracks from "${album.title}"`
        });
      }
    } catch (error) {
      console.error('Error adding chart album to queue:', error);
      showConfirmDialog({
        type: 'error',
        title: 'Error',
        message: 'Failed to add album to queue. Please try again.'
      });
    }
  };

  // Load Recommendations from Last.fm and/or ListenBrainz (merged and de-duped)
  const loadRecommendations = async () => {
    // Check if Last.fm or ListenBrainz is configured
    const lastfmConfig = metaServiceConfigs.lastfm;
    const listenbrainzConfig = metaServiceConfigs.listenbrainz;

    if (!lastfmConfig?.username && !listenbrainzConfig?.username) {
      console.log('â­ No recommendation service configured, skipping recommendations load');
      setRecommendations({
        artists: [],
        tracks: [],
        loading: false,
        error: 'not_configured'
      });
      return;
    }

    setRecommendations(prev => ({ ...prev, loading: true, error: null }));

    try {
      // Fetch from both services in parallel if both are configured
      const fetchPromises = [];

      if (listenbrainzConfig?.username) {
        console.log(`â­ Loading Recommendations from ListenBrainz for ${listenbrainzConfig.username}...`);
        fetchPromises.push(
          loadListenbrainzRecommendations(listenbrainzConfig.username)
            .catch(err => { console.error('ListenBrainz recommendations error:', err); return []; })
        );
      } else {
        fetchPromises.push(Promise.resolve([]));
      }

      if (lastfmConfig?.username) {
        console.log(`â­ Loading Recommendations from Last.fm for ${lastfmConfig.username}...`);
        fetchPromises.push(
          loadLastfmRecommendations(lastfmConfig.username)
            .catch(err => { console.error('Last.fm recommendations error:', err); return []; })
        );
      } else {
        fetchPromises.push(Promise.resolve([]));
      }

      const [listenbrainzTracks, lastfmTracks] = await Promise.all(fetchPromises);

      // Merge and de-dupe tracks (ListenBrainz first since it has MBID metadata)
      const seenTracks = new Set();
      const tracks = [];

      for (const track of listenbrainzTracks) {
        const key = `${track.artist.toLowerCase().trim()}|${track.title.toLowerCase().trim()}`;
        if (!seenTracks.has(key)) {
          seenTracks.add(key);
          tracks.push({ ...track, source: 'listenbrainz' });
        }
      }

      for (const track of lastfmTracks) {
        const key = `${track.artist.toLowerCase().trim()}|${track.title.toLowerCase().trim()}`;
        if (!seenTracks.has(key)) {
          seenTracks.add(key);
          tracks.push({ ...track, source: 'lastfm' });
        }
      }

      console.log(`â­ Merged ${listenbrainzTracks.length} ListenBrainz + ${lastfmTracks.length} Last.fm tracks â†’ ${tracks.length} unique tracks`);

      // Extract unique artists
      const artistMap = new Map();
      tracks.forEach(track => {
        if (track.artist && !artistMap.has(track.artist)) {
          artistMap.set(track.artist, {
            id: track.artist.toLowerCase().replace(/[^a-z0-9]/g, '-'),
            name: track.artist,
            image: null,
            imageLoaded: false // Track whether image lookup has completed
          });
        }
      });
      const artists = Array.from(artistMap.values());

      console.log(`â­ Extracted ${artists.length} unique artists`);

      // Set initial state with tracks (sources empty, will resolve in background)
      setRecommendations({
        artists,
        tracks,
        loading: false,
        error: null
      });

      // Resolve tracks in background using the resolver pipeline
      resolveRecommendationTracks(tracks);

      // Fetch artist images in background
      resolveRecommendationArtistImages(artists);

    } catch (error) {
      console.error('Failed to load Recommendations:', error);
      setRecommendations(prev => ({
        ...prev,
        loading: false,
        error: 'Failed to load recommendations. Please try again.'
      }));
    }
  };

  // Load recommendations from Last.fm
  const loadLastfmRecommendations = async (username) => {
    const response = await fetch(`https://www.last.fm/player/station/user/${encodeURIComponent(username)}/recommended`);
    if (!response.ok) {
      throw new Error(`Failed to fetch Last.fm recommendations: ${response.status}`);
    }

    const data = await response.json();
    const playlist = data.playlist || [];

    // Transform tracks to app format with empty sources (will be resolved)
    return playlist.map((track, index) => ({
      id: track.spelling_id || `rec-${index}-${track.name}-${track.artists?.[0]?.name}`.replace(/\s+/g, '-'),
      title: track.name || track._name,
      artist: track.artists?.[0]?.name || track.artists?.[0]?._name || 'Unknown Artist',
      duration: track.duration || null,
      sources: {} // Will be populated by resolver pipeline
    }));
  };

  // Load recommendations from ListenBrainz
  const loadListenbrainzRecommendations = async (username) => {
    // ListenBrainz has a recommendations endpoint that returns personalized playlists
    // First try to get recommendation playlists
    const playlistsResponse = await fetch(`https://api.listenbrainz.org/1/user/${encodeURIComponent(username)}/playlists/recommendations`);

    if (playlistsResponse.ok) {
      const playlistsData = await playlistsResponse.json();
      const playlists = playlistsData.playlists || [];

      // Get the most recent recommendation playlist
      if (playlists.length > 0) {
        const latestPlaylist = playlists[0];
        const playlistId = latestPlaylist.playlist?.identifier?.split('/').pop();

        if (playlistId) {
          // Fetch the full playlist with tracks
          const playlistResponse = await fetch(`https://api.listenbrainz.org/1/playlist/${playlistId}`);
          if (playlistResponse.ok) {
            const playlistData = await playlistResponse.json();
            const tracks = playlistData.playlist?.track || [];

            return tracks.map((track, index) => ({
              id: track.identifier?.[0]?.split('/').pop() || `lb-rec-${index}-${track.title}`.replace(/\s+/g, '-'),
              title: track.title || 'Unknown Track',
              artist: track.creator || 'Unknown Artist',
              duration: track.duration ? Math.floor(track.duration / 1000) : null,
              sources: {},
              mbid: track.identifier?.[0]?.split('/').pop() || null
            }));
          }
        }
      }
    }

    // Fallback: use top recordings as pseudo-recommendations
    console.log('â­ No ListenBrainz recommendation playlists found, falling back to top recordings');
    const statsResponse = await fetch(`https://api.listenbrainz.org/1/stats/user/${encodeURIComponent(username)}/recordings?range=month&count=50`);

    if (statsResponse.ok) {
      const statsData = await statsResponse.json();
      const recordings = statsData.payload?.recordings || [];

      return recordings.map((rec, index) => ({
        id: rec.recording_mbid || `lb-top-${index}-${rec.track_name}`.replace(/\s+/g, '-'),
        title: rec.track_name || 'Unknown Track',
        artist: rec.artist_name || 'Unknown Artist',
        duration: null,
        sources: {},
        mbid: rec.recording_mbid || null,
        listenCount: rec.listen_count
      }));
    }

    return [];
  };

  // Load charts when navigating to discover page (Pop of the Tops)
  useEffect(() => {
    // Only load if we're on the discover page AND cache is loaded AND charts haven't been loaded yet
    if (activeView === 'discover' && cacheLoaded && !chartsLoaded) {
      loadCharts();
    }
  }, [activeView, cacheLoaded, chartsLoaded]);

  // Load critics picks when navigating to critics-picks page
  useEffect(() => {
    // Only load if we're on the critics-picks page AND cache is loaded AND not already loaded
    if (activeView === 'critics-picks' && cacheLoaded && !criticsPicksLoaded) {
      loadCriticsPicks();
    }
  }, [activeView, cacheLoaded, criticsPicksLoaded]);

  // Load recommendations when navigating to the page or when config changes
  useEffect(() => {
    // Only load if we're on the recommendations page AND cache is loaded
    if (activeView === 'recommendations' && cacheLoaded) {
      loadRecommendations();
    }
  }, [activeView, cacheLoaded, metaServiceConfigs.lastfm?.username, metaServiceConfigs.listenbrainz?.username]);

  // Resolve recommendation tracks using the resolver pipeline
  const resolveRecommendationTracks = async (tracks) => {
    console.log(`â­ Resolving ${tracks.length} recommendation tracks...`);

    for (const track of tracks) {
      // Check if queue resolution has priority - if so, pause
      if (queueResolutionActiveRef.current) {
        console.log(`â¸ï¸ Pausing recommendations resolution - queue resolution has priority`);
        while (queueResolutionActiveRef.current) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
        console.log(`â–¶ï¸ Resuming recommendations resolution`);
      }

      console.log(`ðŸ” Resolving: ${track.artist} - ${track.title}`);

      // Resolve all sources for this track
      for (const resolverId of activeResolvers) {
        const resolver = allResolvers.find(r => r.id === resolverId);
        if (!resolver || !resolver.capabilities.resolve) continue;

        try {
          const config = await getResolverConfig(resolverId);
          const resolved = await resolver.resolve(track.artist, track.title, null, config);

          if (resolved) {
            console.log(`  âœ… ${resolver.name}: Found match for "${track.title}"`);
            // Update the track's sources and trigger re-render
            setRecommendations(prev => ({
              ...prev,
              tracks: prev.tracks.map(t =>
                t.id === track.id
                  ? {
                      ...t,
                      sources: { ...t.sources, [resolverId]: resolved },
                      duration: t.duration || resolved.duration || null
                    }
                  : t
              )
            }));
          }
        } catch (error) {
          console.error(`  âŒ ${resolver.name} resolve error:`, error);
        }
      }
    }

    console.log(`â­ Finished resolving recommendation tracks`);
  };

  // Fetch images for recommended artists
  const resolveRecommendationArtistImages = async (artists) => {
    console.log(`â­ Fetching images for ${artists.length} recommended artists...`);

    for (const artist of artists) {
      try {
        const result = await getArtistImage(artist.name);
        setRecommendations(prev => ({
          ...prev,
          artists: prev.artists.map(a =>
            a.id === artist.id ? { ...a, image: result?.url || null, imageLoaded: true } : a
          )
        }));
      } catch (err) {
        console.error(`Error fetching image for ${artist.name}:`, err);
        // Mark as loaded even on error so we show fallback icon instead of spinner
        setRecommendations(prev => ({
          ...prev,
          artists: prev.artists.map(a =>
            a.id === artist.id ? { ...a, imageLoaded: true } : a
          )
        }));
      }
    }
    console.log(`â­ Finished fetching recommended artist images`);
  };

  // Fetch images for search result artists
  const resolveSearchArtistImages = async (artists) => {
    console.log(`ðŸ” Fetching images for ${artists.length} search result artists...`);

    for (const artist of artists) {
      // Skip if already has image or is loading
      if (artist.image || artist.imageLoaded) continue;

      try {
        const result = await getArtistImage(artist.name);
        setSearchResults(prev => ({
          ...prev,
          artists: prev.artists.map(a =>
            a.id === artist.id ? { ...a, image: result?.url || null, imageLoaded: true } : a
          )
        }));
      } catch (err) {
        console.error(`Error fetching image for ${artist.name}:`, err);
        // Mark as loaded even on error so we show fallback icon instead of spinner
        setSearchResults(prev => ({
          ...prev,
          artists: prev.artists.map(a =>
            a.id === artist.id ? { ...a, imageLoaded: true } : a
          )
        }));
      }
    }
    console.log(`ðŸ” Finished fetching search result artist images`);
  };

  // Resolve unresolved search tracks (when songs tab is selected)
  const resolveSearchTracks = async (tracks) => {
    console.log(`ðŸ” Resolving ${tracks.length} unresolved search tracks...`);

    for (const track of tracks) {
      // Skip if already has sources
      if (Object.keys(track.sources || {}).length > 0) continue;

      console.log(`ðŸ” Resolving: ${track.artist} - ${track.title}`);

      // Query all enabled resolvers in priority order
      const enabledResolvers = resolverOrder
        .filter(id => activeResolvers.includes(id))
        .map(id => allResolvers.find(r => r.id === id))
        .filter(Boolean);

      const newSources = {};

      // Parallel resolution
      const resolverPromises = enabledResolvers.map(async (resolver) => {
        if (!resolver.capabilities.resolve || !resolver.play) return;

        try {
          const config = await getResolverConfig(resolver.id);
          const result = await resolver.resolve(track.artist, track.title, track.album, config);

          if (result) {
            const confidence = calculateConfidence(track, result);
            newSources[resolver.id] = { ...result, confidence };
            console.log(`  âœ… ${resolver.name}: Found match (confidence: ${(confidence * 100).toFixed(0)}%)`);
          }
        } catch (error) {
          console.error(`  âŒ ${resolver.name} resolve error:`, error);
        }
      });

      await Promise.all(resolverPromises);

      // Update track in searchResults
      if (Object.keys(newSources).length > 0) {
        setSearchResults(prev => ({
          ...prev,
          tracks: prev.tracks.map(t =>
            t.id === track.id ? { ...t, sources: newSources } : t
          )
        }));
        console.log(`âœ… Found ${Object.keys(newSources).length} source(s) for: ${track.title}`);
      } else {
        // Mark as resolved even with no sources to prevent re-resolving
        setSearchResults(prev => ({
          ...prev,
          tracks: prev.tracks.map(t =>
            t.id === track.id ? { ...t, sources: {}, resolved: true } : t
          )
        }));
      }
    }
    console.log(`ðŸ” Finished resolving search tracks`);
  };

  // Load Listening History from Last.fm and/or ListenBrainz (merged and de-duped)
  const loadListeningHistory = async () => {
    setListeningHistory(prev => ({ ...prev, loading: true, error: null }));
    console.log('ðŸ“œ Loading Listening History...');

    try {
      // Get configs from metaServiceConfigs
      const lastfmConfig = metaServiceConfigs.lastfm;
      const listenbrainzConfig = metaServiceConfigs.listenbrainz;

      // If no service is configured
      if (!lastfmConfig?.username && !listenbrainzConfig?.username) {
        setListeningHistory({
          tracks: [],
          loading: false,
          error: 'No listening history service connected. Configure Last.fm or ListenBrainz in Settings > Resolvers.'
        });
        return;
      }

      // Fetch from both services in parallel if both are configured
      const fetchPromises = [];

      if (listenbrainzConfig?.username) {
        console.log(`ðŸ“œ Loading history from ListenBrainz for ${listenbrainzConfig.username}...`);
        fetchPromises.push(
          loadListenbrainzHistory(listenbrainzConfig.username)
            .catch(err => { console.error('ListenBrainz history error:', err); return []; })
        );
      } else {
        fetchPromises.push(Promise.resolve([]));
      }

      if (lastfmConfig?.username) {
        const apiKey = lastfmApiKey.current;
        if (apiKey) {
          console.log(`ðŸ“œ Loading history from Last.fm for ${lastfmConfig.username}...`);
          fetchPromises.push(
            loadLastfmHistory(lastfmConfig.username, apiKey)
              .catch(err => { console.error('Last.fm history error:', err); return []; })
          );
        } else {
          console.log('ðŸ“œ Last.fm API key not configured, skipping Last.fm history');
          fetchPromises.push(Promise.resolve([]));
        }
      } else {
        fetchPromises.push(Promise.resolve([]));
      }

      const [listenbrainzTracks, lastfmTracks] = await Promise.all(fetchPromises);

      // Merge and de-dupe tracks by artist+title+timestamp (within 5 min window)
      // Sort by playedAt descending, keeping most recent plays
      const allTracks = [
        ...listenbrainzTracks.map(t => ({ ...t, source: 'listenbrainz' })),
        ...lastfmTracks.map(t => ({ ...t, source: 'lastfm' }))
      ].sort((a, b) => (b.playedAt || 0) - (a.playedAt || 0));

      const seenTracks = new Set();
      const tracks = [];

      for (const track of allTracks) {
        // Create a key that considers artist+title and groups listens within 5 minutes
        const timeWindow = track.playedAt ? Math.floor(track.playedAt / (5 * 60 * 1000)) : 'now';
        const key = `${track.artist.toLowerCase().trim()}|${track.title.toLowerCase().trim()}|${timeWindow}`;
        if (!seenTracks.has(key)) {
          seenTracks.add(key);
          tracks.push(track);
        }
      }

      console.log(`ðŸ“œ Merged ${listenbrainzTracks.length} ListenBrainz + ${lastfmTracks.length} Last.fm listens â†’ ${tracks.length} unique listens`);

      // Set initial state with tracks
      setListeningHistory({
        tracks,
        loading: false,
        error: null
      });

      // Resolve tracks in background using the resolver pipeline
      resolveHistoryTracks(tracks);

    } catch (error) {
      console.error('Failed to load Listening History:', error);
      setListeningHistory({
        tracks: [],
        loading: false,
        error: error.message || 'Failed to load listening history. Please try again.'
      });
    }
  };

  // Period options for top charts
  const historyPeriodOptions = [
    { value: '7day', label: 'Last 7 Days' },
    { value: '1month', label: 'Last Month' },
    { value: '3month', label: 'Last 3 Months' },
    { value: '6month', label: 'Last 6 Months' },
    { value: '12month', label: 'Last Year' },
    { value: 'overall', label: 'All Time' }
  ];

  // Load Top Tracks from Last.fm
  const loadTopTracks = async (period = historyPeriod) => {
    setTopTracks(prev => ({ ...prev, loading: true, error: null }));
    console.log(`ðŸ“Š Loading Top Tracks (${period})...`);

    try {
      const lastfmConfig = metaServiceConfigs.lastfm;
      if (!lastfmConfig?.username) {
        setTopTracks({ tracks: [], loading: false, error: 'No Last.fm account connected.' });
        return;
      }

      const apiKey = lastfmApiKey.current;
      if (!apiKey) {
        setTopTracks({ tracks: [], loading: false, error: 'Last.fm API key not configured.' });
        return;
      }

      const url = `https://ws.audioscrobbler.com/2.0/?method=user.gettoptracks&user=${encodeURIComponent(lastfmConfig.username)}&api_key=${apiKey}&format=json&period=${period}&limit=50`;
      const response = await fetch(url);

      if (!response.ok) throw new Error(`Failed to fetch top tracks: ${response.status}`);

      const data = await response.json();
      const topTracksList = data.toptracks?.track || [];

      console.log(`ðŸ“Š Received ${topTracksList.length} top tracks`);

      const tracks = topTracksList.map((track, index) => ({
        id: `top-track-${index}-${track.name}`.replace(/\s+/g, '-'),
        title: track.name,
        artist: track.artist?.name || 'Unknown Artist',
        album: null,
        albumArt: track.image?.[2]?.['#text'] || null,
        playCount: parseInt(track.playcount) || 0,
        rank: index + 1,
        sources: {}
      }));

      setTopTracks({ tracks, loading: false, error: null });
      resolveTopTracks(tracks);
    } catch (error) {
      console.error('Failed to load Top Tracks:', error);
      setTopTracks({ tracks: [], loading: false, error: error.message });
    }
  };

  // Load Top Artists from Last.fm
  const loadTopArtists = async (period = historyPeriod) => {
    setTopArtists(prev => ({ ...prev, loading: true, error: null }));
    console.log(`ðŸ“Š Loading Top Artists (${period})...`);

    try {
      const lastfmConfig = metaServiceConfigs.lastfm;
      if (!lastfmConfig?.username) {
        setTopArtists({ artists: [], loading: false, error: 'No Last.fm account connected.' });
        return;
      }

      const apiKey = lastfmApiKey.current;
      if (!apiKey) {
        setTopArtists({ artists: [], loading: false, error: 'Last.fm API key not configured.' });
        return;
      }

      const url = `https://ws.audioscrobbler.com/2.0/?method=user.gettopartists&user=${encodeURIComponent(lastfmConfig.username)}&api_key=${apiKey}&format=json&period=${period}&limit=50`;
      const response = await fetch(url);

      if (!response.ok) throw new Error(`Failed to fetch top artists: ${response.status}`);

      const data = await response.json();
      const topArtistsList = data.topartists?.artist || [];

      console.log(`ðŸ“Š Received ${topArtistsList.length} top artists`);

      const artists = topArtistsList.map((artist, index) => ({
        id: `top-artist-${index}-${artist.name}`.replace(/\s+/g, '-'),
        name: artist.name,
        image: null, // Will be fetched from Spotify
        playCount: parseInt(artist.playcount) || 0,
        rank: index + 1
      }));

      setTopArtists({ artists, loading: false, error: null });

      // Fetch artist images from Spotify in background
      resolveTopArtistImages(artists);
    } catch (error) {
      console.error('Failed to load Top Artists:', error);
      setTopArtists({ artists: [], loading: false, error: error.message });
    }
  };

  // Resolve artist images from Spotify
  const resolveTopArtistImages = async (artists) => {
    console.log(`ðŸ“Š Fetching images for ${artists.length} top artists...`);

    for (const artist of artists) {
      try {
        const result = await getArtistImage(artist.name);
        if (result?.url) {
          setTopArtists(prev => ({
            ...prev,
            artists: prev.artists.map(a =>
              a.id === artist.id ? { ...a, image: result.url } : a
            )
          }));
        }
      } catch (err) {
        console.error(`Error fetching image for ${artist.name}:`, err);
      }
    }
    console.log(`ðŸ“Š Finished fetching top artist images`);
  };

  // Load Top Albums from Last.fm
  const loadTopAlbums = async (period = historyPeriod) => {
    setTopAlbums(prev => ({ ...prev, loading: true, error: null }));
    console.log(`ðŸ“Š Loading Top Albums (${period})...`);

    try {
      const lastfmConfig = metaServiceConfigs.lastfm;
      if (!lastfmConfig?.username) {
        setTopAlbums({ albums: [], loading: false, error: 'No Last.fm account connected.' });
        return;
      }

      const apiKey = lastfmApiKey.current;
      if (!apiKey) {
        setTopAlbums({ albums: [], loading: false, error: 'Last.fm API key not configured.' });
        return;
      }

      const url = `https://ws.audioscrobbler.com/2.0/?method=user.gettopalbums&user=${encodeURIComponent(lastfmConfig.username)}&api_key=${apiKey}&format=json&period=${period}&limit=50`;
      const response = await fetch(url);

      if (!response.ok) throw new Error(`Failed to fetch top albums: ${response.status}`);

      const data = await response.json();
      const topAlbumsList = data.topalbums?.album || [];

      console.log(`ðŸ“Š Received ${topAlbumsList.length} top albums`);

      const albums = topAlbumsList.map((album, index) => ({
        id: `top-album-${index}-${album.name}`.replace(/\s+/g, '-'),
        name: album.name,
        artist: album.artist?.name || 'Unknown Artist',
        image: album.image?.[3]?.['#text'] || album.image?.[2]?.['#text'] || null,
        playCount: parseInt(album.playcount) || 0,
        rank: index + 1
      }));

      setTopAlbums({ albums, loading: false, error: null });
    } catch (error) {
      console.error('Failed to load Top Albums:', error);
      setTopAlbums({ albums: [], loading: false, error: error.message });
    }
  };

  // Parse friend input to extract service and username
  const parseFriendInput = (input) => {
    const trimmed = input.trim();

    // Check for Last.fm URL
    const lastfmMatch = trimmed.match(/last\.fm\/user\/([^\/\?]+)/i);
    if (lastfmMatch) {
      return { service: 'lastfm', username: lastfmMatch[1] };
    }

    // Check for ListenBrainz URL
    const listenbrainzMatch = trimmed.match(/listenbrainz\.org\/user\/([^\/\?]+)/i);
    if (listenbrainzMatch) {
      return { service: 'listenbrainz', username: listenbrainzMatch[1] };
    }

    // Plain username - will try Last.fm first, then ListenBrainz
    return { service: null, username: trimmed };
  };

  // Fetch Last.fm user info (avatar, display name)
  const fetchLastfmUserInfo = async (username) => {
    const apiKey = lastfmApiKey.current;
    if (!apiKey) throw new Error('Last.fm API key not configured');

    const url = `https://ws.audioscrobbler.com/2.0/?method=user.getinfo&user=${encodeURIComponent(username)}&api_key=${apiKey}&format=json`;
    const response = await fetch(url);

    if (!response.ok) {
      if (response.status === 404) throw new Error('User not found on Last.fm');
      throw new Error(`Last.fm API error: ${response.status}`);
    }

    const data = await response.json();
    if (data.error) throw new Error(data.message || 'User not found on Last.fm');

    const user = data.user;
    return {
      username: user.name,
      displayName: user.realname || user.name,
      avatarUrl: user.image?.[2]?.['#text'] || user.image?.[1]?.['#text'] || null
    };
  };

  // Fetch ListenBrainz user info
  const fetchListenbrainzUserInfo = async (username) => {
    // Use listen-count endpoint to validate user exists (the /1/user/{username} endpoint doesn't work)
    const url = `https://api.listenbrainz.org/1/user/${encodeURIComponent(username)}/listen-count`;
    const response = await fetch(url);

    if (!response.ok) {
      if (response.status === 404) throw new Error('User not found on ListenBrainz');
      throw new Error(`ListenBrainz API error: ${response.status}`);
    }

    // Verify response has valid data
    const data = await response.json();
    if (data.payload?.count === undefined) {
      throw new Error('User not found on ListenBrainz');
    }

    // ListenBrainz doesn't have avatars, return username only
    return {
      username: username,
      displayName: username,
      avatarUrl: null // Will use generated avatar fallback
    };
  };

  // Fetch friend's most recent track (for on-air status)
  const fetchFriendRecentTrack = async (friend) => {
    try {
      if (friend.service === 'lastfm') {
        const apiKey = lastfmApiKey.current;
        if (!apiKey) return null;

        const url = `https://ws.audioscrobbler.com/2.0/?method=user.getrecenttracks&user=${encodeURIComponent(friend.username)}&api_key=${apiKey}&format=json&limit=1`;
        const response = await fetch(url);
        if (!response.ok) return null;

        const data = await response.json();
        const track = data.recenttracks?.track?.[0];
        if (!track) return null;

        // Check if currently playing (no date means currently playing)
        const isNowPlaying = track['@attr']?.nowplaying === 'true';
        const timestamp = isNowPlaying ? Date.now() : (track.date?.uts ? parseInt(track.date.uts) * 1000 : null);

        return {
          name: track.name,
          artist: track.artist?.['#text'] || track.artist?.name || 'Unknown Artist',
          album: track.album?.['#text'] || null,
          timestamp: timestamp,
          albumArt: track.image?.[2]?.['#text'] || track.image?.[1]?.['#text'] || null
        };
      } else if (friend.service === 'listenbrainz') {
        const url = `https://api.listenbrainz.org/1/user/${encodeURIComponent(friend.username)}/listens?count=1`;
        const response = await fetch(url);
        if (!response.ok) return null;

        const data = await response.json();
        const listen = data.payload?.listens?.[0];
        if (!listen) return null;

        return {
          name: listen.track_metadata?.track_name || 'Unknown Track',
          artist: listen.track_metadata?.artist_name || 'Unknown Artist',
          album: listen.track_metadata?.release_name || null,
          timestamp: listen.listened_at ? listen.listened_at * 1000 : null,
          albumArt: null // ListenBrainz doesn't provide album art in listens - will be fetched via getAlbumArt
        };
      }
      return null;
    } catch (error) {
      console.error(`Error fetching recent track for ${friend.username}:`, error);
      return null;
    }
  };

  // Check if friend is "on air" (listened within last 10 minutes)
  const isOnAir = (friend) => {
    if (!friend.cachedRecentTrack?.timestamp) return false;
    const tenMinutesAgo = Date.now() - (10 * 60 * 1000);
    return friend.cachedRecentTrack.timestamp > tenMinutesAgo;
  };

  // Add a friend from username or URL
  const addFriend = async (input) => {
    setAddFriendLoading(true);

    try {
      const { service, username } = parseFriendInput(input);

      if (!username) {
        showToast('Please enter a username or profile URL', 'error');
        return;
      }

      let userInfo = null;
      let finalService = service;

      if (service === 'lastfm') {
        userInfo = await fetchLastfmUserInfo(username);
        finalService = 'lastfm';
      } else if (service === 'listenbrainz') {
        userInfo = await fetchListenbrainzUserInfo(username);
        finalService = 'listenbrainz';
      } else {
        // Try Last.fm first, then ListenBrainz
        try {
          userInfo = await fetchLastfmUserInfo(username);
          finalService = 'lastfm';
        } catch (lfmError) {
          console.log(`User not found on Last.fm, trying ListenBrainz...`);
          try {
            userInfo = await fetchListenbrainzUserInfo(username);
            finalService = 'listenbrainz';
          } catch (lbError) {
            throw new Error('User not found on Last.fm or ListenBrainz');
          }
        }
      }

      // Check if already added
      const existingFriend = friends.find(f =>
        f.username.toLowerCase() === userInfo.username.toLowerCase() &&
        f.service === finalService
      );
      if (existingFriend) {
        showToast(`${userInfo.displayName} is already in your friends list`, 'error');
        return;
      }

      // Create friend object
      const newFriend = {
        id: `friend-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        username: userInfo.username,
        service: finalService,
        displayName: userInfo.displayName,
        avatarUrl: userInfo.avatarUrl,
        addedAt: Date.now(),
        lastFetched: Date.now(),
        cachedRecentTrack: null,
        savedToCollection: true  // Friends are saved to collection by default
      };

      // Fetch recent track for initial on-air status
      const recentTrack = await fetchFriendRecentTrack(newFriend);
      if (recentTrack) {
        newFriend.cachedRecentTrack = recentTrack;
        // Resolve the track in background for instant playback
        resolveFriendTrack(recentTrack);
      }

      setFriends(prev => [...prev, newFriend]);
      setAddFriendModalOpen(false);
      setAddFriendInput('');
      showToast(`Added ${newFriend.displayName} from ${finalService === 'lastfm' ? 'Last.fm' : 'ListenBrainz'}`);

      console.log(`ðŸ‘¥ Added friend: ${newFriend.displayName} (${finalService})`);
    } catch (error) {
      console.error('Failed to add friend:', error);
      showToast(error.message || 'Failed to add friend', 'error');
    } finally {
      setAddFriendLoading(false);
    }
  };

  // Remove a friend completely (deletes from friends list and unpins)
  const removeFriend = (friendId) => {
    const friend = friends.find(f => f.id === friendId);
    setFriends(prev => prev.filter(f => f.id !== friendId));
    setPinnedFriendIds(prev => prev.filter(id => id !== friendId));
    if (friend) {
      showToast(`${friend.displayName} removed`);
    }
  };
  removeFriendRef.current = removeFriend;

  // Remove friend from collection (keeps them as temporary, stays pinned if pinned)
  const removeFriendFromCollection = (friendId) => {
    setFriends(prev => prev.map(f =>
      f.id === friendId ? { ...f, savedToCollection: false } : f
    ));
    const friend = friends.find(f => f.id === friendId);
    if (friend) {
      showToast(`${friend.displayName} removed from collection`);
    }
  };
  removeFriendFromCollectionRef.current = removeFriendFromCollection;

  // Pin a friend to the sidebar
  const pinFriend = (friendId) => {
    if (!pinnedFriendIds.includes(friendId)) {
      setPinnedFriendIds(prev => [...prev, friendId]);
      const friend = friends.find(f => f.id === friendId);
      if (friend) {
        showToast(`${friend.displayName} pinned to sidebar`);
      }
    }
  };
  pinFriendRef.current = pinFriend;

  // Unpin a friend from the sidebar (with warning for unsaved friends)
  const unpinFriend = (friendId) => {
    const friend = friends.find(f => f.id === friendId);

    // If friend is not saved to collection and warning not dismissed, show warning
    if (friend && !friend.savedToCollection && !skipUnsavedFriendWarning) {
      setPendingUnpinFriend(friend);
      setUnsavedFriendWarningOpen(true);
      return;
    }

    // Otherwise proceed with unpin
    setPinnedFriendIds(prev => prev.filter(id => id !== friendId));
    if (friend) {
      showToast(`${friend.displayName} unpinned from sidebar`);
    }
  };
  unpinFriendRef.current = unpinFriend;

  // Confirm unpin after warning dialog
  const confirmUnpinFriend = () => {
    if (pendingUnpinFriend) {
      setPinnedFriendIds(prev => prev.filter(id => id !== pendingUnpinFriend.id));
      showToast(`${pendingUnpinFriend.displayName} unpinned from sidebar`);
      setUnsavedFriendWarningOpen(false);
      setPendingUnpinFriend(null);
    }
  };

  // Save friend to collection
  const saveFriendToCollection = (friendId) => {
    setFriends(prev => prev.map(f =>
      f.id === friendId ? { ...f, savedToCollection: true } : f
    ));
    const friend = friends.find(f => f.id === friendId);
    if (friend) {
      showToast(`${friend.displayName} saved to collection`);
    }
  };
  saveFriendToCollectionRef.current = saveFriendToCollection;

  // Reorder pinned friends in sidebar (for drag-drop)
  const reorderPinnedFriends = (fromIndex, toIndex) => {
    setPinnedFriendIds(prev => {
      const newOrder = [...prev];
      const [removed] = newOrder.splice(fromIndex, 1);
      newOrder.splice(toIndex, 0, removed);
      return newOrder;
    });
  };

  // Resolve a friend's current track in background (for instant playback)
  const resolveFriendTrack = async (track) => {
    if (!track || !track.name || !track.artist) return;

    const cacheKey = `${track.artist.toLowerCase()}|${track.name.toLowerCase()}|0`;
    const currentResolverHash = getResolverSettingsHash();

    // Check if already cached and valid
    const cachedData = trackSourcesCache.current[cacheKey];
    if (cachedData &&
        (Date.now() - cachedData.timestamp) < CACHE_TTL.trackSources &&
        cachedData.resolverHash === currentResolverHash) {
      console.log(`ðŸ‘¥ Friend track already resolved: ${track.artist} - ${track.name}`);
      return;
    }

    console.log(`ðŸ‘¥ Resolving friend track: ${track.artist} - ${track.name}`);

    const sources = {};

    for (const resolverId of activeResolvers) {
      // Yield to queue resolution if active
      if (queueResolutionActiveRef.current) {
        console.log(`â¸ï¸ Pausing friend track resolution - queue has priority`);
        while (queueResolutionActiveRef.current) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      }

      const resolver = allResolvers.find(r => r.id === resolverId);
      if (!resolver || !resolver.capabilities.resolve) continue;

      try {
        const config = await getResolverConfig(resolverId);
        const resolved = await resolver.resolve(track.artist, track.name, null, config);

        if (resolved) {
          console.log(`  âœ… ${resolver.name}: Found match for friend track`);
          sources[resolverId] = resolved;
        }
      } catch (error) {
        console.error(`  âŒ ${resolver.name} resolve error:`, error);
      }
    }

    // Cache the results
    if (Object.keys(sources).length > 0) {
      trackSourcesCache.current[cacheKey] = {
        sources,
        timestamp: Date.now(),
        resolverHash: currentResolverHash
      };
      console.log(`ðŸ‘¥ Friend track resolved with ${Object.keys(sources).length} sources`);
    }
  };

  // Refresh recent tracks for pinned friends (for polling)
  const refreshPinnedFriends = async () => {
    const pinnedFriends = friends.filter(f => pinnedFriendIds.includes(f.id));

    for (const friend of pinnedFriends) {
      const recentTrack = await fetchFriendRecentTrack(friend);
      if (recentTrack) {
        // Check if track changed before updating
        const previousTrack = friend.cachedRecentTrack;
        const trackChanged = !previousTrack ||
          previousTrack.name !== recentTrack.name ||
          previousTrack.artist !== recentTrack.artist;

        setFriends(prev => prev.map(f =>
          f.id === friend.id
            ? { ...f, cachedRecentTrack: recentTrack, lastFetched: Date.now() }
            : f
        ));

        // Resolve the track in background if it's new/changed and friend is on-air
        if (trackChanged && recentTrack.timestamp && (Date.now() - recentTrack.timestamp) < 10 * 60 * 1000) {
          resolveFriendTrack(recentTrack);
        }
      }
    }
  };

  // Poll pinned friends every 2 minutes for on-air status
  useEffect(() => {
    if (pinnedFriendIds.length > 0) {
      // Initial refresh
      refreshPinnedFriends();

      // Set up polling interval
      friendPollIntervalRef.current = setInterval(refreshPinnedFriends, 2 * 60 * 1000);

      return () => {
        if (friendPollIntervalRef.current) {
          clearInterval(friendPollIntervalRef.current);
        }
      };
    }
  }, [pinnedFriendIds.length]);

  // Load friend's recent listening history
  const loadFriendRecentTracks = async (friend) => {
    setFriendHistoryLoading(true);

    try {
      let tracks = [];

      if (friend.service === 'lastfm') {
        const apiKey = lastfmApiKey.current;
        if (!apiKey) throw new Error('Last.fm API key not configured');

        const url = `https://ws.audioscrobbler.com/2.0/?method=user.getrecenttracks&user=${encodeURIComponent(friend.username)}&api_key=${apiKey}&format=json&limit=50`;
        const response = await fetch(url);
        if (!response.ok) throw new Error(`Failed to fetch recent tracks: ${response.status}`);

        const data = await response.json();
        const recentTracks = data.recenttracks?.track || [];

        tracks = recentTracks.map((track, index) => ({
          id: `friend-recent-${index}-${track.name}`.replace(/\s+/g, '-'),
          title: track.name,
          artist: track.artist?.['#text'] || track.artist?.name || 'Unknown Artist',
          album: track.album?.['#text'] || null,
          albumArt: track.image?.[2]?.['#text'] || track.image?.[1]?.['#text'] || null,
          timestamp: track.date?.uts ? parseInt(track.date.uts) * 1000 : Date.now(),
          nowPlaying: track['@attr']?.nowplaying === 'true',
          sources: {}
        }));
      } else if (friend.service === 'listenbrainz') {
        const url = `https://api.listenbrainz.org/1/user/${encodeURIComponent(friend.username)}/listens?count=50`;
        const response = await fetch(url);
        if (!response.ok) throw new Error(`Failed to fetch listens: ${response.status}`);

        const data = await response.json();
        const listens = data.payload?.listens || [];

        tracks = listens.map((listen, index) => ({
          id: `friend-recent-${index}-${listen.track_metadata?.track_name}`.replace(/\s+/g, '-'),
          title: listen.track_metadata?.track_name || 'Unknown Track',
          artist: listen.track_metadata?.artist_name || 'Unknown Artist',
          album: listen.track_metadata?.release_name || null,
          albumArt: null,
          timestamp: listen.listened_at ? listen.listened_at * 1000 : Date.now(),
          nowPlaying: false,
          sources: {}
        }));
      }

      setFriendHistoryData(prev => ({ ...prev, recent: tracks }));

      // Resolve tracks in background
      if (tracks.length > 0) {
        resolveFriendHistoryTracks(tracks, 'recent');
      }
    } catch (error) {
      console.error('Failed to load friend recent tracks:', error);
      showToast('Failed to load listening history', 'error');
    } finally {
      setFriendHistoryLoading(false);
    }
  };

  // Load friend's top tracks
  const loadFriendTopTracks = async (friend, period = friendHistoryPeriod) => {
    if (friend.service !== 'lastfm') {
      return loadFriendTopTracksListenBrainz(friend, period);
    }

    setFriendHistoryLoading(true);

    try {
      const apiKey = lastfmApiKey.current;
      if (!apiKey) throw new Error('Last.fm API key not configured');

      const url = `https://ws.audioscrobbler.com/2.0/?method=user.gettoptracks&user=${encodeURIComponent(friend.username)}&api_key=${apiKey}&format=json&period=${period}&limit=50`;
      const response = await fetch(url);
      if (!response.ok) throw new Error(`Failed to fetch top tracks: ${response.status}`);

      const data = await response.json();
      const topTracksList = data.toptracks?.track || [];

      const tracks = topTracksList.map((track, index) => ({
        id: `friend-top-track-${index}-${track.name}`.replace(/\s+/g, '-'),
        title: track.name,
        artist: track.artist?.name || 'Unknown Artist',
        albumArt: track.image?.[2]?.['#text'] || null,
        playCount: parseInt(track.playcount) || 0,
        rank: index + 1,
        sources: {}
      }));

      setFriendHistoryData(prev => ({ ...prev, topTracks: tracks }));

      // Resolve tracks in background
      if (tracks.length > 0) {
        resolveFriendHistoryTracks(tracks, 'topTracks');
      }
    } catch (error) {
      console.error('Failed to load friend top tracks:', error);
      showToast('Failed to load top tracks', 'error');
    } finally {
      setFriendHistoryLoading(false);
    }
  };

  // ListenBrainz version
  const loadFriendTopTracksListenBrainz = async (friend, period) => {
    setFriendHistoryLoading(true);

    try {
      const range = period === 'overall' ? 'all_time' : period === '7day' ? 'week' : period === '1month' ? 'month' : period === '3month' ? 'quarter' : period === '6month' ? 'half_yearly' : 'year';
      const url = `https://api.listenbrainz.org/1/stats/user/${encodeURIComponent(friend.username)}/recordings?range=${range}&count=50`;
      const response = await fetch(url);
      if (!response.ok) throw new Error(`Failed to fetch top recordings: ${response.status}`);

      // Handle 204 No Content (no stats available for this period)
      if (response.status === 204) {
        setFriendHistoryData(prev => ({ ...prev, topTracks: [] }));
        setFriendHistoryLoading(false);
        return;
      }

      const data = await response.json();
      const recordings = data.payload?.recordings || [];

      const tracks = recordings.map((rec, index) => ({
        id: `friend-top-track-${index}-${rec.track_name}`.replace(/\s+/g, '-'),
        title: rec.track_name || 'Unknown Track',
        artist: rec.artist_name || 'Unknown Artist',
        albumArt: null,
        playCount: rec.listen_count || 0,
        rank: index + 1,
        sources: {}
      }));

      setFriendHistoryData(prev => ({ ...prev, topTracks: tracks }));

      // Resolve tracks in background
      if (tracks.length > 0) {
        resolveFriendHistoryTracks(tracks, 'topTracks');
      }
    } catch (error) {
      console.error('Failed to load friend top tracks:', error);
      showToast('Failed to load top tracks', 'error');
    } finally {
      setFriendHistoryLoading(false);
    }
  };

  // Load friend's top artists
  const loadFriendTopArtists = async (friend, period = friendHistoryPeriod) => {
    setFriendHistoryLoading(true);

    try {
      let artists = [];

      if (friend.service === 'lastfm') {
        const apiKey = lastfmApiKey.current;
        if (!apiKey) throw new Error('Last.fm API key not configured');

        const url = `https://ws.audioscrobbler.com/2.0/?method=user.gettopartists&user=${encodeURIComponent(friend.username)}&api_key=${apiKey}&format=json&period=${period}&limit=50`;
        const response = await fetch(url);
        if (!response.ok) throw new Error(`Failed to fetch top artists: ${response.status}`);

        const data = await response.json();
        const topArtistsList = data.topartists?.artist || [];

        artists = topArtistsList.map((artist, index) => ({
          id: `friend-top-artist-${index}-${artist.name}`.replace(/\s+/g, '-'),
          name: artist.name,
          image: null,
          playCount: parseInt(artist.playcount) || 0,
          rank: index + 1
        }));
      } else {
        const range = period === 'overall' ? 'all_time' : period === '7day' ? 'week' : period === '1month' ? 'month' : period === '3month' ? 'quarter' : period === '6month' ? 'half_yearly' : 'year';
        const url = `https://api.listenbrainz.org/1/stats/user/${encodeURIComponent(friend.username)}/artists?range=${range}&count=50`;
        const response = await fetch(url);
        if (!response.ok) throw new Error(`Failed to fetch top artists: ${response.status}`);

        // Handle 204 No Content (no stats available for this period)
        if (response.status === 204) {
          setFriendHistoryData(prev => ({ ...prev, topArtists: [] }));
          setFriendHistoryLoading(false);
          return;
        }

        const data = await response.json();
        const artistList = data.payload?.artists || [];

        artists = artistList.map((artist, index) => ({
          id: `friend-top-artist-${index}-${artist.artist_name}`.replace(/\s+/g, '-'),
          name: artist.artist_name || 'Unknown Artist',
          image: null,
          playCount: artist.listen_count || 0,
          rank: index + 1
        }));
      }

      setFriendHistoryData(prev => ({ ...prev, topArtists: artists }));

      // Fetch artist images in background
      if (artists.length > 0) {
        resolveFriendTopArtistImages(artists);
      }
    } catch (error) {
      console.error('Failed to load friend top artists:', error);
      showToast('Failed to load top artists', 'error');
    } finally {
      setFriendHistoryLoading(false);
    }
  };

  // Resolve friend top artist images
  const resolveFriendTopArtistImages = async (artists) => {
    for (const artist of artists) {
      try {
        const result = await getArtistImage(artist.name);
        if (result?.url) {
          setFriendHistoryData(prev => ({
            ...prev,
            topArtists: prev.topArtists.map(a =>
              a.id === artist.id ? { ...a, image: result.url } : a
            )
          }));
        }
      } catch (err) {
        console.error(`Error fetching image for ${artist.name}:`, err);
      }
    }
  };

  // Load friend's top albums
  const loadFriendTopAlbums = async (friend, period = friendHistoryPeriod) => {
    setFriendHistoryLoading(true);

    try {
      let albums = [];

      if (friend.service === 'lastfm') {
        const apiKey = lastfmApiKey.current;
        if (!apiKey) throw new Error('Last.fm API key not configured');

        const url = `https://ws.audioscrobbler.com/2.0/?method=user.gettopalbums&user=${encodeURIComponent(friend.username)}&api_key=${apiKey}&format=json&period=${period}&limit=50`;
        const response = await fetch(url);
        if (!response.ok) throw new Error(`Failed to fetch top albums: ${response.status}`);

        const data = await response.json();
        const topAlbumsList = data.topalbums?.album || [];

        albums = topAlbumsList.map((album, index) => ({
          id: `friend-top-album-${index}-${album.name}`.replace(/\s+/g, '-'),
          name: album.name,
          artist: album.artist?.name || 'Unknown Artist',
          image: album.image?.[3]?.['#text'] || album.image?.[2]?.['#text'] || null,
          playCount: parseInt(album.playcount) || 0,
          rank: index + 1
        }));
      } else {
        const range = period === 'overall' ? 'all_time' : period === '7day' ? 'week' : period === '1month' ? 'month' : period === '3month' ? 'quarter' : period === '6month' ? 'half_yearly' : 'year';
        const url = `https://api.listenbrainz.org/1/stats/user/${encodeURIComponent(friend.username)}/releases?range=${range}&count=50`;
        const response = await fetch(url);
        if (!response.ok) throw new Error(`Failed to fetch top releases: ${response.status}`);

        // Handle 204 No Content (no stats available for this period)
        if (response.status === 204) {
          setFriendHistoryData(prev => ({ ...prev, topAlbums: [] }));
          setFriendHistoryLoading(false);
          return;
        }

        const data = await response.json();
        const releaseList = data.payload?.releases || [];

        albums = releaseList.map((release, index) => ({
          id: `friend-top-album-${index}-${release.release_name}`.replace(/\s+/g, '-'),
          name: release.release_name || 'Unknown Album',
          artist: release.artist_name || 'Unknown Artist',
          image: null,
          playCount: release.listen_count || 0,
          rank: index + 1
        }));
      }

      setFriendHistoryData(prev => ({ ...prev, topAlbums: albums }));
    } catch (error) {
      console.error('Failed to load friend top albums:', error);
      showToast('Failed to load top albums', 'error');
    } finally {
      setFriendHistoryLoading(false);
    }
  };

  // Navigate to friend's history view
  const navigateToFriend = (friend) => {
    setCurrentFriend(friend);
    setFriendHistoryTab('recent');
    setFriendHistoryData({ recent: [], topTracks: [], topAlbums: [], topArtists: [] });
    navigateTo('friendHistory');
    loadFriendRecentTracks(friend);
  };
  navigateToFriendRef.current = navigateToFriend;

  // Resolve top tracks using the resolver pipeline
  const resolveTopTracks = async (tracks) => {
    console.log(`ðŸ“Š Resolving ${tracks.length} top tracks...`);

    for (const track of tracks) {
      if (queueResolutionActiveRef.current) {
        console.log(`â¸ï¸ Pausing top tracks resolution - queue resolution has priority`);
        while (queueResolutionActiveRef.current) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
        console.log(`â–¶ï¸ Resuming top tracks resolution`);
      }

      for (const resolverId of activeResolvers) {
        const resolver = allResolvers.find(r => r.id === resolverId);
        if (!resolver || !resolver.capabilities.resolve) continue;
        if (resolverId === 'localfiles') continue;

        try {
          const config = await getResolverConfig(resolverId);
          const result = await resolver.resolve(track.artist, track.title, track.album, config);

          if (result) {
            setTopTracks(prev => ({
              ...prev,
              tracks: prev.tracks.map(t =>
                t.id === track.id
                  ? { ...t, sources: { ...t.sources, [resolverId]: result }, albumArt: t.albumArt || result.albumArt }
                  : t
              )
            }));
          }
        } catch (err) {
          console.error(`Error resolving top track with ${resolverId}:`, err);
        }
      }
    }
    console.log(`ðŸ“Š Finished resolving top tracks`);
  };

  // Load listening history from Last.fm
  const loadLastfmHistory = async (username, apiKey) => {
    const url = `https://ws.audioscrobbler.com/2.0/?method=user.getrecenttracks&user=${encodeURIComponent(username)}&api_key=${apiKey}&format=json&limit=50`;
    const response = await fetch(url);

    if (!response.ok) {
      throw new Error(`Failed to fetch Last.fm listening history: ${response.status}`);
    }

    const data = await response.json();
    const recentTracks = data.recenttracks?.track || [];

    // Transform tracks to app format
    return recentTracks.map((track, index) => ({
      id: `history-${index}-${track.date?.uts || 'now'}-${track.name}`.replace(/\s+/g, '-'),
      title: track.name,
      artist: track.artist?.['#text'] || track.artist?.name || 'Unknown Artist',
      album: track.album?.['#text'] || null,
      albumArt: track.image?.[2]?.['#text'] || null, // Medium size image
      playedAt: track.date?.uts ? parseInt(track.date.uts) * 1000 : null, // Convert to ms
      nowPlaying: track['@attr']?.nowplaying === 'true',
      sources: {} // Will be populated by resolver pipeline
    }));
  };

  // Load listening history from ListenBrainz
  const loadListenbrainzHistory = async (username) => {
    const url = `https://api.listenbrainz.org/1/user/${encodeURIComponent(username)}/listens?count=50`;
    const response = await fetch(url);

    if (!response.ok) {
      throw new Error(`Failed to fetch ListenBrainz listening history: ${response.status}`);
    }

    const data = await response.json();
    const listens = data.payload?.listens || [];

    // Transform listens to app format
    return listens.map((listen, index) => ({
      id: listen.recording_msid || `lb-history-${index}-${listen.listened_at}-${listen.track_metadata?.track_name}`.replace(/\s+/g, '-'),
      title: listen.track_metadata?.track_name || 'Unknown Track',
      artist: listen.track_metadata?.artist_name || 'Unknown Artist',
      album: listen.track_metadata?.release_name || null,
      albumArt: null, // ListenBrainz doesn't provide album art directly
      playedAt: listen.listened_at ? listen.listened_at * 1000 : null, // Convert to ms
      nowPlaying: listen.playing_now || false,
      sources: {},
      mbid: listen.track_metadata?.additional_info?.recording_mbid || null
    }));
  };

  // Resolve history tracks using the resolver pipeline
  const resolveHistoryTracks = async (tracks) => {
    console.log(`ðŸ“œ Resolving ${tracks.length} history tracks...`);

    for (const track of tracks) {
      // Check if queue resolution has priority - if so, pause
      if (queueResolutionActiveRef.current) {
        console.log(`â¸ï¸ Pausing history resolution - queue resolution has priority`);
        while (queueResolutionActiveRef.current) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
        console.log(`â–¶ï¸ Resuming history resolution`);
      }

      console.log(`ðŸ” Resolving: ${track.artist} - ${track.title}`);

      // Resolve all sources for this track
      for (const resolverId of activeResolvers) {
        const resolver = allResolvers.find(r => r.id === resolverId);
        if (!resolver || !resolver.capabilities.resolve) continue;

        try {
          const config = await getResolverConfig(resolverId);
          const resolved = await resolver.resolve(track.artist, track.title, track.album, config);

          if (resolved) {
            console.log(`  âœ… ${resolver.name}: Found match for "${track.title}"`);
            // Update the track's sources and trigger re-render
            setListeningHistory(prev => ({
              ...prev,
              tracks: prev.tracks.map(t =>
                t.id === track.id
                  ? {
                      ...t,
                      sources: { ...t.sources, [resolverId]: resolved },
                      duration: t.duration || resolved.duration || null
                    }
                  : t
              )
            }));
          }
        } catch (error) {
          console.error(`  âŒ ${resolver.name} resolve error:`, error);
        }
      }
    }

    console.log(`ðŸ“œ Finished resolving history tracks`);
  };

  // Resolve friend history tracks - similar to resolveHistoryTracks but updates friendHistoryData
  const resolveFriendHistoryTracks = async (tracks, dataKey) => {
    console.log(`ðŸ‘¥ Resolving ${tracks.length} friend ${dataKey} tracks...`);

    for (const track of tracks) {
      // Check if queue resolution has priority - if so, pause
      if (queueResolutionActiveRef.current) {
        console.log(`â¸ï¸ Pausing friend history resolution - queue resolution has priority`);
        while (queueResolutionActiveRef.current) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
        console.log(`â–¶ï¸ Resuming friend history resolution`);
      }

      // Resolve all sources for this track
      for (const resolverId of activeResolvers) {
        const resolver = allResolvers.find(r => r.id === resolverId);
        if (!resolver || !resolver.capabilities.resolve) continue;

        try {
          const config = await getResolverConfig(resolverId);
          const resolved = await resolver.resolve(track.artist, track.title, track.album, config);

          if (resolved) {
            // Update the track's sources in friendHistoryData
            setFriendHistoryData(prev => ({
              ...prev,
              [dataKey]: prev[dataKey].map(t =>
                t.id === track.id
                  ? {
                      ...t,
                      sources: { ...t.sources, [resolverId]: resolved },
                      duration: t.duration || resolved.duration || null
                    }
                  : t
              )
            }));
          }
        } catch (error) {
          // Silent fail for resolution errors
        }
      }
    }

    console.log(`ðŸ‘¥ Finished resolving friend ${dataKey} tracks`);
  };

  // Helper function to search MusicBrainz with fallback for multi-artist names
  // If artist contains "&" or " and " and search fails, tries with just the first artist name
  const searchMusicBrainzRelease = async (album, artist) => {
    const doSearch = async (artistQuery) => {
      const searchQuery = encodeURIComponent(`release:"${album}" AND artist:"${artistQuery}"`);
      const mbResponse = await fetch(
        `https://musicbrainz.org/ws/2/release/?query=${searchQuery}&fmt=json&limit=1`,
        { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' } }
      );

      if (!mbResponse.ok) {
        throw new Error('MusicBrainz search failed');
      }

      const mbData = await mbResponse.json();
      return mbData.releases || [];
    };

    // Try with full artist name first
    let releases = await doSearch(artist);

    // If no results and artist contains "&" or " and ", try with just the first artist
    if (releases.length === 0) {
      let firstArtist = null;

      if (artist.includes(' & ')) {
        firstArtist = artist.split(' & ')[0].trim();
      } else if (artist.toLowerCase().includes(' and ')) {
        firstArtist = artist.split(/ and /i)[0].trim();
      }

      if (firstArtist) {
        console.log(`MusicBrainz: No results for "${artist}", trying with "${firstArtist}"`);
        releases = await doSearch(firstArtist);
      }
    }

    return releases;
  };

  // Fetch album art for Critic's Picks in background
  const fetchCriticsPicksAlbumArt = async (albums) => {
    // First pass: check cache for all albums (instant, no network)
    const albumsNeedingFetch = [];
    const cachedUpdates = [];
    const failedAlbumIds = [];

    for (const album of albums) {
      const lookupKey = `${album.artist}-${album.title}`.toLowerCase();
      const cachedReleaseId = albumToReleaseIdCache.current[lookupKey];
      const hasArtUrl = cachedReleaseId && albumArtCache.current[cachedReleaseId]?.url;

      if (hasArtUrl) {
        // We have cached art - collect for batch update
        cachedUpdates.push({ id: album.id, albumArt: albumArtCache.current[cachedReleaseId].url });
      } else if (cachedReleaseId === null) {
        // Previously failed to find this album - mark as null to show placeholder
        failedAlbumIds.push(album.id);
      } else {
        // No cached art or release ID not yet looked up - need to fetch
        albumsNeedingFetch.push(album);
      }
    }

    // Apply cached updates immediately (both successes and known failures)
    if (cachedUpdates.length > 0 || failedAlbumIds.length > 0) {
      console.log(`ðŸ“° Using cached art for ${cachedUpdates.length} Critic's Picks albums, ${failedAlbumIds.length} known failures`);
      setCriticsPicks(prev => prev.map(a => {
        const cached = cachedUpdates.find(u => u.id === a.id);
        if (cached) return { ...a, albumArt: cached.albumArt };
        if (failedAlbumIds.includes(a.id)) return { ...a, albumArt: null };
        return a;
      }));
    }

    // Second pass: fetch art for albums not in cache
    for (const album of albumsNeedingFetch) {
      try {
        const artUrl = await getAlbumArt(album.artist, album.title);
        // Set to artUrl if found, or null if not (to show placeholder instead of shimmer)
        setCriticsPicks(prev => prev.map(a =>
          a.id === album.id ? { ...a, albumArt: artUrl || null } : a
        ));
      } catch (error) {
        console.log(`Could not fetch art for: ${album.artist} - ${album.title}`);
        // Set to null on error to show placeholder
        setCriticsPicks(prev => prev.map(a =>
          a.id === album.id ? { ...a, albumArt: null } : a
        ));
      }
      // Small delay to avoid rate limiting
      await new Promise(resolve => setTimeout(resolve, 200));
    }
  };

  // Navigate to a Critic's Picks album release page
  const openCriticsPicksAlbum = async (album) => {
    console.log(`ðŸŽµ Opening Critic's Pick: ${album.artist} - ${album.title}`);

    try {
      // Search MusicBrainz for the release (with fallback for multi-artist names)
      const releases = await searchMusicBrainzRelease(album.title, album.artist);

      if (releases.length === 0) {
        // Fallback: just navigate to artist page
        console.log('Release not found in MusicBrainz, navigating to artist page');
        fetchArtistData(album.artist);
        return;
      }

      const release = releases[0];
      const artistCredit = release['artist-credit']?.[0];

      // Cache the release ID mapping so art loaded on album page can be reused
      const lookupKey = `${album.artist}-${album.title}`.toLowerCase();
      albumToReleaseIdCache.current[lookupKey] = release.id;

      // Create artist object for the release page
      const artist = {
        id: artistCredit?.artist?.id,
        name: artistCredit?.artist?.name || album.artist
      };

      // Create release object matching the expected format
      const releaseObj = {
        id: release.id,
        title: release.title,
        date: release.date,
        releaseType: release['release-group']?.['primary-type']?.toLowerCase() || 'album',
        albumArt: album.albumArt
      };

      // Set artist context and fetch release data
      // Mark that we're opening a release so header stays collapsed
      openingReleaseRef.current = true;
      setCurrentArtist(artist);
      navigateTo('artist');
      fetchReleaseData(releaseObj, artist);

    } catch (error) {
      console.error('Error opening Critic\'s Pick album:', error);
      // Fallback: navigate to artist page
      fetchArtistData(album.artist);
    }
  };

  // Navigate to a Top Album from History page
  const openTopAlbum = async (album) => {
    console.log(`ðŸŽµ Opening Top Album: ${album.artist} - ${album.name}`);

    try {
      // Search MusicBrainz for the release (with fallback for multi-artist names)
      const releases = await searchMusicBrainzRelease(album.name, album.artist);

      if (releases.length === 0) {
        // Fallback: just navigate to artist page
        console.log('Release not found in MusicBrainz, navigating to artist page');
        fetchArtistData(album.artist);
        return;
      }

      const release = releases[0];
      const artistCredit = release['artist-credit']?.[0];

      // Cache the release ID mapping so art loaded on album page can be reused
      const lookupKey = `${album.artist}-${album.name}`.toLowerCase();
      albumToReleaseIdCache.current[lookupKey] = release.id;

      // Create artist object for the release page
      const artist = {
        id: artistCredit?.artist?.id,
        name: artistCredit?.artist?.name || album.artist
      };

      // Create release object matching the expected format
      const releaseObj = {
        id: release.id,
        title: release.title,
        date: release.date,
        releaseType: release['release-group']?.['primary-type']?.toLowerCase() || 'album',
        albumArt: album.image
      };

      // Set artist context and fetch release data
      // Mark that we're opening a release so header stays collapsed
      openingReleaseRef.current = true;
      setCurrentArtist(artist);
      navigateTo('artist');
      fetchReleaseData(releaseObj, artist);

    } catch (error) {
      console.error('Error opening Top Album:', error);
      // Fallback: navigate to artist page
      fetchArtistData(album.artist);
    }
  };

  // Prefetch Critic's Picks album tracks on hover (for Add to Queue)
  const prefetchCriticsPicksTracks = async (album) => {
    // Skip if already prefetched
    if (prefetchedReleases[album.id]) {
      return;
    }

    try {
      console.log('ðŸ” Prefetching Critic\'s Pick tracks for:', album.title);

      // Search MusicBrainz for the release
      const searchQuery = encodeURIComponent(`release:"${album.title}" AND artist:"${album.artist}"`);
      const mbResponse = await fetch(
        `https://musicbrainz.org/ws/2/release/?query=${searchQuery}&fmt=json&limit=1`,
        { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' } }
      );

      if (!mbResponse.ok) return;

      const mbData = await mbResponse.json();
      if (!mbData.releases || mbData.releases.length === 0) return;

      const releaseId = mbData.releases[0].id;

      // Fetch release details with tracks
      const releaseDetailsResponse = await fetch(
        `https://musicbrainz.org/ws/2/release/${releaseId}?inc=recordings+artist-credits&fmt=json`,
        { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' } }
      );

      if (!releaseDetailsResponse.ok) return;

      const releaseData = await releaseDetailsResponse.json();

      // Extract tracks
      const tracks = [];
      if (releaseData.media && releaseData.media.length > 0) {
        releaseData.media.forEach((medium) => {
          if (medium.tracks) {
            medium.tracks.forEach(track => {
              const trackId = `${album.artist}-${track.title || 'untitled'}-${album.title}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
              tracks.push({
                id: trackId,
                position: track.position,
                title: track.title || track.recording?.title || 'Unknown Track',
                length: track.length,
                recordingId: track.recording?.id,
                artist: album.artist,
                album: album.title,
                albumArt: album.albumArt,
                sources: {}
              });
            });
          }
        });
      }

      // Cache the prefetched tracks
      setPrefetchedReleases(prev => ({
        ...prev,
        [album.id]: {
          tracks,
          title: album.title,
          albumArt: album.albumArt,
          artist: album.artist
        }
      }));

      console.log(`âœ… Prefetched ${tracks.length} tracks for ${album.title}`);
    } catch (error) {
      console.error('Error prefetching Critic\'s Pick tracks:', error);
    }
  };

  // Add Critic's Picks album to queue
  const addCriticsPicksToQueue = async (album) => {
    const context = { type: 'album', id: album.id, name: album.title, artist: album.artist };

    // Check if we have prefetched tracks
    const prefetched = prefetchedReleases[album.id];

    if (prefetched?.tracks?.length > 0) {
      addToQueue(prefetched.tracks, context);
      return;
    }

    // Otherwise, fetch and add
    await prefetchCriticsPicksTracks(album);
    const newPrefetched = prefetchedReleases[album.id];
    if (newPrefetched?.tracks?.length > 0) {
      addToQueue(newPrefetched.tracks, context);
    }
  };

  // Cache for mapping artist+album -> MusicBrainz release ID (to avoid repeated searches)
  const albumToReleaseIdCache = useRef({});

  // Fetch album art for a track by searching MusicBrainz first, then using the shared albumArtCache
  const getAlbumArt = async (artist, album) => {
    if (!artist || !album) return null;

    const lookupKey = `${artist}-${album}`.toLowerCase();

    // Check if we've already looked up this artist+album combo
    if (albumToReleaseIdCache.current[lookupKey] !== undefined) {
      const releaseId = albumToReleaseIdCache.current[lookupKey];
      if (releaseId === null) return null; // Previously failed lookup

      // If we have cached art, return it
      if (albumArtCache.current[releaseId]?.url) {
        return albumArtCache.current[releaseId].url;
      }

      // We have a release ID but no cached art - try to fetch cover art
      try {
        const caaResponse = await fetch(
          `https://coverartarchive.org/release/${releaseId}/front-250`,
          { redirect: 'follow' }
        );
        if (caaResponse.ok) {
          const artUrl = caaResponse.url;
          albumArtCache.current[releaseId] = { url: artUrl, timestamp: Date.now() };
          return artUrl;
        }
      } catch (error) {
        console.log(`Cover art fetch failed for release ${releaseId}:`, error.message);
      }
      return null; // No art available for this release
    }

    try {
      // Search MusicBrainz for the release (with fallback for multi-artist names)
      const releases = await searchMusicBrainzRelease(album, artist);

      if (releases.length === 0) {
        albumToReleaseIdCache.current[lookupKey] = null;
        return null;
      }

      const releaseId = releases[0].id;
      albumToReleaseIdCache.current[lookupKey] = releaseId;

      // Check if we already have art for this release in the shared cache
      if (albumArtCache.current[releaseId]?.url) {
        return albumArtCache.current[releaseId].url;
      }

      // Fetch cover art from Cover Art Archive
      const caaResponse = await fetch(
        `https://coverartarchive.org/release/${releaseId}/front-250`,
        { redirect: 'follow' }
      );

      if (caaResponse.ok) {
        const artUrl = caaResponse.url;
        // Store in the shared albumArtCache with timestamp
        albumArtCache.current[releaseId] = { url: artUrl, timestamp: Date.now() };
        return artUrl;
      }

      return null;
    } catch (error) {
      console.log(`Cover art not found for: ${artist} - ${album}`);
      albumToReleaseIdCache.current[lookupKey] = null;
      return null;
    }
  };

  // Detect face position in an image using browser's FaceDetector API
  const detectFacePosition = async (imageUrl) => {
    // Check if FaceDetector API is available (Chromium/Electron)
    if (!('FaceDetector' in window)) {
      console.log('FaceDetector API not available');
      return null;
    }

    try {
      // Load image into an HTMLImageElement
      const img = new Image();
      img.crossOrigin = 'anonymous';
      await new Promise((resolve, reject) => {
        img.onload = resolve;
        img.onerror = reject;
        img.src = imageUrl;
      });

      // Detect faces
      const detector = new FaceDetector();
      const faces = await detector.detect(img);

      if (faces.length === 0) {
        console.log('No faces detected in image');
        return null;
      }

      // Find largest face (by bounding box area) - likely the main artist
      const largest = faces.reduce((a, b) =>
        (a.boundingBox.width * a.boundingBox.height) >
        (b.boundingBox.width * b.boundingBox.height) ? a : b
      );

      // Calculate vertical center of face as percentage
      const faceCenter = largest.boundingBox.y + (largest.boundingBox.height / 2);
      const percentage = Math.round((faceCenter / img.height) * 100);

      console.log(`Face detected at ${percentage}% from top`);
      return `center ${percentage}%`;
    } catch (error) {
      console.error('Face detection failed:', error);
      return null;
    }
  };

  // Fetch artist image from Spotify API with caching and face detection
  // Track in-flight requests to prevent duplicate concurrent fetches
  const artistImageFetchPromises = useRef({});

  const getArtistImage = async (artistName) => {
    if (!artistName) return null;

    const normalizedName = artistName.trim().toLowerCase();
    const cached = artistImageCache.current[normalizedName];
    const now = Date.now();

    // Check cache validity - return both url and facePosition
    if (cached && (now - cached.timestamp) < CACHE_TTL.artistImage) {
      return { url: cached.url, facePosition: cached.facePosition };
    }

    // Check if there's already a fetch in progress for this artist
    if (artistImageFetchPromises.current[normalizedName]) {
      return artistImageFetchPromises.current[normalizedName];
    }

    // Spotify requires authentication
    if (!spotifyToken) {
      console.log('Spotify not connected, cannot fetch artist image');
      return null;
    }

    // Create the fetch promise and store it
    const fetchPromise = (async () => {
      try {
        // Search for the artist on Spotify with exact artist name matching
        const searchUrl = `https://api.spotify.com/v1/search?q=artist:"${encodeURIComponent(artistName)}"&type=artist&limit=5`;
        const response = await fetch(searchUrl, {
          headers: { 'Authorization': `Bearer ${spotifyToken}` }
        });

        if (!response.ok) {
          console.error('Spotify artist search failed:', response.status);
          return null;
        }

        const data = await response.json();

        // Find the artist with exact name match only (case-insensitive)
        // Don't fall back to first result - this causes wrong images for similar artist names
        const artists = data.artists?.items || [];
        const artist = artists.find(a => a.name.toLowerCase() === artistName.toLowerCase());

        if (artist?.images?.length > 0) {
          // Spotify returns images sorted by size (largest first)
          const imageUrl = artist.images[0].url;

          // Detect face position for smart cropping
          const facePosition = await detectFacePosition(imageUrl);

          artistImageCache.current[normalizedName] = {
            url: imageUrl,
            facePosition: facePosition, // may be null
            timestamp: now
          };

          return { url: imageUrl, facePosition };
        }

        return null; // No image available, don't cache failure
      } catch (error) {
        console.error('Failed to fetch artist image from Spotify:', error);
        return null; // Don't cache failures
      } finally {
        // Clean up the in-flight promise
        delete artistImageFetchPromises.current[normalizedName];
      }
    })();

    artistImageFetchPromises.current[normalizedName] = fetchPromise;
    return fetchPromise;
  };

  // Fetch artist image and bio for search preview pane
  useEffect(() => {
    // Only fetch for artist previews when we have a preview item
    if (searchDetailCategory !== 'artists' || !searchPreviewItem) {
      setSearchPreviewArtistImage(null);
      setSearchPreviewArtistBio(null);
      return;
    }

    const artistName = searchPreviewItem.name;
    if (!artistName) return;

    // Fetch artist image from Spotify (uses existing cache)
    const fetchArtistImage = async () => {
      const result = await getArtistImage(artistName);
      if (result?.url) {
        setSearchPreviewArtistImage(result);
      } else {
        setSearchPreviewArtistImage(null);
      }
    };

    // Fetch artist bio snippet from Last.fm (lightweight version, no loading state)
    const fetchArtistBioSnippet = async () => {
      const apiKey = lastfmApiKey.current;
      if (!apiKey) {
        setSearchPreviewArtistBio(null);
        return;
      }

      try {
        const url = `https://ws.audioscrobbler.com/2.0/?method=artist.getinfo&artist=${encodeURIComponent(artistName)}&api_key=${apiKey}&format=json`;
        const response = await fetch(url);
        if (!response.ok) {
          setSearchPreviewArtistBio(null);
          return;
        }

        const data = await response.json();
        if (data.artist?.bio) {
          // Use summary for preview (shorter than content)
          const bioSummary = data.artist.bio.summary || data.artist.bio.content || '';
          // Strip HTML tags and limit to ~200 chars for preview
          const cleanBio = bioSummary.replace(/<[^>]*>/g, '').trim();
          const truncatedBio = cleanBio.length > 200 ? cleanBio.substring(0, 200) + '...' : cleanBio;
          setSearchPreviewArtistBio(truncatedBio);
        } else {
          setSearchPreviewArtistBio(null);
        }
      } catch (error) {
        console.error('Failed to fetch artist bio snippet:', error);
        setSearchPreviewArtistBio(null);
      }
    };

    fetchArtistImage();
    fetchArtistBioSnippet();
  }, [searchDetailCategory, searchPreviewItem?.id]);

  // Fetch artist biography from Last.fm (lazy loaded on Biography tab click)
  const getLastfmBio = async (artistName) => {
    if (!artistName) return null;

    const apiKey = lastfmApiKey.current;
    if (!apiKey) {
      console.warn('âš ï¸ Last.fm API key not available, cannot fetch artist bio');
      return null;
    }

    try {
      const url = `https://ws.audioscrobbler.com/2.0/?method=artist.getinfo&artist=${encodeURIComponent(artistName)}&api_key=${apiKey}&format=json`;

      const response = await fetch(url);
      if (!response.ok) {
        console.error('Last.fm artist info request failed:', response.status);
        return null;
      }

      const data = await response.json();
      if (data.artist?.bio) {
        // Strip HTML tags from bio content
        const bioContent = data.artist.bio.content || data.artist.bio.summary || '';
        const cleanBio = bioContent.replace(/<[^>]*>/g, '').trim();

        // Check if bio has meaningful content (not just "Read more on Last.fm" or similar)
        // Last.fm often returns empty bios with just a link
        if (!cleanBio || cleanBio.length < 50 || cleanBio.toLowerCase().includes('read more on last.fm')) {
          console.log('ðŸŽ§ Last.fm bio is empty or too short, skipping');
          return null;
        }

        // Also get the Last.fm URL for "Read more" link
        const lastfmUrl = data.artist.url || null;

        return { bio: cleanBio, url: lastfmUrl, source: 'lastfm' };
      }

      return null;
    } catch (error) {
      console.error('Failed to fetch artist bio from Last.fm:', error);
      return null;
    }
  };

  // Fetch artist biography from Wikipedia via Wikidata (uses MBID)
  const getWikipediaBio = async (artistMbid) => {
    if (!artistMbid) {
      console.log('ðŸ“š Wikipedia bio skipped: no MBID');
      return null;
    }

    try {
      // Step 1: Query MusicBrainz for Wikidata relation
      const mbUrl = `https://musicbrainz.org/ws/2/artist/${artistMbid}?inc=url-rels&fmt=json`;
      const mbResponse = await fetch(mbUrl, {
        headers: { 'User-Agent': 'Parachord/1.0 (https://parachord.app)' }
      });

      if (!mbResponse.ok) {
        console.log('ðŸ“š MusicBrainz artist lookup failed:', mbResponse.status);
        return null;
      }

      const mbData = await mbResponse.json();

      // Find Wikidata URL in relations
      const wikidataRel = mbData.relations?.find(r =>
        r.type === 'wikidata' && r.url?.resource
      );

      if (!wikidataRel) {
        console.log('ðŸ“š No Wikidata link found for artist');
        return null;
      }

      // Extract Wikidata ID (e.g., "Q1299" from "https://www.wikidata.org/wiki/Q1299")
      const wikidataUrl = wikidataRel.url.resource;
      const wikidataId = wikidataUrl.split('/').pop();

      // Step 2: Query Wikidata for Wikipedia article title
      const wdUrl = `https://www.wikidata.org/w/api.php?action=wbgetentities&ids=${wikidataId}&props=sitelinks&sitefilter=enwiki&format=json&origin=*`;
      const wdResponse = await fetch(wdUrl);

      if (!wdResponse.ok) {
        console.log('ðŸ“š Wikidata lookup failed:', wdResponse.status);
        return null;
      }

      const wdData = await wdResponse.json();
      const wikiTitle = wdData.entities?.[wikidataId]?.sitelinks?.enwiki?.title;

      if (!wikiTitle) {
        console.log('ðŸ“š No English Wikipedia article found');
        return null;
      }

      // Step 3: Fetch Wikipedia article extract (longer bio)
      // Using MediaWiki API with extracts to get more content than the summary endpoint
      const wpUrl = `https://en.wikipedia.org/w/api.php?action=query&titles=${encodeURIComponent(wikiTitle)}&prop=extracts&exintro=1&explaintext=1&format=json&origin=*`;
      const wpResponse = await fetch(wpUrl);

      if (!wpResponse.ok) {
        console.log('ðŸ“š Wikipedia extract fetch failed:', wpResponse.status);
        return null;
      }

      const wpData = await wpResponse.json();
      const pages = wpData.query?.pages;
      const pageId = pages ? Object.keys(pages)[0] : null;
      const extract = pageId && pageId !== '-1' ? pages[pageId].extract : null;

      if (extract) {
        console.log('ðŸ“š Wikipedia bio fetched successfully');
        // Normalize line breaks: ensure double newlines between paragraphs for visual separation
        const formattedBio = extract.trim().replace(/\n+/g, '\n\n');
        return {
          bio: formattedBio,
          url: `https://en.wikipedia.org/wiki/${encodeURIComponent(wikiTitle)}`,
          source: 'wikipedia'
        };
      }

      return null;
    } catch (error) {
      console.error('ðŸ“š Failed to fetch Wikipedia bio:', error);
      return null;
    }
  };

  // Fetch artist image from Wikipedia/Wikidata (fallback when Spotify has no image)
  const getWikipediaArtistImage = async (artistMbid) => {
    if (!artistMbid) return null;

    try {
      // Step 1: Get Wikidata ID via MusicBrainz
      const mbUrl = `https://musicbrainz.org/ws/2/artist/${artistMbid}?inc=url-rels&fmt=json`;
      const mbResponse = await fetch(mbUrl, {
        headers: { 'User-Agent': 'Parachord/1.0 (https://parachord.app)' }
      });

      if (!mbResponse.ok) return null;

      const mbData = await mbResponse.json();
      const wikidataRel = mbData.relations?.find(r =>
        r.type === 'wikidata' && r.url?.resource
      );

      if (!wikidataRel) return null;

      const wikidataId = wikidataRel.url.resource.split('/').pop();

      // Step 2: Get Wikipedia article title
      const wdUrl = `https://www.wikidata.org/w/api.php?action=wbgetentities&ids=${wikidataId}&props=sitelinks&sitefilter=enwiki&format=json&origin=*`;
      const wdResponse = await fetch(wdUrl);

      if (!wdResponse.ok) return null;

      const wdData = await wdResponse.json();
      const wikiTitle = wdData.entities?.[wikidataId]?.sitelinks?.enwiki?.title;

      if (!wikiTitle) return null;

      // Step 3: Fetch Wikipedia page summary (includes thumbnail)
      const wpUrl = `https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(wikiTitle)}`;
      const wpResponse = await fetch(wpUrl);

      if (!wpResponse.ok) return null;

      const wpData = await wpResponse.json();

      if (wpData.thumbnail?.source) {
        console.log('ðŸ“š Wikipedia artist image found');
        return wpData.thumbnail.source;
      }

      return null;
    } catch (error) {
      console.error('ðŸ“š Failed to fetch Wikipedia artist image:', error);
      return null;
    }
  };

  // Fetch artist biography from Discogs (uses MBID or artist name)
  const getDiscogsBio = async (artistMbid, artistName) => {
    if (!artistMbid && !artistName) {
      console.log('ðŸ“€ Discogs bio skipped: no MBID or name');
      return null;
    }

    try {
      // Get Discogs token from metaservice config if available
      const discogsConfig = metaServiceConfigs?.discogs || {};
      const token = discogsConfig.personalAccessToken;

      const headers = {
        'User-Agent': 'Parachord/1.0 (https://parachord.app)'
      };
      if (token) {
        headers['Authorization'] = `Discogs token=${token}`;
      }

      // Search for artist on Discogs
      const searchQuery = artistName || artistMbid;
      const searchUrl = `https://api.discogs.com/database/search?q=${encodeURIComponent(searchQuery)}&type=artist&per_page=5`;

      const searchResponse = await fetch(searchUrl, { headers });

      if (!searchResponse.ok) {
        console.log('ðŸ“€ Discogs search failed:', searchResponse.status);
        return null;
      }

      const searchData = await searchResponse.json();

      if (!searchData.results?.length) {
        console.log('ðŸ“€ No Discogs results found');
        return null;
      }

      // Find best match - prefer exact name match
      let artistResult = searchData.results.find(r =>
        r.title?.toLowerCase() === artistName?.toLowerCase()
      );

      // Fall back to first result if no exact match
      if (!artistResult) {
        artistResult = searchData.results[0];
      }

      // Fetch full artist profile
      const artistUrl = artistResult.resource_url;
      const artistResponse = await fetch(artistUrl, { headers });

      if (!artistResponse.ok) {
        console.log('ðŸ“€ Discogs artist fetch failed:', artistResponse.status);
        return null;
      }

      const artistData = await artistResponse.json();

      if (artistData.profile) {
        // Clean up Discogs profile (remove [a=Artist] style links)
        const cleanProfile = artistData.profile
          .replace(/\[a=([^\]]+)\]/g, '$1')  // [a=Artist Name] -> Artist Name
          .replace(/\[l=([^\]]+)\]/g, '$1')  // [l=Label Name] -> Label Name
          .replace(/\[m=([^\]]+)\]/g, '$1')  // [m=Master] -> Master
          .replace(/\[r=([^\]]+)\]/g, '$1')  // [r=Release] -> Release
          .replace(/\[url=([^\]]+)\]([^\[]+)\[\/url\]/g, '$2')  // [url=...]text[/url] -> text
          .trim();

        console.log('ðŸ“€ Discogs bio fetched successfully');
        return {
          bio: cleanProfile,
          url: artistData.uri || `https://www.discogs.com/artist/${artistData.id}`,
          source: 'discogs'
        };
      }

      return null;
    } catch (error) {
      console.error('ðŸ“€ Failed to fetch Discogs bio:', error);
      return null;
    }
  };

  // Fetch artist image from Discogs (fallback when Spotify and Wikipedia have no image)
  const getDiscogsArtistImage = async (artistMbid, artistName) => {
    if (!artistName) return null;

    try {
      const discogsConfig = metaServiceConfigs?.discogs || {};
      const token = discogsConfig.personalAccessToken;

      const headers = {
        'User-Agent': 'Parachord/1.0 (https://parachord.app)'
      };
      if (token) {
        headers['Authorization'] = `Discogs token=${token}`;
      }

      // Search for artist
      const searchUrl = `https://api.discogs.com/database/search?q=${encodeURIComponent(artistName)}&type=artist&per_page=5`;
      const searchResponse = await fetch(searchUrl, { headers });

      if (!searchResponse.ok) return null;

      const searchData = await searchResponse.json();

      if (!searchData.results?.length) return null;

      // Find best match
      let artistResult = searchData.results.find(r =>
        r.title?.toLowerCase() === artistName.toLowerCase()
      ) || searchData.results[0];

      // Fetch full artist profile for images
      const artistResponse = await fetch(artistResult.resource_url, { headers });

      if (!artistResponse.ok) return null;

      const artistData = await artistResponse.json();

      // Discogs images array - first is primary
      if (artistData.images?.length > 0) {
        // Prefer primary image, fall back to first
        const primaryImage = artistData.images.find(img => img.type === 'primary');
        const imageUrl = primaryImage?.uri || artistData.images[0].uri;
        console.log('ðŸ“€ Discogs artist image found');
        return imageUrl;
      }

      return null;
    } catch (error) {
      console.error('ðŸ“€ Failed to fetch Discogs artist image:', error);
      return null;
    }
  };

  // Fetch artist biography from all sources with priority: Wikipedia > Discogs > Last.fm
  const getArtistBio = async (artistName, artistMbid) => {
    if (!artistName) return null;

    setLoadingBio(true);
    try {
      // Fetch from all sources in parallel
      const [wikipediaBio, discogsBio, lastfmBio] = await Promise.all([
        getWikipediaBio(artistMbid),
        getDiscogsBio(artistMbid, artistName),
        getLastfmBio(artistName)
      ]);

      // Store all sources for potential future use
      const allSources = {};
      if (wikipediaBio) allSources.wikipedia = wikipediaBio;
      if (discogsBio) allSources.discogs = discogsBio;
      if (lastfmBio) allSources.lastfm = lastfmBio;

      // Select best bio based on priority: Wikipedia > Discogs > Last.fm
      const selected = wikipediaBio ?? discogsBio ?? lastfmBio;

      if (selected) {
        console.log(`ðŸŽ¤ Selected bio from ${selected.source}`);
        return { ...selected, allSources };
      }

      console.log('ðŸŽ¤ No biography found from any source');
      return null;
    } catch (error) {
      console.error('Failed to fetch artist bio:', error);
      return null;
    } finally {
      setLoadingBio(false);
    }
  };

  // Fetch similar artists from ListenBrainz Labs API
  const getListenBrainzSimilarArtists = async (artistMbid) => {
    if (!artistMbid) {
      console.log('ðŸŽ¸ ListenBrainz similar artists skipped: no MBID');
      return [];
    }

    try {
      const url = 'https://labs.api.listenbrainz.org/similar-artists/json';
      const payload = [
        {
          artist_mbids: [artistMbid],
          algorithm: 'session_based_days_7500_session_300_contribution_5_threshold_10_limit_100_filter_True_skip_30'
        }
      ];

      console.log(`ðŸŽ¸ Fetching ListenBrainz similar artists for MBID: ${artistMbid}`);
      const response = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      if (!response.ok) {
        console.error('ListenBrainz similar artists request failed:', response.status);
        return [];
      }

      const data = await response.json();
      console.log(`ðŸŽ¸ ListenBrainz returned ${data?.length || 0} results`);

      // Filter out the reference artist (first result) and map to our format
      // ListenBrainz returns results with score field, higher is more similar
      if (data && Array.isArray(data) && data.length > 1) {
        // Skip first result (reference artist) and take next 20
        const similarArtists = data.slice(1, 21).map((a, index) => ({
          name: a.name || a.artist_name,
          mbid: a.artist_mbid,
          match: Math.round(a.score * 100) || Math.max(95 - (index * 4), 20), // Convert score to percentage
          source: 'listenbrainz',
          imageLoaded: false
        }));
        console.log(`ðŸŽ¸ Returning ${similarArtists.length} ListenBrainz similar artists:`, similarArtists.map(a => a.name));
        return similarArtists;
      }

      return [];
    } catch (error) {
      console.error('Failed to fetch similar artists from ListenBrainz:', error);
      return [];
    }
  };

  // Fetch similar artists from Last.fm API
  const getLastfmSimilarArtists = async (artistName) => {
    if (!artistName) return [];

    const apiKey = lastfmApiKey.current;
    if (!apiKey) {
      console.log('ðŸŽ¸ Last.fm similar artists skipped: no API key');
      return [];
    }

    try {
      const url = `https://ws.audioscrobbler.com/2.0/?method=artist.getsimilar&artist=${encodeURIComponent(artistName)}&api_key=${apiKey}&format=json&limit=20`;

      const response = await fetch(url);
      if (!response.ok) {
        console.error('Last.fm similar artists request failed:', response.status);
        return [];
      }

      const data = await response.json();
      if (data.similarartists?.artist) {
        const artists = data.similarartists.artist.map(a => ({
          name: a.name,
          match: Math.round(parseFloat(a.match) * 100), // Convert 0-1 to percentage
          url: a.url,
          source: 'lastfm',
          imageLoaded: false
        }));
        console.log(`ðŸŽ¸ Returning ${artists.length} Last.fm similar artists`);
        return artists;
      }

      return [];
    } catch (error) {
      console.error('Failed to fetch similar artists from Last.fm:', error);
      return [];
    }
  };

  // Fetch related artists from both Last.fm and ListenBrainz (merged and de-duped)
  const getRelatedArtists = async (artistName, artistMbid) => {
    if (!artistName) return [];

    setLoadingRelated(true);
    try {
      // Fetch from both sources in parallel
      const [lastfmArtists, listenbrainzArtists] = await Promise.all([
        getLastfmSimilarArtists(artistName),
        getListenBrainzSimilarArtists(artistMbid)
      ]);

      console.log(`ðŸŽ¸ Fetched ${lastfmArtists.length} from Last.fm, ${listenbrainzArtists.length} from ListenBrainz`);

      // Merge and de-dupe by artist name (case-insensitive)
      const artistMap = new Map();

      // Add Last.fm artists first
      for (const artist of lastfmArtists) {
        const key = artist.name.toLowerCase().trim();
        artistMap.set(key, { ...artist });
      }

      // Merge ListenBrainz artists, combining data for duplicates
      for (const artist of listenbrainzArtists) {
        const key = artist.name.toLowerCase().trim();
        if (artistMap.has(key)) {
          const existing = artistMap.get(key);
          // Keep the higher match score and add ListenBrainz MBID
          artistMap.set(key, {
            ...existing,
            match: Math.max(existing.match, artist.match),
            mbid: artist.mbid || existing.mbid,
            source: 'both' // Mark as appearing in both sources
          });
        } else {
          artistMap.set(key, { ...artist });
        }
      }

      const merged = Array.from(artistMap.values());
      console.log(`ðŸŽ¸ Merged to ${merged.length} unique related artists`);

      return merged;
    } catch (error) {
      console.error('Failed to fetch related artists:', error);
      return [];
    } finally {
      setLoadingRelated(false);
    }
  };

  // Fetch images for related artists
  const resolveRelatedArtistImages = async (artists) => {
    console.log(`ðŸŽ¸ Fetching images for ${artists.length} related artists...`);

    for (const artist of artists) {
      try {
        const result = await getArtistImage(artist.name);
        // Update with image URL and mark as loaded
        setRelatedArtists(prev => prev.map(a =>
          a.name === artist.name ? { ...a, image: result?.url || null, imageLoaded: true } : a
        ));
      } catch (err) {
        console.error(`Error fetching image for ${artist.name}:`, err);
        // Mark as loaded even on error so we show the fallback icon
        setRelatedArtists(prev => prev.map(a =>
          a.name === artist.name ? { ...a, imageLoaded: true } : a
        ));
      }
    }
    console.log(`ðŸŽ¸ Finished fetching related artist images`);
  };

  // Get 4 unique covers for a playlist's 2x2 grid display
  // Prioritizes album art, falls back to artist images
  // Returns array of up to 4 image URLs, using cache when available
  const getPlaylistCovers = async (playlistId, tracks) => {
    // Check cache first
    const cached = playlistCoverCache.current[playlistId];
    if (cached && Date.now() - cached.timestamp < CACHE_TTL.playlistCover) {
      return cached.covers;
    }

    // Collect unique covers from tracks
    const seenAlbums = new Set(); // Albums we've already tried
    const seenArtists = new Set(); // Artists we've already used for images
    const covers = [];

    for (const track of tracks) {
      if (covers.length >= 4) break;

      let foundCover = false;

      // First try album art if we have album info
      if (track.album && track.artist) {
        const albumKey = `${track.artist}-${track.album}`.toLowerCase();
        if (!seenAlbums.has(albumKey)) {
          seenAlbums.add(albumKey);

          // If track already has albumArt, use it
          if (track.albumArt) {
            covers.push(track.albumArt);
            foundCover = true;
          } else {
            // Try to fetch album art
            const artUrl = await getAlbumArt(track.artist, track.album);
            if (artUrl) {
              covers.push(artUrl);
              foundCover = true;
            }
          }
        }
      }

      // Fall back to artist image if no album art found for this track
      if (!foundCover && track.artist) {
        const artistKey = track.artist.toLowerCase();
        if (!seenArtists.has(artistKey)) {
          seenArtists.add(artistKey);

          const artistResult = await getArtistImage(track.artist);
          if (artistResult?.url) {
            covers.push(artistResult.url);
          }
        }
      }
    }

    // Cache the result
    if (covers.length > 0) {
      playlistCoverCache.current[playlistId] = {
        covers,
        timestamp: Date.now()
      };
    }

    return covers;
  };

  // Fetch and update covers for a single playlist (used after import)
  const fetchPlaylistCovers = async (playlistId, tracks) => {
    if (!tracks || tracks.length === 0) return;

    const covers = await getPlaylistCovers(playlistId, tracks);
    if (covers.length > 0) {
      setAllPlaylistCovers(prev => ({
        ...prev,
        [playlistId]: covers
      }));
    }
  };

  // State for current playlist's cover art grid
  const [playlistCoverArt, setPlaylistCoverArt] = useState([]);

  const loadPlaylist = async (playlistOrId, { skipNavigation = false } = {}) => {
    // Accept either a playlist object or an ID for backwards compatibility
    let playlist;
    if (typeof playlistOrId === 'string') {
      console.log('ðŸ–±ï¸ Playlist clicked, ID:', playlistOrId);
      playlist = playlists.find(p => p.id === playlistOrId);
      if (!playlist) {
        console.error('âŒ Playlist not found:', playlistOrId);
        return;
      }
    } else {
      playlist = playlistOrId;
      console.log('ðŸ–±ï¸ Playlist clicked, ID:', playlist.id);
    }

    // Skip if already viewing this playlist (avoid unnecessary reloads)
    if (activeView === 'playlist-view' && selectedPlaylist?.id === playlist.id) {
      console.log('ðŸ“‹ Already viewing playlist:', playlist.title);
      return;
    }

    console.log('ðŸ“‹ Found playlist:', playlist.title);

    setSelectedPlaylist(playlist);
    setPlaylistCoverArt([]); // Reset cover art
    if (!skipNavigation) {
      navigateTo('playlist-view');
    }
    console.log(`ðŸ“‹ Loading playlist: ${playlist.title}`);

    // Parse XSPF if we have the content
    if (playlist.xspf) {
      const parsed = parseXSPF(playlist.xspf);
      if (parsed) {
        console.log(`ðŸŽµ Parsed ${parsed.tracks.length} tracks from XSPF`);

        // Step 1: Immediately display all tracks with metadata (no sources yet)
        const tracksWithIds = parsed.tracks.map(track => {
          const trackId = `${track.artist || 'unknown'}-${track.title || 'untitled'}-${track.album || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
          return { ...track, id: trackId, sources: {} };
        });
        setPlaylistTracks(tracksWithIds);

        // Step 1.5: Fetch playlist cover art (4 unique album covers for 2x2 grid)
        getPlaylistCovers(playlist.id, tracksWithIds).then(covers => {
          setPlaylistCoverArt(covers);
        });

        // Step 1.6: Fetch album art for tracks that don't have it (background, non-blocking)
        tracksWithIds.forEach(async (track) => {
          if (!track.albumArt && track.album) {
            const artUrl = await getAlbumArt(track.artist, track.album);
            if (artUrl) {
              setPlaylistTracks(prevTracks =>
                prevTracks.map(t =>
                  t.id === track.id && !t.albumArt
                    ? { ...t, albumArt: artUrl }
                    : t
                )
              );
            }
          }
        });

        // Step 2: Resolve sources in the background for each track
        for (const track of tracksWithIds) {
          // Check if queue resolution has priority - if so, pause page resolution
          if (queueResolutionActiveRef.current) {
            console.log(`â¸ï¸ Pausing playlist resolution - queue resolution has priority`);
            while (queueResolutionActiveRef.current) {
              await new Promise(resolve => setTimeout(resolve, 100));
            }
            console.log(`â–¶ï¸ Resuming playlist resolution`);
          }

          console.log(`ðŸ” Resolving: ${track.artist} - ${track.title}`);

          // Resolve all sources for this track
          for (const resolverId of activeResolvers) {
            const resolver = allResolvers.find(r => r.id === resolverId);
            if (!resolver || !resolver.capabilities.resolve) continue;

            try {
              const config = await getResolverConfig(resolverId);
              const resolved = await resolver.resolve(track.artist, track.title, track.album, config);

              if (resolved) {
                console.log(`  âœ… ${resolver.name}: Found match`);
                // Update the track's sources and duration (if available) and trigger re-render
                setPlaylistTracks(prevTracks =>
                  prevTracks.map(t =>
                    t.id === track.id
                      ? {
                          ...t,
                          sources: { ...t.sources, [resolverId]: resolved },
                          // Update duration if resolved source has it and track doesn't
                          duration: t.duration || resolved.duration || 0
                        }
                      : t
                  )
                );
              }
            } catch (error) {
              console.error(`  âŒ ${resolver.name} resolve error:`, error);
            }
          }
        }

        console.log(`âœ… Finished resolving ${tracksWithIds.length} tracks`);
      }
    } else if (playlist.tracks && playlist.tracks.length > 0) {
      // Handle playlists with tracks array directly (e.g., newly created playlists)
      console.log(`ðŸŽµ Loading ${playlist.tracks.length} tracks from playlist object`);

      // Add IDs and sources to tracks if not present
      const tracksWithIds = playlist.tracks.map(track => {
        const trackId = track.id || `${track.artist || 'unknown'}-${track.title || 'untitled'}-${track.album || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
        return { ...track, id: trackId, sources: track.sources || {} };
      });
      setPlaylistTracks(tracksWithIds);

      // Fetch playlist cover art
      getPlaylistCovers(playlist.id, tracksWithIds).then(covers => {
        setPlaylistCoverArt(covers);
      });

      // Fetch album art for tracks that don't have it
      tracksWithIds.forEach(async (track) => {
        if (!track.albumArt && track.album) {
          const artUrl = await getAlbumArt(track.artist, track.album);
          if (artUrl) {
            setPlaylistTracks(prevTracks =>
              prevTracks.map(t =>
                t.id === track.id && !t.albumArt
                  ? { ...t, albumArt: artUrl }
                  : t
              )
            );
          }
        }
      });

      // Resolve sources in background
      for (const track of tracksWithIds) {
        // Check if queue resolution has priority - if so, pause page resolution
        if (queueResolutionActiveRef.current) {
          console.log(`â¸ï¸ Pausing playlist resolution - queue resolution has priority`);
          while (queueResolutionActiveRef.current) {
            await new Promise(resolve => setTimeout(resolve, 100));
          }
          console.log(`â–¶ï¸ Resuming playlist resolution`);
        }

        console.log(`ðŸ” Resolving: ${track.artist} - ${track.title}`);

        for (const resolverId of activeResolvers) {
          const resolver = allResolvers.find(r => r.id === resolverId);
          if (!resolver || !resolver.capabilities.resolve) continue;

          try {
            const config = await getResolverConfig(resolverId);
            const resolved = await resolver.resolve(track.artist, track.title, track.album, config);

            if (resolved) {
              console.log(`  âœ… ${resolver.name}: Found match`);
              setPlaylistTracks(prevTracks =>
                prevTracks.map(t =>
                  t.id === track.id
                    ? {
                        ...t,
                        sources: { ...t.sources, [resolverId]: resolved },
                        duration: t.duration || resolved.duration || 0
                      }
                    : t
                )
              );
            }
          } catch (error) {
            console.error(`  âŒ ${resolver.name} resolve error:`, error);
          }
        }
      }

      console.log(`âœ… Finished resolving ${tracksWithIds.length} tracks`);
    } else {
      // No tracks to display
      console.log('âš ï¸ Playlist has no tracks');
      setPlaylistTracks([]);
    }
  };

  // Keep queue in sync with playlistTracks as they get resolved
  // This ensures queue items get their sources updated without re-setting the entire queue
  useEffect(() => {
    if (currentQueue.length === 0 || playlistTracks.length === 0) return;

    // Check if queue tracks match playlist tracks (by id)
    const queueIds = new Set(currentQueue.map(t => t.id));
    const playlistIds = new Set(playlistTracks.map(t => t.id));

    // Only sync if the queue was created from this playlist
    const isQueueFromPlaylist = currentQueue.every(t => playlistIds.has(t.id));
    if (!isQueueFromPlaylist) return;

    // Update queue items with resolved sources and duration from playlistTracks
    setCurrentQueue(prevQueue =>
      prevQueue.map(queueTrack => {
        const playlistTrack = playlistTracks.find(t => t.id === queueTrack.id);
        if (playlistTrack) {
          const hasMoreSources = Object.keys(playlistTrack.sources || {}).length > Object.keys(queueTrack.sources || {}).length;
          const hasDuration = playlistTrack.duration && !queueTrack.duration;

          if (hasMoreSources || hasDuration) {
            // Update queue track with new sources and/or duration
            return {
              ...queueTrack,
              sources: { ...queueTrack.sources, ...playlistTrack.sources },
              duration: queueTrack.duration || playlistTrack.duration || 0
            };
          }
        }
        return queueTrack;
      })
    );
  }, [playlistTracks]);

  // Sync queue tracks with trackSources updates (for release/album tracks)
  // This ensures queue items get their sources updated when resolution completes
  useEffect(() => {
    if (currentQueue.length === 0 || Object.keys(trackSources).length === 0) return;

    // Check if any queue tracks need source updates from trackSources
    // trackSources uses keys like "1-Track Title" (position-title)
    let hasUpdates = false;
    const updatedQueue = currentQueue.map(queueTrack => {
      // Try to find matching sources in trackSources
      // Queue tracks from releases have position property
      if (queueTrack.position && queueTrack.title) {
        const trackKey = `${queueTrack.position}-${queueTrack.title}`;
        const resolvedSources = trackSources[trackKey];

        if (resolvedSources && Object.keys(resolvedSources).length > Object.keys(queueTrack.sources || {}).length) {
          hasUpdates = true;
          return { ...queueTrack, sources: { ...queueTrack.sources, ...resolvedSources } };
        }
      }
      return queueTrack;
    });

    if (hasUpdates) {
      setCurrentQueue(updatedQueue);
    }
  }, [trackSources]);

  // Watch for queue changes and resolve any unresolved tracks with priority
  // This handles cases where setCurrentQueue is called directly (e.g., clicking a track to play)
  useEffect(() => {
    if (currentQueue.length === 0) return;
    if (queueResolutionActiveRef.current) return; // Already resolving

    // Find tracks that need resolution
    const unresolvedTracks = currentQueue.filter(track =>
      !track.sources || Object.keys(track.sources).length === 0
    );

    if (unresolvedTracks.length > 0) {
      console.log(`ðŸŽ¯ Queue has ${unresolvedTracks.length} unresolved tracks, starting priority resolution`);
      resolveQueueTracks(unresolvedTracks);
    }
  }, [currentQueue]);

  // Navigation helpers
  const navigateTo = (view) => {
    if (view !== activeView) {
      // Clear search state when leaving search view
      if (activeView === 'search') {
        setSearchQuery('');
        setSearchResults({ artists: [], albums: [], tracks: [], playlists: [] });
        setIsSearching(false);
        setDisplayLimits({ artists: 5, albums: 5, tracks: 8, playlists: 5 });
        setSearchDetailCategory(null);
        setSearchPreviewItem(null);
      }
      setViewHistory(prev => [...prev, view]);
      setForwardHistory([]); // Clear forward history when navigating to a new view
      setActiveView(view);
      if (view === 'settings') {
        setSettingsTab('marketplace');
      }
    }
  };

  const navigateBack = () => {
    // If we're on artist page and have artist history, go to previous artist
    if (activeView === 'artist' && artistHistory.length > 0) {
      const newArtistHistory = [...artistHistory];
      const previousArtist = newArtistHistory.pop();
      setArtistHistory(newArtistHistory);

      // Fetch the previous artist's data
      const loadPreviousArtist = async () => {
        const cacheKey = previousArtist.toLowerCase();
        const cachedData = artistDataCache.current[cacheKey];
        const now = Date.now();

        // Check if artist image is in cache
        const normalizedName = previousArtist.trim().toLowerCase();
        const cachedImage = artistImageCache.current[normalizedName];
        const imageCacheValid = cachedImage && (now - cachedImage.timestamp) < CACHE_TTL.artistImage;

        // Cache is valid if data exists and not expired
        const cacheValid = cachedData &&
                          (now - cachedData.timestamp) < CACHE_TTL.artistData;

        if (cacheValid) {
          // Set artist image immediately from cache if available
          if (imageCacheValid) {
            setArtistImage(cachedImage.url);
            setArtistImagePosition(cachedImage.facePosition || 'center 25%');
          } else {
            setArtistImage(null);
            setArtistImagePosition('center 25%');
            getArtistImage(previousArtist).then(result => {
              if (result) {
                setArtistImage(result.url);
                setArtistImagePosition(result.facePosition || 'center 25%');
              }
            });
          }

          setCurrentArtist(cachedData.artist);
          const releasesWithCache = cachedData.releases.map(release => ({
            ...release,
            // Use cached URL if available, undefined if needs fetch (shows shimmer)
            albumArt: albumArtCache.current[release.id]?.url !== undefined
              ? albumArtCache.current[release.id]?.url
              : undefined
          }));
          setArtistReleases(releasesWithCache);
          setSmartReleaseTypeFilter(releasesWithCache);
          setLoadingArtist(false);
          fetchAlbumArtLazy(cachedData.releases);
        } else {
          // No valid cache - show loading state
          setLoadingArtist(true);
          setArtistImage(null);
          setArtistImagePosition('center 25%');

          // Refetch if not in cache (rare case)
          const searchResponse = await fetch(
            `https://musicbrainz.org/ws/2/artist?query=${encodeURIComponent(previousArtist)}&fmt=json&limit=1`,
            { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' } }
          );
          const searchData = await searchResponse.json();
          if (searchData.artists?.[0]) {
            const artist = searchData.artists[0];
            setCurrentArtist(artist);
            getArtistImage(previousArtist).then(result => {
              if (result) {
                setArtistImage(result.url);
                setArtistImagePosition(result.facePosition || 'center 25%');
              }
            });
          }
          setLoadingArtist(false);
        }
      };
      loadPreviousArtist();
      return;
    }

    if (viewHistory.length > 1) {
      const newHistory = [...viewHistory];
      const currentView = newHistory.pop(); // Remove current view
      const previousView = newHistory[newHistory.length - 1];
      setViewHistory(newHistory);
      setForwardHistory(prev => [...prev, currentView]); // Add current view to forward history
      setActiveView(previousView);

      // Clear associated state when leaving certain views
      if (currentView === 'artist') {
        setCurrentArtist(null);
        setArtistImage(null);
        setArtistImagePosition('center 25%');
        setArtistReleases([]);
        setReleaseTypeFilter('all');
        setArtistHistory([]); // Clear artist history when leaving artist view
      }
      if (currentView === 'release') {
        setCurrentRelease(null);
      }
      if (currentView === 'playlist-view') {
        setSelectedPlaylist(null);
        setPlaylistTracks([]);
      }
    }
  };

  const navigateForward = () => {
    if (forwardHistory.length > 0) {
      const newForwardHistory = [...forwardHistory];
      const nextView = newForwardHistory.pop();
      setForwardHistory(newForwardHistory);
      setViewHistory(prev => [...prev, nextView]);
      setActiveView(nextView);
    }
  };

  // Playlist import/export functions
  const handleImportPlaylist = async () => {
    try {
      console.log('ðŸ“¥ Importing playlist...');
      const result = await window.electron.playlists.import();
      
      if (!result) {
        console.log('Import cancelled');
        return;
      }
      
      if (result.error) {
        showConfirmDialog({
          type: 'error',
          title: 'Import Failed',
          message: result.error
        });
        return;
      }

      const { content, filename } = result;

      // Parse to get playlist info
      const parsed = parseXSPF(content);
      if (!parsed) {
        showConfirmDialog({
          type: 'error',
          title: 'Import Failed',
          message: 'Failed to parse XSPF file'
        });
        return;
      }
      
      // Generate unique ID for imported playlist
      const id = `imported-${Date.now()}`;

      // Create playlist object
      const newPlaylist = {
        id: id,
        title: parsed.title,
        creator: parsed.creator,
        tracks: parsed.tracks || [],
        xspf: content,
        createdAt: parsed.date || Date.now(), // Use XSPF date (original creation) or import time
        addedAt: Date.now(), // When added to library
        lastModified: Date.now()
      };

      // Save to electron-store
      const saveResult = await window.electron.playlists.save(newPlaylist);

      if (!saveResult.success) {
        showConfirmDialog({
          type: 'error',
          title: 'Save Failed',
          message: saveResult.error
        });
        return;
      }

      // Add to state (prepend so it appears at top immediately)
      setPlaylists(prev => [newPlaylist, ...prev]);

      // Fetch covers for the 2x2 grid display immediately
      fetchPlaylistCovers(id, parsed.tracks || []);

      console.log(`âœ… Imported playlist: ${parsed.title} (${newPlaylist.tracks.length} tracks)`);
      showConfirmDialog({
        type: 'success',
        title: 'Playlist Imported',
        message: parsed.title
      });
    } catch (error) {
      console.error('Import error:', error);
      showConfirmDialog({
        type: 'error',
        title: 'Import Failed',
        message: error.message
      });
    }
  };

  // Import playlist from URL (hosted XSPF)
  // skipStorageUpdate: true when loading from storage on app start (to avoid duplicates)
  const handleImportPlaylistFromUrl = async (url, skipStorageUpdate = false, storedAddedAt = null) => {
    try {
      console.log('ðŸŒ Importing playlist from URL:', url);

      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`Failed to fetch: ${response.status} ${response.statusText}`);
      }

      const content = await response.text();

      // Parse to get playlist info
      const parsed = parseXSPF(content);
      if (!parsed) {
        showConfirmDialog({
          type: 'error',
          title: 'Import Failed',
          message: 'Failed to parse XSPF file from URL'
        });
        return;
      }

      // Generate ID from URL using a simple hash for uniqueness
      // Using full URL hash instead of truncated base64 to avoid collisions
      const hashCode = (str) => {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash; // Convert to 32bit integer
        }
        return Math.abs(hash).toString(36);
      };
      const id = 'hosted-' + hashCode(url);

      // Check if playlist already exists
      const existingIndex = playlists.findIndex(p => p.sourceUrl === url);
      if (existingIndex >= 0) {
        // Update existing playlist
        setPlaylists(prev => prev.map((p, i) =>
          i === existingIndex
            ? { ...p, xspf: content, title: parsed.title, creator: parsed.creator, tracks: parsed.tracks || [], lastUpdated: Date.now() }
            : p
        ));
        console.log(`ðŸ”„ Updated hosted playlist: ${parsed.title} (${parsed.tracks?.length || 0} tracks)`);
        return { updated: true, playlist: parsed };
      }

      // Add new hosted playlist
      const newPlaylist = {
        id: id,
        filename: null,  // No local file for hosted playlists
        title: parsed.title,
        creator: parsed.creator,
        tracks: parsed.tracks || [],
        xspf: content,
        sourceUrl: url,  // Track the source URL for updates
        createdAt: parsed.date || Date.now(), // Use XSPF date (original creation) or import time
        addedAt: storedAddedAt || Date.now(), // When added to library (use stored value on reload)
        lastModified: Date.now()
      };

      // Add to state (prepend so it appears at top immediately, unless loading from storage)
      setPlaylists(prev => skipStorageUpdate ? [...prev, newPlaylist] : [newPlaylist, ...prev]);

      // Fetch covers for the 2x2 grid display immediately
      fetchPlaylistCovers(id, parsed.tracks || []);

      // Save URL to persistent storage for reload on app start
      // Skip this when loading from storage to avoid duplicates
      if (!skipStorageUpdate) {
        const hostedPlaylists = await window.electron?.store?.get('hosted_playlists') || [];
        hostedPlaylists.push({ url, id, addedAt: Date.now() });
        await window.electron?.store?.set('hosted_playlists', hostedPlaylists);
      }

      console.log(`âœ… Imported hosted playlist: ${parsed.title}`);
      return { updated: false, playlist: parsed };
    } catch (error) {
      console.error('URL import error:', error);
      throw error;
    }
  };

  // Refresh a hosted playlist
  const refreshHostedPlaylist = async (playlistId) => {
    const playlist = playlists.find(p => p.id === playlistId);
    if (!playlist?.sourceUrl) {
      console.log('Not a hosted playlist, cannot refresh');
      return false;
    }

    try {
      console.log(`ðŸ”„ Refreshing hosted playlist: ${playlist.title}`);
      const result = await handleImportPlaylistFromUrl(playlist.sourceUrl);

      // If currently viewing this playlist, reload the tracks
      if (selectedPlaylist?.id === playlistId) {
        const parsed = parseXSPF(result?.playlist ? playlists.find(p => p.id === playlistId)?.xspf : playlist.xspf);
        if (parsed) {
          const tracksWithIds = parsed.tracks.map(track => {
            const trackId = `${track.artist || 'unknown'}-${track.title || 'untitled'}-${track.album || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
            return { ...track, id: trackId, sources: {} };
          });
          setPlaylistTracks(tracksWithIds);

          // Re-resolve sources in background
          for (const track of tracksWithIds) {
            for (const resolverId of activeResolvers) {
              const resolver = allResolvers.find(r => r.id === resolverId);
              if (!resolver || !resolver.capabilities.resolve) continue;

              try {
                const config = await getResolverConfig(resolverId);
                const resolved = await resolver.resolve(track.artist, track.title, track.album, config);

                if (resolved) {
                  setPlaylistTracks(prevTracks =>
                    prevTracks.map(t =>
                      t.id === track.id
                        ? { ...t, sources: { ...t.sources, [resolverId]: resolved } }
                        : t
                    )
                  );
                }
              } catch (error) {
                console.error(`  âŒ ${resolver.name} resolve error:`, error);
              }
            }
          }
        }
      }

      return true;
    } catch (error) {
      console.error('Refresh error:', error);
      return false;
    }
  };

  // Poll hosted playlists for updates
  const hostedPlaylistPollInterval = useRef(null);

  useEffect(() => {
    // Start polling for hosted playlist updates (every 5 minutes)
    const pollHostedPlaylists = async () => {
      const hostedPlaylists = playlists.filter(p => p.sourceUrl);
      if (hostedPlaylists.length === 0) return;

      console.log(`ðŸ”„ Checking ${hostedPlaylists.length} hosted playlist(s) for updates...`);

      for (const playlist of hostedPlaylists) {
        try {
          const response = await fetch(playlist.sourceUrl);
          if (!response.ok) continue;

          const content = await response.text();

          // Check if content changed
          if (content !== playlist.xspf) {
            console.log(`ðŸ“ Hosted playlist changed: ${playlist.title}`);
            await handleImportPlaylistFromUrl(playlist.sourceUrl);
          }
        } catch (error) {
          console.error(`Failed to check playlist ${playlist.title}:`, error);
        }
      }
    };

    // Poll every 5 minutes
    hostedPlaylistPollInterval.current = setInterval(pollHostedPlaylists, 5 * 60 * 1000);

    // Also poll on mount (after a short delay to let playlists load)
    const initialPoll = setTimeout(pollHostedPlaylists, 10000);

    return () => {
      clearInterval(hostedPlaylistPollInterval.current);
      clearTimeout(initialPoll);
    };
  }, [playlists.filter(p => p.sourceUrl).length]); // Re-run when hosted playlist count changes

  // Load hosted playlists on app start
  useEffect(() => {
    const loadHostedPlaylists = async () => {
      let hostedPlaylistUrls = await window.electron?.store?.get('hosted_playlists') || [];
      if (hostedPlaylistUrls.length === 0) {
        setPlaylistsLoading(false);
        return;
      }

      // Deduplicate by URL (in case duplicates accumulated from previous bug)
      const seenUrls = new Set();
      const deduped = hostedPlaylistUrls.filter(item => {
        if (seenUrls.has(item.url)) return false;
        seenUrls.add(item.url);
        return true;
      });

      // Save deduped list back to storage if we removed duplicates
      if (deduped.length < hostedPlaylistUrls.length) {
        console.log(`ðŸ§¹ Cleaned up ${hostedPlaylistUrls.length - deduped.length} duplicate hosted playlist entries`);
        await window.electron?.store?.set('hosted_playlists', deduped);
        hostedPlaylistUrls = deduped;
      }

      console.log(`ðŸ“¦ Loading ${hostedPlaylistUrls.length} hosted playlist(s)...`);

      for (const { url, addedAt } of hostedPlaylistUrls) {
        try {
          // Pass true to skip storage update (already in storage), and stored addedAt to preserve order
          await handleImportPlaylistFromUrl(url, true, addedAt);
        } catch (error) {
          console.error(`Failed to load hosted playlist from ${url}:`, error);
        }
      }

      // All hosted playlists loaded
      setPlaylistsLoading(false);
    };

    // Delay to allow local playlists to load first
    const timer = setTimeout(loadHostedPlaylists, 2000);
    return () => clearTimeout(timer);
  }, []);

  const handleExportPlaylist = async (playlist) => {
    try {
      console.log(`ðŸ“¤ Exporting playlist: ${playlist.id}`);
      
      const defaultFilename = playlist.filename || `${playlist.id}.xspf`;
      const result = await window.electron.playlists.export(defaultFilename, playlist.xspf);
      
      if (!result) {
        console.log('Export cancelled');
        return;
      }
      
      if (!result.success) {
        showConfirmDialog({
          type: 'error',
          title: 'Export Failed',
          message: result.error
        });
        return;
      }

      console.log(`âœ… Exported to: ${result.filepath}`);
      showConfirmDialog({
        type: 'success',
        title: 'Playlist Exported',
        message: 'Successfully saved to disk'
      });
    } catch (error) {
      console.error('Export error:', error);
      showConfirmDialog({
        type: 'error',
        title: 'Export Error',
        message: error.message
      });
    }
  };

  // Add Spotify authentication functions

  // Refresh the Spotify token and return the new token (or null if refresh failed)
  // This is called when a 401 is detected to get a fresh token
  const refreshSpotifyToken = async () => {
    console.log('ðŸ”„ Refreshing Spotify token...');
    if (!window.electron?.spotify) {
      console.log('window.electron.spotify not available');
      return null;
    }

    const tokenData = await window.electron.spotify.checkToken();
    if (tokenData && tokenData.token) {
      console.log('âœ… Token refreshed successfully');
      setSpotifyToken(tokenData.token);
      setSpotifyConnected(true);
      return tokenData.token;
    } else {
      console.log('âŒ Token refresh failed - no valid token returned');
      setSpotifyToken(null);
      setSpotifyConnected(false);
      return null;
    }
  };

  const checkSpotifyToken = async () => {
    console.log('Checking Spotify token...');
    if (window.electron?.spotify) {
      const tokenData = await window.electron.spotify.checkToken();
      console.log('Token data received:', {
        hasData: !!tokenData,
        hasToken: !!tokenData?.token,
        tokenLength: tokenData?.token?.length,
        tokenPreview: tokenData?.token ? tokenData.token.substring(0, 20) + '...' : 'null',
        expiry: tokenData?.expiry,
        hasRefresh: !!tokenData?.refreshToken
      });
      if (tokenData && tokenData.token) {
        console.log('Valid token found, setting connected state');
        setSpotifyToken(tokenData.token);
        setSpotifyConnected(true);
        // Enable Spotify resolver if authenticated
        setActiveResolvers(prev => {
          if (!prev.includes('spotify')) {
            console.log('Adding Spotify to active resolvers');
            return [...prev, 'spotify'];
          }
          return prev;
        });
      } else {
        console.log('No valid token found');
      }
    } else {
      console.log('window.electron.spotify not available');
    }
  };

  const connectSpotify = async () => {
    console.log('=== Connect Spotify Clicked ===');
    console.log('window.electron:', !!window.electron);
    console.log('window.electron.spotify:', !!window.electron?.spotify);
    
    if (window.electron?.spotify) {
      try {
        console.log('Calling authenticate...');
        const result = await window.electron.spotify.authenticate();
        console.log('Authenticate result:', result);
      } catch (error) {
        console.error('Spotify auth error:', error);
        showConfirmDialog({
          type: 'error',
          title: 'Authentication Failed',
          message: 'Spotify authentication failed. Check console for details.'
        });
      }
    } else {
      console.error('window.electron.spotify not available!');
      showConfirmDialog({
        type: 'error',
        title: 'API Not Available',
        message: 'Electron API not available. Make sure preload.js is loaded correctly.'
      });
    }
  };

  const disconnectSpotify = async () => {
    if (window.electron?.spotify) {
      await window.electron.store.delete('spotify_token');
      await window.electron.store.delete('spotify_refresh_token');
      await window.electron.store.delete('spotify_token_expiry');
      setSpotifyToken(null);
      setSpotifyConnected(false);
      // Remove Spotify sources from all tracks and remove from active resolvers
      removeResolverSources('spotify');
      setActiveResolvers(prev => prev.filter(id => id !== 'spotify'));
    }
  };

  // Meta Service config helpers
  const saveMetaServiceConfig = async (serviceId, config) => {
    const newConfigs = { ...metaServiceConfigs, [serviceId]: config };
    setMetaServiceConfigs(newConfigs);
    if (window.electron?.store) {
      await window.electron.store.set('meta_service_configs', newConfigs);
      console.log(`ðŸ’¾ Saved ${serviceId} config`);
    }
  };

  const clearMetaServiceConfig = async (serviceId) => {
    const newConfigs = { ...metaServiceConfigs };
    delete newConfigs[serviceId];
    setMetaServiceConfigs(newConfigs);
    if (window.electron?.store) {
      await window.electron.store.set('meta_service_configs', newConfigs);
      console.log(`ðŸ—‘ï¸ Cleared ${serviceId} config`);
    }
  };

  // Last.fm specific helpers
  const connectLastfm = async (username, apiKey, apiSecret) => {
    if (!username?.trim()) {
      showConfirmDialog({
        type: 'error',
        title: 'Username Required',
        message: 'Please enter your Last.fm username.'
      });
      return false;
    }

    setLastfmConnecting(true);

    // Validate username exists by checking the recommendations endpoint
    try {
      const response = await fetch(`https://www.last.fm/player/station/user/${encodeURIComponent(username.trim())}/recommended`);
      if (!response.ok) {
        setLastfmConnecting(false);
        showConfirmDialog({
          type: 'error',
          title: 'Invalid Username',
          message: `Could not find Last.fm user "${username}". Please check the username and try again.`
        });
        return false;
      }
    } catch (error) {
      console.error('Last.fm validation error:', error);
      setLastfmConnecting(false);
      showConfirmDialog({
        type: 'error',
        title: 'Connection Error',
        message: 'Could not connect to Last.fm. Please check your internet connection.'
      });
      return false;
    }

    await saveMetaServiceConfig('lastfm', {
      username: username.trim(),
      apiKey: apiKey?.trim() || null,
      apiSecret: apiSecret?.trim() || null
    });

    // Also set API credentials on the scrobbler for scrobbling support
    // Note: Last.fm scrobbling also requires OAuth (sessionKey) which is done via ScrobblerSettingsCard
    if (apiKey?.trim() && apiSecret?.trim() && window.lastfmScrobbler) {
      window.lastfmScrobbler.setApiCredentials(apiKey.trim(), apiSecret.trim());
      console.log('ðŸŽ§ Last.fm scrobbler API credentials set');
    }

    setLastfmConnecting(false);
    // Clear inputs after successful connection
    setLastfmUsernameInput('');
    setLastfmApiKeyInput('');
    setLastfmApiSecretInput('');

    console.log(`ðŸŽ§ Connected to Last.fm as ${username}`);
    return true;
  };

  const disconnectLastfm = async () => {
    await clearMetaServiceConfig('lastfm');
    console.log('ðŸŽ§ Disconnected from Last.fm');
  };

  // ListenBrainz specific helpers
  const connectListenbrainz = async (username, userToken) => {
    if (!username?.trim()) {
      showConfirmDialog({
        type: 'error',
        title: 'Username Required',
        message: 'Please enter your ListenBrainz username.'
      });
      return false;
    }

    setListenbrainzConnecting(true);

    // Validate username exists by checking the user endpoint
    try {
      const response = await fetch(`https://api.listenbrainz.org/1/user/${encodeURIComponent(username.trim())}/listen-count`);
      if (!response.ok) {
        setListenbrainzConnecting(false);
        showConfirmDialog({
          type: 'error',
          title: 'Invalid Username',
          message: `Could not find ListenBrainz user "${username}". Please check the username and try again.`
        });
        return false;
      }
    } catch (error) {
      console.error('ListenBrainz validation error:', error);
      setListenbrainzConnecting(false);
      showConfirmDialog({
        type: 'error',
        title: 'Connection Error',
        message: 'Could not connect to ListenBrainz. Please check your internet connection.'
      });
      return false;
    }

    // If token provided, validate it
    if (userToken?.trim()) {
      try {
        const tokenResponse = await fetch('https://api.listenbrainz.org/1/validate-token', {
          headers: {
            'Authorization': `Token ${userToken.trim()}`
          }
        });
        const tokenData = await tokenResponse.json();
        if (!tokenData.valid) {
          setListenbrainzConnecting(false);
          showConfirmDialog({
            type: 'error',
            title: 'Invalid Token',
            message: 'The user token is invalid. Please check and try again, or leave it blank to connect without a token.'
          });
          return false;
        }
      } catch (error) {
        console.error('ListenBrainz token validation error:', error);
        // Non-fatal - continue without token
      }
    }

    await saveMetaServiceConfig('listenbrainz', {
      username: username.trim(),
      userToken: userToken?.trim() || null
    });

    // Also connect the scrobbler if token is provided
    if (userToken?.trim() && window.listenbrainzScrobbler) {
      try {
        await window.listenbrainzScrobbler.connect(userToken.trim());
        // Update scrobbler configs state
        const newConfig = await window.listenbrainzScrobbler.getConfig();
        setScrobblerConfigs(prev => ({ ...prev, listenbrainz: newConfig }));
        console.log('ðŸŽµ ListenBrainz scrobbler connected');
      } catch (err) {
        console.error('Failed to connect ListenBrainz scrobbler:', err);
        // Non-fatal - meta service still works for recommendations
      }
    }

    setListenbrainzConnecting(false);
    // Clear inputs after successful connection
    setListenbrainzUsernameInput('');
    setListenbrainzTokenInput('');

    console.log(`ðŸŽµ Connected to ListenBrainz as ${username}`);
    return true;
  };

  const disconnectListenbrainz = async () => {
    await clearMetaServiceConfig('listenbrainz');
    console.log('ðŸŽµ Disconnected from ListenBrainz');
  };

// Listen for Spotify auth events
useEffect(() => {
  checkSpotifyToken();

  if (window.electron?.spotify) {
    window.electron.spotify.onAuthSuccess((data) => {
      console.log('Spotify auth success!', {
        hasToken: !!data.token,
        tokenLength: data.token?.length,
        tokenPreview: data.token ? data.token.substring(0, 20) + '...' : 'null'
      });
      setSpotifyToken(data.token);
      setSpotifyConnected(true);
      // Automatically enable Spotify resolver after successful auth
      setActiveResolvers(prev => {
        if (!prev.includes('spotify')) {
          return [...prev, 'spotify'];
        }
        return prev;
      });
      console.log('Spotify connected and enabled!');
    });
    window.electron.spotify.onAuthError((error) => {
      console.error('Spotify auth failed:', error);
      showConfirmDialog({
        type: 'error',
        title: 'Spotify Authentication Failed',
        message: error
      });
    });
  }

  // Periodically check and refresh token every 5 minutes
  const tokenRefreshInterval = setInterval(() => {
    console.log('â° Periodic token refresh check...');
    checkSpotifyToken();
  }, 5 * 60 * 1000); // 5 minutes

  return () => clearInterval(tokenRefreshInterval);
}, []);

// Spotify Connect - Get available devices
const getSpotifyDevices = async () => {
  if (!spotifyToken) return [];
  
  try {
    const response = await fetch('https://api.spotify.com/v1/me/player/devices', {
      headers: {
        'Authorization': `Bearer ${spotifyToken}`
      }
    });
    
    if (response.ok) {
      const data = await response.json();
      return data.devices || [];
    }
  } catch (error) {
    console.error('Failed to get devices:', error);
  }
  return [];
};

// Play on Spotify Connect (controls external Spotify clients)
const playOnSpotifyConnect = async (track) => {
  if (!spotifyToken) {
    showConfirmDialog({
      type: 'error',
      title: 'Spotify Not Connected',
      message: 'Please connect to Spotify in Settings to use this feature.'
    });
    return false;
  }

  try {
    // Get available devices
    const devices = await getSpotifyDevices();
    console.log('Available Spotify devices:', devices);

    if (devices.length === 0) {
      showConfirmDialog({
        type: 'info',
        title: 'No Devices Found',
        message: 'No Spotify devices found. Please open Spotify on your phone, computer, or web player (spotify.com), then try again.'
      });
      return false;
    }
    
    // Log all devices for debugging
    console.log(`Found ${devices.length} Spotify device(s):`);
    devices.forEach((d, i) => {
      console.log(`Device ${i + 1}:`, {
        name: d.name,
        type: d.type,
        id: d.id,
        is_active: d.is_active,
        is_restricted: d.is_restricted,
        volume_percent: d.volume_percent
      });
    });

    // Filter out restricted devices (can't be controlled remotely)
    const controllableDevices = devices.filter(d => !d.is_restricted);
    if (controllableDevices.length === 0) {
      console.warn('âš ï¸ All devices are restricted, trying with all devices anyway');
    }
    const availableDevices = controllableDevices.length > 0 ? controllableDevices : devices;

    // Device selection priority:
    // 1. Active device (if any)
    // 2. Computer type devices (Spotify desktop app)
    // 3. Smartphone type devices
    // 4. Any other device (but NOT Web Browser - these are often phantom devices)
    let activeDevice = availableDevices.find(d => d.is_active);

    if (!activeDevice) {
      // No active device - select by preference
      // Prefer Computer > Smartphone > Speaker > other, but avoid "Web Player" type
      const computerDevice = availableDevices.find(d => d.type === 'Computer');
      const smartphoneDevice = availableDevices.find(d => d.type === 'Smartphone');
      const speakerDevice = availableDevices.find(d => d.type === 'Speaker');
      const nonWebDevice = availableDevices.find(d => d.type !== 'Computer' && !d.name.toLowerCase().includes('web'));

      activeDevice = computerDevice || smartphoneDevice || speakerDevice || nonWebDevice || availableDevices[0];
      console.log(`ðŸ“± No active device, selected by preference: "${activeDevice.name}" (${activeDevice.type})`);
    } else {
      console.log(`ðŸ“± Using active device: "${activeDevice.name}" (${activeDevice.type})`);
    }
    
    // If device is not active, wake it up by transferring playback
    // Use play: false to avoid briefly playing the previous track
    if (!activeDevice.is_active) {
      console.log('Device not active, waking device...');
      const transferResponse = await fetch('https://api.spotify.com/v1/me/player', {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${spotifyToken}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          device_ids: [activeDevice.id],
          play: false // Wake device but don't resume previous track
        })
      });

      if (!transferResponse.ok && transferResponse.status !== 204) {
        console.error('Failed to wake device:', transferResponse.status);
        const error = await transferResponse.text();
        console.error('Wake error details:', error);
        // Don't return - try the play call anyway as fallback
      } else {
        console.log('Device woken up, waiting for it to become ready...');
        // Longer delay to let device fully wake up
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    // Now play the specific track on the device
    console.log('Starting playback on device:', activeDevice.name);
    const response = await fetch(`https://api.spotify.com/v1/me/player/play?device_id=${activeDevice.id}`, {
      method: 'PUT',
      headers: {
        'Authorization': `Bearer ${spotifyToken}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        uris: [track.spotifyUri]
      })
    });
    
    if (response.ok || response.status === 204) {
      console.log('âœ… Play command accepted by Spotify:', activeDevice.name);

      // Verify playback actually started by polling the player state
      // This catches cases where the command was accepted but playback didn't start
      await new Promise(resolve => setTimeout(resolve, 500)); // Brief delay before checking

      try {
        const verifyResponse = await fetch('https://api.spotify.com/v1/me/player', {
          headers: { 'Authorization': `Bearer ${spotifyToken}` }
        });

        if (verifyResponse.ok) {
          const verifyData = await verifyResponse.json();
          if (verifyData.is_playing) {
            console.log('âœ… Verified: Spotify is now playing');
          } else {
            console.warn('âš ï¸ Play command accepted but Spotify reports is_playing=false');
            console.log('Player state:', {
              is_playing: verifyData.is_playing,
              progress_ms: verifyData.progress_ms,
              item: verifyData.item?.name,
              device: verifyData.device?.name
            });
          }
          // Store device info for volume control capability check
          if (verifyData.device) {
            setSpotifyDevice({
              name: verifyData.device.name,
              type: verifyData.device.type,
              supports_volume: verifyData.device.supports_volume
            });
          }
        }
      } catch (verifyError) {
        console.warn('Could not verify playback state:', verifyError.message);
      }

      setCurrentTrack(track);
      setIsPlaying(true);
      // Reset browser playback state since we're now using Spotify Connect
      setBrowserPlaybackActive(false);
      setIsExternalPlayback(false);

      // Don't call getCurrentPlaybackState() here - let polling handle it
      // This prevents flickering when starting playback
      return true;
    } else {
      const error = await response.text();
      console.error('Spotify play failed:', response.status, error);
      
      // Provide specific error messages
      if (response.status === 404) {
        showConfirmDialog({
          type: 'error',
          title: 'Device Not Responding',
          message: `Spotify device "${activeDevice.name}" is not responding.\n\nTry playing any song on Spotify first, then use Parachord.`
        });
      } else if (response.status === 403) {
        showConfirmDialog({
          type: 'error',
          title: 'Premium Required',
          message: 'Spotify Premium is required for remote playback.'
        });
      } else {
        showConfirmDialog({
          type: 'error',
          title: 'Playback Failed',
          message: `Failed to play on Spotify. Error: ${response.status}`
        });
      }
      return false;
    }
  } catch (error) {
    console.error('Spotify Connect error:', error);
    showConfirmDialog({
      type: 'error',
      title: 'Spotify Error',
      message: error.message
    });
    return false;
  }
};

// Get current playback state from Spotify
const getCurrentPlaybackState = async () => {
  if (!spotifyToken) return;

  // Don't update track info from Spotify when browser playback is active
  // This prevents overwriting the current track with whatever Spotify last played
  if (browserPlaybackActive || isExternalPlayback) {
    return;
  }

  try {
    const response = await fetch('https://api.spotify.com/v1/me/player', {
      headers: {
        'Authorization': `Bearer ${spotifyToken}`
      }
    });

    if (response.ok) {
      const data = await response.json();
      if (data && data.item) {
        const newIsPlaying = data.is_playing;
        const newProgress = data.progress_ms / 1000;
        const newTrackId = `spotify-${data.item.id}`;

        // Only update if something changed
        if (isPlaying !== newIsPlaying) {
          setIsPlaying(newIsPlaying);
        }

        // Update progress baseline for smooth interpolation
        // The interpolation effect will smoothly update between API polls
        // Include isPlaying so interpolation only runs when Spotify is actually playing
        spotifyProgressBaselineRef.current = {
          progress: newProgress,
          timestamp: Date.now(),
          isPlaying: newIsPlaying
        };
        setProgress(newProgress);

        // Check if Spotify is playing a different track than what we initiated
        // Use currentTrackRef to avoid stale closure issues
        const track = currentTrackRef.current;
        const currentSpotifyUri = track?.spotifyUri || track?.sources?.spotify?.spotifyUri;
        const newSpotifyUri = data.item.uri;

        // Determine if this is the same track we're playing (even if URIs weren't set yet)
        const isSameTrack = currentSpotifyUri === newSpotifyUri ||
          (track && !currentSpotifyUri && track.title?.toLowerCase() === data.item.name?.toLowerCase());

        // Debug: Log track comparison for highlight debugging
        if (!isSameTrack) {
          console.log('ðŸ”„ Spotify polling: Track mismatch detected', {
            currentSpotifyUri,
            newSpotifyUri,
            trackTitle: track?.title,
            spotifyTitle: data.item.name,
            trackId: track?.id,
            hasPlaybackContext: !!track?._playbackContext
          });
        }

        if (!isSameTrack) {
          // Different track is playing - this is an external change (user changed track in Spotify app)
          // Create new track without playback context since we didn't initiate this
          setCurrentTrack({
            id: newTrackId,
            title: data.item.name,
            artist: data.item.artists.map(a => a.name).join(', '),
            album: data.item.album.name,
            duration: data.item.duration_ms / 1000,
            albumArt: data.item.album.images[0]?.url,
            spotifyUri: data.item.uri,
            spotifyId: data.item.id,
            sources: ['spotify']
            // Note: _playbackContext is intentionally not set here since this is an external track change
          });
        } else {
          // Same track - update metadata while preserving original ID and playback context
          setCurrentTrack(prev => ({
            ...prev,
            // Preserve original ID and context - never overwrite these
            duration: data.item.duration_ms / 1000,
            albumArt: prev.albumArt || data.item.album.images[0]?.url,
            spotifyUri: data.item.uri,
            spotifyId: data.item.id
          }));
        }

        // Update device info if available
        if (data.device) {
          setSpotifyDevice({
            name: data.device.name,
            type: data.device.type,
            supports_volume: data.device.supports_volume
          });
        }
      }
    }
  } catch (error) {
    console.error('Failed to get playback state:', error);
  }
};

// Poll Spotify playback state when playing
useEffect(() => {
  if (!spotifyToken || !isPlaying) return;
  
  const currentIsSpotify = currentTrack?.sources?.spotify || currentTrack?.spotifyUri;
  if (!currentIsSpotify) return;
  
  // Poll every 5 seconds (reduced from 2 to minimize flickering)
  const interval = setInterval(() => {
    getCurrentPlaybackState();
  }, 5000);
  
  return () => clearInterval(interval);
}, [spotifyToken, isPlaying, currentTrack]);

  const formatTime = (seconds) => {
    if (!seconds || isNaN(seconds)) return '0:00';
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  const formatTimeAgo = (timestamp) => {
    if (!timestamp) return '';
    const now = Date.now();
    const diff = now - timestamp;
    const minutes = Math.floor(diff / 60000);
    const hours = Math.floor(diff / 3600000);
    const days = Math.floor(diff / 86400000);

    if (minutes < 1) return 'Just now';
    if (minutes < 60) return `${minutes}m ago`;
    if (hours < 24) return `${hours}h ago`;
    if (days < 7) return `${days}d ago`;

    // For older, show date with year
    const date = new Date(timestamp);
    const currentYear = new Date().getFullYear();
    const dateYear = date.getFullYear();
    // Show year if it's not the current year
    if (dateYear !== currentYear) {
      return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
    }
    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
  };

  return React.createElement('div', {
    className: 'h-screen bg-gray-100 text-gray-900 flex flex-col'
  },

    // Main content with sidebar (no separate header - search is in sidebar)
    React.createElement('div', {
      className: 'flex-1 flex overflow-hidden'
    },
      // Sidebar
      React.createElement('div', {
        className: 'w-64 bg-gray-50 border-r border-gray-200 flex flex-col no-drag',
        onDragOver: (e) => {
          // Show Add to Playlist panel when dragging a track over sidebar
          if (draggingTrackForPlaylist && !addToPlaylistPanel.open) {
            e.preventDefault();
            setAddToPlaylistPanel({
              open: true,
              tracks: [draggingTrackForPlaylist],
              sourceName: draggingTrackForPlaylist.title,
              sourceType: 'track'
            });
            setSelectedPlaylistsForAdd([]);
          }
        }
      },
        // Draggable title bar area (space for macOS traffic lights)
        React.createElement('div', {
          className: 'h-8 drag flex-shrink-0'
        }),
        // Navigation arrows
        React.createElement('div', {
          className: 'flex items-center gap-2 px-4 pb-2'
        },
          React.createElement('button', {
            onClick: navigateBack,
            disabled: viewHistory.length <= 1,
            className: `p-1.5 rounded hover:bg-gray-200 transition-colors no-drag ${viewHistory.length <= 1 ? 'text-gray-300 cursor-not-allowed' : 'text-gray-600'}`
          },
            React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
              React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M15 19l-7-7 7-7' })
            )
          ),
          React.createElement('button', {
            onClick: navigateForward,
            disabled: forwardHistory.length === 0,
            className: `p-1.5 rounded hover:bg-gray-200 transition-colors no-drag ${forwardHistory.length === 0 ? 'text-gray-300 cursor-not-allowed' : 'text-gray-600'}`
          },
            React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
              React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M9 5l7 7-7 7' })
            )
          )
        ),

        // Search - navigates to search page
        React.createElement('div', { className: 'px-4 py-2 border-b border-gray-200' },
          React.createElement('button', {
            className: `w-full flex items-center gap-2 text-gray-500 hover:text-gray-700 cursor-pointer transition-colors ${
              activeView === 'search' ? 'text-gray-900 font-medium' : ''
            }`,
            onClick: () => navigateTo('search')
          },
            React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
              React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' })
            ),
            React.createElement('span', { className: 'text-sm' }, 'SEARCH')
          )
        ),

        // Scrollable navigation area
        React.createElement('div', { className: 'flex-1 overflow-y-auto scrollable-content px-2 py-2' },
          // DISCOVER section
          React.createElement('div', { className: 'mb-4' },
            React.createElement('div', { className: 'px-3 py-2 text-xs font-semibold text-gray-400 uppercase tracking-wider' }, 'Discover'),
            React.createElement('button', {
              onClick: () => navigateTo('recommendations'),
              className: `w-full flex items-center gap-3 px-3 py-2 rounded text-sm transition-colors ${
                activeView === 'recommendations' ? 'bg-gray-200 text-gray-900 font-medium' : 'text-gray-600 hover:bg-gray-100'
              }`
            },
              // Star icon for Recommendations
              React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z' })
              ),
              "Recommendations"
            ),
            React.createElement('button', {
              onClick: () => {
                navigateTo('discover');
                loadCharts();
              },
              className: `w-full flex items-center gap-3 px-3 py-2 rounded text-sm transition-colors ${
                activeView === 'discover' ? 'bg-gray-200 text-gray-900 font-medium' : 'text-gray-600 hover:bg-gray-100'
              }`
            },
              // Bar chart icon for Charts
              React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z' })
              ),
              'Pop of the Tops'
            ),
            React.createElement('button', {
              onClick: () => {
                navigateTo('critics-picks');
                loadCriticsPicks();
              },
              className: `w-full flex items-center gap-3 px-3 py-2 rounded text-sm transition-colors ${
                activeView === 'critics-picks' ? 'bg-gray-200 text-gray-900 font-medium' : 'text-gray-600 hover:bg-gray-100'
              }`
            },
              // Award/trophy icon for Critical Darlings
              React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M5 3h14a1 1 0 011 1v3a7 7 0 01-7 7 7 7 0 01-7-7V4a1 1 0 011-1zM8.5 21h7M12 17v4M8 14l-3-3m11 3l3-3' })
              ),
              "Critical Darlings"
            )
          ),

          // YOUR MUSIC section
          React.createElement('div', { className: 'mb-4' },
            React.createElement('div', { className: 'px-3 py-2 text-xs font-semibold text-gray-400 uppercase tracking-wider' }, 'Your Music'),
            React.createElement('button', {
              onClick: () => navigateTo('library'),
              onDragOver: (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; },
              onDragEnter: (e) => { e.preventDefault(); setCollectionDropHighlight(true); },
              onDragLeave: (e) => { e.preventDefault(); setCollectionDropHighlight(false); },
              onDrop: handleCollectionDrop,
              className: `w-full flex items-center gap-3 px-3 py-2 rounded text-sm transition-colors ${
                collectionDropHighlight ? 'bg-purple-100 border-2 border-purple-400 text-purple-700' :
                activeView === 'library' ? 'bg-gray-200 text-gray-900 font-medium' : 'text-gray-600 hover:bg-gray-100'
              }`
            },
              React.createElement('svg', { className: 'w-4 h-4 flex-shrink-0', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10' })
              ),
              'Collection',
              sidebarBadges.collection && React.createElement('span', {
                key: `collection-badge-${Date.now()}`,
                className: 'ml-auto text-xs bg-purple-500 text-white px-1.5 py-0.5 rounded-full sidebar-badge'
              }, `+${sidebarBadges.collection}`)
            ),
            React.createElement('button', {
              onClick: () => navigateTo('playlists'),
              className: `w-full flex items-center gap-3 px-3 py-2 rounded text-sm transition-colors ${
                activeView === 'playlists' || activeView === 'playlist-view' ? 'bg-gray-200 text-gray-900 font-medium' : 'text-gray-600 hover:bg-gray-100'
              }`
            },
              React.createElement('svg', { className: 'w-4 h-4 flex-shrink-0', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M4 6h16M4 10h16M4 14h16M4 18h16' })
              ),
              'Playlists',
              sidebarBadges.playlists && React.createElement('span', {
                key: `playlists-badge-${Date.now()}`,
                className: 'ml-auto text-xs bg-purple-500 text-white px-1.5 py-0.5 rounded-full sidebar-badge'
              }, `+${sidebarBadges.playlists}`)
            ),
            React.createElement('button', {
              onClick: () => {}, // Placeholder
              className: 'w-full flex items-center gap-3 px-3 py-2 rounded text-sm text-gray-400 cursor-not-allowed'
            },
              React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M5.636 18.364a9 9 0 010-12.728m12.728 0a9 9 0 010 12.728m-9.9-2.829a5 5 0 010-7.07m7.072 0a5 5 0 010 7.07M13 12a1 1 0 11-2 0 1 1 0 012 0z' })
              ),
              'Stations'
            ),
            React.createElement('button', {
              onClick: () => {
                navigateTo('history');
                loadTopTracks();
              },
              className: `w-full flex items-center gap-3 px-3 py-2 rounded text-sm transition-colors ${
                activeView === 'history' ? 'bg-gray-200 text-gray-900 font-medium' : 'text-gray-600 hover:bg-gray-100'
              }`
            },
              React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z' })
              ),
              'History'
            )
          ),

          // FRIENDS section (only show if there are pinned friends OR dragging a friend over)
          (pinnedFriendIds.length > 0 || friendDragOverSidebar) && React.createElement('div', {
            className: `rounded-lg transition-colors ${friendDragOverSidebar ? 'bg-purple-50 ring-2 ring-purple-300 ring-inset' : ''}`,
            onDragOver: (e) => {
              if (e.dataTransfer.types.includes('friendid')) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
                setFriendDragOverSidebar(true);
              }
            },
            onDragLeave: (e) => {
              // Only reset if leaving the section entirely
              if (!e.currentTarget.contains(e.relatedTarget)) {
                setFriendDragOverSidebar(false);
              }
            },
            onDrop: (e) => {
              e.preventDefault();
              setFriendDragOverSidebar(false);
              const friendId = e.dataTransfer.getData('friendId');
              if (friendId && !pinnedFriendIds.includes(friendId)) {
                pinFriend(friendId);
              }
            }
          },
          React.createElement('div', { className: 'px-3 py-2 flex items-center justify-between' },
            React.createElement('span', { className: 'text-xs font-semibold text-gray-400 uppercase tracking-wider' }, 'Friends'),
            React.createElement('button', {
              onClick: (e) => { e.stopPropagation(); setAddFriendModalOpen(true); },
              className: 'w-4 h-4 flex items-center justify-center text-gray-400 hover:text-gray-600 transition-colors rounded hover:bg-gray-200',
              title: 'Add friend'
            },
              React.createElement('svg', { className: 'w-3 h-3', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor', strokeWidth: 2 },
                React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', d: 'M12 4v16m8-8H4' })
              )
            )
          ),
          // Show drop hint when dragging but no friends pinned yet
          friendDragOverSidebar && pinnedFriendIds.length === 0 && React.createElement('div', {
            className: 'px-3 py-4 text-sm text-purple-600 text-center'
          }, 'Drop to pin'),
          pinnedFriendIds.map((friendId, index) => {
            const friend = friends.find(f => f.id === friendId);
            if (!friend) return null;
            const onAir = isOnAir(friend);
            const isSelected = activeView === 'friendHistory' && currentFriend?.id === friend.id;

            return React.createElement('div', {
              key: friend.id,
              className: `px-3 py-1.5 rounded cursor-pointer group transition-colors flex items-center ${
                isSelected ? 'bg-gray-200 text-gray-900' : 'hover:bg-gray-100'
              }`,
              style: { minHeight: '52px' },  // Fixed height to prevent layout shift when mini playbar appears
              draggable: true,
              onClick: () => navigateToFriend(friend),
              onDragStart: (e) => {
                e.dataTransfer.setData('friendIndex', index.toString());
                e.dataTransfer.effectAllowed = 'move';
              },
              onDragOver: (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
              },
              onDrop: (e) => {
                e.preventDefault();
                const fromIndex = parseInt(e.dataTransfer.getData('friendIndex'));
                if (!isNaN(fromIndex) && fromIndex !== index) {
                  reorderPinnedFriends(fromIndex, index);
                }
              },
              onContextMenu: (e) => {
                e.preventDefault();
                if (window.electron?.contextMenu?.showTrackMenu) {
                  window.electron.contextMenu.showTrackMenu({
                    type: 'friend',
                    friend: friend,
                    isPinned: true,
                    isSavedToCollection: friend.savedToCollection
                  });
                }
              }
            },
              React.createElement('div', { className: 'flex items-center gap-2' },
                // Hexagonal avatar with on-air indicator
                React.createElement('div', {
                  className: 'relative flex-shrink-0',
                  onClick: (e) => {
                    e.stopPropagation();
                    navigateToFriend(friend);
                  }
                },
                  React.createElement('div', {
                    className: 'w-8 h-8 bg-gray-200 overflow-hidden',
                    style: {
                      clipPath: 'polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%)'
                    }
                  },
                    friend.avatarUrl
                      ? React.createElement('img', {
                          src: friend.avatarUrl,
                          alt: friend.displayName,
                          className: 'w-full h-full object-cover'
                        })
                      : React.createElement('div', {
                          className: 'w-full h-full flex items-center justify-center text-gray-500 text-xs font-medium bg-gradient-to-br from-purple-400 to-pink-400 text-white'
                        }, friend.displayName.charAt(0).toUpperCase())
                  ),
                  // On-air indicator dot
                  onAir && React.createElement('div', {
                    className: 'absolute -bottom-0.5 -right-0.5 w-3 h-3 bg-green-500 rounded-full border-2 border-gray-50'
                  })
                ),
                // Name and track info
                React.createElement('div', { className: 'flex-1 min-w-0' },
                  React.createElement('div', {
                    className: 'text-sm text-gray-600 truncate'
                  }, friend.displayName),
                  // Mini playbar showing friend's current track
                  onAir && friend.cachedRecentTrack && React.createElement(FriendMiniPlaybar, {
                    track: friend.cachedRecentTrack,
                    getAlbumArt: getAlbumArt,
                    onPlay: (e) => {
                      e.stopPropagation();
                      // Get cached sources for instant playback
                      const cacheKey = `${friend.cachedRecentTrack.artist.toLowerCase()}|${friend.cachedRecentTrack.name.toLowerCase()}|0`;
                      const cachedSources = trackSourcesCache.current[cacheKey]?.sources || {};
                      const track = {
                        title: friend.cachedRecentTrack.name,
                        artist: friend.cachedRecentTrack.artist,
                        album: friend.cachedRecentTrack.album,
                        albumArt: friend.cachedRecentTrack.albumArt,
                        sources: cachedSources
                      };
                      handlePlay(track);
                    },
                    onContextMenu: (e) => {
                      e.preventDefault();
                      e.stopPropagation();
                      if (window.electron?.contextMenu?.showTrackMenu) {
                        // Get cached sources for context menu actions too
                        const cacheKey = `${friend.cachedRecentTrack.artist.toLowerCase()}|${friend.cachedRecentTrack.name.toLowerCase()}|0`;
                        const cachedSources = trackSourcesCache.current[cacheKey]?.sources || {};
                        window.electron.contextMenu.showTrackMenu({
                          type: 'friend-track',
                          track: {
                            title: friend.cachedRecentTrack.name,
                            artist: friend.cachedRecentTrack.artist,
                            album: friend.cachedRecentTrack.album,
                            albumArt: friend.cachedRecentTrack.albumArt,
                            sources: cachedSources
                          }
                        });
                      }
                    }
                  })
                )
              )
            );
          })
          ),

          // Empty state hint for Friends when no friends pinned but friends exist
          friends.length > 0 && pinnedFriendIds.length === 0 && !friendDragOverSidebar && React.createElement('div', {
            className: 'rounded-lg transition-colors',
            onDragOver: (e) => {
              if (e.dataTransfer.types.includes('friendid')) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
                setFriendDragOverSidebar(true);
              }
            },
            onDragLeave: () => setFriendDragOverSidebar(false),
            onDrop: (e) => {
              e.preventDefault();
              setFriendDragOverSidebar(false);
              const friendId = e.dataTransfer.getData('friendId');
              if (friendId && !pinnedFriendIds.includes(friendId)) {
                pinFriend(friendId);
              }
            }
          },
            React.createElement('div', { className: 'px-3 py-2 text-xs font-semibold text-gray-400 uppercase tracking-wider' }, 'Friends'),
            React.createElement('div', { className: 'px-3 py-2 text-xs text-gray-400 italic' }, 'Drag friends here to pin')
          )
        ),

        // Settings button at bottom of sidebar
        React.createElement('div', { className: 'px-4 py-2 border-t border-gray-200' },
          React.createElement('button', {
            onClick: () => navigateTo('settings'),
            className: `w-full flex items-center gap-3 px-3 py-1.5 rounded text-sm transition-colors ${
              activeView === 'settings' ? 'bg-gray-200 text-gray-900' : 'text-gray-600 hover:bg-gray-100'
            }`
          },
            React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
              React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z' }),
              React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M15 12a3 3 0 11-6 0 3 3 0 016 0z' })
            ),
            'Settings'
          )
        )
      ),

      // Toast notification
      toast && React.createElement('div', {
        className: `fixed bottom-24 left-1/2 transform -translate-x-1/2 z-50 px-4 py-2 rounded-lg shadow-lg transition-all ${
          toast.type === 'error' ? 'bg-red-600 text-white' : 'bg-gray-900 text-white'
        }`
      }, toast.message),

      // Main content area
      React.createElement('div', {
        ref: mainContentRef,
        className: 'flex-1 flex flex-col overflow-hidden bg-white'
      },

    // External Track Prompt Modal
    showExternalPrompt && pendingExternalTrack && React.createElement('div', {
      className: 'fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50',
      onClick: (e) => {
        if (e.target === e.currentTarget) {
          // Clear the auto-skip timeout and interval
          if (externalTrackTimeoutRef.current) {
            clearTimeout(externalTrackTimeoutRef.current);
            externalTrackTimeoutRef.current = null;
          }
          if (externalTrackIntervalRef.current) {
            clearInterval(externalTrackIntervalRef.current);
            externalTrackIntervalRef.current = null;
          }
          setIsPlaying(false);
          setShowExternalPrompt(false);
          setPendingExternalTrack(null);
          setPendingExternalResolverId(null);
        }
      }
    },
      React.createElement('div', {
        className: 'bg-white rounded-2xl shadow-2xl max-w-sm w-full mx-4 overflow-hidden transform transition-all relative',
        onClick: (e) => e.stopPropagation()
      },
        // Close button
        React.createElement('button', {
          onClick: () => {
            // Clear the auto-skip timeout and interval
            if (externalTrackTimeoutRef.current) {
              clearTimeout(externalTrackTimeoutRef.current);
              externalTrackTimeoutRef.current = null;
            }
            if (externalTrackIntervalRef.current) {
              clearInterval(externalTrackIntervalRef.current);
              externalTrackIntervalRef.current = null;
            }
            // Pause playback and dismiss the prompt
            setIsPlaying(false);
            setShowExternalPrompt(false);
            setPendingExternalTrack(null);
            setPendingExternalResolverId(null);
            console.log('â¸ï¸ User dismissed external track prompt, pausing playback');
          },
          className: 'absolute top-4 right-4 p-1.5 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-lg transition-colors',
          title: 'Dismiss and pause'
        }, React.createElement(X, { size: 18 })),
        // Header with icon
        React.createElement('div', {
          className: 'px-6 pt-6 pb-4 flex flex-col items-center text-center'
        },
          // Icon circle
          React.createElement('div', {
            className: 'w-16 h-16 rounded-full bg-purple-100 flex items-center justify-center mb-4'
          },
            React.createElement('svg', {
              className: 'w-8 h-8 text-purple-600',
              fill: 'none',
              viewBox: '0 0 24 24',
              stroke: 'currentColor',
              strokeWidth: 2
            },
              React.createElement('path', {
                strokeLinecap: 'round',
                strokeLinejoin: 'round',
                d: 'M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14'
              })
            )
          ),
          // Title
          React.createElement('h3', { className: 'text-lg font-semibold text-gray-900 mb-3' },
            'Open in Browser'
          ),
          // Track info
          React.createElement('div', { className: 'mb-1' },
            React.createElement('div', { className: 'font-medium text-gray-900' }, pendingExternalTrack.title),
            React.createElement('div', { className: 'text-sm text-gray-500' }, pendingExternalTrack.artist)
          ),
          // Source badge
          React.createElement('div', {
            className: 'inline-flex items-center gap-1.5 px-2.5 py-1 rounded-full text-xs font-medium mt-2 ' +
              (pendingExternalTrack.bandcampUrl ? 'bg-cyan-100 text-cyan-700' :
               pendingExternalTrack.youtubeUrl || pendingExternalTrack.youtubeId ? 'bg-red-100 text-red-700' :
               'bg-purple-100 text-purple-700')
          },
            (allResolvers.find(r =>
              r.id === (pendingExternalTrack.bandcampUrl ? 'bandcamp' :
                       pendingExternalTrack.youtubeUrl || pendingExternalTrack.youtubeId ? 'youtube' : 'unknown')
            )?.name || 'External')
          )
        ),
        // Auto-skip notice with countdown
        React.createElement('div', { className: 'text-center text-xs text-gray-400 pb-3' },
          `Auto-skipping in ${externalTrackCountdown} second${externalTrackCountdown !== 1 ? 's' : ''}...`
        ),
        // "Don't show again" checkbox
        React.createElement('label', {
          className: 'flex items-center justify-center gap-2 px-6 pb-4 cursor-pointer select-none'
        },
          React.createElement('input', {
            type: 'checkbox',
            id: 'skip-external-prompt-checkbox',
            className: 'w-4 h-4 rounded border-gray-300 text-purple-600 focus:ring-purple-500 cursor-pointer',
            onChange: async (e) => {
              const checked = e.target.checked;
              setSkipExternalPrompt(checked);
              if (window.electron?.store) {
                await window.electron.store.set('skip_external_prompt', checked);
              }
            }
          }),
          React.createElement('span', { className: 'text-xs text-gray-500' }, "Don't show this again")
        ),
        // Buttons
        React.createElement('div', { className: 'px-6 pb-6 flex gap-3' },
          React.createElement('button', {
            onClick: () => handleOpenExternalTrack(pendingExternalTrack),
            className: 'flex-1 bg-purple-600 hover:bg-purple-700 text-white py-3 px-4 rounded-xl font-medium transition-colors'
          }, 'Open in Browser'),
          React.createElement('button', {
            onClick: handleSkipExternalTrack,
            className: 'flex-1 bg-gray-100 hover:bg-gray-200 text-gray-700 py-3 px-4 rounded-xl font-medium transition-colors'
          }, 'Skip')
        )
      )
    ),

    // Unsaved friend unpin warning dialog
    unsavedFriendWarningOpen && pendingUnpinFriend && React.createElement('div', {
      className: 'fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50',
      onClick: (e) => {
        if (e.target === e.currentTarget) {
          setUnsavedFriendWarningOpen(false);
          setPendingUnpinFriend(null);
        }
      }
    },
      React.createElement('div', {
        className: 'bg-white rounded-2xl shadow-2xl max-w-sm w-full mx-4 overflow-hidden',
        onClick: (e) => e.stopPropagation()
      },
        // Header
        React.createElement('div', { className: 'px-6 pt-6 pb-4 text-center' },
          React.createElement('div', {
            className: 'w-12 h-12 mx-auto mb-4 rounded-full bg-amber-100 flex items-center justify-center'
          },
            React.createElement('svg', {
              className: 'w-6 h-6 text-amber-600',
              fill: 'none',
              viewBox: '0 0 24 24',
              stroke: 'currentColor'
            },
              React.createElement('path', {
                strokeLinecap: 'round',
                strokeLinejoin: 'round',
                strokeWidth: 2,
                d: 'M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z'
              })
            )
          ),
          React.createElement('h3', {
            className: 'text-lg font-semibold text-gray-900 mb-2'
          }, 'Friend Not Saved'),
          React.createElement('p', {
            className: 'text-sm text-gray-600'
          }, `${pendingUnpinFriend.displayName} isn't saved to your collection. If you unpin them, you'll need to add them again to pin them later.`)
        ),
        // "Don't show again" checkbox
        React.createElement('label', {
          className: 'flex items-center justify-center gap-2 px-6 pb-4 cursor-pointer select-none'
        },
          React.createElement('input', {
            type: 'checkbox',
            className: 'w-4 h-4 rounded border-gray-300 text-purple-600 focus:ring-purple-500 cursor-pointer',
            onChange: async (e) => {
              const checked = e.target.checked;
              setSkipUnsavedFriendWarning(checked);
              if (window.electron?.store) {
                await window.electron.store.set('skip_unsaved_friend_warning', checked);
              }
            }
          }),
          React.createElement('span', { className: 'text-xs text-gray-500' }, "Don't show this again")
        ),
        // Buttons
        React.createElement('div', { className: 'px-6 pb-6 flex gap-3' },
          React.createElement('button', {
            onClick: () => {
              // Save to collection, then unpin
              saveFriendToCollection(pendingUnpinFriend.id);
              setPinnedFriendIds(prev => prev.filter(id => id !== pendingUnpinFriend.id));
              showToast(`${pendingUnpinFriend.displayName} saved and unpinned`);
              setUnsavedFriendWarningOpen(false);
              setPendingUnpinFriend(null);
            },
            className: 'flex-1 bg-purple-600 hover:bg-purple-700 text-white py-3 px-4 rounded-xl font-medium transition-colors'
          }, 'Save & Unpin'),
          React.createElement('button', {
            onClick: confirmUnpinFriend,
            className: 'flex-1 bg-gray-100 hover:bg-gray-200 text-gray-700 py-3 px-4 rounded-xl font-medium transition-colors'
          }, 'Just Unpin')
        )
      )
    ),

    // Show loading state until cache is loaded (prevents flash of default view)
    !cacheLoaded ? React.createElement('div', {
      className: 'flex-1 flex items-center justify-center bg-white'
    },
      React.createElement('div', { className: 'animate-pulse text-gray-400' }, 'Loading...')
    ) :

    // Search Page - Full page search view
    activeView === 'search' ? (
      searchDetailCategory ?
        // DETAIL VIEW - Similar structure to artist page with collapsible header
        React.createElement('div', {
          className: 'flex-1 flex flex-col bg-white',
          style: { overflow: 'hidden' }
        },
          // Header section (outside scrollable area)
          React.createElement('div', {
            className: 'relative',
            style: {
              height: searchHeaderCollapsed ? '70px' : '120px',
              flexShrink: 0,
              transition: 'height 300ms ease-out',
              overflow: 'hidden'
            }
          },
            // Background - light gray gradient
            React.createElement('div', {
              className: 'absolute inset-0',
              style: {
                background: 'linear-gradient(135deg, #6b7280 0%, #9ca3af 50%, #6b7280 100%)'
              }
            }),
            // Header content - matches artist page collapsed header style
            React.createElement('div', {
              className: 'absolute inset-0 flex items-center px-6 z-10'
            },
              // Left: Search icon + query in quotes
              React.createElement('div', { className: 'flex items-center gap-3 flex-shrink-0 mr-6' },
                React.createElement('svg', { className: 'w-5 h-5 text-white/70', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                  React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' })
                ),
                React.createElement('span', {
                  className: 'text-2xl font-light text-white uppercase',
                  style: { textShadow: '0 2px 10px rgba(0,0,0,0.3)', letterSpacing: '0.2em' }
                }, `"${searchQuery}"`)
              ),
              // Tabs (next to title, like artist page)
              React.createElement('div', {
                className: 'flex items-center gap-1',
                style: { textShadow: '0 1px 10px rgba(0,0,0,0.3)' }
              },
                [
                  { key: 'artists', label: 'Artists', count: searchResults.artists.length },
                  { key: 'albums', label: 'Albums', count: searchResults.albums.length },
                  { key: 'tracks', label: 'Songs', count: searchResults.tracks.length }
                ].map((tab, i) => React.createElement(React.Fragment, { key: tab.key },
                  i > 0 && React.createElement('span', {
                    className: 'text-white/50 mx-2'
                  }, '|'),
                  React.createElement('button', {
                    onClick: () => {
                      setSearchDetailCategory(tab.key);
                    },
                    className: `px-2 py-1 text-sm font-medium uppercase tracking-wider transition-colors no-drag ${
                      searchDetailCategory === tab.key ? 'text-white' : 'text-white/60 hover:text-white'
                    }`
                  }, `${tab.count} ${tab.label}`)
                ))
              )
            )
          ),
          // Scrollable content area - single column layout with grids/lists
          React.createElement('div', {
            className: 'flex-1 overflow-y-auto bg-white scrollable-content',
            onScroll: handleSearchDetailScroll
          },
            // Sticky filter bar for Artists (sort dropdown + search on right like other pages)
            searchDetailCategory === 'artists' && React.createElement('div', {
              className: 'sticky top-0 z-10 flex items-center px-6 py-3 bg-white border-b border-gray-200'
            },
              // Sort dropdown
              React.createElement('div', { className: 'relative' },
                React.createElement('button', {
                  onClick: (e) => { e.stopPropagation(); setSearchResultsSortDropdownOpen(!searchResultsSortDropdownOpen); },
                  className: 'flex items-center gap-1 px-3 py-1.5 text-sm text-gray-500 hover:text-gray-700 transition-colors no-drag'
                },
                  React.createElement('span', null,
                    searchResultsSort === 'relevance' ? 'Relevance' :
                    searchResultsSort === 'name' ? 'Name' : 'Sort'
                  ),
                  React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M19 9l-7 7-7-7' })
                  )
                ),
                searchResultsSortDropdownOpen && React.createElement('div', {
                  className: 'absolute left-0 top-full mt-1 bg-white rounded-lg shadow-lg py-1 min-w-[160px] z-30 border border-gray-200'
                },
                  [
                    { value: 'relevance', label: 'Relevance' },
                    { value: 'name', label: 'Name' }
                  ].map(option =>
                    React.createElement('button', {
                      key: option.value,
                      onClick: (e) => {
                        e.stopPropagation();
                        setSearchResultsSort(option.value);
                        setSearchResultsSortDropdownOpen(false);
                      },
                      className: `w-full px-4 py-2 text-left text-sm hover:bg-gray-100 flex items-center justify-between no-drag ${
                        searchResultsSort === option.value ? 'text-gray-900 font-medium' : 'text-gray-600'
                      }`
                    },
                      option.label,
                      searchResultsSort === option.value && React.createElement('svg', {
                        className: 'w-4 h-4',
                        fill: 'none',
                        viewBox: '0 0 24 24',
                        stroke: 'currentColor'
                      },
                        React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M5 13l4 4L19 7' })
                      )
                    )
                  )
                )
              ),
              React.createElement('div', { className: 'flex-1' }),
              // Search/filter on right
              React.createElement('div', { className: 'flex items-center' },
                searchResultsFilterOpen ?
                  React.createElement('div', { className: 'flex items-center border border-gray-300 rounded-full px-3 py-1.5' },
                    React.createElement('input', {
                      type: 'text',
                      value: searchResultsFilter,
                      onChange: (e) => setSearchResultsFilter(e.target.value),
                      onBlur: () => { if (!searchResultsFilter.trim()) setSearchResultsFilterOpen(false); },
                      autoFocus: true,
                      placeholder: 'Filter...',
                      className: 'bg-transparent text-gray-700 text-sm placeholder-gray-400 outline-none no-drag',
                      style: { width: '150px' }
                    }),
                    searchResultsFilter && React.createElement('button', {
                      onClick: () => { setSearchResultsFilter(''); setSearchResultsFilterOpen(false); },
                      className: 'ml-2 text-gray-400 hover:text-gray-600 no-drag'
                    },
                      React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                        React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M6 18L18 6M6 6l12 12' })
                      )
                    )
                  )
                :
                  React.createElement('button', {
                    onClick: () => setSearchResultsFilterOpen(true),
                    className: 'p-1.5 text-gray-400 hover:text-gray-600 transition-colors no-drag'
                  },
                    React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                      React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' })
                    )
                  )
              )
            ),

            // Sticky filter bar for Albums (sort dropdown + search like Critical Darlings)
            searchDetailCategory === 'albums' && React.createElement('div', {
              className: 'sticky top-0 z-10 flex items-center px-6 py-3 bg-white border-b border-gray-200'
            },
              // Sort dropdown
              React.createElement('div', { className: 'relative' },
                React.createElement('button', {
                  onClick: (e) => { e.stopPropagation(); setSearchResultsSortDropdownOpen(!searchResultsSortDropdownOpen); },
                  className: 'flex items-center gap-1 px-3 py-1.5 text-sm text-gray-500 hover:text-gray-700 transition-colors no-drag'
                },
                  React.createElement('span', null,
                    searchResultsSort === 'relevance' ? 'Relevance' :
                    searchResultsSort === 'title' ? 'Title' :
                    searchResultsSort === 'artist' ? 'Artist' :
                    searchResultsSort === 'year-desc' ? 'Year (Newest)' :
                    searchResultsSort === 'year-asc' ? 'Year (Oldest)' : 'Sort'
                  ),
                  React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M19 9l-7 7-7-7' })
                  )
                ),
                searchResultsSortDropdownOpen && React.createElement('div', {
                  className: 'absolute left-0 top-full mt-1 bg-white rounded-lg shadow-lg py-1 min-w-[160px] z-30 border border-gray-200'
                },
                  [
                    { value: 'relevance', label: 'Relevance' },
                    { value: 'title', label: 'Title' },
                    { value: 'artist', label: 'Artist' },
                    { value: 'year-desc', label: 'Year (Newest)' },
                    { value: 'year-asc', label: 'Year (Oldest)' }
                  ].map(option =>
                    React.createElement('button', {
                      key: option.value,
                      onClick: (e) => {
                        e.stopPropagation();
                        setSearchResultsSort(option.value);
                        setSearchResultsSortDropdownOpen(false);
                      },
                      className: `w-full px-4 py-2 text-left text-sm hover:bg-gray-100 flex items-center justify-between no-drag ${
                        searchResultsSort === option.value ? 'text-gray-900 font-medium' : 'text-gray-600'
                      }`
                    },
                      option.label,
                      searchResultsSort === option.value && React.createElement('svg', {
                        className: 'w-4 h-4',
                        fill: 'none',
                        viewBox: '0 0 24 24',
                        stroke: 'currentColor'
                      },
                        React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M5 13l4 4L19 7' })
                      )
                    )
                  )
                )
              ),
              React.createElement('div', { className: 'flex-1' }),
              // Search/filter
              React.createElement('div', { className: 'flex items-center' },
                searchResultsFilterOpen ?
                  React.createElement('div', { className: 'flex items-center border border-gray-300 rounded-full px-3 py-1.5' },
                    React.createElement('input', {
                      type: 'text',
                      value: searchResultsFilter,
                      onChange: (e) => setSearchResultsFilter(e.target.value),
                      onBlur: () => { if (!searchResultsFilter.trim()) setSearchResultsFilterOpen(false); },
                      autoFocus: true,
                      placeholder: 'Filter...',
                      className: 'bg-transparent text-gray-700 text-sm placeholder-gray-400 outline-none no-drag',
                      style: { width: '150px' }
                    }),
                    searchResultsFilter && React.createElement('button', {
                      onClick: () => { setSearchResultsFilter(''); setSearchResultsFilterOpen(false); },
                      className: 'ml-2 text-gray-400 hover:text-gray-600 no-drag'
                    },
                      React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                        React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M6 18L18 6M6 6l12 12' })
                      )
                    )
                  )
                :
                  React.createElement('button', {
                    onClick: () => setSearchResultsFilterOpen(true),
                    className: 'p-1.5 text-gray-400 hover:text-gray-600 transition-colors no-drag'
                  },
                    React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                      React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' })
                    )
                  )
              )
            ),

            // Sticky filter bar for Songs (sort dropdown + search)
            searchDetailCategory === 'tracks' && React.createElement('div', {
              className: 'sticky top-0 z-10 flex items-center px-6 py-3 bg-white border-b border-gray-200'
            },
              // Sort dropdown
              React.createElement('div', { className: 'relative' },
                React.createElement('button', {
                  onClick: (e) => { e.stopPropagation(); setSearchResultsSortDropdownOpen(!searchResultsSortDropdownOpen); },
                  className: 'flex items-center gap-1 px-3 py-1.5 text-sm text-gray-500 hover:text-gray-700 transition-colors no-drag'
                },
                  React.createElement('span', null,
                    searchResultsSort === 'relevance' ? 'Relevance' :
                    searchResultsSort === 'title' ? 'Title' :
                    searchResultsSort === 'artist' ? 'Artist' :
                    searchResultsSort === 'duration-asc' ? 'Duration (Short)' :
                    searchResultsSort === 'duration-desc' ? 'Duration (Long)' : 'Sort'
                  ),
                  React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M19 9l-7 7-7-7' })
                  )
                ),
                searchResultsSortDropdownOpen && React.createElement('div', {
                  className: 'absolute left-0 top-full mt-1 bg-white rounded-lg shadow-lg py-1 min-w-[160px] z-30 border border-gray-200'
                },
                  [
                    { value: 'relevance', label: 'Relevance' },
                    { value: 'title', label: 'Title' },
                    { value: 'artist', label: 'Artist' },
                    { value: 'duration-asc', label: 'Duration (Short)' },
                    { value: 'duration-desc', label: 'Duration (Long)' }
                  ].map(option =>
                    React.createElement('button', {
                      key: option.value,
                      onClick: (e) => {
                        e.stopPropagation();
                        setSearchResultsSort(option.value);
                        setSearchResultsSortDropdownOpen(false);
                      },
                      className: `w-full px-4 py-2 text-left text-sm hover:bg-gray-100 flex items-center justify-between no-drag ${
                        searchResultsSort === option.value ? 'text-gray-900 font-medium' : 'text-gray-600'
                      }`
                    },
                      option.label,
                      searchResultsSort === option.value && React.createElement('svg', {
                        className: 'w-4 h-4',
                        fill: 'none',
                        viewBox: '0 0 24 24',
                        stroke: 'currentColor'
                      },
                        React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M5 13l4 4L19 7' })
                      )
                    )
                  )
                )
              ),
              React.createElement('div', { className: 'flex-1' }),
              // Search/filter
              React.createElement('div', { className: 'flex items-center' },
                searchResultsFilterOpen ?
                  React.createElement('div', { className: 'flex items-center border border-gray-300 rounded-full px-3 py-1.5' },
                    React.createElement('input', {
                      type: 'text',
                      value: searchResultsFilter,
                      onChange: (e) => setSearchResultsFilter(e.target.value),
                      onBlur: () => { if (!searchResultsFilter.trim()) setSearchResultsFilterOpen(false); },
                      autoFocus: true,
                      placeholder: 'Filter...',
                      className: 'bg-transparent text-gray-700 text-sm placeholder-gray-400 outline-none no-drag',
                      style: { width: '150px' }
                    }),
                    searchResultsFilter && React.createElement('button', {
                      onClick: () => { setSearchResultsFilter(''); setSearchResultsFilterOpen(false); },
                      className: 'ml-2 text-gray-400 hover:text-gray-600 no-drag'
                    },
                      React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                        React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M6 18L18 6M6 6l12 12' })
                      )
                    )
                  )
                :
                  React.createElement('button', {
                    onClick: () => setSearchResultsFilterOpen(true),
                    className: 'p-1.5 text-gray-400 hover:text-gray-600 transition-colors no-drag'
                  },
                    React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                      React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' })
                    )
                  )
              )
            ),

            // Content container with padding
            React.createElement('div', { className: 'px-6 py-6' },
              // Artists grid (like Recommendations)
              searchDetailCategory === 'artists' && (() => {
                // Filter and sort artists
                let filteredArtists = searchResultsFilter
                  ? searchResults.artists.filter(a => a.name?.toLowerCase().includes(searchResultsFilter.toLowerCase()))
                  : [...searchResults.artists];

                // Sort artists
                if (searchResultsSort === 'name') {
                  filteredArtists.sort((a, b) => (a.name || '').localeCompare(b.name || ''));
                }
                // 'relevance' keeps original order from search results

                return filteredArtists.length > 0 && React.createElement('div', {
                  className: 'grid gap-x-4 gap-y-8',
                  style: { gridTemplateColumns: 'repeat(auto-fill, minmax(160px, 1fr))' }
                },
                  ...filteredArtists.map((artist) =>
                  React.createElement('div', {
                    key: artist.id,
                    className: 'flex flex-col items-center cursor-grab active:cursor-grabbing group',
                    draggable: true,
                    onDragStart: (e) => {
                      e.dataTransfer.effectAllowed = 'copy';
                      e.dataTransfer.setData('text/plain', JSON.stringify({
                        type: 'artist',
                        artist: {
                          id: (artist.name || 'unknown').toLowerCase().replace(/[^a-z0-9-]/g, ''),
                          name: artist.name,
                          image: artist.image || null
                        }
                      }));
                    },
                    onClick: () => fetchArtistData(artist.name),
                    onContextMenu: (e) => {
                      e.preventDefault();
                      e.stopPropagation();
                      if (window.electron?.contextMenu?.showTrackMenu) {
                        window.electron.contextMenu.showTrackMenu({
                          type: 'artist',
                          artist: {
                            id: (artist.name || 'unknown').toLowerCase().replace(/[^a-z0-9-]/g, ''),
                            name: artist.name,
                            image: artist.image || null
                          }
                        });
                      }
                    }
                  },
                    React.createElement('div', {
                      className: 'relative w-36 h-36 rounded-full overflow-hidden'
                    },
                      React.createElement('div', {
                        className: `w-full h-full group-hover:scale-110 transition-transform duration-300 ${
                          artist.image ? '' : !artist.imageLoaded ? 'bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer' : 'bg-gradient-to-br from-purple-500 to-pink-500'
                        }`,
                        style: artist.image ? {
                          backgroundImage: `url(${artist.image})`,
                          backgroundSize: 'cover',
                          backgroundPosition: 'center'
                        } : !artist.imageLoaded ? {
                          backgroundSize: '200% 100%'
                        } : {}
                      })
                    ),
                    React.createElement('span', {
                      className: 'mt-3 text-sm font-medium text-gray-700 text-center truncate w-full group-hover:text-purple-600 transition-colors'
                    }, artist.name)
                  )
                )
                );
              })(),

              // Artists empty state
              searchDetailCategory === 'artists' && (searchResultsFilter
                ? searchResults.artists.filter(a => a.name?.toLowerCase().includes(searchResultsFilter.toLowerCase())).length === 0
                : searchResults.artists.length === 0
              ) && React.createElement('div', {
                className: 'text-center py-12 text-gray-400'
              }, searchResultsFilter ? 'No artists match your filter.' : 'No artists found.'),

              // Albums grid (like Critical Darlings)
              searchDetailCategory === 'albums' && (() => {
                // Filter and sort albums
                let filteredAlbums = searchResultsFilter
                  ? searchResults.albums.filter(a =>
                      a.title?.toLowerCase().includes(searchResultsFilter.toLowerCase()) ||
                      a['artist-credit']?.[0]?.name?.toLowerCase().includes(searchResultsFilter.toLowerCase())
                    )
                  : [...searchResults.albums];

                // Sort albums
                if (searchResultsSort === 'title') {
                  filteredAlbums.sort((a, b) => (a.title || '').localeCompare(b.title || ''));
                } else if (searchResultsSort === 'artist') {
                  filteredAlbums.sort((a, b) =>
                    (a['artist-credit']?.[0]?.name || '').localeCompare(b['artist-credit']?.[0]?.name || '')
                  );
                } else if (searchResultsSort === 'year-desc') {
                  filteredAlbums.sort((a, b) => {
                    const yearA = parseInt(a['first-release-date']?.split('-')[0]) || 0;
                    const yearB = parseInt(b['first-release-date']?.split('-')[0]) || 0;
                    return yearB - yearA;
                  });
                } else if (searchResultsSort === 'year-asc') {
                  filteredAlbums.sort((a, b) => {
                    const yearA = parseInt(a['first-release-date']?.split('-')[0]) || 9999;
                    const yearB = parseInt(b['first-release-date']?.split('-')[0]) || 9999;
                    return yearA - yearB;
                  });
                }

                return filteredAlbums.length > 0 && React.createElement('div', {
                  className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-x-4 gap-y-8 pb-6'
                },
                  filteredAlbums.map(album =>
                  React.createElement('div', {
                    key: album.id,
                    className: 'group cursor-pointer',
                    draggable: true,
                    onDragStart: (e) => {
                      e.dataTransfer.effectAllowed = 'copy';
                      e.dataTransfer.setData('text/plain', JSON.stringify({
                        type: 'album',
                        album: {
                          id: `${album['artist-credit']?.[0]?.name || 'unknown'}-${album.title || 'untitled'}`.toLowerCase().replace(/[^a-z0-9-]/g, ''),
                          title: album.title,
                          artist: album['artist-credit']?.[0]?.name || 'Unknown',
                          year: album['first-release-date']?.split('-')[0] ? parseInt(album['first-release-date'].split('-')[0]) : null,
                          art: album.albumArt || null
                        }
                      }));
                    },
                    onMouseEnter: () => prefetchSearchAlbumTracks(album),
                    onClick: () => handleAlbumClick(album),
                    onContextMenu: (e) => {
                      e.preventDefault();
                      e.stopPropagation();
                      const artistName = album['artist-credit']?.[0]?.name || 'Unknown';
                      const albumData = {
                        title: album.title,
                        artist: artistName,
                        year: album['first-release-date']?.split('-')[0] ? parseInt(album['first-release-date'].split('-')[0]) : null,
                        art: album.albumArt || null
                      };
                      const prefetched = prefetchedReleasesRef.current[album.id];
                      const isLoading = prefetchInProgress.has(album.id);
                      window.electron.contextMenu.showTrackMenu({
                        type: 'release',
                        name: album.title,
                        album: albumData,
                        tracks: prefetched?.tracks || [],
                        loading: isLoading
                      });
                    }
                  },
                    // Album art with hover overlay
                    React.createElement('div', {
                      className: 'aspect-square rounded-lg overflow-hidden mb-3 relative'
                    },
                      // Shimmering skeleton (shows while waiting for albumArt or while image loads)
                      React.createElement('div', {
                        className: 'absolute inset-0 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                        style: { backgroundSize: '200% 100%' }
                      }),
                      // Image with fade-in (hides shimmer when loaded)
                      album.albumArt && React.createElement('img', {
                        src: album.albumArt,
                        alt: album.title,
                        className: 'absolute inset-0 w-full h-full object-cover group-hover:scale-105 transition-opacity duration-300',
                        style: { opacity: 0 },
                        ref: (el) => { if (el && el.complete && el.naturalWidth > 0) el.style.opacity = '1'; },
                        onLoad: (e) => { e.target.style.opacity = '1'; },
                        onError: (e) => {
                          e.target.style.display = 'none';
                          const fallback = e.target.nextElementSibling;
                          if (fallback) fallback.style.display = 'flex';
                        }
                      }),
                      // Fallback placeholder (hidden until image error)
                      album.albumArt && React.createElement('div', {
                        className: 'absolute inset-0 bg-gradient-to-br from-purple-500 to-pink-500 items-center justify-center text-white/60',
                        style: { display: 'none' }
                      },
                        React.createElement('svg', { className: 'w-16 h-16', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor', strokeWidth: 1 },
                          React.createElement('circle', { cx: 12, cy: 12, r: 10 }),
                          React.createElement('circle', { cx: 12, cy: 12, r: 3 }),
                          React.createElement('circle', { cx: 12, cy: 12, r: 6, strokeDasharray: '2 2' })
                        )
                      ),
                      // Hover overlay with Add to Queue button
                      React.createElement('div', {
                        className: 'absolute inset-0 bg-black/60 opacity-0 group-hover:opacity-100 transition-opacity duration-200 flex items-center justify-center'
                      },
                        React.createElement('button', {
                          onClick: (e) => {
                            e.stopPropagation();
                            // Add album tracks to queue (prefetched on hover)
                            const prefetched = prefetchedReleasesRef.current[album.id];
                            if (prefetched?.tracks?.length > 0) {
                              const context = { type: 'album', id: album.id, name: album.title, artist: album.artist };
                              addToQueue(prefetched.tracks, context);
                            }
                          },
                          className: 'bg-white text-gray-900 px-4 py-2 rounded-full text-sm font-medium hover:bg-gray-100 transition-colors flex items-center gap-2 shadow-lg'
                        },
                          React.createElement('svg', {
                            className: 'w-4 h-4',
                            fill: 'none',
                            viewBox: '0 0 24 24',
                            stroke: 'currentColor'
                          },
                            React.createElement('path', {
                              strokeLinecap: 'round',
                              strokeLinejoin: 'round',
                              strokeWidth: 2,
                              d: 'M12 4v16m8-8H4'
                            })
                          ),
                          'Add to Queue'
                        )
                      )
                    ),
                    // Album info
                    React.createElement('div', { className: 'space-y-1' },
                      React.createElement('div', {
                        className: 'font-medium text-gray-900 truncate group-hover:text-purple-600 transition-colors'
                      }, album.title),
                      React.createElement('div', {
                        className: 'text-sm text-gray-500 truncate hover:text-purple-600 hover:underline cursor-pointer transition-colors',
                        onClick: (e) => {
                          e.stopPropagation();
                          fetchArtistData(album['artist-credit']?.[0]?.name);
                        }
                      }, album['artist-credit']?.[0]?.name || 'Unknown Artist')
                    )
                  )
                )
                );
              })(),

              // Albums empty state
              searchDetailCategory === 'albums' && (() => {
                const filteredAlbums = searchResultsFilter
                  ? searchResults.albums.filter(a =>
                      a.title?.toLowerCase().includes(searchResultsFilter.toLowerCase()) ||
                      a['artist-credit']?.[0]?.name?.toLowerCase().includes(searchResultsFilter.toLowerCase())
                    )
                  : searchResults.albums;
                return filteredAlbums.length === 0;
              })() && React.createElement('div', {
                className: 'text-center py-12 text-gray-400'
              }, searchResultsFilter ? 'No albums match your filter.' : 'No albums found.'),

              // Tracks list (like Recommended Songs)
              searchDetailCategory === 'tracks' && (() => {
                // Filter and sort tracks
                let filteredTracks = searchResultsFilter
                  ? searchResults.tracks.filter(t =>
                      t.title?.toLowerCase().includes(searchResultsFilter.toLowerCase()) ||
                      t.artist?.toLowerCase().includes(searchResultsFilter.toLowerCase())
                    )
                  : [...searchResults.tracks];

                // Sort tracks
                if (searchResultsSort === 'title') {
                  filteredTracks.sort((a, b) => (a.title || '').localeCompare(b.title || ''));
                } else if (searchResultsSort === 'artist') {
                  filteredTracks.sort((a, b) => (a.artist || '').localeCompare(b.artist || ''));
                } else if (searchResultsSort === 'duration-asc') {
                  filteredTracks.sort((a, b) => (a.duration || 0) - (b.duration || 0));
                } else if (searchResultsSort === 'duration-desc') {
                  filteredTracks.sort((a, b) => (b.duration || 0) - (a.duration || 0));
                }

                return filteredTracks.length > 0 && React.createElement('div', { className: 'space-y-0' },
                  ...filteredTracks.map((track, index) => {
                    const hasResolved = Object.keys(track.sources || {}).length > 0;
                    const isResolving = !hasResolved && track.resolving;
                    const isCurrentTrack = currentTrack?.id === track.id;
                    const isNowPlaying = isCurrentTrack && playbackContext?.type === 'search';

                    return React.createElement('div', {
                      key: track.id,
                      draggable: true,
                      onDragStart: (e) => {
                        setDraggingTrackForPlaylist(track);
                        e.dataTransfer.effectAllowed = 'copy';
                      e.dataTransfer.setData('text/plain', JSON.stringify({
                        type: 'track',
                        track: {
                          id: track.id,
                          title: track.title,
                          artist: track.artist,
                          album: track.album,
                          duration: track.duration,
                          albumArt: track.albumArt,
                          sources: track.sources || {}
                        }
                      }));
                    },
                    onDragEnd: () => {
                      setDraggingTrackForPlaylist(null);
                      setDropTargetPlaylistId(null);
                      setDropTargetNewPlaylist(false);
                      if (addToPlaylistPanel.open && selectedPlaylistsForAdd.length === 0) {
                        setAddToPlaylistPanel(prev => ({ ...prev, open: false }));
                      }
                    },
                    className: `flex items-center gap-4 py-2 px-3 border-b border-gray-100 hover:bg-gray-50 cursor-grab active:cursor-grabbing transition-colors group ${
                      isResolving ? 'opacity-60' : ''
                    } ${isNowPlaying && isPlaying ? 'bg-purple-50' : ''}`,
                    onClick: () => {
                      const tracksAfter = filteredTracks.slice(index + 1);
                      const context = { type: 'search', name: searchQuery };
                      setQueueWithContext(tracksAfter, context);
                      handlePlay(track);
                    },
                    onContextMenu: (e) => {
                      e.preventDefault();
                      if (window.electron?.contextMenu?.showTrackMenu) {
                        window.electron.contextMenu.showTrackMenu({
                          type: 'track',
                          track: track
                        });
                      }
                    }
                  },
                    // Track number or playing indicator
                    React.createElement('span', {
                      className: `text-sm flex-shrink-0 text-right ${isNowPlaying && isPlaying ? 'text-purple-500' : 'text-gray-400'}`,
                      style: { pointerEvents: 'none', width: '32px' }
                    }, isNowPlaying && isPlaying ? 'â–¶' : String(index + 1).padStart(2, '0')),

                    // Track title - fixed width column (font-medium for emphasis)
                    React.createElement('span', {
                      className: `text-sm font-medium truncate transition-colors ${isNowPlaying && isPlaying ? 'text-purple-600' : hasResolved ? 'text-gray-900 group-hover:text-gray-900' : 'text-gray-500'}`,
                      style: { pointerEvents: 'none', width: '360px', flexShrink: 0 }
                    }, track.title),

                    // Artist name - fixed width column, clickable (lighter weight than title)
                    React.createElement('span', {
                      className: 'text-sm text-gray-500 truncate hover:text-purple-600 hover:underline cursor-pointer transition-colors',
                      style: { width: '240px', flexShrink: 0 },
                      onClick: (e) => {
                        e.stopPropagation();
                        fetchArtistData(track.artist);
                      }
                    }, track.artist),

                    // Duration - fixed width column
                    React.createElement('span', {
                      className: 'text-sm text-gray-400 text-right tabular-nums',
                      style: { pointerEvents: 'none', width: '50px', flexShrink: 0, marginLeft: 'auto' }
                    }, formatTime(track.duration)),

                    // Resolver icons - fixed width column
                    React.createElement('div', {
                      className: 'flex items-center gap-1 justify-end',
                      style: { width: '100px', flexShrink: 0, minHeight: '24px' }
                    },
                      isResolving ?
                        React.createElement('div', {
                          className: 'flex items-center gap-1'
                        },
                          React.createElement('div', {
                            className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer',
                            title: 'Resolving track...'
                          }),
                          React.createElement('div', {
                            className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer',
                            style: { animationDelay: '0.1s' }
                          })
                        )
                      : hasResolved ?
                        Object.entries(track.sources)
                          .sort(([aId], [bId]) => {
                            const aIndex = resolverOrder.indexOf(aId);
                            const bIndex = resolverOrder.indexOf(bId);
                            return aIndex - bIndex;
                          })
                          .map(([resolverId, source]) => {
                            const resolver = allResolvers.find(r => r.id === resolverId);
                            if (!resolver || !resolver.play) return null;
                            return React.createElement('button', {
                              key: resolverId,
                              className: 'no-drag',
                              onClick: (e) => {
                                e.stopPropagation();
                                const tracksAfter = filteredTracks.slice(index + 1);
                                const context = { type: 'search', name: searchQuery };
                                setQueueWithContext(tracksAfter, context);
                                handlePlay({ ...track, preferredResolver: resolverId });
                              },
                              style: {
                                width: '24px',
                                height: '24px',
                                borderRadius: '4px',
                                backgroundColor: resolver.color,
                                border: 'none',
                                cursor: 'pointer',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                pointerEvents: 'auto',
                                opacity: (source.confidence || 0) > 0.8 ? 1 : 0.6,
                                transition: 'transform 0.1s'
                              },
                              onMouseEnter: (e) => e.currentTarget.style.transform = 'scale(1.1)',
                              onMouseLeave: (e) => e.currentTarget.style.transform = 'scale(1)',
                              title: `Play from ${resolver.name}${source.confidence ? ` (${Math.round(source.confidence * 100)}% match)` : ''}`
                            }, React.createElement(ResolverIcon, { resolverId, size: 14 }));
                          })
                      :
                        null
                    )
                  );
                  })
                );
              })(),

              // Tracks empty state
              searchDetailCategory === 'tracks' && (() => {
                const filteredTracks = searchResultsFilter
                  ? searchResults.tracks.filter(t =>
                      t.title?.toLowerCase().includes(searchResultsFilter.toLowerCase()) ||
                      t.artist?.toLowerCase().includes(searchResultsFilter.toLowerCase())
                    )
                  : searchResults.tracks;
                return filteredTracks.length === 0;
              })() && React.createElement('div', {
                className: 'text-center py-12 text-gray-400'
              }, searchResultsFilter ? 'No songs match your filter.' : 'No songs found.'),

              // Playlists list (keep existing style)
              searchDetailCategory === 'playlists' && searchResults.playlists.map((playlist, index) =>
                React.createElement('div', {
                  key: playlist.title,
                  className: 'flex items-center px-6 py-3 hover:bg-gray-50 cursor-pointer transition-colors',
                  onClick: () => handlePlaylistClick(playlist)
                },
                  // Row number
                  React.createElement('span', { className: 'w-10 text-sm text-gray-400' }, String(index + 1).padStart(2, '0')),
                  // Playlist title
                  React.createElement('span', { className: 'flex-1 font-medium text-gray-900 truncate' }, playlist.title),
                  // Creator/Author
                  React.createElement('span', { className: 'w-40 text-sm text-gray-600 truncate' }, playlist.creator || '-'),
                  // Track count
                  React.createElement('span', { className: 'w-24 text-sm text-gray-500 text-right' }, `${playlist.tracks?.length || 0} tracks`)
                )
              )
            )
          ) // end scrollable content
        ) // end detail view container
      :
        // MAIN VIEW - clean white layout matching reference
        React.createElement('div', {
          className: 'h-full overflow-y-auto bg-white'
        },
          // Header bar with SEARCH title and CLOSE button
          React.createElement('div', { className: 'flex items-center justify-between px-8 py-3 border-b border-gray-200' },
            React.createElement('span', { className: 'text-xs font-medium tracking-widest text-gray-400 uppercase' }, 'Search'),
            React.createElement('button', {
              onClick: () => navigateBack(),
              className: 'flex items-center gap-1 px-3 py-1 text-xs text-gray-500 hover:text-gray-700 border border-gray-300 rounded hover:bg-gray-50 transition-colors no-drag'
            },
              'CLOSE',
              React.createElement('span', { className: 'text-gray-400' }, 'Ã—')
            )
          ),

          // Content area
          React.createElement('div', { className: 'px-8 py-6', ref: searchResultsContainerRef },
        // Main view content
        React.createElement('div', null,
          // Large search input with cursor styling
          React.createElement('div', { className: 'mb-8' },
            React.createElement('input', {
              ref: (el) => el && activeView === 'search' && !searchQuery && el.focus(),
              type: 'text',
              value: searchQuery,
              onChange: (e) => handleSearchInput(e.target.value),
              placeholder: '',
              className: 'w-full text-6xl font-extralight text-gray-900 bg-transparent border-none outline-none tracking-tight',
              style: {
                caretColor: '#9ca3af',
                fontFamily: 'system-ui, -apple-system, sans-serif'
              }
            })
          ),

        // Results area
        // Show search history when no query
        (!searchQuery) ?
          // Search history view
          (searchHistory.length > 0 ?
            React.createElement('div', { className: 'space-y-4' },
              // Header with clear all button
              React.createElement('div', { className: 'flex items-center justify-between' },
                React.createElement('h3', {
                  className: 'text-xs font-semibold text-gray-400 uppercase tracking-wider'
                }, 'Recent Searches'),
                React.createElement('button', {
                  onClick: () => clearSearchHistory(),
                  className: 'text-xs text-gray-400 hover:text-red-500 transition-colors'
                }, 'Clear All')
              ),
              // History list
              React.createElement('div', { className: 'space-y-1' },
                ...searchHistory.slice(0, 10).map((entry, i) =>
                  React.createElement(SearchHistoryItem, {
                    key: `history-${i}-${entry.query}`,
                    entry,
                    onQueryClick: (query) => {
                      handleSearchInput(query);
                    },
                    onResultClick: (result) => {
                      // Navigate directly to the result
                      if (result.type === 'artist') {
                        fetchArtistData(result.name);
                      } else if (result.type === 'album') {
                        handleAlbumClick({ id: result.id, title: result.name, 'artist-credit': [{ name: result.artist }] });
                      } else if (result.type === 'playlist') {
                        const playlist = playlists.find(p => p.id === result.id);
                        if (playlist) handlePlaylistClick(playlist);
                      } else if (result.type === 'track') {
                        // Play the track directly - create a minimal track object for resolution
                        const track = {
                          id: result.id,
                          title: result.name,
                          artist: result.artist,
                          albumArt: result.imageUrl,
                          sources: {}
                        };
                        handlePlay(track);
                      }
                    },
                    onRemove: (query) => clearSearchHistory(query)
                  })
                )
              )
            ) :
            // No history yet - show placeholder
            React.createElement('div', { className: 'text-center py-12' },
              React.createElement('svg', {
                className: 'w-12 h-12 mx-auto text-gray-300 mb-4',
                fill: 'none',
                stroke: 'currentColor',
                viewBox: '0 0 24 24'
              },
                React.createElement('path', {
                  strokeLinecap: 'round',
                  strokeLinejoin: 'round',
                  strokeWidth: 1.5,
                  d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z'
                })
              ),
              React.createElement('p', { className: 'text-gray-400 text-sm' }, 'Start typing to search')
            )
          ) :
        isSearching ?
          // Loading skeletons - dynamically sized based on container width
          React.createElement('div', { className: 'space-y-10' },
            // Artists skeleton - circular style
            React.createElement('div', null,
              React.createElement('h3', { className: 'text-xs font-semibold text-gray-400 uppercase tracking-wider mb-4' }, 'ARTISTS'),
              React.createElement('div', { className: 'flex gap-4' },
                ...Array(getItemsPerRow(130)).fill(null).map((_, i) => {
                  const skeletonWidth = Math.floor((searchContainerWidth - (getItemsPerRow(130) - 1) * 16) / getItemsPerRow(130));
                  const imageSize = Math.min(skeletonWidth - 8, 120);
                  return React.createElement('div', {
                    key: `artist-skeleton-${i}`,
                    className: 'flex flex-col items-center transition-all duration-300 ease-out',
                    style: { width: skeletonWidth }
                  },
                    React.createElement('div', {
                      className: 'rounded-full bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 mb-2 animate-shimmer mx-auto transition-all duration-300 ease-out',
                      style: { width: imageSize, height: imageSize, backgroundSize: '200% 100%', animationDelay: `${i * 100}ms` }
                    }),
                    React.createElement('div', {
                      className: 'h-3 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 w-3/4 rounded animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 100 + 50}ms` }
                    })
                  );
                })
              )
            ),
            // Songs skeleton - rounded style
            React.createElement('div', null,
              React.createElement('h3', { className: 'text-xs font-semibold text-gray-400 uppercase tracking-wider mb-4' }, 'SONGS'),
              React.createElement('div', { className: 'flex gap-4' },
                ...Array(getItemsPerRow(110)).fill(null).map((_, i) => {
                  const skeletonWidth = Math.floor((searchContainerWidth - (getItemsPerRow(110) - 1) * 16) / getItemsPerRow(110));
                  return React.createElement('div', {
                    key: `track-skeleton-${i}`,
                    className: 'transition-all duration-300 ease-out',
                    style: { width: skeletonWidth }
                  },
                    React.createElement('div', {
                      className: 'w-full aspect-square rounded-lg bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 mb-2 animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 100}ms` }
                    }),
                    React.createElement('div', {
                      className: 'h-3 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 w-3/4 mb-1 rounded animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 100 + 50}ms` }
                    }),
                    React.createElement('div', {
                      className: 'h-2 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 w-1/2 rounded animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 100 + 100}ms` }
                    }),
                    React.createElement('div', {
                      className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 w-10 mt-1 rounded animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 100 + 150}ms` }
                    })
                  );
                })
              )
            ),
            // Albums skeleton - rounded style
            React.createElement('div', null,
              React.createElement('h3', { className: 'text-xs font-semibold text-gray-400 uppercase tracking-wider mb-4' }, 'ALBUMS'),
              React.createElement('div', { className: 'flex gap-4' },
                ...Array(getItemsPerRow(150)).fill(null).map((_, i) => {
                  const skeletonWidth = Math.floor((searchContainerWidth - (getItemsPerRow(150) - 1) * 16) / getItemsPerRow(150));
                  return React.createElement('div', {
                    key: `album-skeleton-${i}`,
                    className: 'transition-all duration-300 ease-out',
                    style: { width: skeletonWidth }
                  },
                    React.createElement('div', {
                      className: 'w-full aspect-square rounded-lg bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 mb-3 animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 100}ms` }
                    }),
                    React.createElement('div', {
                      className: 'h-3 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 w-3/4 mb-1 rounded animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 100 + 50}ms` }
                    }),
                    React.createElement('div', {
                      className: 'h-2 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 w-1/2 rounded animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 100 + 100}ms` }
                    })
                  );
                })
              )
            )
          )
        :
        // No results state
        searchResults.artists.length === 0 &&
        searchResults.albums.length === 0 &&
        searchResults.tracks.length === 0 &&
        searchResults.playlists.length === 0 ?
          React.createElement('div', { className: 'text-center py-12 text-gray-400' },
            `No results found for "${searchQuery}"`
          )
        :
        // Results
        React.createElement('div', { className: 'space-y-10' },
          // Artists section with image cards - responsive grid
          searchResults.artists.length > 0 && React.createElement('div', null,
            React.createElement('div', { className: 'flex items-center justify-between mb-4' },
              React.createElement('h3', { className: 'text-xs font-semibold text-gray-400 uppercase tracking-wider' }, 'ARTISTS'),
              searchResults.artists.length > 10 &&
                React.createElement('button', {
                  onClick: () => {
                    setSearchDetailCategory('artists');
                    setSearchPreviewItem(searchResults.artists[0] || null);
                  },
                  className: 'text-xs text-gray-500 hover:text-gray-700'
                }, 'Show more')
            ),
            React.createElement('div', {
              className: 'flex gap-4'
            },
              ...searchResults.artists.slice(0, getItemsPerRow(130)).map(artist =>
                React.createElement(SearchArtistCard, {
                  key: artist.id,
                  artist: artist,
                  onClick: () => {
                    // Get cached artist image if available
                    const normalizedName = artist.name?.trim().toLowerCase();
                    const cachedImage = normalizedName ? artistImageCache.current[normalizedName] : null;
                    saveSearchHistory(searchQuery, {
                      type: 'artist',
                      id: artist.id,
                      name: artist.name,
                      imageUrl: cachedImage?.url || null
                    });
                    fetchArtistData(artist.name);
                  },
                  getArtistImage: getArtistImage,
                  itemWidth: Math.floor((searchContainerWidth - (getItemsPerRow(130) - 1) * 16) / getItemsPerRow(130)),
                  onContextMenu: (artist) => {
                    if (window.electron?.contextMenu?.showTrackMenu) {
                      window.electron.contextMenu.showTrackMenu({
                        type: 'artist',
                        artist: {
                          id: (artist.name || 'unknown').toLowerCase().replace(/[^a-z0-9-]/g, ''),
                          name: artist.name,
                          image: null
                        }
                      });
                    }
                  }
                })
              )
            )
          ),

          // Songs/Tracks section with album art cards - responsive grid
          searchResults.tracks.length > 0 && React.createElement('div', null,
            React.createElement('div', { className: 'flex items-center justify-between mb-4' },
              React.createElement('h3', { className: 'text-xs font-semibold text-gray-400 uppercase tracking-wider' }, 'SONGS'),
              searchResults.tracks.length > 10 &&
                React.createElement('button', {
                  onClick: () => {
                    setSearchDetailCategory('tracks');
                    setSearchPreviewItem(searchResults.tracks[0] || null);
                  },
                  className: 'text-xs text-gray-500 hover:text-gray-700'
                }, 'Show more')
            ),
            React.createElement('div', {
              className: 'flex gap-4'
            },
              ...searchResults.tracks.slice(0, getItemsPerRow(110)).map(track => {
                const trackItemWidth = Math.floor((searchContainerWidth - (getItemsPerRow(110) - 1) * 16) / getItemsPerRow(110));
                return React.createElement('div', {
                  key: track.id,
                  className: 'text-left group transition-all duration-300 ease-out',
                  style: { width: trackItemWidth }
                },
                  // Album art with rounded corners - this is the draggable part
                  React.createElement('div', {
                    className: 'w-full aspect-square rounded-lg overflow-hidden mb-2 relative cursor-grab active:cursor-grabbing',
                    draggable: true,
                    onClick: () => {
                      // Get album art from track or fall back to cache
                      const cachedArt = track.releaseId ? albumArtCache.current[track.releaseId]?.url : null;
                      saveSearchHistory(searchQuery, {
                        type: 'track',
                        id: track.id,
                        name: track.title,
                        artist: track.artist,
                        imageUrl: track.albumArt || cachedArt || null
                      });
                      handlePlay(track);
                    },
                    onDragStart: (e) => {
                      e.dataTransfer.effectAllowed = 'copy';
                      e.dataTransfer.setData('text/plain', JSON.stringify({
                        type: 'track',
                        track: {
                          id: track.id,
                          title: track.title,
                          artist: track.artist,
                          album: track.album,
                          duration: track.duration,
                          albumArt: track.albumArt,
                          sources: track.sources || {}
                        }
                      }));
                    },
                    onContextMenu: (e) => {
                      e.preventDefault();
                      e.stopPropagation();
                      if (window.electron?.contextMenu?.showTrackMenu) {
                        window.electron.contextMenu.showTrackMenu({
                          type: 'track',
                          track: {
                            id: track.id,
                            title: track.title,
                            artist: track.artist,
                            album: track.album,
                            duration: track.duration,
                            albumArt: track.albumArt,
                            sources: track.sources || {}
                          }
                        });
                      }
                    }
                  },
                    // Shimmering skeleton (shows while waiting for albumArt or while image loads)
                    React.createElement('div', {
                      className: 'absolute inset-0 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                      style: { backgroundSize: '200% 100%' }
                    }),
                    // Image with fade-in (hides shimmer when loaded)
                    track.albumArt && React.createElement('img', {
                      src: track.albumArt,
                      alt: track.album,
                      className: 'absolute inset-0 w-full h-full object-cover group-hover:scale-105 transition-opacity duration-300',
                      style: { opacity: 0 },
                      ref: (el) => { if (el && el.complete && el.naturalWidth > 0) el.style.opacity = '1'; },
                      onLoad: (e) => { e.target.style.opacity = '1'; },
                      onError: (e) => {
                        e.target.style.display = 'none';
                        const fallback = e.target.nextElementSibling;
                        if (fallback) fallback.style.display = 'flex';
                      }
                    }),
                    // Fallback placeholder (hidden until image error)
                    track.albumArt && React.createElement('div', {
                      className: 'absolute inset-0 bg-gradient-to-br from-purple-500 to-pink-500 items-center justify-center text-white/60',
                      style: { display: 'none' }
                    },
                      React.createElement('svg', { className: 'w-10 h-10', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor', strokeWidth: 1 },
                        React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', d: 'M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3' })
                      )
                    )
                  ),
                  // Track info - not draggable
                  React.createElement('div', { className: 'text-sm font-medium text-gray-900 truncate' }, track.title),
                  React.createElement('div', { className: 'text-xs text-gray-500 truncate' }, track.artist),
                  // Resolver icons (small squares like track lists) - show ALL matched resolvers
                  React.createElement('div', { className: 'flex gap-1 mt-1 flex-wrap', style: { minHeight: '18px' } },
                    ...(track.sources && Object.keys(track.sources).length > 0 ?
                      Object.keys(track.sources).map(source => {
                        const colors = {
                          spotify: '#1DB954',
                          youtube: '#FF0000',
                          bandcamp: '#1DA0C3',
                          qobuz: '#0070CC',
                          applemusic: '#FA243C',
                          localfiles: '#6B7280'
                        };
                        return React.createElement('div', {
                          key: source,
                          style: {
                            width: '18px',
                            height: '18px',
                            borderRadius: '3px',
                            backgroundColor: colors[source] || '#9CA3AF',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center'
                          }
                        }, React.createElement(ResolverIcon, { resolverId: source, size: 10 }));
                      })
                    : [])
                  )
                );
              })
            )
          ),

          // Albums section with album art cards - responsive grid
          searchResults.albums.length > 0 && React.createElement('div', null,
            React.createElement('div', { className: 'flex items-center justify-between mb-4' },
              React.createElement('h3', { className: 'text-xs font-semibold text-gray-400 uppercase tracking-wider' }, 'ALBUMS'),
              searchResults.albums.length > 8 &&
                React.createElement('button', {
                  onClick: () => {
                    setSearchDetailCategory('albums');
                    setSearchPreviewItem(searchResults.albums[0] || null);
                  },
                  className: 'text-xs text-gray-500 hover:text-gray-700'
                }, 'Show more')
            ),
            React.createElement('div', {
              className: 'flex gap-4'
            },
              ...searchResults.albums.slice(0, getItemsPerRow(150)).map(album => {
                const albumItemWidth = Math.floor((searchContainerWidth - (getItemsPerRow(150) - 1) * 16) / getItemsPerRow(150));
                return React.createElement('button', {
                  key: album.id,
                  onClick: () => {
                    saveSearchHistory(searchQuery, {
                      type: 'album',
                      id: album.id,
                      name: album.title,
                      artist: album['artist-credit']?.[0]?.name,
                      imageUrl: album.albumArt || null
                    });
                    handleAlbumClick(album);
                  },
                  onMouseEnter: () => {
                    // Prefetch album tracks on hover for context menu
                    prefetchSearchAlbumTracks(album);
                  },
                  className: 'text-left group cursor-grab active:cursor-grabbing transition-all duration-300 ease-out',
                  style: { width: albumItemWidth },
                  draggable: true,
                  onDragStart: (e) => {
                    e.dataTransfer.effectAllowed = 'copy';
                    e.dataTransfer.setData('text/plain', JSON.stringify({
                      type: 'album',
                      album: {
                        id: `${album['artist-credit']?.[0]?.name || 'unknown'}-${album.title || 'untitled'}`.toLowerCase().replace(/[^a-z0-9-]/g, ''),
                        title: album.title,
                        artist: album['artist-credit']?.[0]?.name || 'Unknown',
                        year: album['first-release-date']?.split('-')[0] ? parseInt(album['first-release-date'].split('-')[0]) : null,
                        art: null
                      }
                    }));
                  },
                  onContextMenu: (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (window.electron?.contextMenu?.showTrackMenu) {
                      const artistName = album['artist-credit']?.[0]?.name || 'Unknown';
                      const albumData = {
                        title: album.title,
                        artist: artistName,
                        year: album['first-release-date']?.split('-')[0] ? parseInt(album['first-release-date'].split('-')[0]) : null,
                        art: album.albumArt || null
                      };
                      // Check prefetched cache (use ref) and loading state (use module-level Set)
                      const prefetched = prefetchedReleasesRef.current[album.id];
                      const isLoading = prefetchInProgress.has(album.id);
                      window.electron.contextMenu.showTrackMenu({
                        type: 'release',
                        name: album.title,
                        album: albumData,
                        tracks: prefetched?.tracks || [],
                        loading: isLoading
                      });
                    }
                  }
                },
                  // Album art with rounded corners and hover effect (matches Critics Picks style)
                  React.createElement('div', { className: 'w-full aspect-square rounded-lg overflow-hidden mb-3 relative' },
                    // Shimmering skeleton (shows while waiting for albumArt or while image loads)
                    React.createElement('div', {
                      className: 'absolute inset-0 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                      style: { backgroundSize: '200% 100%' }
                    }),
                    // Image with fade-in (hides shimmer when loaded)
                    album.albumArt && React.createElement('img', {
                      src: album.albumArt,
                      alt: album.title,
                      className: 'absolute inset-0 w-full h-full object-cover group-hover:scale-105 transition-opacity duration-300',
                      style: { opacity: 0 },
                      ref: (el) => { if (el && el.complete && el.naturalWidth > 0) el.style.opacity = '1'; },
                      onLoad: (e) => { e.target.style.opacity = '1'; },
                      onError: (e) => {
                        // On error, show the fallback placeholder
                        e.target.style.display = 'none';
                        const fallback = e.target.nextElementSibling;
                        if (fallback) fallback.style.display = 'flex';
                      }
                    }),
                    // Fallback placeholder (hidden until image error)
                    album.albumArt && React.createElement('div', {
                      className: 'absolute inset-0 bg-gradient-to-br from-purple-500 to-pink-500 items-center justify-center text-white/60',
                      style: { display: 'none' }
                    },
                      React.createElement('svg', { className: 'w-16 h-16', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor', strokeWidth: 1 },
                        React.createElement('circle', { cx: 12, cy: 12, r: 10 }),
                        React.createElement('circle', { cx: 12, cy: 12, r: 3 }),
                        React.createElement('circle', { cx: 12, cy: 12, r: 6, strokeDasharray: '2 2' })
                      )
                    )
                  ),
                  // Album info
                  React.createElement('div', { className: 'text-sm font-medium text-gray-900 truncate' }, album.title),
                  React.createElement('div', { className: 'text-xs text-gray-500 truncate' },
                    `${album['artist-credit']?.[0]?.name || 'Unknown'} â€¢ ${album['first-release-date']?.split('-')[0] || ''}`
                  )
                );
              })
            )
          ),

          // Playlists section - single row with overflow hidden
          searchResults.playlists.length > 0 && React.createElement('div', null,
            React.createElement('div', { className: 'flex items-center justify-between mb-4' },
              React.createElement('h3', { className: 'text-xs font-semibold text-gray-400 uppercase tracking-wider' }, 'PLAYLISTS'),
              searchResults.playlists.length > 5 &&
                React.createElement('button', {
                  onClick: () => {
                    setSearchDetailCategory('playlists');
                    setSearchPreviewItem(searchResults.playlists[0] || null);
                  },
                  className: 'text-xs text-gray-500 hover:text-gray-700'
                }, 'Show more')
            ),
            React.createElement('div', {
              className: 'flex gap-4 overflow-hidden'
            },
              ...searchResults.playlists.slice(0, 20).map(playlist =>
                React.createElement('button', {
                  key: playlist.title,
                  onClick: () => {
                    saveSearchHistory(searchQuery, {
                      type: 'playlist',
                      id: playlist.id,
                      name: playlist.title,
                      imageUrl: null
                    });
                    handlePlaylistClick(playlist);
                  },
                  className: 'flex-shrink-0 text-left',
                  style: { width: '160px' }
                },
                  React.createElement('div', { className: 'text-sm font-medium text-gray-900 truncate' }, playlist.title),
                  React.createElement('div', { className: 'text-xs text-gray-500 truncate mt-1' },
                    `${playlist.tracks?.length || 0} tracks`
                  )
                )
              )
            )
          )
        )
        )
      )
    ) // end main view
    ) : // end activeView === 'search' ternary

      // Main content area - Artist Page (completely separate layout)
      activeView === 'artist' ? React.createElement('div', { 
        className: 'flex-1 flex flex-col',
        style: { overflow: 'hidden' }
      },
        // Artist page hero header (not inside scrollable area) - only show when NOT viewing or loading a release
        // Clickable to toggle collapse state
        !currentRelease && !loadingRelease && React.createElement('div', {
          className: 'relative',
          style: {
            height: isHeaderCollapsed ? '80px' : '320px',
            flexShrink: 0,
            transition: 'height 300ms ease-out',
            overflow: 'hidden',
            cursor: isHeaderCollapsed ? 'pointer' : 'default'
          },
        },
          // Clickable overlay to expand collapsed header (sits behind content)
          isHeaderCollapsed && React.createElement('div', {
            className: 'absolute inset-0 z-0',
            style: { cursor: 'pointer' },
            onClick: () => setIsHeaderCollapsed(false),
            title: 'Click to expand'
          }),
          // Background image with gradient overlay
          artistImage && React.createElement('div', {
            className: 'absolute inset-0',
            style: {
              backgroundImage: `url(${artistImage})`,
              backgroundSize: 'cover',
              backgroundPosition: artistImagePosition,
              filter: 'blur(0px)',
              pointerEvents: 'none'
            }
          }),
          // Gradient overlay for readability
          React.createElement('div', {
            className: 'absolute inset-0',
            style: {
              background: artistImage
                ? isHeaderCollapsed
                  ? 'linear-gradient(to bottom, rgba(0,0,0,0.7) 0%, rgba(17,17,17,0.95) 100%)'
                  : 'linear-gradient(to bottom, rgba(0,0,0,0.3) 0%, rgba(0,0,0,0.6) 50%, rgba(17,17,17,1) 100%)'
                : 'linear-gradient(to bottom, rgba(60,60,80,0.4) 0%, rgba(17,17,17,1) 100%)',
              pointerEvents: 'none'
            }
          }),
          // EXPANDED STATE - Artist info overlay (centered)
          !loadingRelease && currentArtist && !isHeaderCollapsed && React.createElement('div', {
            className: 'absolute inset-0 flex flex-col items-center justify-center text-center px-6 z-10',
            style: {
              opacity: isHeaderCollapsed ? 0 : 1,
              transition: 'opacity 300ms ease-out'
            }
          },
            React.createElement('h1', {
              className: 'text-5xl font-light text-white',
              style: {
                textShadow: '0 2px 20px rgba(0,0,0,0.5)',
                letterSpacing: '0.3em',
                textTransform: 'uppercase'
              }
            }, currentArtist.name),
            // Navigation tabs (centered)
            React.createElement('div', {
              className: 'flex items-center gap-1 mt-6',
              style: { textShadow: '0 1px 10px rgba(0,0,0,0.5)' }
            },
              ['music', 'biography', 'related'].map((tab, index) => [
                index > 0 && React.createElement('span', {
                  key: `sep-${tab}`,
                  className: 'text-gray-400 mx-2'
                }, '|'),
                React.createElement('button', {
                  key: tab,
                  onClick: async () => {
                    setArtistPageTab(tab);
                    // Lazy load data when tab is first clicked
                    if (tab === 'biography' && !artistBio && !loadingBio && currentArtist) {
                      const bioData = await getArtistBio(currentArtist.name, currentArtist.mbid);
                      setArtistBio(bioData);
                    }
                    if (tab === 'related' && relatedArtists.length === 0 && currentArtist) {
                      const related = await getRelatedArtists(currentArtist.name, currentArtist.mbid);
                      if (related.length > 0) { setRelatedArtists(related); resolveRelatedArtistImages(related); }
                    }
                  },
                  className: `px-2 py-1 text-sm font-medium uppercase tracking-wider transition-colors no-drag ${
                    artistPageTab === tab
                      ? 'text-white'
                      : 'text-gray-400 hover:text-white'
                  }`
                }, tab === 'related' ? 'Related Artists' : tab.charAt(0).toUpperCase() + tab.slice(1))
              ]).flat().filter(Boolean)
            ),
            // Start Artist Station button - responsive sizing
            React.createElement('button', {
              onClick: () => console.log('Start Artist Station - placeholder'),
              className: `mt-6 rounded-full font-medium text-white no-drag transition-all hover:scale-105 ${isCompactHeader ? 'px-4 py-1.5 text-sm' : 'px-6 py-2'}`,
              style: {
                backgroundColor: '#E91E63',
                boxShadow: '0 4px 15px rgba(233, 30, 99, 0.4)'
              }
            }, isCompactHeader ? 'Station' : 'Start Artist Station')
          ),
          // COLLAPSED STATE - Inline layout
          !loadingRelease && currentArtist && isHeaderCollapsed && React.createElement('div', {
            className: 'absolute inset-0 flex items-center px-16 z-10',
            style: {
              opacity: isHeaderCollapsed ? 1 : 0,
              transition: 'opacity 300ms ease-out'
            }
          },
            // Left side: Artist name - clickable to expand header
            React.createElement('h1', {
              className: 'text-2xl font-light mr-6 text-white flex-shrink-0 cursor-pointer hover:text-purple-300 transition-colors no-drag',
              style: {
                textShadow: '0 2px 10px rgba(0,0,0,0.5)',
                letterSpacing: '0.2em',
                textTransform: 'uppercase',
                maxWidth: '40%',
                lineHeight: '1.2'
              },
              onClick: () => setIsHeaderCollapsed(false),
              title: 'Click to expand'
            }, currentArtist.name),
            // Center: Navigation tabs
            React.createElement('div', {
              className: 'flex items-center gap-1',
              style: { textShadow: '0 1px 10px rgba(0,0,0,0.5)' }
            },
              ['music', 'biography', 'related'].map((tab, index) => [
                index > 0 && React.createElement('span', {
                  key: `sep-collapsed-${tab}`,
                  className: 'text-gray-400 mx-2'
                }, '|'),
                React.createElement('button', {
                  key: `collapsed-${tab}`,
                  onClick: async () => {
                    setArtistPageTab(tab);
                    if (tab === 'biography' && !artistBio && !loadingBio && currentArtist) {
                      const bioData = await getArtistBio(currentArtist.name, currentArtist.mbid);
                      setArtistBio(bioData);
                    }
                    if (tab === 'related' && relatedArtists.length === 0 && currentArtist) {
                      const related = await getRelatedArtists(currentArtist.name, currentArtist.mbid);
                      if (related.length > 0) { setRelatedArtists(related); resolveRelatedArtistImages(related); }
                    }
                  },
                  className: `px-2 py-1 text-sm font-medium uppercase tracking-wider transition-colors no-drag ${
                    artistPageTab === tab
                      ? 'text-white'
                      : 'text-gray-400 hover:text-white'
                  }`
                }, tab === 'related' ? 'Related Artists' : tab.charAt(0).toUpperCase() + tab.slice(1))
              ]).flat().filter(Boolean)
            ),
            // Right side: Start Artist Station button - responsive sizing
            React.createElement('button', {
              onClick: () => console.log('Start Artist Station - placeholder'),
              className: `ml-auto rounded-full font-medium text-white no-drag transition-all hover:scale-105 ${isCompactHeader ? 'px-3 py-1.5 text-xs' : 'px-5 py-2 text-sm'}`,
              style: {
                backgroundColor: '#E91E63',
                boxShadow: '0 4px 15px rgba(233, 30, 99, 0.4)'
              }
            }, isCompactHeader ? 'Station' : 'Start Artist Station')
          )
        ),
        
        // Loading state for release - show real header (already loaded), skeleton for content only
        loadingRelease && React.createElement('div', {
          className: 'flex-1 flex flex-col',
          style: { backgroundColor: 'white' }
        },
          // Real header with artist image (already loaded)
          React.createElement('div', {
            className: 'relative',
            style: { height: '80px', flexShrink: 0, overflow: 'hidden' }
          },
            // Background image
            artistImage && React.createElement('div', {
              className: 'absolute inset-0',
              style: {
                backgroundImage: `url(${artistImage})`,
                backgroundSize: 'cover',
                backgroundPosition: artistImagePosition
              }
            }),
            // Gradient overlay
            React.createElement('div', {
              className: 'absolute inset-0',
              style: {
                background: artistImage
                  ? 'linear-gradient(to bottom, rgba(0,0,0,0.5) 0%, rgba(17,17,17,0.95) 100%)'
                  : 'linear-gradient(to bottom, rgba(60,60,80,0.4) 0%, rgba(17,17,17,1) 100%)'
              }
            }),
            // Artist info overlay (matching collapsed artist header)
            React.createElement('div', {
              className: 'absolute inset-0 flex items-center px-16 z-10'
            },
              // Left side: Artist name
              React.createElement('h1', {
                className: 'text-2xl font-light mr-6 text-white flex-shrink-0',
                style: {
                  textShadow: '0 2px 10px rgba(0,0,0,0.5)',
                  letterSpacing: '0.2em',
                  textTransform: 'uppercase',
                  maxWidth: '40%',
                  lineHeight: '1.2'
                }
              }, currentArtist?.name || ''),
              // Center: Navigation tabs
              React.createElement('div', {
                className: 'flex items-center gap-1',
                style: { textShadow: '0 1px 10px rgba(0,0,0,0.5)' }
              },
                ['music', 'biography', 'related'].map((tab, index) => [
                  index > 0 && React.createElement('span', {
                    key: `sep-loading-${tab}`,
                    className: 'text-gray-400 mx-2'
                  }, '|'),
                  React.createElement('span', {
                    key: `loading-${tab}`,
                    className: `px-2 py-1 text-sm font-medium uppercase tracking-wider ${
                      tab === 'music' ? 'text-white' : 'text-gray-400'
                    }`
                  }, tab === 'related' ? 'Related Artists' : tab.charAt(0).toUpperCase() + tab.slice(1))
                ]).flat().filter(Boolean)
              ),
              // Right side: Start Album Station button - responsive sizing
              React.createElement('button', {
                className: `ml-auto rounded-full font-medium text-white no-drag transition-all hover:scale-105 ${isCompactHeader ? 'px-3 py-1.5 text-xs' : 'px-5 py-2 text-sm'}`,
                style: {
                  backgroundColor: '#E91E63',
                  boxShadow: '0 4px 15px rgba(233, 30, 99, 0.4)'
                }
              }, isCompactHeader ? 'Station' : 'Start Album Station')
            )
          ),
          // Skeleton content with white background (matching release page)
          React.createElement('div', { className: 'bg-white flex-1' },
            // ALBUM DETAILS header with breadcrumb (artist name known, album loading)
            React.createElement('div', {
              className: 'flex items-center justify-between px-6 py-4 border-b border-gray-200'
            },
              // Breadcrumb navigation: Artist Name > Loading...
              React.createElement('div', {
                className: 'flex items-center gap-2 text-xs font-medium tracking-widest uppercase'
              },
                React.createElement('button', {
                  onClick: () => {
                    setCurrentRelease(null);
                  },
                  className: 'text-gray-400 hover:text-gray-600 transition-colors uppercase'
                }, currentArtist?.name || 'Artist'),
                React.createElement('span', { className: 'text-gray-300' }, '/'),
React.createElement('div', {
                  className: 'h-3 w-24 rounded bg-gradient-to-r from-gray-300 via-gray-200 to-gray-300 animate-shimmer',
                  style: { backgroundSize: '200% 100%' }
                })
              ),
              React.createElement('div')
            ),
            // Two-column layout matching ReleasePage
            React.createElement('div', { className: 'flex gap-0 p-6' },
              // Left column - album art skeleton (matches ReleasePage: width 240px, pr-8)
              React.createElement('div', {
                className: 'flex-shrink-0 pr-8',
                style: { width: '240px' }
              },
                // Album art (w-48 h-48 = 192px)
                React.createElement('div', {
                  className: 'w-48 h-48 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                  style: { backgroundSize: '200% 100%' }
                }),
                // Metadata below art
                React.createElement('div', { className: 'mt-4 space-y-1' },
                  React.createElement('div', {
                    className: 'h-5 rounded w-3/4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                    style: { backgroundSize: '200% 100%' }
                  }),
                  React.createElement('div', {
                    className: 'h-4 rounded w-1/2 mt-1 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                    style: { backgroundSize: '200% 100%' }
                  }),
                  React.createElement('div', {
                    className: 'h-4 rounded w-1/3 mt-1 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                    style: { backgroundSize: '200% 100%' }
                  })
                )
              ),
              // Right column - track list skeleton
              React.createElement('div', { className: 'flex-1 min-w-0 space-y-0' },
                [75, 60, 85, 55, 70, 80, 50, 65, 90, 58].map((width, i) =>
                  React.createElement('div', {
                    key: `track-skeleton-${i}`,
                    className: 'flex items-center gap-4 py-3 px-2',
                    style: { backgroundColor: i % 2 === 0 ? '#fafafa' : 'transparent' }
                  },
                    // Track number
                    React.createElement('div', {
                      className: 'w-6 h-4 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                      style: { backgroundSize: '200% 100%' }
                    }),
                    // Track title
                    React.createElement('div', { className: 'flex-1' },
                      React.createElement('div', {
                        className: 'h-4 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                        style: { width: `${width}%`, backgroundSize: '200% 100%' }
                      })
                    ),
                    // Duration
                    React.createElement('div', {
                      className: 'w-10 h-4 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                      style: { backgroundSize: '200% 100%' }
                    })
                  )
                )
              )
            )
          )
        ),
        
        // Release page - artist header (shows artist image/name/tabs at top)
        !loadingRelease && currentRelease && React.createElement('div', {
          className: 'relative',
          style: {
            height: '80px',
            flexShrink: 0,
            overflow: 'hidden'
          }
        },
          // Background image with gradient overlay
          artistImage && React.createElement('div', {
            className: 'absolute inset-0',
            style: {
              backgroundImage: `url(${artistImage})`,
              backgroundSize: 'cover',
              backgroundPosition: artistImagePosition,
              filter: 'blur(0px)'
            }
          }),
          // Gradient overlay for readability
          React.createElement('div', {
            className: 'absolute inset-0',
            style: {
              background: artistImage
                ? 'linear-gradient(to bottom, rgba(0,0,0,0.5) 0%, rgba(17,17,17,0.95) 100%)'
                : 'linear-gradient(to bottom, rgba(60,60,80,0.4) 0%, rgba(17,17,17,1) 100%)'
            }
          }),
          // Artist info overlay (inline layout for release page - matches collapsed artist header)
          React.createElement('div', {
            className: 'absolute inset-0 flex items-center px-16 z-10'
          },
            // Left side: Artist name
            React.createElement('h1', {
              className: 'text-2xl font-light mr-6 text-white cursor-pointer hover:text-purple-300 transition-colors no-drag flex-shrink-0',
              style: {
                textShadow: '0 2px 10px rgba(0,0,0,0.5)',
                letterSpacing: '0.2em',
                textTransform: 'uppercase',
                maxWidth: '40%',
                lineHeight: '1.2'
              },
              onClick: () => {
                const artistName = currentRelease?.artist?.name || currentArtist?.name;
                setCurrentRelease(null);
                // Ensure full artist data is loaded
                if (artistName && artistReleases.length === 0) {
                  fetchArtistData(artistName);
                }
              },
              title: 'Back to artist'
            }, currentRelease.artist?.name || currentArtist?.name),
            // Center: Navigation tabs
            React.createElement('div', {
              className: 'flex items-center gap-1',
              style: { textShadow: '0 1px 10px rgba(0,0,0,0.5)' }
            },
              ['music', 'biography', 'related'].map((tab, index) => [
                index > 0 && React.createElement('span', {
                  key: `sep-release-${tab}`,
                  className: 'text-gray-400 mx-2'
                }, '|'),
                React.createElement('button', {
                  key: `release-${tab}`,
                  onClick: async () => {
                    // Go back to artist page and switch to the selected tab
                    const artistName = currentRelease?.artist?.name || currentArtist?.name;
                    setCurrentRelease(null);
                    setArtistPageTab(tab);
                    // Ensure full artist data is loaded if navigating to music tab
                    if (tab === 'music' && artistName && artistReleases.length === 0) {
                      fetchArtistData(artistName);
                    }
                    if (tab === 'biography' && !artistBio && !loadingBio && artistName) {
                      // Ensure artist data is loaded first
                      if (artistReleases.length === 0) {
                        fetchArtistData(artistName);
                      }
                      const bioData = await getArtistBio(artistName, currentArtist?.mbid);
                      setArtistBio(bioData);
                    }
                    if (tab === 'related' && relatedArtists.length === 0 && artistName) {
                      // Ensure artist data is loaded first
                      if (artistReleases.length === 0) {
                        fetchArtistData(artistName);
                      }
                      const related = await getRelatedArtists(artistName, currentArtist?.mbid);
                      if (related.length > 0) { setRelatedArtists(related); resolveRelatedArtistImages(related); }
                    }
                  },
                  className: `px-2 py-1 text-sm font-medium uppercase tracking-wider transition-colors no-drag ${
                    tab === 'music'
                      ? 'text-white'
                      : 'text-gray-400 hover:text-white'
                  }`
                }, tab === 'related' ? 'Related Artists' : tab.charAt(0).toUpperCase() + tab.slice(1))
              ]).flat().filter(Boolean)
            ),
            // Right side: Start Album Station button - responsive sizing
            React.createElement('button', {
              onClick: () => console.log('Start Album Station - placeholder'),
              className: `ml-auto rounded-full font-medium text-white no-drag transition-all hover:scale-105 ${isCompactHeader ? 'px-3 py-1.5 text-xs' : 'px-5 py-2 text-sm'}`,
              style: {
                backgroundColor: '#E91E63',
                boxShadow: '0 4px 15px rgba(233, 30, 99, 0.4)'
              }
            }, isCompactHeader ? 'Station' : 'Start Album Station')
          )
        ),

        // Release page content (scrollable) - new layout with album details header
        !loadingRelease && currentRelease && React.createElement('div', {
          className: 'scrollable-content bg-white',
          style: {
            flex: 1,
            overflowY: 'scroll',
            pointerEvents: 'auto'
          }
        },
          // ALBUM DETAILS section header with breadcrumb
          React.createElement('div', {
            className: 'flex items-center justify-between px-6 py-4 border-b border-gray-200'
          },
            // Breadcrumb navigation: Artist Name > Album Name
            React.createElement('div', {
              className: 'flex items-center gap-2 text-xs font-medium tracking-widest uppercase'
            },
              React.createElement('button', {
                onClick: () => {
                  // Clear the release view to go back to artist
                  setCurrentRelease(null);
                  // If artist releases aren't loaded, fetch full artist data
                  const artistName = currentRelease?.artist?.name || currentArtist?.name;
                  if (artistName && artistReleases.length === 0) {
                    fetchArtistData(artistName);
                  }
                },
                className: 'text-gray-400 hover:text-gray-600 transition-colors uppercase'
              }, currentArtist?.name || currentRelease?.artist?.name || 'Artist'),
              React.createElement('span', { className: 'text-gray-300' }, '/'),
              React.createElement('span', { className: 'text-gray-600 uppercase' },
                currentRelease?.title || 'Album Details'
              )
            ),
            // Empty div to maintain layout (no close button needed with breadcrumb)
            React.createElement('div')
          ),
          // Two-column layout: album art + metadata on left, tracklist on right
          React.createElement(ReleasePage, {
            release: currentRelease,
            handleSearch: handleSearchInput,
            handlePlay: handlePlay,
            onTrackPlay: (track, tracksAfter) => {
              // Set queue with remaining tracks from the album, then play
              const context = { type: 'album', id: currentRelease?.id, name: currentRelease?.title, artist: currentRelease?.artist?.name };
              // Tag the current track with context too
              const taggedTrack = { ...track, _playbackContext: context };
              setQueueWithContext(tracksAfter, context);
              handlePlay(taggedTrack);
            },
            onTrackContextMenu: (track) => {
              if (window.electron?.contextMenu?.showTrackMenu) {
                window.electron.contextMenu.showTrackMenu({
                  type: 'track',
                  track: track
                });
              }
            },
            trackSources: trackSources,
            resolvers: resolvers,
            // Now playing props
            currentTrack: currentTrack,
            playbackContext: playbackContext,
            isPlaying: isPlaying,
            // Drag and drop handlers for adding tracks to playlists
            onDragStart: (track) => {
              setDraggingTrackForPlaylist(track);
            },
            onDragEnd: () => {
              setDraggingTrackForPlaylist(null);
              setDropTargetPlaylistId(null);
              setDropTargetNewPlaylist(false);
              // Close panel if it was opened by drag and nothing was dropped
              if (addToPlaylistPanel.open && selectedPlaylistsForAdd.length === 0) {
                setAddToPlaylistPanel(prev => ({ ...prev, open: false }));
              }
            }
          })
        ),
        
        // Skeleton loading state for artist - only show before currentArtist is set
        !currentRelease && !loadingRelease && loadingArtist && !currentArtist && React.createElement('div', {
          className: 'flex-1'
        },
          // Skeleton header area with shimmer
          React.createElement('div', {
            className: 'relative h-48 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
            style: { backgroundSize: '200% 100%' }
          }),
          // Skeleton content
          React.createElement('div', { className: 'p-6' },
            // Skeleton filter buttons
            React.createElement('div', { className: 'flex gap-2 mb-4' },
              Array.from({ length: 4 }).map((_, i) =>
                React.createElement('div', {
                  key: `filter-skeleton-${i}`,
                  className: 'h-10 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded-full animate-shimmer',
                  style: { width: `${80 + i * 15}px`, backgroundSize: '200% 100%', animationDelay: `${i * 100}ms` }
                })
              )
            ),
            // Skeleton release count
            React.createElement('div', {
              className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-24 mb-6 animate-shimmer',
              style: { backgroundSize: '200% 100%' }
            }),
            // Skeleton album grid
            React.createElement('div', {
              className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4'
            },
              Array.from({ length: 10 }).map((_, i) =>
                React.createElement('div', { key: `album-skeleton-${i}` },
                  React.createElement('div', {
                    className: 'aspect-square bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded-lg mb-3 animate-shimmer',
                    style: { backgroundSize: '200% 100%', animationDelay: `${i * 50}ms` }
                  }),
                  React.createElement('div', {
                    className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-3/4 mb-2 animate-shimmer',
                    style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 25}ms` }
                  }),
                  React.createElement('div', {
                    className: 'h-3 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-1/2 animate-shimmer',
                    style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 50}ms` }
                  })
                )
              )
            )
          )
        ),
        
        // Artist content (scrollable) - show when we have artist data (even while releases are loading)
        !currentRelease && !loadingRelease && currentArtist && React.createElement('div', {
          ref: artistPageScrollRef,
          className: 'scrollable-content',
          style: {
            flex: 1,
            overflowY: 'scroll',
            pointerEvents: 'auto'
          },
          onScroll: handleArtistPageScroll
        },
          // Sticky filter bar (Music tab only)
          artistPageTab === 'music' && React.createElement('div', {
            className: 'sticky top-0 z-10 flex items-center px-6 py-3 bg-white border-b border-gray-200'
          },
            // Release type filter pills
            React.createElement('div', { className: 'flex gap-2 flex-wrap' },
              [
                { value: 'album', label: 'Studio Albums' },
                { value: 'ep', label: 'EPs' },
                { value: 'single', label: 'Singles' },
                { value: 'live', label: 'Live' },
                { value: 'compilation', label: 'Compilations' },
                { value: 'all', label: 'All' }
              ].map(({ value, label }) => {
                const searchFiltered = filterArtistReleases(artistReleases);
                const count = value === 'all'
                  ? searchFiltered.length
                  : searchFiltered.filter(r => r.releaseType === value).length;

                // While loading, show all filter types; otherwise hide those with 0 count (except 'all')
                if (!loadingArtist && count === 0 && value !== 'all') return null;

                return React.createElement('button', {
                  key: value,
                  onClick: () => setReleaseTypeFilter(value),
                  className: `px-3 py-1.5 rounded-full text-sm transition-all no-drag ${
                    releaseTypeFilter === value
                      ? 'bg-purple-600 text-white'
                      : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                  }`,
                }, loadingArtist ? label : `${label} (${count})`);
              })
            ),
            // Spacer
            React.createElement('div', { className: 'flex-1' }),
            // Sort dropdown
            React.createElement('div', { className: 'relative mr-3' },
              React.createElement('button', {
                onClick: (e) => { e.stopPropagation(); setArtistSortDropdownOpen(!artistSortDropdownOpen); },
                className: 'flex items-center gap-1 px-3 py-1.5 text-sm text-gray-500 hover:text-gray-700 transition-colors'
              },
                React.createElement('span', null, artistSortOptions.find(o => o.value === artistSort)?.label || 'Sort'),
                React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                  React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M19 9l-7 7-7-7' })
                )
              ),
              // Dropdown menu
              artistSortDropdownOpen && React.createElement('div', {
                className: 'absolute right-0 top-full mt-1 bg-white rounded-lg shadow-lg py-1 min-w-[160px] z-30 border border-gray-200'
              },
                artistSortOptions.map(option =>
                  React.createElement('button', {
                    key: option.value,
                    onClick: (e) => {
                      e.stopPropagation();
                      setArtistSort(option.value);
                      setArtistSortDropdownOpen(false);
                    },
                    className: `w-full px-4 py-2 text-left text-sm hover:bg-gray-100 flex items-center justify-between ${
                      artistSort === option.value ? 'text-gray-900 font-medium' : 'text-gray-600'
                    }`
                  },
                    option.label,
                    artistSort === option.value && React.createElement('svg', {
                      className: 'w-4 h-4',
                      fill: 'none',
                      viewBox: '0 0 24 24',
                      stroke: 'currentColor'
                    },
                      React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M5 13l4 4L19 7' })
                    )
                  )
                )
              )
            ),
            // Search toggle/field
            React.createElement('div', { className: 'flex items-center' },
              artistSearchOpen ?
                React.createElement('div', { className: 'flex items-center border border-gray-300 rounded-full px-3 py-1.5' },
                  React.createElement('input', {
                    type: 'text',
                    value: artistSearch,
                    onChange: (e) => setArtistSearch(e.target.value),
                    onBlur: () => {
                      if (!artistSearch.trim()) {
                        setArtistSearchOpen(false);
                      }
                    },
                    autoFocus: true,
                    placeholder: 'Filter...',
                    className: 'bg-transparent text-gray-700 text-sm placeholder-gray-400 outline-none',
                    style: { width: '150px' }
                  }),
                  artistSearch && React.createElement('button', {
                    onClick: () => {
                      setArtistSearch('');
                      setArtistSearchOpen(false);
                    },
                    className: 'ml-2 text-gray-400 hover:text-gray-600'
                  },
                    React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                      React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M6 18L18 6M6 6l12 12' })
                    )
                  )
                )
              :
                React.createElement('button', {
                  onClick: () => setArtistSearchOpen(true),
                  className: 'p-1.5 text-gray-400 hover:text-gray-600 transition-colors'
                },
                  React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' })
                  )
                )
            )
          ),
          // MUSIC TAB - Discography
          artistPageTab === 'music' && React.createElement('div', {
            className: 'space-y-6 p-6'
          },
            // Loading skeletons for discography
            loadingArtist && React.createElement('div', {
              className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4 pb-6'
            },
              Array.from({ length: 10 }).map((_, i) =>
                React.createElement('div', { key: `album-skeleton-${i}` },
                  React.createElement('div', {
                    className: 'aspect-square bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded-lg mb-3 animate-shimmer',
                    style: { backgroundSize: '200% 100%', animationDelay: `${i * 50}ms` }
                  }),
                  React.createElement('div', {
                    className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-3/4 mb-2 animate-shimmer',
                    style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 25}ms` }
                  }),
                  React.createElement('div', {
                    className: 'h-3 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-1/2 animate-shimmer',
                    style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 50}ms` }
                  })
                )
              )
            ),
            // Discography grid (when loaded)
            !loadingArtist && React.createElement('div', {
              className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4 pb-6'
            },
              sortArtistReleases(filterArtistReleases(artistReleases)).map(release =>
                React.createElement(ReleaseCard, {
                  key: release.id,
                  release: release,
                  currentArtist: currentArtist,
                  fetchReleaseData: fetchReleaseData,
                  onHoverFetch: (rel) => {
                    // Prefetch release tracks on hover for context menu
                    prefetchReleaseTracks(rel, currentArtist);
                  },
                  onContextMenu: async (rel) => {
                    // For releases, show context menu with tracks
                    if (window.electron?.contextMenu?.showTrackMenu) {
                      const albumData = {
                        title: rel.title,
                        artist: currentArtist?.name,
                        year: rel.date?.split('-')[0] ? parseInt(rel.date.split('-')[0]) : null,
                        art: rel.albumArt
                      };
                      // Check prefetched cache first (use ref to avoid stale closure)
                      const prefetched = prefetchedReleasesRef.current[rel.id];
                      if (prefetched?.tracks?.length > 0) {
                        window.electron.contextMenu.showTrackMenu({
                          type: 'release',
                          name: rel.title,
                          album: albumData,
                          tracks: prefetched.tracks
                        });
                      } else if (currentRelease?.id === rel.id && currentRelease?.tracks?.length > 0) {
                        // Use already loaded tracks from current release
                        const tracks = currentRelease.tracks.map(t => {
                          const trackId = `${currentArtist?.name || 'unknown'}-${t.title || 'untitled'}-${rel.title || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
                          return {
                            ...t,
                            id: trackId,
                            artist: currentArtist?.name,
                            album: rel.title,
                            albumArt: rel.albumArt,
                            sources: trackSources[`${t.position}-${t.title}`] || {}
                          };
                        });
                        window.electron.contextMenu.showTrackMenu({
                          type: 'release',
                          name: rel.title,
                          album: albumData,
                          tracks: tracks
                        });
                      } else {
                        // No tracks available yet - show with 0 tracks
                        window.electron.contextMenu.showTrackMenu({
                          type: 'release',
                          name: rel.title,
                          album: albumData,
                          releaseId: rel.id,
                          artist: currentArtist?.name,
                          albumArt: rel.albumArt,
                          tracks: []
                        });
                      }
                    }
                  },
                  isVisible: (releaseTypeFilter === 'all' || release.releaseType === releaseTypeFilter) &&
                    (!artistSearch.trim() || release.title.toLowerCase().includes(artistSearch.toLowerCase()))
                })
              )
            ),

            // Empty state (only show when not loading)
            !loadingArtist && (() => {
              const filtered = sortArtistReleases(filterArtistReleases(artistReleases));
              const typeFiltered = filtered.filter(r => releaseTypeFilter === 'all' || r.releaseType === releaseTypeFilter);
              if (typeFiltered.length === 0) {
                const typeLabels = {
                  all: '',
                  album: 'studio albums',
                  live: 'live albums',
                  compilation: 'compilations',
                  ep: 'EPs',
                  single: 'singles'
                };
                return React.createElement('div', { className: 'text-center py-12 text-gray-400' },
                  artistSearch.trim()
                    ? `No releases matching "${artistSearch}"`
                    : `No ${typeLabels[releaseTypeFilter] || releaseTypeFilter} found`
                );
              }
              return null;
            })()
          ),

          // BIOGRAPHY TAB
          artistPageTab === 'biography' && React.createElement('div', {
            className: 'max-w-3xl mx-auto p-6'
          },
            // Loading state - skeleton paragraphs
            loadingBio && React.createElement('div', { className: 'space-y-4' },
              // First paragraph skeleton (longer)
              React.createElement('div', { className: 'space-y-2' },
                React.createElement('div', { className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer w-full', style: { backgroundSize: '200% 100%' } }),
                React.createElement('div', { className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer w-full', style: { backgroundSize: '200% 100%', animationDelay: '50ms' } }),
                React.createElement('div', { className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer w-11/12', style: { backgroundSize: '200% 100%', animationDelay: '100ms' } }),
                React.createElement('div', { className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer w-4/5', style: { backgroundSize: '200% 100%', animationDelay: '150ms' } })
              ),
              // Second paragraph skeleton
              React.createElement('div', { className: 'space-y-2' },
                React.createElement('div', { className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer w-full', style: { backgroundSize: '200% 100%', animationDelay: '200ms' } }),
                React.createElement('div', { className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer w-full', style: { backgroundSize: '200% 100%', animationDelay: '250ms' } }),
                React.createElement('div', { className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer w-3/4', style: { backgroundSize: '200% 100%', animationDelay: '300ms' } })
              ),
              // Third paragraph skeleton (shorter)
              React.createElement('div', { className: 'space-y-2' },
                React.createElement('div', { className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer w-full', style: { backgroundSize: '200% 100%', animationDelay: '350ms' } }),
                React.createElement('div', { className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer w-2/3', style: { backgroundSize: '200% 100%', animationDelay: '400ms' } })
              )
            ),
            // Bio content
            !loadingBio && artistBio && React.createElement('div', { className: 'space-y-4' },
              React.createElement('div', {
                className: 'text-sm text-gray-700 leading-relaxed whitespace-pre-wrap'
              }, artistBio.bio),
              // Source attribution and link
              React.createElement('div', { className: 'flex items-center gap-2 mt-4' },
                React.createElement('span', {
                  className: 'text-xs text-gray-400'
                }, `From ${artistBio.source === 'wikipedia' ? 'Wikipedia' : artistBio.source === 'discogs' ? 'Discogs' : 'Last.fm'}`),
                artistBio.url && React.createElement('a', {
                  href: artistBio.url,
                  target: '_blank',
                  rel: 'noopener noreferrer',
                  className: 'text-purple-600 hover:text-purple-700 text-sm'
                }, 'Read more â†’')
              )
            ),
            // No bio found
            !loadingBio && !artistBio && React.createElement('div', {
              className: 'text-center py-12 text-gray-400'
            }, 'No biography available for this artist.')
          ),

          // RELATED ARTISTS TAB
          artistPageTab === 'related' && (() => {
            // Compute source counts for filter pills
            const listenbrainzCount = relatedArtists.filter(a => a.source === 'listenbrainz').length;
            const lastfmCount = relatedArtists.filter(a => a.source === 'lastfm').length;
            const bothCount = relatedArtists.filter(a => a.source === 'both').length;
            // Show filter bar when both services have data OR when configured (MBID available for ListenBrainz, API key for Last.fm)
            const hasBothServicesConfigured = !!currentArtist?.mbid && !!lastfmApiKey.current;

            // Filter artists based on source filter
            const filteredArtists = relatedArtistsSourceFilter === 'all'
              ? relatedArtists
              : relatedArtists.filter(a =>
                  relatedArtistsSourceFilter === 'both'
                    ? a.source === 'both'
                    : a.source === relatedArtistsSourceFilter || a.source === 'both'
                );

            return React.createElement('div', null,
              // Sticky filter bar - show when both services are configured
              hasBothServicesConfigured && React.createElement('div', {
                className: 'sticky top-0 z-10 flex items-center px-6 py-3 bg-white border-b border-gray-200'
              },
                React.createElement('div', { className: 'flex gap-2' },
                  [
                    { value: 'all', label: 'All', count: relatedArtists.length },
                    { value: 'listenbrainz', label: 'ListenBrainz', count: listenbrainzCount + bothCount },
                    { value: 'lastfm', label: 'Last.fm', count: lastfmCount + bothCount },
                    { value: 'both', label: 'Both', count: bothCount }
                  ].filter(({ value, count }) => value === 'all' || count > 0).map(({ value, label, count }) =>
                    React.createElement('button', {
                      key: value,
                      onClick: () => setRelatedArtistsSourceFilter(value),
                      className: `px-3 py-1.5 rounded-full text-sm transition-all no-drag ${
                        relatedArtistsSourceFilter === value
                          ? value === 'listenbrainz' ? 'bg-orange-500 text-white'
                            : value === 'lastfm' ? 'bg-red-600 text-white'
                            : value === 'both' ? 'bg-gradient-to-r from-orange-500 to-red-600 text-white'
                            : 'bg-purple-600 text-white'
                          : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                      }`
                    }, loadingRelated ? label : `${label} (${count})`)
                  )
                )
              ),
              // Content with padding
              React.createElement('div', { className: 'p-6' },
                // Loading state - skeleton grid with staggered shimmer animation
                loadingRelated && React.createElement('div', {
                  className: 'grid gap-x-4 gap-y-8',
                  style: { gridTemplateColumns: 'repeat(auto-fill, minmax(160px, 1fr))' }
                },
                  Array.from({ length: 12 }).map((_, i) =>
                    React.createElement('div', { key: `skeleton-${i}`, className: 'flex flex-col items-center' },
                      React.createElement('div', {
                        className: 'w-36 h-36 rounded-full bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                        style: { backgroundSize: '200% 100%', animationDelay: `${i * 50}ms` }
                      }),
                      React.createElement('div', {
                        className: 'w-24 h-4 mt-3 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer rounded',
                        style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 25}ms` }
                      })
                    )
                  )
                ),
                // Related artists grid (sorted by match, highest first) - matching Top Artists style
                !loadingRelated && filteredArtists.length > 0 && React.createElement('div', {
                  className: 'grid gap-x-4 gap-y-8',
                  style: { gridTemplateColumns: 'repeat(auto-fill, minmax(160px, 1fr))' }
                },
                  [...filteredArtists].sort((a, b) => b.match - a.match).map((artist) =>
                    React.createElement('div', {
                      key: artist.name,
                      className: 'flex flex-col items-center cursor-grab active:cursor-grabbing group',
                      draggable: true,
                      onDragStart: (e) => {
                        e.dataTransfer.effectAllowed = 'copy';
                        e.dataTransfer.setData('text/plain', JSON.stringify({
                          type: 'artist',
                          artist: {
                            id: artist.name.toLowerCase().replace(/[^a-z0-9]/g, '-'),
                            name: artist.name,
                            image: artist.image
                          }
                        }));
                      },
                      onClick: () => fetchArtistData(artist.name),
                      onContextMenu: (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        if (window.electron?.contextMenu?.showTrackMenu) {
                          window.electron.contextMenu.showTrackMenu({
                            type: 'artist',
                            artist: {
                              id: artist.name.toLowerCase().replace(/[^a-z0-9]/g, '-'),
                              name: artist.name,
                              image: artist.image
                            }
                          });
                        }
                      }
                    },
                      React.createElement('div', {
                        className: 'relative w-36 h-36 rounded-full overflow-hidden'
                      },
                        React.createElement('div', {
                          className: `w-full h-full group-hover:scale-110 transition-transform duration-300 ${
                            artist.image ? '' : !artist.imageLoaded ? 'bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer' : 'bg-gradient-to-br from-purple-500 to-pink-500'
                          }`,
                          style: artist.image ? {
                            backgroundImage: `url(${artist.image})`,
                            backgroundSize: 'cover',
                            backgroundPosition: 'center'
                          } : !artist.imageLoaded ? {
                            backgroundSize: '200% 100%'
                          } : {}
                        })
                      ),
                      React.createElement('span', {
                        className: 'mt-3 text-sm font-medium text-gray-700 text-center truncate w-full group-hover:text-purple-600 transition-colors'
                      }, artist.name)
                    )
                  )
                ),
                // No related artists found (or filtered to none)
                !loadingRelated && filteredArtists.length === 0 && React.createElement('div', {
                  className: 'text-center py-12 text-gray-400'
                }, relatedArtists.length === 0
                  ? 'No related artists found.'
                  : `No artists from ${relatedArtistsSourceFilter === 'listenbrainz' ? 'ListenBrainz' : relatedArtistsSourceFilter === 'lastfm' ? 'Last.fm' : 'both sources'}.`
                )
              )
            );
          })()
        )
      )
      
      // Main content area - Playlist Page loading state (waiting for playlist to be resolved)
      : activeView === 'playlist-view' && !selectedPlaylist ? React.createElement('div', {
        className: 'flex-1 flex flex-col',
        style: { overflow: 'hidden' }
      },
        // Hero header with pending playlist title (real header, not skeleton)
        React.createElement('div', {
          className: 'relative',
          style: {
            height: '140px',
            flexShrink: 0,
            overflow: 'hidden'
          }
        },
          // Gradient background (same as loaded state)
          React.createElement('div', {
            className: 'absolute inset-0',
            style: {
              backgroundImage: 'linear-gradient(to bottom right, #f43f5e, #ec4899, #c026d3)',
              backgroundSize: 'cover',
              backgroundPosition: 'center',
              filter: 'blur(20px) brightness(0.7)',
              transform: 'scale(1.2)'
            }
          }),
          // Gradient overlay
          React.createElement('div', {
            className: 'absolute inset-0',
            style: {
              background: 'linear-gradient(to bottom, rgba(0,0,0,0.3) 0%, rgba(17,17,17,0.95) 100%)'
            }
          }),
          // Header content with title
          React.createElement('div', {
            className: 'absolute inset-0 flex items-center px-8 z-10'
          },
            // Playlist icon
            React.createElement('div', {
              className: 'w-6 h-6 rounded-full bg-white/20 flex items-center justify-center mr-3'
            },
              React.createElement('svg', { className: 'w-3 h-3 text-white', fill: 'currentColor', viewBox: '0 0 24 24' },
                React.createElement('circle', { cx: '12', cy: '12', r: '10' })
              )
            ),
            // Playlist name from pending load
            React.createElement('h1', {
              className: 'text-2xl font-bold text-white',
              style: {
                textShadow: '0 2px 10px rgba(0,0,0,0.5)',
                letterSpacing: '0.1em',
                textTransform: 'uppercase'
              }
            }, pendingPlaylistLoad?.title || 'Loading...')
          )
        ),
        // Content area with sticky bar and loading skeletons
        React.createElement('div', {
          className: 'scrollable-content bg-white',
          style: {
            flex: 1,
            overflowY: 'scroll',
            pointerEvents: 'auto'
          }
        },
          // PLAYLIST DETAILS sticky bar with breadcrumb (same as loaded state)
          React.createElement('div', {
            className: 'flex items-center justify-between px-6 py-4 border-b border-gray-200'
          },
            // Breadcrumb navigation: Playlists > Playlist Name
            React.createElement('div', {
              className: 'flex items-center gap-2 text-xs font-medium tracking-widest uppercase'
            },
              React.createElement('button', {
                onClick: () => {
                  setPendingPlaylistLoad(null);
                  setActiveView('playlists');
                  setViewHistory(['library', 'playlists']);
                },
                className: 'text-gray-400 hover:text-gray-600 transition-colors uppercase'
              }, 'Playlists'),
              React.createElement('span', { className: 'text-gray-300' }, '/'),
              React.createElement('span', { className: 'text-gray-600 uppercase' },
                pendingPlaylistLoad?.title || 'Loading'
              )
            ),
            // Close button
            React.createElement('button', {
              onClick: () => {
                setPendingPlaylistLoad(null);
                setActiveView('playlists');
                setViewHistory(['library', 'playlists']);
              },
              className: 'flex items-center gap-1 px-3 py-1 text-xs text-gray-500 hover:text-gray-700 border border-gray-300 rounded hover:bg-gray-50 transition-colors no-drag'
            },
              'CLOSE',
              React.createElement('span', { className: 'text-gray-400' }, 'Ã—')
            )
          ),
          // Loading content placeholder
          React.createElement('div', { className: 'flex gap-0 p-6' },
            // LEFT COLUMN: Skeleton album art and metadata
            React.createElement('div', {
              className: 'flex-shrink-0 pr-8',
              style: { width: '240px' }
            },
              // Skeleton 2x2 album art grid
              React.createElement('div', {
                className: 'grid grid-cols-2 gap-0.5 rounded-lg overflow-hidden mb-4',
                style: { width: '192px', height: '192px' }
              },
                Array.from({ length: 4 }).map((_, i) =>
                  React.createElement('div', {
                    key: `cover-skeleton-${i}`,
                    className: 'aspect-square bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                    style: { backgroundSize: '200% 100%', animationDelay: `${i * 50}ms` }
                  })
                )
              ),
              // Skeleton metadata
              React.createElement('div', { className: 'mt-4 space-y-2' },
                React.createElement('div', {
                  className: 'h-5 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-40 animate-shimmer',
                  style: { backgroundSize: '200% 100%' }
                }),
                React.createElement('div', {
                  className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-32 animate-shimmer',
                  style: { backgroundSize: '200% 100%', animationDelay: '100ms' }
                }),
                React.createElement('div', {
                  className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-24 animate-shimmer',
                  style: { backgroundSize: '200% 100%', animationDelay: '200ms' }
                })
              )
            ),
            // RIGHT COLUMN: Skeleton track list
            React.createElement('div', { className: 'flex-1 min-w-0 space-y-2' },
              Array.from({ length: 8 }).map((_, i) =>
                React.createElement('div', {
                  key: `track-skeleton-${i}`,
                  className: 'flex items-center gap-4 py-2 px-3'
                },
                  React.createElement('div', {
                    className: 'w-8 h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer',
                    style: { backgroundSize: '200% 100%', animationDelay: `${i * 30}ms` }
                  }),
                  React.createElement('div', {
                    className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer',
                    style: { width: '200px', backgroundSize: '200% 100%', animationDelay: `${i * 30 + 15}ms` }
                  }),
                  React.createElement('div', {
                    className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer',
                    style: { width: '120px', backgroundSize: '200% 100%', animationDelay: `${i * 30 + 30}ms` }
                  }),
                  React.createElement('div', { className: 'flex-1' }),
                  React.createElement('div', {
                    className: 'w-10 h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer',
                    style: { backgroundSize: '200% 100%', animationDelay: `${i * 30 + 45}ms` }
                  })
                )
              )
            )
          )
        )
      )

      // Main content area - Playlist Page (new design matching album page layout)
      : activeView === 'playlist-view' && selectedPlaylist ? React.createElement('div', {
        className: 'flex-1 flex flex-col',
        style: { overflow: 'hidden' }
      },
        // Playlist hero header (similar to Playlists main page)
        React.createElement('div', {
          className: 'relative',
          style: {
            height: '140px',
            flexShrink: 0,
            overflow: 'hidden'
          }
        },
          // Background with first album art or gradient
          React.createElement('div', {
            className: 'absolute inset-0',
            style: {
              backgroundImage: playlistCoverArt[0]
                ? `url(${playlistCoverArt[0]})`
                : 'linear-gradient(to bottom right, #f43f5e, #ec4899, #c026d3)',
              backgroundSize: 'cover',
              backgroundPosition: 'center',
              filter: 'blur(20px) brightness(0.7)',
              transform: 'scale(1.2)'
            }
          }),
          // Gradient overlay
          React.createElement('div', {
            className: 'absolute inset-0',
            style: {
              background: 'linear-gradient(to bottom, rgba(0,0,0,0.3) 0%, rgba(17,17,17,0.95) 100%)'
            }
          }),
          // Header content
          React.createElement('div', {
            className: 'absolute inset-0 flex items-center px-8 z-10'
          },
            // Playlist icon
            React.createElement('div', {
              className: 'w-6 h-6 rounded-full bg-white/20 flex items-center justify-center mr-3'
            },
              React.createElement('svg', { className: 'w-3 h-3 text-white', fill: 'currentColor', viewBox: '0 0 24 24' },
                React.createElement('circle', { cx: '12', cy: '12', r: '10' })
              )
            ),
            // Playlist name
            React.createElement('h1', {
              className: 'text-2xl font-bold text-white',
              style: {
                textShadow: '0 2px 10px rgba(0,0,0,0.5)',
                letterSpacing: '0.1em',
                textTransform: 'uppercase'
              }
            }, selectedPlaylist.title)
          )
        ),

        // Playlist content (scrollable) - white background with new layout
        React.createElement('div', {
          className: 'scrollable-content bg-white',
          style: {
            flex: 1,
            overflowY: 'scroll',
            pointerEvents: 'auto'
          }
        },
          // PLAYLIST DETAILS section header with breadcrumb and Edit buttons
          React.createElement('div', {
            className: 'flex items-center justify-between px-6 py-4 border-b border-gray-200'
          },
            // Breadcrumb navigation: Playlists > Playlist Name
            React.createElement('div', {
              className: 'flex items-center gap-2 text-xs font-medium tracking-widest uppercase'
            },
              React.createElement('button', {
                onClick: () => {
                  if (playlistEditMode) {
                    setPlaylistEditMode(false);
                    setEditedPlaylistData(null);
                  }
                  setSelectedPlaylist(null);
                  setPlaylistTracks([]);
                  setPlaylistCoverArt([]);
                  navigateTo('playlists');
                },
                className: 'text-gray-400 hover:text-gray-600 transition-colors uppercase'
              }, 'Playlists'),
              React.createElement('span', { className: 'text-gray-300' }, '/'),
              React.createElement('span', { className: 'text-gray-600 uppercase' },
                playlistEditMode ? 'Editing' : (selectedPlaylist.title || 'Playlist Details')
              )
            ),
            React.createElement('div', { className: 'flex items-center gap-2' },
              // Edit / Cancel+Done buttons
              playlistEditMode ? React.createElement(React.Fragment, null,
                // Cancel button
                React.createElement('button', {
                  onClick: () => {
                    setPlaylistEditMode(false);
                    setEditedPlaylistData(null);
                  },
                  className: 'flex items-center gap-1 px-3 py-1 text-xs text-gray-500 hover:text-gray-700 border border-gray-300 rounded hover:bg-gray-50 transition-colors no-drag'
                }, 'CANCEL'),
                // Done button
                React.createElement('button', {
                  onClick: async () => {
                    if (editedPlaylistData) {
                      const updated = {
                        ...selectedPlaylist,
                        title: editedPlaylistData.title,
                        creator: editedPlaylistData.creator,
                        tracks: editedPlaylistData.tracks,
                        lastModified: Date.now()
                      };
                      setSelectedPlaylist(updated);
                      setPlaylistTracks(editedPlaylistData.tracks);
                      setPlaylists(prev => prev.map(p => p.id === updated.id ? updated : p));
                      await savePlaylistToStore(updated);
                    }
                    setPlaylistEditMode(false);
                    setEditedPlaylistData(null);
                  },
                  className: 'flex items-center gap-1 px-3 py-1 text-xs text-white bg-fuchsia-600 hover:bg-fuchsia-700 rounded transition-colors no-drag'
                }, 'DONE')
              ) : React.createElement('button', {
                onClick: () => {
                  setPlaylistEditMode(true);
                  setEditedPlaylistData({
                    title: selectedPlaylist.title,
                    creator: selectedPlaylist.creator || '',
                    tracks: [...playlistTracks]
                  });
                },
                className: 'flex items-center gap-1 px-3 py-1 text-xs text-gray-500 hover:text-gray-700 border border-gray-300 rounded hover:bg-gray-50 transition-colors no-drag'
              }, 'EDIT'),
              // Close button (hidden in edit mode since Cancel serves that purpose)
              !playlistEditMode && React.createElement('button', {
                onClick: () => {
                  setSelectedPlaylist(null);
                  setPlaylistTracks([]);
                  setPlaylistCoverArt([]);
                  navigateTo('playlists');
                },
                className: 'flex items-center gap-1 px-3 py-1 text-xs text-gray-500 hover:text-gray-700 border border-gray-300 rounded hover:bg-gray-50 transition-colors no-drag'
              },
                'CLOSE',
                React.createElement('span', { className: 'text-gray-400' }, 'Ã—')
              )
            )
          ),

          // Two-column layout: playlist cover + metadata on left, tracklist on right
          React.createElement('div', { className: 'flex gap-0 p-6' },
            // LEFT COLUMN: 2x2 album art grid and metadata
            React.createElement('div', {
              className: 'flex-shrink-0 pr-8',
              style: { width: '240px' }
            },
              // 2x2 Album art grid
              React.createElement('div', {
                className: 'w-48 h-48 rounded shadow-lg overflow-hidden',
                style: {
                  display: 'grid',
                  gridTemplateColumns: '1fr 1fr',
                  gridTemplateRows: '1fr 1fr',
                  gap: '2px',
                  backgroundColor: '#e5e7eb'
                }
              },
                playlistCoverArt.length >= 4 ?
                  // Show 4 album covers in 2x2 grid
                  playlistCoverArt.slice(0, 4).map((url, i) =>
                    React.createElement('div', {
                      key: i,
                      style: {
                        backgroundImage: `url(${url})`,
                        backgroundSize: 'cover',
                        backgroundPosition: 'center'
                      }
                    })
                  )
                : playlistCoverArt.length > 0 ?
                  // Show available covers, fill rest with gradient
                  [...Array(4)].map((_, i) =>
                    React.createElement('div', {
                      key: i,
                      style: {
                        backgroundImage: playlistCoverArt[i]
                          ? `url(${playlistCoverArt[i]})`
                          : 'linear-gradient(135deg, #c026d3, #ec4899)',
                        backgroundSize: 'cover',
                        backgroundPosition: 'center'
                      }
                    })
                  )
                :
                  // Default gradient placeholder
                  [...Array(4)].map((_, i) =>
                    React.createElement('div', {
                      key: i,
                      className: 'flex items-center justify-center',
                      style: {
                        background: `linear-gradient(135deg, ${
                          ['#c026d3', '#ec4899', '#f43f5e', '#fb7185'][i]
                        }, ${
                          ['#ec4899', '#f43f5e', '#fb7185', '#c026d3'][i]
                        })`
                      }
                    })
                  )
              ),

              // Playlist title and metadata
              React.createElement('div', { className: 'mt-4 space-y-1' },
                // Title - editable in edit mode
                playlistEditMode && editedPlaylistData
                  ? React.createElement('input', {
                      type: 'text',
                      value: editedPlaylistData.title,
                      onChange: (e) => setEditedPlaylistData(prev => ({ ...prev, title: e.target.value })),
                      className: 'font-bold text-gray-900 text-lg leading-tight bg-white border border-gray-300 rounded px-2 py-1 w-full focus:outline-none focus:ring-2 focus:ring-fuchsia-500 focus:border-transparent',
                      placeholder: 'Playlist name'
                    })
                  : React.createElement('h2', {
                      className: 'font-bold text-gray-900 text-lg leading-tight'
                    }, selectedPlaylist.title),
                // Creator - editable for imported and hosted playlists in edit mode
                playlistEditMode && editedPlaylistData && (selectedPlaylist.id?.startsWith('imported-') || selectedPlaylist.sourceUrl)
                  ? React.createElement('input', {
                      type: 'text',
                      value: editedPlaylistData.creator,
                      onChange: (e) => setEditedPlaylistData(prev => ({ ...prev, creator: e.target.value })),
                      className: 'text-sm text-gray-500 bg-white border border-gray-300 rounded px-2 py-1 w-full focus:outline-none focus:ring-2 focus:ring-fuchsia-500 focus:border-transparent',
                      placeholder: 'Creator name'
                    })
                  : React.createElement('p', {
                      className: 'text-sm text-gray-500'
                    }, `Created by ${selectedPlaylist.creator || 'Unknown'}`),
                React.createElement('p', {
                  className: 'text-sm text-gray-500'
                }, playlistTracks.length > 0
                  ? `${playlistTracks.length.toString().padStart(2, '0')} Songs`
                  : selectedPlaylist.tracks?.length > 0
                    ? `${selectedPlaylist.tracks.length.toString().padStart(2, '0')} Songs`
                    : 'Loading...'),
                // Created date
                selectedPlaylist.createdAt && React.createElement('p', {
                  className: 'text-xs text-gray-400'
                }, `Created: ${new Date(selectedPlaylist.createdAt).toLocaleDateString()}`),
                // Last modified date
                selectedPlaylist.lastModified && React.createElement('p', {
                  className: 'text-xs text-gray-400'
                }, `Modified: ${new Date(selectedPlaylist.lastModified).toLocaleDateString()}`),
                // Delete Playlist button (only in edit mode)
                playlistEditMode && React.createElement('button', {
                  onClick: () => {
                    if (window.confirm(`Are you sure you want to delete "${selectedPlaylist.title}"? This cannot be undone.`)) {
                      // Delete the playlist
                      window.electron.playlists.delete(selectedPlaylist.id);
                      setPlaylists(prev => prev.filter(p => p.id !== selectedPlaylist.id));
                      // Clear cover cache for this playlist
                      delete playlistCoverCache.current[selectedPlaylist.id];
                      setAllPlaylistCovers(prev => {
                        const newCovers = { ...prev };
                        delete newCovers[selectedPlaylist.id];
                        return newCovers;
                      });
                      // Exit edit mode and navigate back
                      setPlaylistEditMode(false);
                      setEditedPlaylistData(null);
                      setSelectedPlaylist(null);
                      setPlaylistTracks([]);
                      setPlaylistCoverArt([]);
                      navigateTo('playlists');
                    }
                  },
                  className: 'mt-4 flex items-center gap-2 px-3 py-2 text-sm text-red-600 hover:text-red-700 border border-red-300 rounded hover:bg-red-50 transition-colors no-drag w-full justify-center'
                }, 'Delete Playlist')
              )
            ),

            // RIGHT COLUMN: Tracklist
            React.createElement('div', { className: 'flex-1 min-w-0' },
              // Use edited tracks when in edit mode, otherwise use playlistTracks
              (() => {
                const displayTracks = playlistEditMode && editedPlaylistData ? editedPlaylistData.tracks : playlistTracks;
                return displayTracks.length > 0 ?
                React.createElement('div', { className: 'space-y-0' },
                  displayTracks.map((track, index) => {
                    const hasResolved = Object.keys(track.sources || {}).length > 0;
                    const isResolving = Object.keys(track.sources || {}).length === 0;
                    const isDraggedOver = playlistEditMode && playlistDropTarget === index;
                    const isDragging = playlistEditMode && draggedPlaylistTrack === index;
                    const isCurrentTrack = currentTrack?.id === track.id;
                    const isNowPlaying = isCurrentTrack && playbackContext?.type === 'playlist' && playbackContext?.id === selectedPlaylist?.id;

                    // Debug logging for first track only
                    if (index === 0) {
                      console.log('ðŸŽ¯ Playlist highlight check:', {
                        trackId: track.id,
                        currentTrackId: currentTrack?.id,
                        isCurrentTrack,
                        playbackContextType: playbackContext?.type,
                        playbackContextId: playbackContext?.id,
                        selectedPlaylistId: selectedPlaylist?.id,
                        isNowPlaying
                      });
                    }

                    return React.createElement('div', {
                      key: track.id || index,
                      draggable: true,
                      onDragStart: (e) => {
                        // Always allow dragging to other playlists
                        setDraggingTrackForPlaylist(track);
                        e.dataTransfer.effectAllowed = 'move';
                        e.dataTransfer.setData('text/plain', JSON.stringify({ type: 'track', track }));
                        // Only track index for reordering in edit mode
                        if (playlistEditMode) {
                          setDraggedPlaylistTrack(index);
                        }
                      },
                      onDragEnd: () => {
                        setDraggingTrackForPlaylist(null);
                        setDropTargetPlaylistId(null);
                        setDropTargetNewPlaylist(false);
                        if (playlistEditMode) {
                          setDraggedPlaylistTrack(null);
                          setPlaylistDropTarget(null);
                        }
                        // Close panel if it was opened by drag and nothing was dropped
                        if (addToPlaylistPanel.open && selectedPlaylistsForAdd.length === 0) {
                          setAddToPlaylistPanel(prev => ({ ...prev, open: false }));
                        }
                      },
                      onDragOver: playlistEditMode ? (e) => {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'move';
                        if (draggedPlaylistTrack !== null && draggedPlaylistTrack !== index) {
                          setPlaylistDropTarget(index);
                        }
                      } : undefined,
                      onDragLeave: playlistEditMode ? () => {
                        setPlaylistDropTarget(null);
                      } : undefined,
                      onDrop: playlistEditMode ? (e) => {
                        e.preventDefault();
                        if (draggedPlaylistTrack !== null && draggedPlaylistTrack !== index) {
                          moveInEditedPlaylist(draggedPlaylistTrack, index);
                        }
                        setDraggedPlaylistTrack(null);
                        setPlaylistDropTarget(null);
                      } : undefined,
                      className: `flex items-center gap-4 py-2 px-3 border-b border-gray-100 hover:bg-gray-50 transition-colors no-drag group ${
                        playlistEditMode ? 'cursor-grab active:cursor-grabbing' : 'cursor-pointer'
                      } ${isResolving ? 'opacity-60' : ''} ${isDragging ? 'opacity-50 bg-gray-100' : ''} ${isDraggedOver ? 'border-t-2 border-t-purple-500' : ''} ${isNowPlaying && isPlaying ? 'bg-purple-50' : ''}`,
                      onClick: () => {
                        if (draggedPlaylistTrack !== null) return; // Don't play if dragging
                        const tracksAfter = playlistTracks.slice(index + 1);
                        const context = { type: 'playlist', id: selectedPlaylist?.id, name: selectedPlaylist?.title };
                        setQueueWithContext(tracksAfter, context);
                        handlePlay(track);
                      },
                      onContextMenu: (e) => {
                        e.preventDefault();
                        if (window.electron?.contextMenu?.showTrackMenu) {
                          window.electron.contextMenu.showTrackMenu({
                            type: 'track',
                            track: track,
                            // Pass playlist context for "Remove from Playlist" option
                            inPlaylist: true,
                            playlistId: selectedPlaylist.id,
                            trackIndex: index
                          });
                        }
                      }
                    },
                      // Track number or drag handle in edit mode
                      playlistEditMode
                        ? React.createElement('span', {
                            className: 'text-gray-400 flex-shrink-0 flex items-center justify-center',
                            style: { pointerEvents: 'none', width: '32px' },
                            title: 'Drag to reorder'
                          },
                          // Drag handle icon (hamburger/grip lines)
                          React.createElement('svg', {
                            className: 'w-4 h-4',
                            fill: 'none',
                            stroke: 'currentColor',
                            viewBox: '0 0 24 24'
                          },
                            React.createElement('path', {
                              strokeLinecap: 'round',
                              strokeLinejoin: 'round',
                              strokeWidth: 2,
                              d: 'M4 8h16M4 16h16'
                            })
                          )
                        )
                        : React.createElement('span', {
                            className: `text-sm flex-shrink-0 text-right ${isNowPlaying && isPlaying ? 'text-purple-500' : 'text-gray-400'}`,
                            style: { pointerEvents: 'none', width: '32px' }
                          }, isNowPlaying && isPlaying ? 'â–¶' : String(index + 1).padStart(2, '0')),

                      // Track title - fixed width column (font-medium for emphasis)
                      React.createElement('span', {
                        className: `text-sm font-medium truncate transition-colors ${isNowPlaying && isPlaying ? 'text-purple-600' : hasResolved ? 'text-gray-900 group-hover:text-gray-900' : 'text-gray-500'}`,
                        style: { pointerEvents: 'none', width: '360px', flexShrink: 0 }
                      }, track.title),

                      // Artist name - fixed width column, clickable
                      React.createElement('span', {
                        className: 'text-sm text-gray-500 truncate hover:text-purple-600 hover:underline cursor-pointer transition-colors',
                        style: { width: '240px', flexShrink: 0 },
                        onClick: (e) => {
                          e.stopPropagation();
                          fetchArtistData(track.artist);
                        }
                      }, track.artist),

                      // Duration - fixed width column (before resolver icons)
                      React.createElement('span', {
                        className: 'text-sm text-gray-400 text-right tabular-nums',
                        style: { pointerEvents: 'none', width: '50px', flexShrink: 0, marginLeft: 'auto' }
                      }, formatTime(track.duration)),

                      // Resolver icons - fixed width column (last column)
                      React.createElement('div', {
                        className: 'flex items-center gap-1 justify-end',
                        style: { width: '100px', flexShrink: 0, minHeight: '24px' }
                      },
                        isResolving ?
                          React.createElement('div', {
                            className: 'flex items-center gap-1'
                          },
                            React.createElement('div', {
                              className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer',
                              title: 'Resolving track...'
                            }),
                            React.createElement('div', {
                              className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer',
                              style: { animationDelay: '0.1s' }
                            })
                          )
                        : hasResolved ?
                          Object.entries(track.sources)
                            .sort(([aId], [bId]) => {
                              const aIndex = resolverOrder.indexOf(aId);
                              const bIndex = resolverOrder.indexOf(bId);
                              return aIndex - bIndex;
                            })
                            .map(([resolverId, source]) => {
                              const resolver = allResolvers.find(r => r.id === resolverId);
                              if (!resolver || !resolver.play) return null;
                              return React.createElement('button', {
                                key: resolverId,
                                className: 'no-drag',
                                onClick: (e) => {
                                  e.stopPropagation();
                                  const tracksAfter = playlistTracks.slice(index + 1);
                                  const context = { type: 'playlist', id: selectedPlaylist?.id, name: selectedPlaylist?.title };
                                  setQueueWithContext(tracksAfter, context);
                                  handlePlay({ ...track, preferredResolver: resolverId });
                                },
                                style: {
                                  width: '24px',
                                  height: '24px',
                                  borderRadius: '4px',
                                  backgroundColor: resolver.color,
                                  border: 'none',
                                  cursor: 'pointer',
                                  display: 'flex',
                                  alignItems: 'center',
                                  justifyContent: 'center',
                                  pointerEvents: 'auto',
                                  opacity: (source.confidence || 0) > 0.8 ? 1 : 0.6,
                                  transition: 'transform 0.1s'
                                },
                                onMouseEnter: (e) => e.currentTarget.style.transform = 'scale(1.1)',
                                onMouseLeave: (e) => e.currentTarget.style.transform = 'scale(1)',
                                title: `Play from ${resolver.name}${source.confidence ? ` (${Math.round(source.confidence * 100)}% match)` : ''}`
                              }, React.createElement(ResolverIcon, { resolverId, size: 14 }));
                            })
                        :
                          // Show shimmer skeletons while resolving (match resolver icon size)
                          React.createElement('div', {
                            className: 'flex items-center gap-1'
                          },
                            React.createElement('div', {
                              className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer',
                              title: 'Resolving track...'
                            }),
                            React.createElement('div', {
                              className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer',
                              style: { animationDelay: '0.1s' }
                            })
                          )
                      )
                    );
                  })
                )
              :
                React.createElement('div', { className: 'text-center py-12 text-gray-400' },
                  'Loading tracks...'
                );
              })()
            )
          )
        )
      )

      // Main content area - Playlists Page (separate layout like Artist page)
      : activeView === 'playlists' ? React.createElement('div', {
        className: 'flex-1 flex flex-col h-full',
        style: { overflow: 'hidden', minHeight: 0 }
      },
        // Header section (outside scrollable area)
        React.createElement('div', {
          className: 'relative',
          style: {
            height: playlistsHeaderCollapsed ? '80px' : '320px',
            flexShrink: 0,
            transition: 'height 300ms ease-out',
            overflow: 'hidden'
          }
        },
          // Gradient background
          React.createElement('div', {
            className: 'absolute inset-0 bg-gradient-to-br from-rose-500 via-pink-500 to-fuchsia-600'
          }),
          // Background pattern
          React.createElement('div', {
            className: 'absolute inset-0',
            style: {
              opacity: 0.15,
              backgroundImage: 'url("data:image/svg+xml,%3Csvg width=\'60\' height=\'60\' viewBox=\'0 0 60 60\' xmlns=\'http://www.w3.org/2000/svg\'%3E%3Cg fill=\'none\' stroke=\'%23ffffff\' stroke-width=\'2\'%3E%3Cpath d=\'M5 15h50M5 30h35M5 45h45\'/%3E%3Ccircle cx=\'50\' cy=\'30\' r=\'5\' fill=\'%23ffffff\'/%3E%3C/g%3E%3C/svg%3E")'
            }
          }),
          // EXPANDED STATE - Centered content
          !playlistsHeaderCollapsed && React.createElement('div', {
            className: 'absolute inset-0 flex flex-col items-center justify-center text-center px-6 z-10',
            style: {
              opacity: playlistsHeaderCollapsed ? 0 : 1,
              transition: 'opacity 300ms ease-out'
            }
          },
            React.createElement('h1', {
              className: 'text-5xl font-light text-white',
              style: {
                textShadow: '0 2px 20px rgba(0,0,0,0.5)',
                letterSpacing: '0.3em',
                textTransform: 'uppercase'
              }
            }, 'PLAYLISTS'),
            React.createElement('div', {
              className: 'flex items-center gap-1 mt-6',
              style: { textShadow: '0 1px 10px rgba(0,0,0,0.5)' }
            },
              playlistsLoading && playlists.length === 0
                ? React.createElement('div', {
                    className: 'h-5 w-24 rounded bg-white/20 animate-pulse'
                  })
                : React.createElement('span', {
                    className: 'px-2 py-1 text-sm font-medium uppercase tracking-wider text-white'
                  }, `${playlists.length} Playlist${playlists.length !== 1 ? 's' : ''}`)
            ),
            React.createElement('button', {
              onClick: () => setShowUrlImportDialog(true),
              className: 'mt-6 px-6 py-2 rounded-full font-medium text-white no-drag transition-all hover:scale-105',
              style: {
                backgroundColor: '#E91E63',
                boxShadow: '0 4px 15px rgba(233, 30, 99, 0.4)'
              }
            }, 'Import Playlist')
          ),
          // COLLAPSED STATE - Inline layout
          playlistsHeaderCollapsed && React.createElement('div', {
            className: 'absolute inset-0 flex items-center px-6 z-10',
            style: {
              opacity: playlistsHeaderCollapsed ? 1 : 0,
              transition: 'opacity 300ms ease-out'
            }
          },
            React.createElement('h1', {
              className: 'text-2xl font-light text-white',
              style: {
                textShadow: '0 2px 10px rgba(0,0,0,0.5)',
                letterSpacing: '0.2em',
                textTransform: 'uppercase'
              }
            }, 'PLAYLISTS'),
            React.createElement('button', {
              onClick: () => setShowUrlImportDialog(true),
              className: 'ml-auto px-4 py-1.5 rounded-full text-sm font-medium text-white transition-colors hover:opacity-90',
              style: { backgroundColor: '#E91E63' }
            }, 'Import Playlist')
          )
        ),
        // Filter bar (outside scrollable area)
        React.createElement('div', {
          className: 'flex items-center px-6 py-3 bg-white border-b border-gray-200',
          style: { flexShrink: 0 }
        },
          // Sort dropdown
          React.createElement('div', { className: 'relative' },
            React.createElement('button', {
              onClick: (e) => { e.stopPropagation(); setPlaylistsSortDropdownOpen(!playlistsSortDropdownOpen); },
              className: 'flex items-center gap-1 px-3 py-1.5 text-sm text-gray-500 hover:text-gray-700 transition-colors'
            },
              React.createElement('span', null, playlistsSortOptions.find(o => o.value === playlistsSort)?.label || 'Sort'),
              React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M19 9l-7 7-7-7' })
              )
            ),
            playlistsSortDropdownOpen && React.createElement('div', {
              className: 'absolute left-0 top-full mt-1 bg-white rounded-lg shadow-lg py-1 min-w-[160px] z-30 border border-gray-200'
            },
              playlistsSortOptions.map(option =>
                React.createElement('button', {
                  key: option.value,
                  onClick: (e) => {
                    e.stopPropagation();
                    setPlaylistsSort(option.value);
                    setPlaylistsSortDropdownOpen(false);
                  },
                  className: `w-full px-4 py-2 text-left text-sm hover:bg-gray-100 flex items-center justify-between ${
                    playlistsSort === option.value ? 'text-gray-900 font-medium' : 'text-gray-600'
                  }`
                },
                  option.label,
                  playlistsSort === option.value && React.createElement('svg', {
                    className: 'w-4 h-4',
                    fill: 'none',
                    viewBox: '0 0 24 24',
                    stroke: 'currentColor'
                  },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M5 13l4 4L19 7' })
                  )
                )
              )
            )
          ),
          React.createElement('div', { className: 'flex-1' }),
          // View mode toggle (grid/table)
          React.createElement('div', { className: 'flex items-center gap-1 mr-4' },
            React.createElement('button', {
              onClick: () => setPlaylistsViewMode('grid'),
              className: `p-1.5 rounded transition-colors ${playlistsViewMode === 'grid' ? 'bg-gray-200 text-gray-700' : 'text-gray-400 hover:text-gray-600'}`,
              title: 'Grid view'
            },
              React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor', strokeWidth: 2 },
                React.createElement('rect', { x: 3, y: 3, width: 7, height: 7, rx: 1 }),
                React.createElement('rect', { x: 14, y: 3, width: 7, height: 7, rx: 1 }),
                React.createElement('rect', { x: 3, y: 14, width: 7, height: 7, rx: 1 }),
                React.createElement('rect', { x: 14, y: 14, width: 7, height: 7, rx: 1 })
              )
            ),
            React.createElement('button', {
              onClick: () => setPlaylistsViewMode('table'),
              className: `p-1.5 rounded transition-colors ${playlistsViewMode === 'table' ? 'bg-gray-200 text-gray-700' : 'text-gray-400 hover:text-gray-600'}`,
              title: 'Table view'
            },
              React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor', strokeWidth: 2 },
                React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', d: 'M4 6h16M4 12h16M4 18h16' })
              )
            )
          ),
          // Search
          React.createElement('div', { className: 'flex items-center' },
            playlistsSearchOpen ?
              React.createElement('div', { className: 'flex items-center border border-gray-300 rounded-full px-3 py-1.5' },
                React.createElement('input', {
                  type: 'text',
                  value: playlistsSearch,
                  onChange: (e) => setPlaylistsSearch(e.target.value),
                  onBlur: () => { if (!playlistsSearch.trim()) setPlaylistsSearchOpen(false); },
                  autoFocus: true,
                  placeholder: 'Filter...',
                  className: 'bg-transparent text-gray-700 text-sm placeholder-gray-400 outline-none',
                  style: { width: '150px' }
                }),
                playlistsSearch && React.createElement('button', {
                  onClick: () => { setPlaylistsSearch(''); setPlaylistsSearchOpen(false); },
                  className: 'ml-2 text-gray-400 hover:text-gray-600'
                },
                  React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M6 18L18 6M6 6l12 12' })
                  )
                )
              )
            :
              React.createElement('button', {
                onClick: () => setPlaylistsSearchOpen(true),
                className: 'p-1.5 text-gray-400 hover:text-gray-600 transition-colors'
              },
                React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                  React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' })
                )
              )
          )
        ),
        // Content area (scrollable)
        React.createElement('div', {
          className: 'scrollable-content',
          style: {
            flex: 1,
            overflowY: 'scroll',
            pointerEvents: 'auto',
            padding: '24px'
          },
          onScroll: handlePlaylistsScroll
        },
          (() => {
            const filtered = filterPlaylists(playlists);
            const sorted = sortPlaylists(filtered);

            // Show loading skeletons while playlists are loading
            if (playlistsLoading && sorted.length === 0) {
              return React.createElement('div', { className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-6' },
                Array.from({ length: 10 }).map((_, i) =>
                  React.createElement('div', { key: `playlist-skeleton-${i}` },
                    // Skeleton 2x2 album art grid
                    React.createElement('div', {
                      className: 'aspect-square rounded-lg overflow-hidden mb-3 shadow-md'
                    },
                      React.createElement('div', { className: 'grid grid-cols-2 grid-rows-2 w-full h-full' },
                        [0, 1, 2, 3].map(idx =>
                          React.createElement('div', {
                            key: idx,
                            className: 'bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                            style: { backgroundSize: '200% 100%', animationDelay: `${(i * 4 + idx) * 30}ms` }
                          })
                        )
                      )
                    ),
                    // Skeleton title
                    React.createElement('div', {
                      className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-3/4 mb-2 animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 50}ms` }
                    }),
                    // Skeleton creator
                    React.createElement('div', {
                      className: 'h-3 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-1/2 animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 25}ms` }
                    })
                  )
                )
              );
            }

            if (sorted.length === 0 && playlistsSearch) {
              return React.createElement('div', { className: 'text-center py-12 text-gray-400' },
                React.createElement('svg', { className: 'w-12 h-12 mx-auto mb-4 text-gray-300', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                  React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 1.5, d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' })
                ),
                React.createElement('div', { className: 'text-sm' }, 'No playlists match your search')
              );
            }

            if (sorted.length === 0) {
              return React.createElement('div', {
                className: 'text-center py-12 text-gray-400'
              }, 'No playlists yet. Import a playlist to get started!');
            }

            // Grid view
            if (playlistsViewMode === 'grid') {
              return React.createElement('div', { className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-6' },
                sorted.map(playlist => {
                  const covers = allPlaylistCovers[playlist.id] || [];
                  const hasCachedCovers = covers.length > 0;

                  return React.createElement('div', {
                    key: playlist.id,
                    onClick: (e) => {
                      e.preventDefault();
                      e.stopPropagation();
                      loadPlaylist(playlist);
                    },
                    onContextMenu: (e) => {
                      e.preventDefault();
                      if (window.electron?.contextMenu?.showTrackMenu) {
                        const tracksWithIds = (playlist.tracks || []).map((track, idx) => {
                          const trackId = `${track.artist || 'unknown'}-${track.title || 'untitled'}-${track.album || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
                          return { ...track, id: trackId, sources: {} };
                        });
                        window.electron.contextMenu.showTrackMenu({
                          type: 'playlist',
                          playlistId: playlist.id,
                          name: playlist.title,
                          tracks: tracksWithIds
                        });
                      }
                    },
                    className: 'group cursor-pointer'
                  },
                    // Album art mosaic or placeholder (draggable)
                    React.createElement('div', {
                      className: 'relative aspect-square rounded-lg overflow-hidden mb-3 shadow-md group-hover:shadow-lg transition-shadow cursor-grab active:cursor-grabbing',
                      draggable: true,
                      onDragStart: (e) => {
                        const tracksWithIds = (playlist.tracks || []).map(track => {
                          const trackId = `${track.artist || 'unknown'}-${track.title || 'untitled'}-${track.album || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
                          return { ...track, id: trackId, sources: {} };
                        });
                        e.dataTransfer.effectAllowed = 'copy';
                        e.dataTransfer.setData('text/plain', JSON.stringify({
                          type: 'playlist',
                          playlist: {
                            id: playlist.id,
                            title: playlist.title,
                            creator: playlist.creator,
                            tracks: tracksWithIds
                          }
                        }));
                      }
                    },
                      hasCachedCovers ?
                        React.createElement('div', { className: 'grid grid-cols-2 grid-rows-2 w-full h-full' },
                          [0, 1, 2, 3].map(idx => {
                            const gradients = [
                              'bg-gradient-to-br from-violet-400 to-purple-500',
                              'bg-gradient-to-br from-rose-400 to-pink-500',
                              'bg-gradient-to-br from-amber-400 to-orange-500',
                              'bg-gradient-to-br from-emerald-400 to-teal-500'
                            ];
                            return React.createElement('div', {
                              key: idx,
                              className: `relative w-full h-full ${gradients[idx]} flex items-center justify-center`
                            },
                              !covers[idx] && React.createElement(Music, { size: 20, className: 'text-white/70' }),
                              covers[idx] && React.createElement('img', {
                                src: covers[idx],
                                alt: '',
                                className: 'absolute inset-0 w-full h-full object-cover transition-opacity duration-300',
                                style: { opacity: 0 },
                                ref: (el) => { if (el && el.complete && el.naturalWidth > 0) el.style.opacity = '1'; },
                                onLoad: (e) => { e.target.style.opacity = '1'; }
                              })
                            );
                          })
                        )
                      :
                        React.createElement('div', {
                          className: `w-full h-full flex items-center justify-center ${
                            playlist.sourceUrl
                              ? 'bg-gradient-to-br from-blue-400 to-cyan-400'
                              : playlist.isAiPlaylist
                                ? 'bg-gradient-to-br from-violet-500 to-fuchsia-500'
                                : 'bg-gradient-to-br from-purple-400 to-pink-400'
                          }`
                        },
                          // Playlist icon (three lines with play triangle)
                          React.createElement('svg', { className: 'w-12 h-12 text-white/80', viewBox: '0 0 24 24', fill: 'currentColor' },
                            React.createElement('rect', { x: 3, y: 5, width: 18, height: 2, rx: 1 }),
                            React.createElement('rect', { x: 3, y: 11, width: 10, height: 2, rx: 1 }),
                            React.createElement('rect', { x: 3, y: 17, width: 7, height: 2, rx: 1 }),
                            React.createElement('path', { d: 'M15 13.5v6l5.5-3-5.5-3z' })
                          )
                        ),

                      // Hosted indicator
                      playlist.sourceUrl && React.createElement('div', {
                        className: 'absolute top-2 right-2 flex items-center gap-1'
                      },
                        React.createElement('span', {
                          className: 'bg-white/90 backdrop-blur-sm text-blue-500 text-xs px-2 py-0.5 rounded-full font-medium',
                          title: 'Hosted playlist'
                        }, 'ðŸŒ Hosted'),
                        React.createElement('button', {
                          onClick: async (e) => {
                            e.stopPropagation();
                            setRefreshingPlaylist(playlist.id);
                            await refreshHostedPlaylist(playlist.id);
                            setRefreshingPlaylist(null);
                          },
                          className: `p-1 bg-white/90 backdrop-blur-sm rounded-full hover:bg-white transition-colors ${refreshingPlaylist === playlist.id ? 'animate-spin' : ''}`,
                          title: 'Refresh playlist'
                        },
                          React.createElement('svg', { className: 'w-3 h-3 text-gray-600', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                            React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15' })
                          )
                        )
                      ),

                      // AI indicator
                      playlist.isAiPlaylist && !playlist.sourceUrl && React.createElement('div', {
                        className: 'absolute top-2 right-2'
                      },
                        React.createElement('span', {
                          className: 'bg-white/90 backdrop-blur-sm text-purple-600 text-xs px-2 py-0.5 rounded-full font-medium',
                          title: `Generated by ${playlist.creator || 'AI'}`
                        }, 'âœ¨ AI')
                      ),

                      // Hover play overlay
                      React.createElement('div', {
                        className: 'absolute inset-0 bg-black/40 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center'
                      },
                        React.createElement('div', {
                          className: 'w-12 h-12 bg-white rounded-full flex items-center justify-center shadow-lg'
                        }, React.createElement(Play, { size: 24, className: 'text-gray-800 ml-1' }))
                      )
                    ),
                    // Playlist info
                    React.createElement('div', { className: 'font-medium text-gray-900 truncate group-hover:text-green-600 transition-colors' }, playlist.title),
                    React.createElement('div', { className: 'text-sm text-gray-500 truncate' },
                      playlist.creator || `${playlist.tracks?.length || 0} Songs`
                    )
                  );
                }),
                // Trailing skeletons while hosted playlists are still loading
                ...(playlistsLoading ? Array.from({ length: 4 }).map((_, i) =>
                  React.createElement('div', { key: `trailing-skeleton-${i}` },
                    // Skeleton 2x2 album art grid
                    React.createElement('div', {
                      className: 'aspect-square rounded-lg overflow-hidden mb-3 shadow-md'
                    },
                      React.createElement('div', { className: 'grid grid-cols-2 grid-rows-2 w-full h-full' },
                        [0, 1, 2, 3].map(idx =>
                          React.createElement('div', {
                            key: idx,
                            className: 'bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                            style: { backgroundSize: '200% 100%', animationDelay: `${(i * 4 + idx) * 30}ms` }
                          })
                        )
                      )
                    ),
                    // Skeleton title
                    React.createElement('div', {
                      className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-3/4 mb-2 animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 50}ms` }
                    }),
                    // Skeleton creator
                    React.createElement('div', {
                      className: 'h-3 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-1/2 animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 25}ms` }
                    })
                  )
                ) : [])
              );
            }

            // Table view
            return React.createElement('div', { className: 'space-y-0' },
              sorted.map((playlist, index) => {
                const covers = allPlaylistCovers[playlist.id] || [];
                const hasCachedCovers = covers.length > 0;
                const trackCount = playlist.tracks?.length || 0;

                return React.createElement('div', {
                  key: playlist.id,
                  draggable: true,
                  onDragStart: (e) => {
                    const tracksWithIds = (playlist.tracks || []).map(track => {
                      const trackId = `${track.artist || 'unknown'}-${track.title || 'untitled'}-${track.album || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
                      return { ...track, id: trackId, sources: {} };
                    });
                    e.dataTransfer.effectAllowed = 'copy';
                    e.dataTransfer.setData('text/plain', JSON.stringify({
                      type: 'playlist',
                      playlist: {
                        id: playlist.id,
                        title: playlist.title,
                        creator: playlist.creator,
                        tracks: tracksWithIds
                      }
                    }));
                  },
                  onClick: (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    loadPlaylist(playlist);
                  },
                  onContextMenu: (e) => {
                    e.preventDefault();
                    if (window.electron?.contextMenu?.showTrackMenu) {
                      const tracksWithIds = (playlist.tracks || []).map((track, idx) => {
                        const trackId = `${track.artist || 'unknown'}-${track.title || 'untitled'}-${track.album || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
                        return { ...track, id: trackId, sources: {} };
                      });
                      window.electron.contextMenu.showTrackMenu({
                        type: 'playlist',
                        playlistId: playlist.id,
                        name: playlist.title,
                        tracks: tracksWithIds
                      });
                    }
                  },
                  className: `group flex items-center gap-4 py-3 px-4 cursor-pointer hover:bg-gray-50 transition-colors ${index > 0 ? 'border-t border-gray-100' : ''}`
                },
                  // Thumbnail (small mosaic or placeholder)
                  React.createElement('div', {
                    className: 'relative w-12 h-12 rounded overflow-hidden flex-shrink-0'
                  },
                    hasCachedCovers ?
                      React.createElement('div', { className: 'grid grid-cols-2 grid-rows-2 w-full h-full' },
                        [0, 1, 2, 3].map(idx => {
                          const gradients = [
                            'bg-gradient-to-br from-violet-400 to-purple-500',
                            'bg-gradient-to-br from-rose-400 to-pink-500',
                            'bg-gradient-to-br from-amber-400 to-orange-500',
                            'bg-gradient-to-br from-emerald-400 to-teal-500'
                          ];
                          return React.createElement('div', {
                            key: idx,
                            className: `relative w-full h-full ${gradients[idx]}`
                          },
                            covers[idx] && React.createElement('img', {
                              src: covers[idx],
                              alt: '',
                              className: 'absolute inset-0 w-full h-full object-cover transition-opacity duration-300',
                              style: { opacity: 0 },
                              ref: (el) => { if (el && el.complete && el.naturalWidth > 0) el.style.opacity = '1'; },
                              onLoad: (e) => { e.target.style.opacity = '1'; }
                            })
                          );
                        })
                      )
                    :
                      React.createElement('div', {
                        className: `w-full h-full flex items-center justify-center ${
                          playlist.sourceUrl
                            ? 'bg-gradient-to-br from-blue-400 to-cyan-400'
                            : playlist.isAiPlaylist
                              ? 'bg-gradient-to-br from-violet-500 to-fuchsia-500'
                              : 'bg-gradient-to-br from-purple-400 to-pink-400'
                        }`
                      },
                        // Playlist icon (three lines with play triangle)
                        React.createElement('svg', { className: 'w-5 h-5 text-white/80', viewBox: '0 0 24 24', fill: 'currentColor' },
                          React.createElement('rect', { x: 3, y: 5, width: 18, height: 2, rx: 1 }),
                          React.createElement('rect', { x: 3, y: 11, width: 10, height: 2, rx: 1 }),
                          React.createElement('rect', { x: 3, y: 17, width: 7, height: 2, rx: 1 }),
                          React.createElement('path', { d: 'M15 13.5v6l5.5-3-5.5-3z' })
                        )
                      )
                  ),
                  // Playlist name
                  React.createElement('div', { className: 'flex-1 min-w-0' },
                    React.createElement('div', { className: 'font-medium text-gray-900 truncate group-hover:text-green-600 transition-colors' }, playlist.title),
                    playlist.creator && React.createElement('div', { className: 'text-sm text-gray-500 truncate' }, playlist.creator)
                  ),
                  // Hosted badge
                  playlist.sourceUrl && React.createElement('span', {
                    className: 'text-xs text-blue-500 bg-blue-50 px-2 py-1 rounded-full font-medium flex-shrink-0',
                    title: 'Hosted playlist'
                  }, 'ðŸŒ Hosted'),
                  // AI badge
                  playlist.isAiPlaylist && !playlist.sourceUrl && React.createElement('span', {
                    className: 'text-xs text-purple-600 bg-purple-50 px-2 py-1 rounded-full font-medium flex-shrink-0',
                    title: `Generated by ${playlist.creator || 'AI'}`
                  }, 'âœ¨ AI'),
                  // Track count
                  React.createElement('div', { className: 'text-sm text-gray-500 flex-shrink-0 w-20 text-right' },
                    `${trackCount} song${trackCount !== 1 ? 's' : ''}`
                  ),
                  // Play icon on hover
                  React.createElement('div', {
                    className: 'w-8 h-8 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity flex-shrink-0 cursor-pointer hover:scale-110 transition-transform',
                    onClick: (e) => {
                      e.preventDefault();
                      e.stopPropagation();
                      // Play the playlist starting from first track
                      const tracks = playlist.tracks || [];
                      if (tracks.length > 0) {
                        // Create track objects with IDs matching the playlist view format
                        const tracksWithIds = tracks.map(track => {
                          const trackId = `${track.artist || 'unknown'}-${track.title || 'untitled'}-${track.album || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
                          return { ...track, id: trackId, sources: {} };
                        });
                        // Set all tracks after first as queue
                        setCurrentQueue(tracksWithIds.slice(1));
                        // Play first track
                        handlePlay(tracksWithIds[0]);
                      }
                    }
                  },
                    React.createElement(Play, { size: 20, className: 'text-purple-600 fill-purple-600' })
                  )
                );
              }),
              // Trailing skeletons while hosted playlists are still loading (table view)
              ...(playlistsLoading ? Array.from({ length: 4 }).map((_, i) =>
                React.createElement('div', {
                  key: `trailing-table-skeleton-${i}`,
                  className: `flex items-center gap-4 py-3 px-4 border-t border-gray-100`
                },
                  // Skeleton thumbnail
                  React.createElement('div', {
                    className: 'w-12 h-12 rounded overflow-hidden flex-shrink-0 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                    style: { backgroundSize: '200% 100%', animationDelay: `${i * 50}ms` }
                  }),
                  // Skeleton title/creator
                  React.createElement('div', { className: 'flex-1 min-w-0' },
                    React.createElement('div', {
                      className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-48 mb-2 animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 50}ms` }
                    }),
                    React.createElement('div', {
                      className: 'h-3 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-24 animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 25}ms` }
                    })
                  ),
                  // Skeleton track count
                  React.createElement('div', {
                    className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-16 flex-shrink-0 animate-shimmer',
                    style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 50}ms` }
                  })
                )
              ) : [])
            );
          })()
        )
      )

      // Main content area - Normal views (Library, Search, etc.)
      : React.createElement('div', {
        className: `flex-1 ${
          // Views with custom scroll handling should not have overflow on parent
          ['library', 'discover', 'critics-picks', 'recommendations', 'history', 'friendHistory'].includes(activeView)
            ? 'overflow-hidden'
            : 'overflow-y-auto scrollable-content'
        } ${
          // No padding for views with full-bleed heroes
          ['library', 'discover', 'new-releases', 'critics-picks', 'recommendations', 'history', 'friendHistory'].includes(activeView) ? '' : 'p-6'
        }`,
        style: {
          minHeight: 0,
          flexBasis: 0,
          pointerEvents: activeView === 'artist' || activeView === 'playlist-view' ? 'none' : 'auto'
        }
      },
        // Shared header - only show for views without custom heroes
        !['library', 'discover', 'new-releases', 'critics-picks', 'recommendations', 'history', 'friendHistory', 'settings', 'playlists', 'playlist-view'].includes(activeView) &&
        React.createElement('div', { className: 'flex items-center justify-between mb-4' },
          React.createElement('h2', { className: 'text-2xl font-bold' },
            activeView === 'friends' ? 'Friends' :
            'Discover'
          )
        ),

        // Library view with collapsible hero header (matching Recommendations pattern)
        activeView === 'library' && React.createElement('div', {
          className: 'flex-1 flex flex-col h-full',
          style: { overflow: 'hidden', minHeight: 0 }
        },
          // Header section (outside scrollable area)
          React.createElement('div', {
            className: 'relative',
            style: {
              height: collectionHeaderCollapsed ? '80px' : '320px',
              flexShrink: 0,
              transition: 'height 300ms ease-out',
              overflow: 'hidden'
            }
          },
              // Gradient background
              React.createElement('div', {
                className: 'absolute inset-0 bg-gradient-to-br from-violet-600 via-purple-600 to-indigo-700'
              }),
              // Vinyl pattern overlay
              React.createElement('div', {
                className: 'absolute inset-0',
                style: {
                  opacity: 0.08,
                  backgroundImage: 'url("data:image/svg+xml,%3Csvg width=\'60\' height=\'60\' viewBox=\'0 0 60 60\' xmlns=\'http://www.w3.org/2000/svg\'%3E%3Cg fill=\'%23ffffff\'%3E%3Ccircle cx=\'30\' cy=\'30\' r=\'20\' fill=\'none\' stroke=\'%23fff\' stroke-width=\'2\'/%3E%3Ccircle cx=\'30\' cy=\'30\' r=\'12\' fill=\'none\' stroke=\'%23fff\' stroke-width=\'1\'/%3E%3Ccircle cx=\'30\' cy=\'30\' r=\'4\'/%3E%3C/g%3E%3C/svg%3E")'
                }
              }),
              // EXPANDED STATE - Centered content
            !collectionHeaderCollapsed && React.createElement('div', {
              className: 'absolute inset-0 flex flex-col items-center justify-center text-center px-6 z-10',
              style: {
                opacity: collectionHeaderCollapsed ? 0 : 1,
                transition: 'opacity 300ms ease-out'
              }
            },
                // Title
                React.createElement('h1', {
                  className: 'text-5xl font-light text-white',
                  style: {
                    textShadow: '0 2px 20px rgba(0,0,0,0.5)',
                    letterSpacing: '0.3em',
                    textTransform: 'uppercase'
                  }
                }, 'COLLECTION'),
                // Stats row as tabs (matching Artist page styling)
                React.createElement('div', {
                  className: 'flex items-center gap-1 mt-6',
                  style: { textShadow: '0 1px 10px rgba(0,0,0,0.5)' }
                },
                  [
                    { key: 'artists', label: `${collectionData.artists.length} Artists` },
                    { key: 'albums', label: `${collectionData.albums.length} Albums` },
                    { key: 'tracks', label: `${library.length + collectionData.tracks.length} Songs` },
                    { key: 'friends', label: `${friends.length} Friends` }
                  ].map((tab, index) => [
                    index > 0 && React.createElement('span', {
                      key: `sep-expanded-${tab.key}`,
                      className: 'text-white/50 mx-2'
                    }, '|'),
                    React.createElement('button', {
                      key: `expanded-${tab.key}`,
                      onClick: () => setCollectionTab(tab.key),
                      className: `px-2 py-1 text-sm font-medium uppercase tracking-wider transition-colors no-drag ${
                        collectionTab === tab.key
                          ? 'text-white'
                          : 'text-white/60 hover:text-white'
                      }`
                    }, tab.label)
                  ]).flat().filter(Boolean)
                ),
                // Start Collection Station button (pink, matching Artist page)
                React.createElement('button', {
                  onClick: () => console.log('Start Collection Station - placeholder'),
                  className: 'mt-6 px-6 py-2 rounded-full font-medium text-white no-drag transition-all hover:scale-105',
                  style: {
                    backgroundColor: '#E91E63',
                    boxShadow: '0 4px 15px rgba(233, 30, 99, 0.4)'
                  }
                }, 'Start Collection Station')
              ),
            // COLLAPSED STATE - Inline layout matching Recommendations
            collectionHeaderCollapsed && React.createElement('div', {
              className: 'absolute inset-0 flex items-center px-6 z-10',
              style: {
                opacity: collectionHeaderCollapsed ? 1 : 0,
                transition: 'opacity 300ms ease-out'
              }
            },
                // Left: Title
                React.createElement('h1', {
                  className: 'text-2xl font-light text-white mr-6',
                  style: {
                    textShadow: '0 2px 10px rgba(0,0,0,0.5)',
                    letterSpacing: '0.2em',
                    textTransform: 'uppercase'
                  }
                }, 'COLLECTION'),
                // Tabs (next to title, like artist page)
                React.createElement('div', {
                  className: 'flex items-center gap-1',
                  style: { textShadow: '0 1px 10px rgba(0,0,0,0.5)' }
                },
                  [
                    { key: 'artists', label: `${collectionData.artists.length} Artists` },
                    { key: 'albums', label: `${collectionData.albums.length} Albums` },
                    { key: 'tracks', label: `${library.length + collectionData.tracks.length} Songs` },
                    { key: 'friends', label: `${friends.length} Friends` }
                  ].map((tab, index) => [
                    index > 0 && React.createElement('span', {
                      key: `sep-collapsed-${tab.key}`,
                      className: 'text-white/50 mx-2'
                    }, '|'),
                    React.createElement('button', {
                      key: `collapsed-${tab.key}`,
                      onClick: () => setCollectionTab(tab.key),
                      className: `px-2 py-1 text-sm font-medium uppercase tracking-wider transition-colors no-drag ${
                        collectionTab === tab.key
                          ? 'text-white'
                          : 'text-white/60 hover:text-white'
                      }`
                    }, tab.label)
                  ]).flat().filter(Boolean)
                ),
                // Right: Start Collection Station button
                React.createElement('button', {
                  onClick: () => console.log('Start Collection Station - placeholder'),
                  className: 'ml-auto px-4 py-1.5 rounded-full text-sm font-medium text-white transition-colors hover:opacity-90',
                  style: {
                    backgroundColor: '#E91E63'
                  }
                }, 'Start Station')
              )
          ),
          // Scrollable content area
          React.createElement('div', {
            className: 'flex-1 overflow-y-auto scrollable-content',
            style: { minHeight: 0 },
            onScroll: (e) => {
              const scrollTop = e.target.scrollTop;
              if (scrollTop > 50 && !collectionHeaderCollapsed) {
                setCollectionHeaderCollapsed(true);
              } else if (scrollTop <= 50 && collectionHeaderCollapsed) {
                setCollectionHeaderCollapsed(false);
              }
            }
          },
            // Sticky filter bar
            React.createElement('div', {
              className: 'sticky top-0 z-10 flex items-center px-6 py-3 bg-white border-b border-gray-200'
            },
              // Sort dropdown (moved to left)
              React.createElement('div', { className: 'relative' },
                React.createElement('button', {
                  onClick: (e) => { e.stopPropagation(); setCollectionSortDropdownOpen(!collectionSortDropdownOpen); },
                  className: 'flex items-center gap-1 px-3 py-1.5 text-sm text-gray-500 hover:text-gray-700 transition-colors'
                },
                  React.createElement('span', null, getCollectionSortOptions(collectionTab).find(o => o.value === collectionSort[collectionTab])?.label || 'Sort'),
                  React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M19 9l-7 7-7-7' })
                  )
                ),
                // Dropdown menu
                collectionSortDropdownOpen && React.createElement('div', {
                  className: 'absolute left-0 top-full mt-1 bg-white rounded-lg shadow-lg py-1 min-w-[160px] z-30 border border-gray-200'
                },
                  getCollectionSortOptions(collectionTab).map(option =>
                    React.createElement('button', {
                      key: option.value,
                      onClick: (e) => {
                        e.stopPropagation();
                        setCollectionSort(prev => ({ ...prev, [collectionTab]: option.value }));
                        setCollectionSortDropdownOpen(false);
                      },
                      className: `w-full px-4 py-2 text-left text-sm hover:bg-gray-100 flex items-center justify-between ${
                        collectionSort[collectionTab] === option.value ? 'text-gray-900 font-medium' : 'text-gray-600'
                      }`
                    },
                      option.label,
                      collectionSort[collectionTab] === option.value && React.createElement('svg', {
                        className: 'w-4 h-4',
                        fill: 'none',
                        viewBox: '0 0 24 24',
                        stroke: 'currentColor'
                      },
                        React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M5 13l4 4L19 7' })
                      )
                    )
                  )
                )
              ),
              // Spacer
              React.createElement('div', { className: 'flex-1' }),
              // Search toggle/field
              React.createElement('div', { className: 'flex items-center' },
                collectionSearchOpen ?
                  React.createElement('div', { className: 'flex items-center border border-gray-300 rounded-full px-3 py-1.5' },
                    React.createElement('input', {
                      type: 'text',
                      value: collectionSearch,
                      onChange: (e) => setCollectionSearch(e.target.value),
                      onBlur: () => {
                        if (!collectionSearch.trim()) {
                          setCollectionSearchOpen(false);
                        }
                      },
                      autoFocus: true,
                      placeholder: 'Filter...',
                      className: 'bg-transparent text-gray-700 text-sm placeholder-gray-400 outline-none',
                      style: { width: '150px' }
                    }),
                    collectionSearch && React.createElement('button', {
                      onClick: () => {
                        setCollectionSearch('');
                        setCollectionSearchOpen(false);
                      },
                      className: 'ml-2 text-gray-400 hover:text-gray-600'
                    },
                      React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                        React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M6 18L18 6M6 6l12 12' })
                      )
                    )
                  )
                :
                  React.createElement('button', {
                    onClick: () => setCollectionSearchOpen(true),
                    className: 'p-1.5 text-gray-400 hover:text-gray-600 transition-colors'
                  },
                    React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                      React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' })
                    )
                  )
              )
            ),
            // Content with padding
            React.createElement('div', { className: 'p-6' },
              // Artists tab
            collectionTab === 'artists' && (() => {
              const filtered = filterCollectionItems(collectionData.artists, 'artists');
              const sorted = sortCollectionItems(filtered, 'artists');

              if (sorted.length === 0 && collectionSearch) {
                return React.createElement('div', { className: 'flex-1 flex flex-col items-center justify-center text-gray-400 py-20' },
                  React.createElement('p', { className: 'text-lg font-medium text-gray-500' }, 'No artists match your search')
                );
              }

              if (sorted.length === 0) {
                return React.createElement('div', { className: 'flex-1 flex flex-col items-center justify-center text-gray-400 py-20' },
                  React.createElement('svg', { className: 'w-16 h-16 mb-4 text-gray-300', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 1.5, d: 'M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z' })
                  ),
                  React.createElement('p', { className: 'text-lg font-medium text-gray-500 mb-2' }, 'No artists yet'),
                  React.createElement('p', { className: 'text-sm text-gray-400' }, 'Drag artists here to add them to your collection')
                );
              }

              return React.createElement('div', {
                className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4',
                style: { minHeight: 'calc(100vh - 160px)' }  // Ensure enough scroll area to prevent header bounce
              },
                sorted.map(artist =>
                  React.createElement(CollectionArtistCard, {
                    key: artist.name,
                    artist: { ...artist, trackCount: 0 },
                    getArtistImage: getArtistImage,
                    onNavigate: () => fetchArtistData(artist.name)
                  })
                )
              );
            })(),

            // Albums tab
            collectionTab === 'albums' && (() => {
              const filtered = filterCollectionItems(collectionData.albums, 'albums');
              const sorted = sortCollectionItems(filtered, 'albums');

              if (sorted.length === 0 && collectionSearch) {
                return React.createElement('div', { className: 'flex-1 flex flex-col items-center justify-center text-gray-400 py-20' },
                  React.createElement('p', { className: 'text-lg font-medium text-gray-500' }, 'No albums match your search')
                );
              }

              if (sorted.length === 0) {
                return React.createElement('div', { className: 'flex-1 flex flex-col items-center justify-center text-gray-400 py-20' },
                  React.createElement('svg', { className: 'w-16 h-16 mb-4 text-gray-300', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 1.5, d: 'M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3' })
                  ),
                  React.createElement('p', { className: 'text-lg font-medium text-gray-500 mb-2' }, 'No albums yet'),
                  React.createElement('p', { className: 'text-sm text-gray-400' }, 'Drag albums here to add them to your collection')
                );
              }

              return React.createElement('div', {
                className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4',
                style: { minHeight: 'calc(100vh - 160px)' }  // Ensure enough scroll area to prevent header bounce
              },
                sorted.map((album, index) =>
                  React.createElement(CollectionAlbumCard, {
                    key: `${album.title}-${album.artist}-${index}`,
                    album: { ...album, trackCount: 0 },
                    getAlbumArt: getAlbumArt,
                    onNavigate: () => handleCollectionAlbumClick(album)
                  })
                )
              );
            })(),

            // Tracks tab (existing implementation with filter/sort applied)
            collectionTab === 'tracks' && (() => {
              if (libraryLoading) {
                // Skeleton loaders while loading
                return React.createElement('div', { className: 'space-y-0' },
                  Array.from({ length: 8 }).map((_, index) =>
                    React.createElement('div', {
                      key: `skeleton-${index}`,
                      className: 'flex items-center gap-4 py-2 px-3 border-b border-gray-100'
                    },
                      // Track number skeleton
                      React.createElement('div', {
                        className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer',
                        style: { width: '32px', flexShrink: 0 }
                      }),
                      // Title skeleton
                      React.createElement('div', {
                        className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer',
                        style: { width: '360px', flexShrink: 0, animationDelay: '0.1s' }
                      }),
                      // Artist skeleton (wider)
                      React.createElement('div', {
                        className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer',
                        style: { width: '220px', flexShrink: 0, animationDelay: '0.2s' }
                      }),
                      // Album skeleton (narrower)
                      React.createElement('div', {
                        className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer',
                        style: { width: '150px', flexShrink: 0, animationDelay: '0.3s' }
                      }),
                      // Spacer
                      React.createElement('div', { className: 'flex-1' }),
                      // Duration skeleton
                      React.createElement('div', {
                        className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer mr-4',
                        style: { width: '50px', flexShrink: 0, animationDelay: '0.4s' }
                      }),
                      // Resolver icons skeleton
                      React.createElement('div', {
                        className: 'flex items-center gap-1',
                        style: { width: '120px', flexShrink: 0 }
                      },
                        React.createElement('div', {
                          className: 'w-6 h-6 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer',
                          style: { animationDelay: '0.5s' }
                        }),
                        React.createElement('div', {
                          className: 'w-6 h-6 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer',
                          style: { animationDelay: '0.6s' }
                        })
                      )
                    )
                  )
                );
              }

              // Merge local files with collection tracks
              const allTracks = [...library, ...collectionData.tracks];

              // Deduplicate by id
              const trackMap = new Map();
              allTracks.forEach(track => {
                const trackId = track.id || `${track.artist || 'unknown'}-${track.title || 'untitled'}-${track.album || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
                if (!trackMap.has(trackId)) {
                  trackMap.set(trackId, { ...track, id: trackId });
                }
              });

              const mergedTracks = Array.from(trackMap.values());

              const filtered = filterCollectionItems(mergedTracks, 'tracks');
              const sorted = sortCollectionItems(filtered, 'tracks');

              if (sorted.length === 0 && collectionSearch) {
                return React.createElement('div', { className: 'text-center py-12 text-gray-400' },
                  React.createElement('svg', { className: 'w-12 h-12 mx-auto mb-4 text-gray-300', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 1.5, d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' })
                  ),
                  React.createElement('div', { className: 'text-sm' }, 'No tracks match your search')
                );
              }

              if (sorted.length === 0) {
                return React.createElement('div', { className: 'flex-1 flex flex-col items-center justify-center text-gray-400 py-20' },
                  React.createElement('svg', { className: 'w-16 h-16 mb-4 text-gray-300', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 1.5, d: 'M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3' })
                  ),
                  React.createElement('p', { className: 'text-lg font-medium text-gray-500 mb-2' }, 'No tracks yet'),
                  React.createElement('p', { className: 'text-sm text-gray-400' }, 'Drag tracks here or add local music folders in Settings')
                );
              }

              return React.createElement('div', {
                className: 'space-y-0',
                style: { minHeight: 'calc(100vh - 160px)' }  // Ensure enough scroll area to prevent header bounce
              },
                sorted.map((track, index) => {
                  // Use track's own sources (updated by resolution)
                  const effectiveSources = track.sources || {};
                  const hasResolved = Object.keys(effectiveSources).length > 0;
                  const isCurrentTrack = currentTrack?.id === track.id || (currentTrack?.filePath && track.filePath && currentTrack.filePath === track.filePath);
                  const isNowPlaying = isCurrentTrack && playbackContext?.type === 'library';
                  const trackKey = track.filePath || track.id;
                  const isResolving = resolvingLibraryTracks.has(trackKey);

                  return React.createElement('div', {
                    key: track.id || track.filePath || index,
                    className: `flex items-center gap-4 py-2 px-3 border-b border-gray-100 hover:bg-gray-50 cursor-pointer transition-colors no-drag group ${
                      isNowPlaying && isPlaying ? 'bg-purple-50' : ''
                    }`,
                    onClick: () => {
                      const tracksAfter = sorted.slice(index + 1);
                      const context = { type: 'library', name: 'Collection' };
                      setQueueWithContext(tracksAfter, context);
                      handlePlay(track);
                    },
                    onContextMenu: (e) => {
                      e.preventDefault();
                      if (window.electron?.contextMenu?.showTrackMenu) {
                        window.electron.contextMenu.showTrackMenu({
                          type: 'track',
                          track: track
                        });
                      }
                    }
                  },
                    // Track number or playing indicator
                    React.createElement('span', {
                      className: `text-sm flex-shrink-0 text-right ${isNowPlaying && isPlaying ? 'text-purple-500' : 'text-gray-400'}`,
                      style: { pointerEvents: 'none', width: '32px' }
                    }, isNowPlaying && isPlaying ? 'â–¶' : String(index + 1).padStart(2, '0')),

                    // Track title - fixed width column (font-medium for emphasis)
                    React.createElement('span', {
                      className: `text-sm font-medium truncate transition-colors ${isNowPlaying && isPlaying ? 'text-purple-600' : 'text-gray-900 group-hover:text-gray-900'}`,
                      style: { pointerEvents: 'none', width: '360px', flexShrink: 0 }
                    }, track.title),

                    // Artist name - fixed width column, clickable (wider)
                    React.createElement('span', {
                      className: 'text-sm text-gray-500 truncate hover:text-purple-600 hover:underline cursor-pointer transition-colors',
                      style: { width: '220px', flexShrink: 0 },
                      onClick: (e) => {
                        e.stopPropagation();
                        fetchArtistData(track.artist);
                      }
                    }, track.artist || 'Unknown Artist'),

                    // Album name - fixed width column (narrower), clickable
                    track.album ? React.createElement('span', {
                      className: 'text-sm text-gray-500 truncate hover:text-purple-600 hover:underline cursor-pointer transition-colors',
                      style: { width: '150px', flexShrink: 0 },
                      onClick: (e) => {
                        e.stopPropagation();
                        openChartsAlbum({ artist: track.artist, title: track.album, albumArt: track.albumArt });
                      }
                    }, track.album) : React.createElement('span', {
                      className: 'text-sm text-gray-500 truncate',
                      style: { pointerEvents: 'none', width: '150px', flexShrink: 0 }
                    }, ''),

                    // Spacer to push duration and resolvers to the right
                    React.createElement('div', { className: 'flex-1' }),

                    // Duration - right-justified before resolver icons
                    React.createElement('span', {
                      className: 'text-sm text-gray-400 text-right tabular-nums mr-4',
                      style: { pointerEvents: 'none', width: '50px', flexShrink: 0, marginLeft: 'auto' }
                    }, formatTime(track.duration)),

                    // Resolver icons - fixed width column (last column)
                    React.createElement('div', {
                      className: 'flex items-center gap-1 justify-end',
                      style: { width: '120px', flexShrink: 0, minHeight: '24px' }
                    },
                      (() => {
                        const sources = effectiveSources;
                        const sourceIds = Object.keys(sources);
                        const hasExternalSources = sourceIds.some(id => id !== 'localfiles');

                        if (hasExternalSources) {
                          // Show all resolver icons (including LO)
                          return Object.entries(sources)
                            .sort(([aId], [bId]) => {
                              const aIndex = resolverOrder.indexOf(aId);
                              const bIndex = resolverOrder.indexOf(bId);
                              return aIndex - bIndex;
                            })
                            .map(([resolverId, source]) => {
                              const resolver = allResolvers.find(r => r.id === resolverId);
                              if (!resolver) return null;
                              return React.createElement('button', {
                                key: resolverId,
                                className: 'no-drag',
                                onClick: (e) => {
                                  e.stopPropagation();
                                  const tracksAfter = sorted.slice(index + 1);
                                  const context = { type: 'library', name: 'Collection' };
                                  setQueueWithContext(tracksAfter, context);
                                  handlePlay({ ...track, preferredResolver: resolverId });
                                },
                                style: {
                                  width: '24px',
                                  height: '24px',
                                  borderRadius: '4px',
                                  backgroundColor: resolver.color,
                                  border: 'none',
                                  cursor: 'pointer',
                                  display: 'flex',
                                  alignItems: 'center',
                                  justifyContent: 'center',
                                  pointerEvents: 'auto',
                                  opacity: (source.confidence || 1) > 0.8 ? 1 : 0.6,
                                  transition: 'transform 0.1s'
                                },
                                onMouseEnter: (e) => e.currentTarget.style.transform = 'scale(1.1)',
                                onMouseLeave: (e) => e.currentTarget.style.transform = 'scale(1)',
                                title: `Play from ${resolver.name}${source.confidence ? ` (${Math.round(source.confidence * 100)}% match)` : ''}`
                              }, React.createElement(ResolverIcon, { resolverId, size: 14 }));
                            });
                        } else if (isResolving) {
                          // Show shimmer skeletons while resolving (for both local and collection tracks)
                          const localFilesResolver = allResolvers.find(r => r.id === 'localfiles');
                          return React.createElement('div', { className: 'flex items-center gap-1' },
                            // LO icon only for local files
                            track.filePath && localFilesResolver && React.createElement('button', {
                              key: 'localfiles',
                              className: 'no-drag',
                              onClick: (e) => {
                                e.stopPropagation();
                                const tracksAfter = sorted.slice(index + 1);
                                const context = { type: 'library', name: 'Collection' };
                                setQueueWithContext(tracksAfter, context);
                                handlePlay({ ...track, preferredResolver: 'localfiles' });
                              },
                              style: {
                                width: '24px',
                                height: '24px',
                                borderRadius: '4px',
                                backgroundColor: localFilesResolver.color,
                                border: 'none',
                                cursor: 'pointer',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                fontSize: '10px',
                                fontWeight: 'bold',
                                color: 'white',
                                pointerEvents: 'auto',
                                transition: 'transform 0.1s'
                              },
                              onMouseEnter: (e) => e.currentTarget.style.transform = 'scale(1.1)',
                              onMouseLeave: (e) => e.currentTarget.style.transform = 'scale(1)',
                              title: 'Play from Local Files'
                            }, 'LO'),
                            // Shimmer skeletons
                            React.createElement('div', {
                              className: 'w-6 h-6 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer',
                              title: 'Resolving...'
                            }),
                            React.createElement('div', {
                              className: 'w-6 h-6 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer',
                              style: { animationDelay: '0.1s' }
                            })
                          );
                        } else if (track.filePath) {
                          // Show just the LO icon for local tracks that finished resolving without finding external sources
                          const localFilesResolver = allResolvers.find(r => r.id === 'localfiles');
                          if (!localFilesResolver) return null;
                          return React.createElement('button', {
                            key: 'localfiles',
                            className: 'no-drag',
                            onClick: (e) => {
                              e.stopPropagation();
                              const tracksAfter = sorted.slice(index + 1);
                              const context = { type: 'library', name: 'Collection' };
                              setQueueWithContext(tracksAfter, context);
                              handlePlay({ ...track, preferredResolver: 'localfiles' });
                            },
                            style: {
                              width: '24px',
                              height: '24px',
                              borderRadius: '4px',
                              backgroundColor: localFilesResolver.color,
                              border: 'none',
                              cursor: 'pointer',
                              display: 'flex',
                              alignItems: 'center',
                              justifyContent: 'center',
                              fontSize: '10px',
                              fontWeight: 'bold',
                              color: 'white',
                              pointerEvents: 'auto',
                              transition: 'transform 0.1s'
                            },
                            onMouseEnter: (e) => e.currentTarget.style.transform = 'scale(1.1)',
                            onMouseLeave: (e) => e.currentTarget.style.transform = 'scale(1)',
                            title: 'Play from Local Files'
                          }, 'LO');
                        }
                        return null;
                      })()
                    )
                  );
                })
              );
            })(),

            // Friends tab
            collectionTab === 'friends' && (() => {
              // Only show friends saved to collection (savedToCollection !== false for backwards compatibility)
              const savedFriends = friends.filter(f => f.savedToCollection !== false);

              // Sort friends
              const sortedFriends = [...savedFriends].sort((a, b) => {
                const sort = collectionSort.friends;
                if (sort === 'alpha-asc') return a.displayName.localeCompare(b.displayName);
                if (sort === 'alpha-desc') return b.displayName.localeCompare(a.displayName);
                if (sort === 'recent') return b.addedAt - a.addedAt;
                if (sort === 'on-air') {
                  const aOnAir = isOnAir(a);
                  const bOnAir = isOnAir(b);
                  if (aOnAir && !bOnAir) return -1;
                  if (!aOnAir && bOnAir) return 1;
                  // Secondary sort by most recent activity
                  const aTime = a.cachedRecentTrack?.timestamp || 0;
                  const bTime = b.cachedRecentTrack?.timestamp || 0;
                  return bTime - aTime;
                }
                return 0;
              });

              // Filter by search
              const filtered = collectionSearch
                ? sortedFriends.filter(f =>
                    f.displayName.toLowerCase().includes(collectionSearch.toLowerCase()) ||
                    f.username.toLowerCase().includes(collectionSearch.toLowerCase())
                  )
                : sortedFriends;

              // Filter to only on-air if that sort is selected
              const displayFriends = collectionSort.friends === 'on-air'
                ? filtered.filter(f => isOnAir(f))
                : filtered;

              if (displayFriends.length === 0 && collectionSearch) {
                return React.createElement('div', { className: 'flex-1 flex flex-col items-center justify-center text-gray-400 py-20' },
                  React.createElement('p', { className: 'text-lg font-medium text-gray-500' }, 'No friends match your search')
                );
              }

              if (displayFriends.length === 0 && collectionSort.friends === 'on-air') {
                return React.createElement('div', { className: 'flex-1 flex flex-col items-center justify-center text-gray-400 py-20' },
                  React.createElement('svg', { className: 'w-16 h-16 mb-4 text-gray-300', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 1.5, d: 'M5.636 18.364a9 9 0 010-12.728m12.728 0a9 9 0 010 12.728m-9.9-2.829a5 5 0 010-7.07m7.072 0a5 5 0 010 7.07M13 12a1 1 0 11-2 0 1 1 0 012 0z' })
                  ),
                  React.createElement('p', { className: 'text-lg font-medium text-gray-500 mb-2' }, 'No friends on air right now'),
                  React.createElement('p', { className: 'text-sm text-gray-400' }, 'Check back later to see who\'s listening')
                );
              }

              if (savedFriends.length === 0) {
                return React.createElement('div', { className: 'flex-1 flex flex-col items-center justify-center text-gray-400 py-20' },
                  React.createElement('svg', { className: 'w-16 h-16 mb-4 text-gray-300', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 1.5, d: 'M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z' })
                  ),
                  React.createElement('p', { className: 'text-lg font-medium text-gray-500 mb-2' }, 'No friends in collection'),
                  React.createElement('p', { className: 'text-sm text-gray-400 mb-4' }, 'Add friends to your collection to see them here'),
                  React.createElement('button', {
                    onClick: () => setAddFriendModalOpen(true),
                    className: 'px-4 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded-lg text-sm font-medium transition-colors'
                  }, 'Add Friend')
                );
              }

              return React.createElement('div', {
                style: { minHeight: 'calc(100vh - 160px)' }  // Ensure enough scroll area to prevent header bounce
              },
                // Add Friend button
                React.createElement('div', { className: 'mb-4 flex justify-end' },
                  React.createElement('button', {
                    onClick: () => setAddFriendModalOpen(true),
                    className: 'px-4 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded-lg text-sm font-medium transition-colors flex items-center gap-2'
                  },
                    React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                      React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M12 4v16m8-8H4' })
                    ),
                    'Add Friend'
                  )
                ),
                // Grid of friend cards - matching Related Artists style
                React.createElement('div', {
                  className: 'grid gap-x-4 gap-y-8',
                  style: { gridTemplateColumns: 'repeat(auto-fill, minmax(160px, 1fr))' }
                },
                  displayFriends.map(friend => {
                    const onAir = isOnAir(friend);
                    const isPinned = pinnedFriendIds.includes(friend.id);

                    return React.createElement('div', {
                      key: friend.id,
                      className: 'flex flex-col items-center cursor-pointer group',
                      draggable: true,
                      onDragStart: (e) => {
                        e.dataTransfer.setData('friendId', friend.id);
                        e.dataTransfer.effectAllowed = 'copy';
                      },
                      onClick: () => navigateToFriend(friend),
                      onContextMenu: (e) => {
                        e.preventDefault();
                        if (window.electron?.contextMenu?.showTrackMenu) {
                          window.electron.contextMenu.showTrackMenu({
                            type: 'friend',
                            friend: friend,
                            isPinned: isPinned,
                            isSavedToCollection: friend.savedToCollection
                          });
                        }
                      }
                    },
                      // Hexagonal avatar with zoom on hover
                      React.createElement('div', { className: 'relative' },
                        React.createElement('div', {
                          className: 'w-36 h-36 overflow-hidden',
                          style: {
                            clipPath: 'polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%)'
                          }
                        },
                          React.createElement('div', {
                            className: `w-full h-full group-hover:scale-110 transition-transform duration-300 ${
                              friend.avatarUrl ? '' : 'bg-gradient-to-br from-purple-400 to-pink-400'
                            }`,
                            style: friend.avatarUrl ? {
                              backgroundImage: `url(${friend.avatarUrl})`,
                              backgroundSize: 'cover',
                              backgroundPosition: 'center'
                            } : {}
                          },
                            // Show initial if no avatar
                            !friend.avatarUrl && React.createElement('div', {
                              className: 'w-full h-full flex items-center justify-center text-3xl font-medium text-white'
                            }, friend.displayName.charAt(0).toUpperCase())
                          )
                        ),
                        // On-air indicator
                        onAir && React.createElement('div', {
                          className: 'absolute -bottom-1 right-4 w-5 h-5 bg-green-500 rounded-full border-2 border-white'
                        })
                      ),
                      // Name and info
                      React.createElement('span', {
                        className: 'mt-3 text-sm font-medium text-gray-700 text-center truncate w-full group-hover:text-purple-600 transition-colors'
                      }, friend.displayName),
                      // Service badge
                      React.createElement('div', {
                        className: `inline-flex items-center gap-1 mt-1 px-2 py-0.5 rounded-full text-xs ${
                          friend.service === 'lastfm' ? 'bg-red-100 text-red-700' : 'bg-orange-100 text-orange-700'
                        }`
                      }, friend.service === 'lastfm' ? 'Last.fm' : 'ListenBrainz'),
                      // Current track if on-air
                      onAir && friend.cachedRecentTrack && React.createElement('div', {
                        className: 'mt-1 text-xs text-gray-500 truncate text-center max-w-full'
                      },
                        React.createElement('span', { className: 'text-green-600' }, '\u266A '),
                        `${friend.cachedRecentTrack.name}`
                      )
                    );
                  })
                )
              );
            })()
            )
          )
        ),

        activeView === 'friends' && React.createElement('div', {
          className: 'text-center py-12 text-gray-400'
        }, 'ðŸ‘¥ Connect with friends to see what they\'re listening to'),

        // Charts view with collapsible hero header (matching Artist page pattern)
        activeView === 'discover' && React.createElement('div', {
          className: 'flex-1 flex flex-col h-full',
          style: { overflow: 'hidden', minHeight: 0 }
        },
          // Header section (outside scrollable area)
          React.createElement('div', {
            className: 'relative',
            style: {
              height: chartsHeaderCollapsed ? '80px' : '320px',
              flexShrink: 0,
              transition: 'height 300ms ease-out',
              overflow: 'hidden'
            }
          },
              // Gradient background
              React.createElement('div', {
                className: 'absolute inset-0 bg-gradient-to-br from-orange-500 via-pink-500 to-purple-600'
              }),
              // Background pattern
              React.createElement('div', {
                className: 'absolute inset-0',
                style: {
                  opacity: 0.15,
                  backgroundImage: 'url("data:image/svg+xml,%3Csvg width=\'60\' height=\'60\' viewBox=\'0 0 60 60\' xmlns=\'http://www.w3.org/2000/svg\'%3E%3Cg fill=\'none\' fill-rule=\'evenodd\'%3E%3Cg fill=\'%23ffffff\' fill-opacity=\'0.4\'%3E%3Cpath d=\'M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z\'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E")'
                }
              }),
              // EXPANDED STATE - Centered content
              !chartsHeaderCollapsed && React.createElement('div', {
                className: 'absolute inset-0 flex flex-col items-center justify-center text-center px-6 z-10',
                style: {
                  opacity: chartsHeaderCollapsed ? 0 : 1,
                  transition: 'opacity 300ms ease-out'
                }
              },
                React.createElement('h1', {
                  className: 'text-5xl font-light text-white',
                  style: {
                    textShadow: '0 2px 20px rgba(0,0,0,0.5)',
                    letterSpacing: '0.3em',
                    textTransform: 'uppercase'
                  }
                }, 'POP OF THE TOPS'),
                React.createElement('div', {
                  className: 'flex items-center gap-1 mt-6',
                  style: { textShadow: '0 1px 10px rgba(0,0,0,0.5)' }
                },
                  React.createElement('span', {
                    className: 'px-2 py-1 text-sm font-medium uppercase tracking-wider text-white'
                  }, `${charts.length} Albums`)
                ),
                React.createElement('p', {
                  className: 'mt-2 text-white/80 text-sm'
                }, 'Top 50 most played albums on Apple Music')
              ),
              // COLLAPSED STATE - Inline layout
              chartsHeaderCollapsed && React.createElement('div', {
                className: 'absolute inset-0 flex items-center px-6 z-10',
                style: {
                  opacity: chartsHeaderCollapsed ? 1 : 0,
                  transition: 'opacity 300ms ease-out'
                }
              },
                React.createElement('h1', {
                  className: 'text-2xl font-light text-white',
                  style: {
                    textShadow: '0 2px 10px rgba(0,0,0,0.5)',
                    letterSpacing: '0.2em',
                    textTransform: 'uppercase'
                  }
                }, 'POP OF THE TOPS'),
                React.createElement('div', { className: 'flex-1' }),
                React.createElement('span', {
                  className: 'text-sm font-medium uppercase tracking-wider text-white/80'
                }, `${charts.length} Albums`)
              )
          ),
          // Filter bar (outside scrollable area)
          React.createElement('div', {
            className: 'flex items-center px-6 py-3 bg-white border-b border-gray-200',
            style: { flexShrink: 0 }
          },
            // Sort dropdown
              React.createElement('div', { className: 'relative' },
                React.createElement('button', {
                  onClick: (e) => { e.stopPropagation(); setChartsSortDropdownOpen(!chartsSortDropdownOpen); },
                  className: 'flex items-center gap-1 px-3 py-1.5 text-sm text-gray-500 hover:text-gray-700 transition-colors'
                },
                  React.createElement('span', null, chartsSortOptions.find(o => o.value === chartsSort)?.label || 'Sort'),
                  React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M19 9l-7 7-7-7' })
                  )
                ),
                chartsSortDropdownOpen && React.createElement('div', {
                  className: 'absolute left-0 top-full mt-1 bg-white rounded-lg shadow-lg py-1 min-w-[160px] z-30 border border-gray-200'
                },
                  chartsSortOptions.map(option =>
                    React.createElement('button', {
                      key: option.value,
                      onClick: (e) => {
                        e.stopPropagation();
                        setChartsSort(option.value);
                        setChartsSortDropdownOpen(false);
                      },
                      className: `w-full px-4 py-2 text-left text-sm hover:bg-gray-100 flex items-center justify-between ${
                        chartsSort === option.value ? 'text-gray-900 font-medium' : 'text-gray-600'
                      }`
                    },
                      option.label,
                      chartsSort === option.value && React.createElement('svg', {
                        className: 'w-4 h-4',
                        fill: 'none',
                        viewBox: '0 0 24 24',
                        stroke: 'currentColor'
                      },
                        React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M5 13l4 4L19 7' })
                      )
                    )
                  )
                )
              ),
              React.createElement('div', { className: 'flex-1' }),
              // Search
              React.createElement('div', { className: 'flex items-center' },
                chartsSearchOpen ?
                  React.createElement('div', { className: 'flex items-center border border-gray-300 rounded-full px-3 py-1.5' },
                    React.createElement('input', {
                      type: 'text',
                      value: chartsSearch,
                      onChange: (e) => setChartsSearch(e.target.value),
                      onBlur: () => { if (!chartsSearch.trim()) setChartsSearchOpen(false); },
                      autoFocus: true,
                      placeholder: 'Filter...',
                      className: 'bg-transparent text-gray-700 text-sm placeholder-gray-400 outline-none',
                      style: { width: '150px' }
                    }),
                    chartsSearch && React.createElement('button', {
                      onClick: () => { setChartsSearch(''); setChartsSearchOpen(false); },
                      className: 'ml-2 text-gray-400 hover:text-gray-600'
                    },
                      React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                        React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M6 18L18 6M6 6l12 12' })
                      )
                    )
                  )
                :
                  React.createElement('button', {
                    onClick: () => setChartsSearchOpen(true),
                    className: 'p-1.5 text-gray-400 hover:text-gray-600 transition-colors'
                  },
                    React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                      React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' })
                    )
                  )
              )
          ),
          // Content area (scrollable)
          React.createElement('div', {
            className: 'scrollable-content',
            style: {
              flex: 1,
              overflowY: 'scroll',
              pointerEvents: 'auto',
              padding: '24px'
            },
            onScroll: handleChartsScroll
          },
            // Skeleton loading state - show when loading OR when charts haven't been loaded yet
            (chartsLoading || !chartsLoaded) && React.createElement('div', {
              className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4 pb-6'
            },
              Array.from({ length: 15 }).map((_, i) =>
                React.createElement('div', { key: `skeleton-${i}` },
                  // Skeleton album art
                  React.createElement('div', {
                    className: 'aspect-square rounded-lg mb-3 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                    style: { backgroundSize: '200% 100%', animationDelay: `${i * 50}ms` }
                  }),
                  // Skeleton title
                  React.createElement('div', { className: 'space-y-2' },
                    React.createElement('div', {
                      className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-3/4 animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 25}ms` }
                    }),
                    React.createElement('div', {
                      className: 'h-3 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-1/2 animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 50}ms` }
                    })
                  )
                )
              )
            ),

            // Albums grid with filter/sort - only show when loaded and not loading
            chartsLoaded && !chartsLoading && (() => {
              const filtered = filterCharts(charts);
              const sorted = sortCharts(filtered);

              if (sorted.length === 0 && chartsSearch) {
                return React.createElement('div', { className: 'text-center py-12 text-gray-400' },
                  React.createElement('svg', { className: 'w-12 h-12 mx-auto mb-4 text-gray-300', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 1.5, d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' })
                  ),
                  React.createElement('div', { className: 'text-sm' }, 'No albums match your search')
                );
              }

              if (sorted.length === 0) {
                return React.createElement('div', { className: 'text-center py-12 text-gray-400' },
                  React.createElement('div', { className: 'text-sm' }, 'No chart data available')
                );
              }

              return React.createElement('div', {
                className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4 pb-6'
              },
                sorted.map(album =>
                React.createElement('div', {
                  key: album.id,
                  className: 'group cursor-pointer',
                  onMouseEnter: () => prefetchChartsTracks(album),
                  onClick: () => openChartsAlbum(album)
                },
                  // Album art with hover overlay
                  // States: shimmer (fetching or loading image), placeholder (no art)
                  React.createElement('div', {
                    className: `aspect-square rounded-lg overflow-hidden mb-3 relative ${
                      // Purple gradient for failed lookups (null) - shows placeholder icon
                      album.albumArt === null
                        ? 'bg-gradient-to-br from-purple-500 to-pink-500'
                        // Shimmer while fetching OR while image loads from URL
                        : 'bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer'
                    }`,
                    style: album.albumArt === null ? {} : { backgroundSize: '200% 100%' }
                  },
                    // Placeholder - only show when no art (null or missing)
                    !album.albumArt && album.albumArt !== undefined && React.createElement('div', {
                      className: 'absolute inset-0 flex items-center justify-center text-white/60'
                    },
                      React.createElement('svg', { className: 'w-16 h-16', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor', strokeWidth: 1 },
                        React.createElement('circle', { cx: 12, cy: 12, r: 10 }),
                        React.createElement('circle', { cx: 12, cy: 12, r: 3 }),
                        React.createElement('circle', { cx: 12, cy: 12, r: 6, strokeDasharray: '2 2' })
                      )
                    ),
                    album.albumArt && typeof album.albumArt === 'string' && React.createElement('img', {
                      src: album.albumArt,
                      alt: album.title,
                      className: 'absolute inset-0 w-full h-full object-cover group-hover:scale-105 transition-opacity duration-300',
                      style: { opacity: 0 },
                      ref: (el) => { if (el && el.complete && el.naturalWidth > 0) el.style.opacity = '1'; },
                      onLoad: (e) => { e.target.style.opacity = '1'; },
                      onError: (e) => { e.target.style.display = 'none'; }
                    }),
                    // Rank badge
                    React.createElement('div', {
                      className: 'absolute top-2 right-2 px-2 py-1 rounded bg-black/70 text-white text-xs font-bold'
                    }, `#${album.rank}`),
                    // Hover overlay with Add to Queue button
                    React.createElement('div', {
                      className: 'absolute inset-0 bg-black/60 opacity-0 group-hover:opacity-100 transition-opacity duration-200 flex items-center justify-center'
                    },
                      React.createElement('button', {
                        onClick: (e) => {
                          e.stopPropagation();
                          addChartsToQueue(album);
                        },
                        className: 'bg-white text-gray-900 px-4 py-2 rounded-full text-sm font-medium hover:bg-gray-100 transition-colors flex items-center gap-2 shadow-lg'
                      },
                        React.createElement('svg', {
                          className: 'w-4 h-4',
                          fill: 'none',
                          viewBox: '0 0 24 24',
                          stroke: 'currentColor'
                        },
                          React.createElement('path', {
                            strokeLinecap: 'round',
                            strokeLinejoin: 'round',
                            strokeWidth: 2,
                            d: 'M12 4v16m8-8H4'
                          })
                        ),
                        'Add to Queue'
                      )
                    )
                  ),
                  // Album info
                  React.createElement('div', { className: 'space-y-1' },
                    React.createElement('div', {
                      className: 'font-medium text-gray-900 truncate group-hover:text-purple-600 transition-colors'
                    }, album.title),
                    React.createElement('div', {
                      className: 'text-sm text-gray-500 truncate hover:text-purple-600 hover:underline cursor-pointer transition-colors',
                      onClick: (e) => {
                        e.stopPropagation();
                        fetchArtistData(album.artist);
                      }
                    }, album.artist)
                  )
                )
              )
              );
            })()
          )
        ),

        // New Releases view with hero
        activeView === 'new-releases' && React.createElement('div', {
          className: 'h-full overflow-y-auto scrollable-content'
        },
          // Hero section
          React.createElement('div', {
            className: 'relative h-64 bg-gradient-to-br from-emerald-500 via-teal-500 to-cyan-600 overflow-hidden'
          },
            // Background pattern - sparkles
            React.createElement('div', {
              className: 'absolute inset-0 opacity-30',
              style: {
                backgroundImage: 'url("data:image/svg+xml,%3Csvg width=\'100\' height=\'100\' viewBox=\'0 0 100 100\' xmlns=\'http://www.w3.org/2000/svg\'%3E%3Cg fill=\'%23ffffff\'%3E%3Ccircle cx=\'25\' cy=\'25\' r=\'2\'/%3E%3Ccircle cx=\'75\' cy=\'25\' r=\'1.5\'/%3E%3Ccircle cx=\'50\' cy=\'50\' r=\'2.5\'/%3E%3Ccircle cx=\'25\' cy=\'75\' r=\'1.5\'/%3E%3Ccircle cx=\'75\' cy=\'75\' r=\'2\'/%3E%3Ccircle cx=\'10\' cy=\'50\' r=\'1\'/%3E%3Ccircle cx=\'90\' cy=\'50\' r=\'1\'/%3E%3C/g%3E%3C/svg%3E")'
              }
            }),
            // Hero content
            React.createElement('div', {
              className: 'absolute inset-0 flex items-end p-8'
            },
              React.createElement('div', null,
                React.createElement('div', {
                  className: 'inline-flex items-center gap-2 px-3 py-1 bg-white/20 backdrop-blur-sm rounded-full text-white/90 text-sm mb-3'
                },
                  React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z' })
                  ),
                  'Fresh Music'
                ),
                React.createElement('h1', { className: 'text-4xl font-light text-white mb-2', style: { letterSpacing: '0.2em', textTransform: 'uppercase' } }, 'NEW RELEASES'),
                React.createElement('p', { className: 'text-white/80 text-lg' }, 'The latest albums and singles, just dropped')
              )
            )
          ),
          // Placeholder content
          React.createElement('div', { className: 'p-6' },
            React.createElement('div', { className: 'text-center py-12 text-gray-400' },
              React.createElement('div', { className: 'text-5xl mb-4' }, 'âœ¨'),
              React.createElement('div', { className: 'text-lg font-medium text-gray-600 mb-2' }, 'New Releases Coming Soon'),
              React.createElement('div', { className: 'text-sm' }, 'Stay tuned for the freshest music')
            )
          )
        ),

        // Critic's Picks view with collapsible hero header (matching Artist page pattern)
        activeView === 'critics-picks' && React.createElement('div', {
          className: 'flex-1 flex flex-col h-full',
          style: { overflow: 'hidden', minHeight: 0 }
        },
          // Header section (outside scrollable area)
          React.createElement('div', {
            className: 'relative',
            style: {
              height: criticsHeaderCollapsed ? '80px' : '320px',
              flexShrink: 0,
              transition: 'height 300ms ease-out',
              overflow: 'hidden'
            }
          },
              // Gradient background
              React.createElement('div', {
                className: 'absolute inset-0 bg-gradient-to-br from-amber-500 via-orange-500 to-red-500'
              }),
              // Background pattern
              React.createElement('div', {
                className: 'absolute inset-0',
                style: {
                  opacity: 0.15,
                  backgroundImage: 'url("data:image/svg+xml,%3Csvg width=\'80\' height=\'80\' viewBox=\'0 0 80 80\' xmlns=\'http://www.w3.org/2000/svg\'%3E%3Cg fill=\'%23ffffff\'%3E%3Cpath d=\'M40 5l4.5 13.8h14.5l-11.7 8.5 4.5 13.8L40 32.6l-11.8 8.5 4.5-13.8-11.7-8.5h14.5z\'/%3E%3C/g%3E%3C/svg%3E")'
                }
              }),
              // EXPANDED STATE - Centered content
              !criticsHeaderCollapsed && React.createElement('div', {
                className: 'absolute inset-0 flex flex-col items-center justify-center text-center px-6 z-10',
                style: {
                  opacity: criticsHeaderCollapsed ? 0 : 1,
                  transition: 'opacity 300ms ease-out'
                }
              },
                React.createElement('h1', {
                  className: 'text-5xl font-light text-white',
                  style: {
                    textShadow: '0 2px 20px rgba(0,0,0,0.5)',
                    letterSpacing: '0.3em',
                    textTransform: 'uppercase'
                  }
                }, 'CRITICAL DARLINGS'),
                React.createElement('div', {
                  className: 'flex items-center gap-1 mt-6',
                  style: { textShadow: '0 1px 10px rgba(0,0,0,0.5)' }
                },
                  React.createElement('span', {
                    className: 'px-2 py-1 text-sm font-medium uppercase tracking-wider text-white'
                  }, `${criticsPicks.length} Albums`)
                ),
                React.createElement('p', {
                  className: 'mt-2 text-white/80 text-sm'
                }, 'Top-rated albums from leading music publications')
              ),
              // COLLAPSED STATE - Inline layout
              criticsHeaderCollapsed && React.createElement('div', {
                className: 'absolute inset-0 flex items-center px-6 z-10',
                style: {
                  opacity: criticsHeaderCollapsed ? 1 : 0,
                  transition: 'opacity 300ms ease-out'
                }
              },
                React.createElement('h1', {
                  className: 'text-2xl font-light text-white',
                  style: {
                    textShadow: '0 2px 10px rgba(0,0,0,0.5)',
                    letterSpacing: '0.2em',
                    textTransform: 'uppercase'
                  }
                }, 'CRITICAL DARLINGS'),
                React.createElement('div', { className: 'flex-1' }),
                React.createElement('span', {
                  className: 'text-sm font-medium uppercase tracking-wider text-white/80'
                }, `${criticsPicks.length} Albums`)
              )
          ),
          // Filter bar (outside scrollable area)
          React.createElement('div', {
            className: 'flex items-center px-6 py-3 bg-white border-b border-gray-200',
            style: { flexShrink: 0 }
          },
            // Sort dropdown
              React.createElement('div', { className: 'relative' },
                React.createElement('button', {
                  onClick: (e) => { e.stopPropagation(); setCriticsSortDropdownOpen(!criticsSortDropdownOpen); },
                  className: 'flex items-center gap-1 px-3 py-1.5 text-sm text-gray-500 hover:text-gray-700 transition-colors'
                },
                  React.createElement('span', null, criticsSortOptions.find(o => o.value === criticsSort)?.label || 'Sort'),
                  React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M19 9l-7 7-7-7' })
                  )
                ),
                criticsSortDropdownOpen && React.createElement('div', {
                  className: 'absolute left-0 top-full mt-1 bg-white rounded-lg shadow-lg py-1 min-w-[160px] z-30 border border-gray-200'
                },
                  criticsSortOptions.map(option =>
                    React.createElement('button', {
                      key: option.value,
                      onClick: (e) => {
                        e.stopPropagation();
                        setCriticsSort(option.value);
                        setCriticsSortDropdownOpen(false);
                      },
                      className: `w-full px-4 py-2 text-left text-sm hover:bg-gray-100 flex items-center justify-between ${
                        criticsSort === option.value ? 'text-gray-900 font-medium' : 'text-gray-600'
                      }`
                    },
                      option.label,
                      criticsSort === option.value && React.createElement('svg', {
                        className: 'w-4 h-4',
                        fill: 'none',
                        viewBox: '0 0 24 24',
                        stroke: 'currentColor'
                      },
                        React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M5 13l4 4L19 7' })
                      )
                    )
                  )
                )
              ),
              React.createElement('div', { className: 'flex-1' }),
              // Search
              React.createElement('div', { className: 'flex items-center' },
                criticsSearchOpen ?
                  React.createElement('div', { className: 'flex items-center border border-gray-300 rounded-full px-3 py-1.5' },
                    React.createElement('input', {
                      type: 'text',
                      value: criticsSearch,
                      onChange: (e) => setCriticsSearch(e.target.value),
                      onBlur: () => { if (!criticsSearch.trim()) setCriticsSearchOpen(false); },
                      autoFocus: true,
                      placeholder: 'Filter...',
                      className: 'bg-transparent text-gray-700 text-sm placeholder-gray-400 outline-none',
                      style: { width: '150px' }
                    }),
                    criticsSearch && React.createElement('button', {
                      onClick: () => { setCriticsSearch(''); setCriticsSearchOpen(false); },
                      className: 'ml-2 text-gray-400 hover:text-gray-600'
                    },
                      React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                        React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M6 18L18 6M6 6l12 12' })
                      )
                    )
                  )
                :
                  React.createElement('button', {
                    onClick: () => setCriticsSearchOpen(true),
                    className: 'p-1.5 text-gray-400 hover:text-gray-600 transition-colors'
                  },
                    React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                      React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' })
                    )
                  )
              )
          ),
          // Content area (scrollable)
          React.createElement('div', {
            className: 'scrollable-content',
            style: {
              flex: 1,
              overflowY: 'scroll',
              pointerEvents: 'auto',
              padding: '24px'
            },
            onScroll: handleCriticsScroll
          },
            // Skeleton loading state - show when loading OR when critics picks haven't been loaded yet
            (criticsPicksLoading || !criticsPicksLoaded) && React.createElement('div', {
              className: 'space-y-4 pb-6'
            },
            Array.from({ length: 8 }).map((_, i) =>
              React.createElement('div', {
                key: `skeleton-${i}`,
                className: 'flex gap-5 p-4 bg-white rounded-xl border border-gray-100'
              },
                // Skeleton album art
                React.createElement('div', {
                  className: 'w-28 h-28 flex-shrink-0 rounded-lg bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                  style: { backgroundSize: '200% 100%', animationDelay: `${i * 50}ms` }
                }),
                // Skeleton content
                React.createElement('div', { className: 'flex-1 space-y-3 py-1' },
                  React.createElement('div', {
                    className: 'h-5 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-2/5 animate-shimmer',
                    style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 25}ms` }
                  }),
                  React.createElement('div', {
                    className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-1/4 animate-shimmer',
                    style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 50}ms` }
                  }),
                  React.createElement('div', { className: 'space-y-2 pt-2' },
                    React.createElement('div', {
                      className: 'h-3 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-full animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 75}ms` }
                    }),
                    React.createElement('div', {
                      className: 'h-3 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-4/5 animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 100}ms` }
                    })
                  )
                )
              )
            )
          ),

          // Albums grid with filter/sort - only show when loaded and not loading
          criticsPicksLoaded && !criticsPicksLoading && (() => {
            const filtered = filterCriticsPicks(criticsPicks);
            const sorted = sortCriticsPicks(filtered);

            if (sorted.length === 0 && criticsSearch) {
              return React.createElement('div', { className: 'text-center py-12 text-gray-400' },
                React.createElement('svg', { className: 'w-12 h-12 mx-auto mb-4 text-gray-300', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                  React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 1.5, d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' })
                ),
                React.createElement('div', { className: 'text-sm' }, 'No albums match your search')
              );
            }

            if (sorted.length === 0) {
              return React.createElement('div', { className: 'text-center py-12 text-gray-400' },
                React.createElement('div', { className: 'text-sm' }, 'No critic picks available')
              );
            }

            return React.createElement('div', {
              className: 'space-y-4 pb-6'
            },
              sorted.map(album =>
              React.createElement('div', {
                key: album.id,
                className: 'group flex gap-5 p-4 bg-white rounded-xl border border-gray-100 hover:border-purple-200 hover:shadow-md transition-all cursor-grab active:cursor-grabbing',
                draggable: true,
                onDragStart: (e) => {
                  e.dataTransfer.effectAllowed = 'copy';
                  const albumData = {
                    type: 'album',
                    album: {
                      id: album.id,
                      title: album.title,
                      artist: album.artist,
                      year: album.pubDate ? album.pubDate.getFullYear() : null,
                      art: album.albumArt || null
                    }
                  };
                  e.dataTransfer.setData('text/plain', JSON.stringify(albumData));
                },
                onMouseEnter: () => prefetchCriticsPicksTracks(album),
                onClick: () => openCriticsPicksAlbum(album)
              },
                // Album art - left column
                // States: undefined = loading (shimmer), null = no art (placeholder), string = has art
                React.createElement('div', {
                  className: `w-28 h-28 flex-shrink-0 rounded-lg overflow-hidden relative ${
                    album.albumArt === null
                      ? 'bg-gradient-to-br from-purple-500 to-pink-500'
                      : album.albumArt === undefined
                        ? 'bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer'
                        : 'bg-gray-100'
                  }`,
                  style: album.albumArt === undefined ? { backgroundSize: '200% 100%' } : {}
                },
                  // Placeholder icon - only show when art fetch completed with no result (null)
                  album.albumArt === null && React.createElement('div', {
                    className: 'absolute inset-0 flex items-center justify-center text-white/60'
                  },
                    React.createElement('svg', { className: 'w-12 h-12', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor', strokeWidth: 1 },
                      React.createElement('circle', { cx: 12, cy: 12, r: 10 }),
                      React.createElement('circle', { cx: 12, cy: 12, r: 3 }),
                      React.createElement('circle', { cx: 12, cy: 12, r: 6, strokeDasharray: '2 2' })
                    )
                  ),
                  // Image - show when we have a URL string
                  typeof album.albumArt === 'string' && React.createElement('img', {
                    src: album.albumArt,
                    alt: album.title,
                    className: 'absolute inset-0 w-full h-full object-cover group-hover:scale-105 transition-all duration-300',
                    style: { opacity: 0 },
                    ref: (el) => { if (el && el.complete && el.naturalWidth > 0) el.style.opacity = '1'; },
                    onLoad: (e) => { e.target.style.opacity = '1'; },
                    onError: (e) => { e.target.style.display = 'none'; }
                  }),
                  // Play overlay on hover
                  React.createElement('div', {
                    className: 'absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity duration-200 flex items-center justify-center'
                  },
                    React.createElement('button', {
                      onClick: (e) => {
                        e.stopPropagation();
                        addCriticsPicksToQueue(album);
                      },
                      className: 'w-10 h-10 bg-white rounded-full flex items-center justify-center shadow-lg hover:scale-110 transition-transform'
                    },
                      React.createElement('svg', {
                        className: 'w-5 h-5 text-gray-900 ml-0.5',
                        fill: 'currentColor',
                        viewBox: '0 0 24 24'
                      },
                        React.createElement('path', { d: 'M8 5v14l11-7z' })
                      )
                    )
                  )
                ),
                // Album info - right column
                React.createElement('div', { className: 'flex-1 min-w-0 flex flex-col justify-center' },
                  React.createElement('div', {
                    className: 'font-semibold text-gray-900 truncate group-hover:text-purple-600 transition-colors text-lg'
                  }, album.title),
                  React.createElement('div', {
                    className: 'text-sm text-gray-500 truncate hover:text-purple-600 hover:underline cursor-pointer transition-colors mt-0.5',
                    onClick: (e) => {
                      e.stopPropagation();
                      fetchArtistData(album.artist);
                    }
                  }, album.artist),
                  // Synopsis
                  album.description && React.createElement('p', {
                    className: 'text-sm text-gray-600 mt-2 line-clamp-2 leading-relaxed'
                  }, album.description)
                )
              )
            )
            );
          })()
          )
        ),

        // Recommendations view with collapsible hero header
        activeView === 'recommendations' && React.createElement('div', {
          className: 'flex-1 flex flex-col h-full',
          style: { overflow: 'hidden', minHeight: 0 }
        },
          // Header section (outside scrollable area)
          React.createElement('div', {
            className: 'relative',
            style: {
              height: recommendationsHeaderCollapsed ? '80px' : '320px',
              flexShrink: 0,
              transition: 'height 300ms ease-out',
              overflow: 'hidden'
            }
          },
            // Gradient background - purple/indigo theme for recommendations
            React.createElement('div', {
              className: 'absolute inset-0 bg-gradient-to-br from-indigo-500 via-purple-500 to-pink-500'
            }),
            // Background pattern - stars for recommendations
            React.createElement('div', {
              className: 'absolute inset-0',
              style: {
                opacity: 0.15,
                backgroundImage: 'url("data:image/svg+xml,%3Csvg width=\'80\' height=\'80\' viewBox=\'0 0 80 80\' xmlns=\'http://www.w3.org/2000/svg\'%3E%3Cg fill=\'%23ffffff\'%3E%3Cpath d=\'M40 5l4.5 13.8h14.5l-11.7 8.5 4.5 13.8L40 32.6l-11.8 8.5 4.5-13.8-11.7-8.5h14.5z\'/%3E%3C/g%3E%3C/svg%3E")'
              }
            }),
            // EXPANDED STATE - Centered content
            !recommendationsHeaderCollapsed && React.createElement('div', {
              className: 'absolute inset-0 flex flex-col items-center justify-center text-center px-6 z-10',
              style: {
                opacity: recommendationsHeaderCollapsed ? 0 : 1,
                transition: 'opacity 300ms ease-out'
              }
            },
              React.createElement('h1', {
                className: 'text-5xl font-light text-white',
                style: {
                  textShadow: '0 2px 20px rgba(0,0,0,0.5)',
                  letterSpacing: '0.3em',
                  textTransform: 'uppercase'
                }
              }, 'RECOMMENDATIONS'),
              // Tabs in expanded state
              React.createElement('div', {
                className: 'flex items-center gap-1 mt-6',
                style: { textShadow: '0 1px 10px rgba(0,0,0,0.5)' }
              },
                [
                  { key: 'artists', label: `${recommendations.artists.length} Artists` },
                  { key: 'songs', label: `${recommendations.tracks.length} Songs` }
                ].map((tab, index) => [
                  index > 0 && React.createElement('span', {
                    key: `sep-expanded-${tab.key}`,
                    className: 'text-white/50 mx-2'
                  }, '|'),
                  React.createElement('button', {
                    key: `expanded-${tab.key}`,
                    onClick: () => setRecommendationsTab(tab.key),
                    className: `px-2 py-1 text-sm font-medium uppercase tracking-wider transition-colors no-drag ${
                      recommendationsTab === tab.key
                        ? 'text-white'
                        : 'text-white/60 hover:text-white'
                    }`
                  }, tab.label)
                ]).flat().filter(Boolean)
              ),
              React.createElement('p', {
                className: 'mt-2 text-white/70 text-sm'
              }, metaServiceConfigs.listenbrainz?.username
                ? `Personalized picks for ${metaServiceConfigs.listenbrainz.username}`
                : metaServiceConfigs.lastfm?.username
                  ? `Personalized picks for ${metaServiceConfigs.lastfm.username}`
                  : 'Connect your Last.fm or ListenBrainz account to get started'
              )
            ),
            // COLLAPSED STATE - Inline layout matching artist page
            recommendationsHeaderCollapsed && React.createElement('div', {
              className: 'absolute inset-0 flex items-center px-6 z-10',
              style: {
                opacity: recommendationsHeaderCollapsed ? 1 : 0,
                transition: 'opacity 300ms ease-out'
              }
            },
              // Left: Title
              React.createElement('h1', {
                className: 'text-2xl font-light text-white mr-6',
                style: {
                  textShadow: '0 2px 10px rgba(0,0,0,0.5)',
                  letterSpacing: '0.2em',
                  textTransform: 'uppercase'
                }
              }, 'RECOMMENDATIONS'),
              // Tabs (next to title, like artist page)
              React.createElement('div', {
                className: 'flex items-center gap-1',
                style: { textShadow: '0 1px 10px rgba(0,0,0,0.5)' }
              },
                [
                  { key: 'artists', label: `${recommendations.artists.length} Artists` },
                  { key: 'songs', label: `${recommendations.tracks.length} Songs` }
                ].map((tab, index) => [
                  index > 0 && React.createElement('span', {
                    key: `sep-collapsed-${tab.key}`,
                    className: 'text-white/50 mx-2'
                  }, '|'),
                  React.createElement('button', {
                    key: `collapsed-${tab.key}`,
                    onClick: () => setRecommendationsTab(tab.key),
                    className: `px-2 py-1 text-sm font-medium uppercase tracking-wider transition-colors no-drag ${
                      recommendationsTab === tab.key
                        ? 'text-white'
                        : 'text-white/60 hover:text-white'
                    }`
                  }, tab.label)
                ]).flat().filter(Boolean)
              )
            )
          ),
          // Scrollable content area
          (() => {
            // Check if both services are configured (show filter bar even while loading)
            const hasBothServicesConfigured = metaServiceConfigs.listenbrainz?.username && metaServiceConfigs.lastfm?.username;

            // Compute filtered recommendations data
            const listenbrainzTrackCount = recommendations.tracks.filter(t => t.source === 'listenbrainz').length;
            const lastfmTrackCount = recommendations.tracks.filter(t => t.source === 'lastfm').length;
            const hasBothSourcesWithData = listenbrainzTrackCount > 0 && lastfmTrackCount > 0;

            // Filter tracks based on source filter
            const filteredTracks = recommendationsSourceFilter === 'all'
              ? recommendations.tracks
              : recommendations.tracks.filter(t => t.source === recommendationsSourceFilter);

            // Get unique artists from filtered tracks
            const filteredArtistNames = new Set(filteredTracks.map(t => t.artist));
            const filteredArtists = recommendations.artists.filter(a => filteredArtistNames.has(a.name));

            return React.createElement('div', {
              className: 'flex-1 overflow-y-auto scrollable-content',
              onScroll: (e) => {
                const scrollTop = e.target.scrollTop;
                if (scrollTop > 50 && !recommendationsHeaderCollapsed) {
                  setRecommendationsHeaderCollapsed(true);
                } else if (scrollTop <= 50 && recommendationsHeaderCollapsed) {
                  setRecommendationsHeaderCollapsed(false);
                }
              }
            },
              // Sticky filter bar - show when both services are configured (even during loading)
              hasBothServicesConfigured && React.createElement('div', {
                className: 'sticky top-0 z-10 flex items-center px-6 py-3 bg-white border-b border-gray-200'
              },
                // Source filter pills
                React.createElement('div', { className: 'flex gap-2' },
                  [
                    { value: 'all', label: 'All', count: recommendations.tracks.length },
                    { value: 'listenbrainz', label: 'ListenBrainz', count: listenbrainzTrackCount },
                    { value: 'lastfm', label: 'Last.fm', count: lastfmTrackCount }
                  ].map(({ value, label, count }) =>
                    React.createElement('button', {
                      key: value,
                      onClick: () => setRecommendationsSourceFilter(value),
                      className: `px-3 py-1.5 rounded-full text-sm transition-all no-drag ${
                        recommendationsSourceFilter === value
                          ? value === 'listenbrainz' ? 'bg-indigo-600 text-white'
                            : value === 'lastfm' ? 'bg-red-600 text-white'
                            : 'bg-purple-600 text-white'
                          : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                      }`
                    }, recommendations.loading ? label : `${label} (${count})`)
                  )
                )
              ),
              // Content with padding
              React.createElement('div', { className: 'p-6' },
                // Loading state - show skeleton for active tab
                recommendations.loading ?
              React.createElement('div', null,
                // Artists skeleton (when artists tab active)
                recommendationsTab === 'artists' && React.createElement('div', {
                  className: 'grid gap-x-4 gap-y-8',
                  style: { gridTemplateColumns: 'repeat(auto-fill, minmax(160px, 1fr))' }
                },
                  ...Array(12).fill(null).map((_, i) =>
                    React.createElement('div', { key: `rec-artist-skeleton-${i}`, className: 'flex flex-col items-center' },
                      React.createElement('div', { className: 'w-36 h-36 rounded-full bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer', style: { backgroundSize: '200% 100%' } }),
                      React.createElement('div', { className: 'w-24 h-4 mt-3 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer rounded', style: { backgroundSize: '200% 100%' } })
                    )
                  )
                ),
                // Songs skeleton (when songs tab active)
                recommendationsTab === 'songs' && React.createElement('div', { className: 'space-y-0' },
                  ...Array(15).fill(null).map((_, i) =>
                    React.createElement('div', {
                      key: `rec-track-skeleton-${i}`,
                      className: 'flex items-center gap-4 py-2 px-3 border-b border-gray-100'
                    },
                      React.createElement('div', {
                        className: 'w-8 h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                        style: { backgroundSize: '200% 100%', animationDelay: `${i * 50}ms` }
                      }),
                      React.createElement('div', {
                        className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                        style: { width: '360px', backgroundSize: '200% 100%', animationDelay: `${i * 50 + 25}ms` }
                      }),
                      React.createElement('div', {
                        className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                        style: { width: '240px', backgroundSize: '200% 100%', animationDelay: `${i * 50 + 50}ms` }
                      }),
                      React.createElement('div', {
                        className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                        style: { width: '50px', backgroundSize: '200% 100%', animationDelay: `${i * 50 + 75}ms` }
                      }),
                      React.createElement('div', {
                        className: 'flex gap-1 ml-auto',
                        style: { width: '100px' }
                      },
                        React.createElement('div', {
                          className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                          style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 100}ms` }
                        }),
                        React.createElement('div', {
                          className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                          style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 125}ms` }
                        })
                      )
                    )
                  )
                )
              )
            // Not configured state
            : recommendations.error === 'not_configured' ?
              React.createElement('div', { className: 'text-center py-16' },
                React.createElement('div', {
                  className: 'w-20 h-20 mx-auto mb-6 rounded-full bg-gray-100 flex items-center justify-center'
                },
                  React.createElement('svg', { className: 'w-10 h-10 text-gray-400', fill: 'currentColor', viewBox: '0 0 24 24' },
                    React.createElement('path', { d: 'M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z' })
                  )
                ),
                React.createElement('h3', {
                  className: 'text-xl font-medium text-gray-900 mb-2'
                }, 'Connect a music service'),
                React.createElement('p', { className: 'text-gray-500 mb-6 max-w-md mx-auto' },
                  'Get personalized music recommendations based on your listening history. Connect your Last.fm or ListenBrainz account to get started.'
                ),
                React.createElement('div', { className: 'flex gap-3 justify-center' },
                  React.createElement('button', {
                    onClick: () => {
                      setActiveView('settings');
                      setSettingsTab('installed');
                      // Find and select the ListenBrainz service
                      const listenbrainzService = metaServices.find(s => s.id === 'listenbrainz');
                      if (listenbrainzService) {
                        setSelectedResolver(listenbrainzService);
                      }
                    },
                    className: 'px-6 py-3 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors font-medium'
                  }, 'Connect ListenBrainz'),
                  React.createElement('button', {
                    onClick: () => {
                      setActiveView('settings');
                      setSettingsTab('installed');
                      // Find and select the Last.fm service
                      const lastfmService = metaServices.find(s => s.id === 'lastfm');
                      if (lastfmService) {
                        setSelectedResolver(lastfmService);
                      }
                    },
                    className: 'px-6 py-3 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors font-medium'
                  }, 'Connect Last.fm')
                )
              )
            // Other error state
            : recommendations.error ?
              React.createElement('div', { className: 'text-center py-12' },
                React.createElement('div', { className: 'text-gray-400 mb-4' }, recommendations.error),
                React.createElement('button', {
                  onClick: loadRecommendations,
                  className: 'px-4 py-2 bg-gray-900 text-white rounded-lg hover:bg-gray-800 transition-colors'
                }, 'Try Again')
              )
            // Results - show content based on active tab
            : React.createElement('div', null,
                // Artists tab content - grid matching Top Artists style
                recommendationsTab === 'artists' && filteredArtists.length > 0 && React.createElement('div', {
                  className: 'grid gap-x-4 gap-y-8',
                  style: { gridTemplateColumns: 'repeat(auto-fill, minmax(160px, 1fr))' }
                },
                  ...filteredArtists.map((artist) =>
                    React.createElement('div', {
                      key: artist.id,
                      className: 'flex flex-col items-center cursor-grab active:cursor-grabbing group',
                      draggable: true,
                      onDragStart: (e) => {
                        e.dataTransfer.effectAllowed = 'copy';
                        e.dataTransfer.setData('text/plain', JSON.stringify({
                          type: 'artist',
                          artist: {
                            id: artist.id,
                            name: artist.name,
                            image: artist.image
                          }
                        }));
                      },
                      onClick: () => fetchArtistData(artist.name),
                      onContextMenu: (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        if (window.electron?.contextMenu?.showTrackMenu) {
                          window.electron.contextMenu.showTrackMenu({
                            type: 'artist',
                            artist: {
                              id: artist.id,
                              name: artist.name,
                              image: artist.image
                            }
                          });
                        }
                      }
                    },
                      React.createElement('div', {
                        className: 'relative w-36 h-36 rounded-full overflow-hidden'
                      },
                        React.createElement('div', {
                          // Show shimmer while loading, purple gradient when loaded but no image, image when available
                          className: `w-full h-full group-hover:scale-110 transition-transform duration-300 ${
                            artist.image ? '' : !artist.imageLoaded ? 'bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer' : 'bg-gradient-to-br from-purple-500 to-pink-500'
                          }`,
                          style: artist.image ? {
                            backgroundImage: `url(${artist.image})`,
                            backgroundSize: 'cover',
                            backgroundPosition: 'center'
                          } : !artist.imageLoaded ? {
                            backgroundSize: '200% 100%'
                          } : {}
                        })
                      ),
                      React.createElement('span', {
                        className: 'mt-3 text-sm font-medium text-gray-700 text-center truncate w-full group-hover:text-purple-600 transition-colors'
                      }, artist.name)
                    )
                  )
                ),

                // Artists tab empty state
                recommendationsTab === 'artists' && filteredArtists.length === 0 && React.createElement('div', {
                  className: 'text-center py-12 text-gray-400'
                }, recommendationsSourceFilter !== 'all' ? `No artists from ${recommendationsSourceFilter === 'listenbrainz' ? 'ListenBrainz' : 'Last.fm'}.` : 'No recommended artists found.'),

                // Songs tab content - track list table
                recommendationsTab === 'songs' && filteredTracks.length > 0 && React.createElement('div', { className: 'space-y-0' },
                  ...filteredTracks.map((track, index) => {
                      const hasResolved = Object.keys(track.sources || {}).length > 0;
                      const isResolving = Object.keys(track.sources || {}).length === 0;

                      return React.createElement('div', {
                        key: track.id,
                        draggable: true,
                        onDragStart: (e) => {
                          setDraggingTrackForPlaylist(track); // Enable playlist drop target
                          e.dataTransfer.effectAllowed = 'copy';
                          e.dataTransfer.setData('text/plain', JSON.stringify({
                            type: 'track',
                            track: {
                              id: track.id,
                              title: track.title,
                              artist: track.artist,
                              duration: track.duration,
                              sources: track.sources || {}
                            }
                          }));
                        },
                        onDragEnd: () => {
                          setDraggingTrackForPlaylist(null);
                          setDropTargetPlaylistId(null);
                          setDropTargetNewPlaylist(false);
                          // Close panel if it was opened by drag and nothing was dropped
                          if (addToPlaylistPanel.open && selectedPlaylistsForAdd.length === 0) {
                            setAddToPlaylistPanel(prev => ({ ...prev, open: false }));
                          }
                        },
                        className: `flex items-center gap-4 py-2 px-3 border-b border-gray-100 hover:bg-gray-50 cursor-grab active:cursor-grabbing transition-colors group ${
                          isResolving ? 'opacity-60' : ''
                        }`,
                        onClick: () => {
                          // Set remaining tracks as queue and play this track
                          const tracksAfter = filteredTracks.slice(index + 1);
                          const context = { type: 'recommendations', name: 'Recommendations' };
                          setQueueWithContext(tracksAfter, context);
                          handlePlay(track);
                        },
                        onContextMenu: (e) => {
                          e.preventDefault();
                          if (window.electron?.contextMenu?.showTrackMenu) {
                            window.electron.contextMenu.showTrackMenu({
                              type: 'track',
                              track: track
                            });
                          }
                        }
                      },
                        // Track number
                        React.createElement('span', {
                          className: 'text-sm text-gray-400 flex-shrink-0 text-right',
                          style: { pointerEvents: 'none', width: '32px' }
                        }, String(index + 1).padStart(2, '0')),

                        // Track title - fixed width column (font-medium for emphasis)
                        React.createElement('span', {
                          className: `text-sm font-medium truncate transition-colors ${hasResolved ? 'text-gray-900 group-hover:text-gray-900' : 'text-gray-500'}`,
                          style: { pointerEvents: 'none', width: '360px', flexShrink: 0 }
                        }, track.title),

                        // Artist name - fixed width column, clickable
                        React.createElement('span', {
                          className: 'text-sm text-gray-500 truncate hover:text-purple-600 hover:underline cursor-pointer transition-colors',
                          style: { width: '240px', flexShrink: 0 },
                          onClick: (e) => {
                            e.stopPropagation();
                            fetchArtistData(track.artist);
                          }
                        }, track.artist),

                        // Duration - fixed width column
                        React.createElement('span', {
                          className: 'text-sm text-gray-400 text-right tabular-nums',
                          style: { pointerEvents: 'none', width: '50px', flexShrink: 0, marginLeft: 'auto' }
                        }, formatTime(track.duration)),

                        // Resolver icons - fixed width column
                        React.createElement('div', {
                          className: 'flex items-center gap-1 justify-end',
                          style: { width: '100px', flexShrink: 0, minHeight: '24px' }
                        },
                          isResolving ?
                            React.createElement('div', {
                              className: 'flex items-center gap-1'
                            },
                              React.createElement('div', {
                                className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer',
                                title: 'Resolving track...'
                              }),
                              React.createElement('div', {
                                className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer',
                                style: { animationDelay: '0.1s' }
                              })
                            )
                          : hasResolved ?
                            Object.entries(track.sources)
                              .sort(([aId], [bId]) => {
                                const aIndex = resolverOrder.indexOf(aId);
                                const bIndex = resolverOrder.indexOf(bId);
                                return aIndex - bIndex;
                              })
                              .map(([resolverId, source]) => {
                                const resolver = allResolvers.find(r => r.id === resolverId);
                                if (!resolver || !resolver.play) return null;
                                return React.createElement('button', {
                                  key: resolverId,
                                  className: 'no-drag',
                                  onClick: (e) => {
                                    e.stopPropagation();
                                    const tracksAfter = recommendations.tracks.slice(index + 1);
                                    const context = { type: 'recommendations', name: 'Recommendations' };
                                    setQueueWithContext(tracksAfter, context);
                                    handlePlay({ ...track, preferredResolver: resolverId });
                                  },
                                  style: {
                                    width: '24px',
                                    height: '24px',
                                    borderRadius: '4px',
                                    backgroundColor: resolver.color,
                                    border: 'none',
                                    cursor: 'pointer',
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    pointerEvents: 'auto',
                                    opacity: (source.confidence || 0) > 0.8 ? 1 : 0.6,
                                    transition: 'transform 0.1s'
                                  },
                                  onMouseEnter: (e) => e.currentTarget.style.transform = 'scale(1.1)',
                                  onMouseLeave: (e) => e.currentTarget.style.transform = 'scale(1)',
                                  title: `Play from ${resolver.name}${source.confidence ? ` (${Math.round(source.confidence * 100)}% match)` : ''}`
                                }, React.createElement(ResolverIcon, { resolverId, size: 14 }));
                              })
                          :
                            // Show shimmer skeletons while resolving
                            React.createElement('div', {
                              className: 'flex items-center gap-1'
                            },
                              React.createElement('div', {
                                className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer',
                                title: 'Resolving track...'
                              }),
                              React.createElement('div', {
                                className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer',
                                style: { animationDelay: '0.1s' }
                              })
                            )
                        )
                      );
                    })
                ),

                // Songs tab empty state
                recommendationsTab === 'songs' && filteredTracks.length === 0 && React.createElement('div', {
                  className: 'text-center py-12 text-gray-400'
                }, recommendationsSourceFilter !== 'all' ? `No songs from ${recommendationsSourceFilter === 'listenbrainz' ? 'ListenBrainz' : 'Last.fm'}.` : 'No recommended songs found.')
              )
            )
          );
          })()
        ),

        // History view with collapsible hero header and tabs
        activeView === 'history' && React.createElement('div', {
          className: 'flex-1 flex flex-col h-full',
          style: { overflow: 'hidden', minHeight: 0 }
        },
          // Header section (outside scrollable area)
          React.createElement('div', {
            className: 'relative',
            style: {
              height: historyHeaderCollapsed ? '80px' : '320px',
              flexShrink: 0,
              transition: 'height 300ms ease-out',
              overflow: 'hidden'
            }
          },
            // Gradient background - blue/cyan theme for history
            React.createElement('div', {
              className: 'absolute inset-0 bg-gradient-to-br from-cyan-500 via-blue-500 to-indigo-600'
            }),
            // Background pattern - clock/time icons
            React.createElement('div', {
              className: 'absolute inset-0',
              style: {
                opacity: 0.15,
                backgroundImage: 'url("data:image/svg+xml,%3Csvg width=\'60\' height=\'60\' viewBox=\'0 0 60 60\' xmlns=\'http://www.w3.org/2000/svg\'%3E%3Cg fill=\'none\' stroke=\'%23ffffff\' stroke-width=\'1.5\'%3E%3Ccircle cx=\'30\' cy=\'30\' r=\'12\'/%3E%3Cpath d=\'M30 22v8l5 5\'/%3E%3C/g%3E%3C/svg%3E")'
              }
            }),
            // EXPANDED STATE - Centered content with tabs
            !historyHeaderCollapsed && React.createElement('div', {
              className: 'absolute inset-0 flex flex-col items-center justify-center text-center px-6 z-10',
              style: {
                opacity: historyHeaderCollapsed ? 0 : 1,
                transition: 'opacity 300ms ease-out'
              }
            },
              React.createElement('h1', {
                className: 'text-5xl font-light text-white',
                style: {
                  textShadow: '0 2px 20px rgba(0,0,0,0.5)',
                  letterSpacing: '0.3em',
                  textTransform: 'uppercase'
                }
              }, 'HISTORY'),
              // Tabs in expanded state
              React.createElement('div', {
                className: 'flex items-center gap-1 mt-6',
                style: { textShadow: '0 1px 10px rgba(0,0,0,0.5)' }
              },
                [
                  { key: 'topTracks', label: 'Top Songs' },
                  { key: 'topAlbums', label: 'Top Albums' },
                  { key: 'topArtists', label: 'Top Artists' },
                  { key: 'recent', label: 'Recently Played' }
                ].map((tab, i, arr) => React.createElement(React.Fragment, { key: tab.key },
                  i > 0 && React.createElement('span', {
                    className: 'text-white/50 mx-2'
                  }, '|'),
                  React.createElement('button', {
                    onClick: () => {
                      setHistoryTab(tab.key);
                      if (tab.key === 'recent') loadListeningHistory();
                      else if (tab.key === 'topTracks') loadTopTracks();
                      else if (tab.key === 'topArtists') loadTopArtists();
                      else if (tab.key === 'topAlbums') loadTopAlbums();
                    },
                    className: `px-2 py-1 text-sm font-medium uppercase tracking-wider transition-colors no-drag ${
                      historyTab === tab.key ? 'text-white' : 'text-white/60 hover:text-white'
                    }`
                  }, tab.label)
                ))
              ),
              React.createElement('p', {
                className: 'mt-2 text-white/80 text-sm'
              }, metaServiceConfigs.listenbrainz?.username && metaServiceConfigs.lastfm?.username
                ? 'Your listening activity from ListenBrainz & Last.fm'
                : metaServiceConfigs.listenbrainz?.username
                  ? 'Your listening activity from ListenBrainz'
                  : 'Your listening activity from Last.fm'
              )
            ),
            // COLLAPSED STATE - Inline layout with tabs
            historyHeaderCollapsed && React.createElement('div', {
              className: 'absolute inset-0 flex items-center px-6 z-10',
              style: {
                opacity: historyHeaderCollapsed ? 1 : 0,
                transition: 'opacity 300ms ease-out'
              }
            },
              React.createElement('h1', {
                className: 'text-2xl font-light text-white mr-6',
                style: {
                  textShadow: '0 2px 10px rgba(0,0,0,0.5)',
                  letterSpacing: '0.2em',
                  textTransform: 'uppercase'
                }
              }, 'HISTORY'),
              React.createElement('div', {
                className: 'flex items-center gap-1',
                style: { textShadow: '0 1px 10px rgba(0,0,0,0.5)' }
              },
                [
                  { key: 'topTracks', label: 'Top Songs' },
                  { key: 'topAlbums', label: 'Top Albums' },
                  { key: 'topArtists', label: 'Top Artists' },
                  { key: 'recent', label: 'Recent' }
                ].map((tab, i) => React.createElement(React.Fragment, { key: tab.key },
                  i > 0 && React.createElement('span', {
                    className: 'text-white/50 mx-2'
                  }, '|'),
                  React.createElement('button', {
                    onClick: () => {
                      setHistoryTab(tab.key);
                      if (tab.key === 'recent') loadListeningHistory();
                      else if (tab.key === 'topTracks') loadTopTracks();
                      else if (tab.key === 'topArtists') loadTopArtists();
                      else if (tab.key === 'topAlbums') loadTopAlbums();
                    },
                    className: `px-2 py-1 text-sm font-medium uppercase tracking-wider transition-colors no-drag ${
                      historyTab === tab.key ? 'text-white' : 'text-white/60 hover:text-white'
                    }`
                  }, tab.label)
                ))
              )
            )
          ),
          // Filter bar (outside scrollable area)
          React.createElement('div', {
            className: 'flex items-center px-6 py-3 bg-white border-b border-gray-200',
            style: { flexShrink: 0 }
          },
            // Period dropdown for top charts OR sort dropdown for recent
            historyTab === 'recent' ?
              React.createElement('div', { className: 'relative' },
                React.createElement('button', {
                  onClick: (e) => { e.stopPropagation(); setHistorySortDropdownOpen(!historySortDropdownOpen); },
                  className: 'flex items-center gap-1 px-3 py-1.5 text-sm text-gray-500 hover:text-gray-700 transition-colors'
                },
                  React.createElement('span', null, historySortOptions.find(o => o.value === historySort)?.label || 'Sort'),
                  React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M19 9l-7 7-7-7' })
                  )
                ),
                historySortDropdownOpen && React.createElement('div', {
                  className: 'absolute left-0 top-full mt-1 bg-white rounded-lg shadow-lg py-1 min-w-[160px] z-30 border border-gray-200'
                },
                  historySortOptions.map(option =>
                    React.createElement('button', {
                      key: option.value,
                      onClick: (e) => {
                        e.stopPropagation();
                        setHistorySort(option.value);
                        setHistorySortDropdownOpen(false);
                      },
                      className: `w-full px-4 py-2 text-left text-sm hover:bg-gray-100 flex items-center justify-between ${
                        historySort === option.value ? 'text-gray-900 font-medium' : 'text-gray-600'
                      }`
                    },
                      option.label,
                      historySort === option.value && React.createElement('svg', {
                        className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor'
                      },
                        React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M5 13l4 4L19 7' })
                      )
                    )
                  )
                )
              )
            :
              // Period dropdown for top charts
              React.createElement('div', { className: 'relative' },
                React.createElement('button', {
                  onClick: (e) => { e.stopPropagation(); setHistoryPeriodDropdownOpen(!historyPeriodDropdownOpen); },
                  className: 'flex items-center gap-1 px-3 py-1.5 text-sm text-gray-500 hover:text-gray-700 transition-colors'
                },
                  React.createElement('span', null, historyPeriodOptions.find(o => o.value === historyPeriod)?.label || 'Period'),
                  React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M19 9l-7 7-7-7' })
                  )
                ),
                historyPeriodDropdownOpen && React.createElement('div', {
                  className: 'absolute left-0 top-full mt-1 bg-white rounded-lg shadow-lg py-1 min-w-[160px] z-30 border border-gray-200'
                },
                  historyPeriodOptions.map(option =>
                    React.createElement('button', {
                      key: option.value,
                      onClick: (e) => {
                        e.stopPropagation();
                        setHistoryPeriod(option.value);
                        setHistoryPeriodDropdownOpen(false);
                        // Reload current tab with new period
                        if (historyTab === 'topTracks') loadTopTracks(option.value);
                        else if (historyTab === 'topArtists') loadTopArtists(option.value);
                        else if (historyTab === 'topAlbums') loadTopAlbums(option.value);
                      },
                      className: `w-full px-4 py-2 text-left text-sm hover:bg-gray-100 flex items-center justify-between ${
                        historyPeriod === option.value ? 'text-gray-900 font-medium' : 'text-gray-600'
                      }`
                    },
                      option.label,
                      historyPeriod === option.value && React.createElement('svg', {
                        className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor'
                      },
                        React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M5 13l4 4L19 7' })
                      )
                    )
                  )
                )
              ),
            React.createElement('div', { className: 'flex-1' }),
            // Search (only for recent and top tracks)
            (historyTab === 'recent' || historyTab === 'topTracks') && React.createElement('div', { className: 'flex items-center' },
              historySearchOpen ?
                React.createElement('div', { className: 'flex items-center border border-gray-300 rounded-full px-3 py-1.5' },
                  React.createElement('input', {
                    type: 'text',
                    value: historySearch,
                    onChange: (e) => setHistorySearch(e.target.value),
                    onBlur: () => { if (!historySearch.trim()) setHistorySearchOpen(false); },
                    autoFocus: true,
                    placeholder: 'Filter...',
                    className: 'bg-transparent text-gray-700 text-sm placeholder-gray-400 outline-none',
                    style: { width: '150px' }
                  }),
                  historySearch && React.createElement('button', {
                    onClick: () => { setHistorySearch(''); setHistorySearchOpen(false); },
                    className: 'ml-2 text-gray-400 hover:text-gray-600'
                  },
                    React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                      React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M6 18L18 6M6 6l12 12' })
                    )
                  )
                )
              :
                React.createElement('button', {
                  onClick: () => setHistorySearchOpen(true),
                  className: 'p-1.5 text-gray-400 hover:text-gray-600 transition-colors'
                },
                  React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' })
                  )
                )
            )
          ),
          // Scrollable content area
          React.createElement('div', {
            className: 'flex-1 overflow-y-auto scrollable-content p-6',
            onScroll: handleHistoryScroll
          },
            // RECENTLY PLAYED TAB
            historyTab === 'recent' && (
              listeningHistory.loading ?
                React.createElement('div', { className: 'space-y-0' },
                  ...Array(15).fill(null).map((_, i) =>
                    React.createElement('div', {
                      key: `history-skeleton-${i}`,
                      className: 'flex items-center gap-4 py-2 px-3 border-b border-gray-100'
                    },
                      React.createElement('div', {
                        className: 'w-8 h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                        style: { backgroundSize: '200% 100%', animationDelay: `${i * 50}ms` }
                      }),
                      React.createElement('div', {
                        className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                        style: { width: '360px', backgroundSize: '200% 100%', animationDelay: `${i * 50 + 25}ms` }
                      }),
                      React.createElement('div', {
                        className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                        style: { width: '240px', backgroundSize: '200% 100%', animationDelay: `${i * 50 + 50}ms` }
                      }),
                      React.createElement('div', {
                        className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                        style: { width: '50px', marginLeft: 'auto', backgroundSize: '200% 100%', animationDelay: `${i * 50 + 75}ms` }
                      }),
                      React.createElement('div', {
                        className: 'flex gap-1',
                        style: { width: '100px' }
                      },
                        React.createElement('div', {
                          className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                          style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 100}ms` }
                        }),
                        React.createElement('div', {
                          className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                          style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 125}ms` }
                        })
                      )
                    )
                  )
                )
              : listeningHistory.error ?
                React.createElement('div', { className: 'text-center py-12' },
                  React.createElement('div', { className: 'text-gray-400 mb-4' }, listeningHistory.error),
                  React.createElement('button', {
                    onClick: loadListeningHistory,
                    className: 'px-4 py-2 bg-gray-900 text-white rounded-lg hover:bg-gray-800 transition-colors'
                  }, 'Try Again')
                )
              : (() => {
                  const filtered = filterHistory(listeningHistory.tracks);
                  const sorted = sortHistory(filtered);

                  if (sorted.length === 0) {
                    return React.createElement('div', {
                      className: 'text-center py-12 text-gray-400'
                    }, historySearch ? 'No tracks match your search.' : 'No recent tracks found.');
                  }

                  return React.createElement('div', { className: 'space-y-0' },
                    ...sorted.map((track, index) => {
                      const hasResolved = Object.keys(track.sources || {}).length > 0;
                      const isResolving = Object.keys(track.sources || {}).length === 0;

                      return React.createElement('div', {
                        key: track.id,
                        draggable: true,
                        onDragStart: (e) => {
                          setDraggingTrackForPlaylist(track);
                          e.dataTransfer.effectAllowed = 'copy';
                          e.dataTransfer.setData('text/plain', JSON.stringify({
                            type: 'track',
                            track: { id: track.id, title: track.title, artist: track.artist, album: track.album, duration: track.duration, sources: track.sources || {} }
                          }));
                        },
                        onDragEnd: () => {
                          setDraggingTrackForPlaylist(null);
                          setDropTargetPlaylistId(null);
                          setDropTargetNewPlaylist(false);
                          if (addToPlaylistPanel.open && selectedPlaylistsForAdd.length === 0) {
                            setAddToPlaylistPanel(prev => ({ ...prev, open: false }));
                          }
                        },
                        className: `flex items-center gap-4 py-2 px-3 border-b border-gray-100 hover:bg-gray-50 cursor-grab active:cursor-grabbing transition-colors group ${isResolving ? 'opacity-60' : ''}`,
                        onClick: () => {
                          const tracksAfter = sorted.slice(index + 1);
                          const context = { type: 'history', name: 'History' };
                          setQueueWithContext(tracksAfter, context);
                          handlePlay(track);
                        },
                        onContextMenu: (e) => {
                          e.preventDefault();
                          if (window.electron?.contextMenu?.showTrackMenu) {
                            window.electron.contextMenu.showTrackMenu({ type: 'track', track: track });
                          }
                        }
                      },
                        React.createElement('span', {
                          className: 'text-sm text-gray-400 flex-shrink-0 text-right',
                          style: { pointerEvents: 'none', width: '32px' }
                        }, String(index + 1).padStart(2, '0')),
                        React.createElement('span', {
                          className: `text-sm font-medium truncate transition-colors ${hasResolved ? 'text-gray-900 group-hover:text-gray-900' : 'text-gray-500'}`,
                          style: { pointerEvents: 'none', width: '360px', flexShrink: 0 }
                        }, track.nowPlaying ? `â–¶ ${track.title}` : track.title),
                        React.createElement('span', {
                          className: 'text-sm text-gray-500 truncate hover:text-purple-600 hover:underline cursor-pointer transition-colors',
                          style: { width: '240px', flexShrink: 0 },
                          onClick: (e) => { e.stopPropagation(); fetchArtistData(track.artist); }
                        }, track.artist),
                        React.createElement('span', {
                          className: 'text-sm text-gray-400 text-right tabular-nums',
                          style: { pointerEvents: 'none', width: '50px', flexShrink: 0, marginLeft: 'auto' }
                        }, track.duration ? formatTime(track.duration) : '--:--'),
                        React.createElement('div', {
                          className: 'flex items-center gap-1 justify-end',
                          style: { width: '100px', flexShrink: 0, minHeight: '24px' }
                        },
                          isResolving ?
                            React.createElement('div', { className: 'flex items-center gap-1' },
                              React.createElement('div', { className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer', title: 'Resolving track...' }),
                              React.createElement('div', { className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer', style: { animationDelay: '0.1s' } })
                            )
                          : hasResolved ?
                            Object.entries(track.sources).sort(([aId], [bId]) => resolverOrder.indexOf(aId) - resolverOrder.indexOf(bId)).map(([resolverId, source]) => {
                              const resolver = allResolvers.find(r => r.id === resolverId);
                              if (!resolver || !resolver.play) return null;
                              return React.createElement('button', {
                                key: resolverId,
                                className: 'no-drag',
                                onClick: (e) => { e.stopPropagation(); const tracksAfter = sorted.slice(index + 1); const context = { type: 'history', name: 'History' }; setQueueWithContext(tracksAfter, context); handlePlay({ ...track, preferredResolver: resolverId }); },
                                style: { width: '24px', height: '24px', borderRadius: '4px', backgroundColor: resolver.color, border: 'none', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center', pointerEvents: 'auto', opacity: (source.confidence || 0) > 0.8 ? 1 : 0.6, transition: 'transform 0.1s' },
                                onMouseEnter: (e) => e.currentTarget.style.transform = 'scale(1.1)',
                                onMouseLeave: (e) => e.currentTarget.style.transform = 'scale(1)',
                                title: `Play from ${resolver.name}${source.confidence ? ` (${Math.round(source.confidence * 100)}% match)` : ''}`
                              }, React.createElement(ResolverIcon, { resolverId, size: 14 }));
                            })
                          :
                            React.createElement('div', { className: 'flex items-center gap-1' },
                              React.createElement('div', { className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer', title: 'Resolving track...' }),
                              React.createElement('div', { className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer', style: { animationDelay: '0.1s' } })
                            )
                        )
                      );
                    })
                  );
                })()
            ),

            // TOP TRACKS TAB
            historyTab === 'topTracks' && (
              topTracks.loading ?
                React.createElement('div', { className: 'space-y-0' },
                  ...Array(15).fill(null).map((_, i) =>
                    React.createElement('div', {
                      key: `top-track-skeleton-${i}`,
                      className: 'flex items-center gap-4 py-2 px-3 border-b border-gray-100'
                    },
                      React.createElement('div', { className: 'w-8 h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer', style: { backgroundSize: '200% 100%' } }),
                      React.createElement('div', { className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer', style: { width: '360px', backgroundSize: '200% 100%' } }),
                      React.createElement('div', { className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer', style: { width: '240px', backgroundSize: '200% 100%' } }),
                      React.createElement('div', { className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer', style: { width: '80px', marginLeft: 'auto', backgroundSize: '200% 100%' } })
                    )
                  )
                )
              : topTracks.error ?
                React.createElement('div', { className: 'text-center py-12' },
                  React.createElement('div', { className: 'text-gray-400 mb-4' }, topTracks.error),
                  React.createElement('button', {
                    onClick: () => loadTopTracks(),
                    className: 'px-4 py-2 bg-gray-900 text-white rounded-lg hover:bg-gray-800 transition-colors'
                  }, 'Try Again')
                )
              : (() => {
                  const filtered = historySearch ? topTracks.tracks.filter(t =>
                    t.title.toLowerCase().includes(historySearch.toLowerCase()) ||
                    t.artist.toLowerCase().includes(historySearch.toLowerCase())
                  ) : topTracks.tracks;

                  if (filtered.length === 0) {
                    return React.createElement('div', { className: 'text-center py-12 text-gray-400' },
                      historySearch ? 'No tracks match your search.' : 'No top tracks found for this period.');
                  }

                  return React.createElement('div', { className: 'space-y-0' },
                    ...filtered.map((track, index) => {
                      const hasResolved = Object.keys(track.sources || {}).length > 0;
                      return React.createElement('div', {
                        key: track.id,
                        draggable: true,
                        onDragStart: (e) => {
                          setDraggingTrackForPlaylist(track);
                          e.dataTransfer.effectAllowed = 'copy';
                          e.dataTransfer.setData('text/plain', JSON.stringify({ type: 'track', track }));
                        },
                        onDragEnd: () => { setDraggingTrackForPlaylist(null); setDropTargetPlaylistId(null); setDropTargetNewPlaylist(false); },
                        className: `flex items-center gap-4 py-2 px-3 border-b border-gray-100 hover:bg-gray-50 cursor-grab active:cursor-grabbing transition-colors group ${!hasResolved ? 'opacity-60' : ''}`,
                        onClick: () => { const tracksAfter = filtered.slice(index + 1); const context = { type: 'history', name: 'Top Tracks' }; setQueueWithContext(tracksAfter, context); handlePlay(track); },
                        onContextMenu: (e) => { e.preventDefault(); if (window.electron?.contextMenu?.showTrackMenu) window.electron.contextMenu.showTrackMenu({ type: 'track', track }); }
                      },
                        React.createElement('span', { className: 'text-sm text-gray-500 font-medium flex-shrink-0 text-right', style: { width: '32px' } }, `#${track.rank}`),
                        React.createElement('span', { className: `text-sm font-medium truncate transition-colors ${hasResolved ? 'text-gray-900 group-hover:text-gray-900' : 'text-gray-500'}`, style: { width: '360px', flexShrink: 0 } }, track.title),
                        React.createElement('span', {
                          className: 'text-sm text-gray-500 truncate hover:text-purple-600 hover:underline cursor-pointer transition-colors',
                          style: { width: '240px', flexShrink: 0 },
                          onClick: (e) => { e.stopPropagation(); fetchArtistData(track.artist); }
                        }, track.artist),
                        React.createElement('span', { className: 'text-sm text-gray-400 text-right tabular-nums', style: { width: '80px', flexShrink: 0, marginLeft: 'auto' } }, `${track.playCount} plays`),
                        React.createElement('div', { className: 'flex items-center gap-1 justify-end', style: { width: '100px', flexShrink: 0, minHeight: '24px' } },
                          hasResolved ?
                            Object.entries(track.sources).sort(([aId], [bId]) => resolverOrder.indexOf(aId) - resolverOrder.indexOf(bId)).map(([resolverId, source]) => {
                              const resolver = allResolvers.find(r => r.id === resolverId);
                              if (!resolver || !resolver.play) return null;
                              return React.createElement('button', {
                                key: resolverId,
                                className: 'no-drag',
                                onClick: (e) => { e.stopPropagation(); const tracksAfter = filtered.slice(index + 1); const context = { type: 'history', name: 'Top Tracks' }; setQueueWithContext(tracksAfter, context); handlePlay({ ...track, preferredResolver: resolverId }); },
                                style: { width: '24px', height: '24px', borderRadius: '4px', backgroundColor: resolver.color, border: 'none', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center', opacity: (source.confidence || 0) > 0.8 ? 1 : 0.6, transition: 'transform 0.1s' },
                                onMouseEnter: (e) => e.currentTarget.style.transform = 'scale(1.1)',
                                onMouseLeave: (e) => e.currentTarget.style.transform = 'scale(1)',
                                title: `Play from ${resolver.name}`
                              }, React.createElement(ResolverIcon, { resolverId, size: 14 }));
                            })
                          :
                            React.createElement('div', { className: 'flex items-center gap-1' },
                              React.createElement('div', { className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer' }),
                              React.createElement('div', { className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer', style: { animationDelay: '0.1s' } })
                            )
                        )
                      );
                    })
                  );
                })()
            ),

            // TOP ARTISTS TAB
            historyTab === 'topArtists' && (
              topArtists.loading ?
                React.createElement('div', {
                  className: 'grid gap-x-4 gap-y-8',
                  style: { gridTemplateColumns: 'repeat(auto-fill, minmax(160px, 1fr))' }
                },
                  ...Array(12).fill(null).map((_, i) =>
                    React.createElement('div', { key: `artist-skeleton-${i}`, className: 'flex flex-col items-center' },
                      React.createElement('div', { className: 'w-36 h-36 rounded-full bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer', style: { backgroundSize: '200% 100%' } }),
                      React.createElement('div', { className: 'w-24 h-4 mt-3 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer rounded', style: { backgroundSize: '200% 100%' } }),
                      React.createElement('div', { className: 'w-16 h-3 mt-1 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer rounded', style: { backgroundSize: '200% 100%' } })
                    )
                  )
                )
              : topArtists.error ?
                React.createElement('div', { className: 'text-center py-12' },
                  React.createElement('div', { className: 'text-gray-400 mb-4' }, topArtists.error),
                  React.createElement('button', {
                    onClick: () => loadTopArtists(),
                    className: 'px-4 py-2 bg-gray-900 text-white rounded-lg hover:bg-gray-800 transition-colors'
                  }, 'Try Again')
                )
              : topArtists.artists.length === 0 ?
                React.createElement('div', { className: 'text-center py-12 text-gray-400' }, 'No top artists found for this period.')
              :
                React.createElement('div', {
                  className: 'grid gap-x-4 gap-y-8',
                  style: { gridTemplateColumns: 'repeat(auto-fill, minmax(160px, 1fr))' }
                },
                  ...topArtists.artists.map((artist) =>
                    React.createElement('div', {
                      key: artist.id,
                      className: 'flex flex-col items-center cursor-grab active:cursor-grabbing group',
                      draggable: true,
                      onDragStart: (e) => {
                        e.dataTransfer.effectAllowed = 'copy';
                        e.dataTransfer.setData('text/plain', JSON.stringify({
                          type: 'artist',
                          artist: {
                            id: artist.id,
                            name: artist.name,
                            image: artist.image
                          }
                        }));
                      },
                      onClick: () => fetchArtistData(artist.name),
                      onContextMenu: (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        if (window.electron?.contextMenu?.showTrackMenu) {
                          window.electron.contextMenu.showTrackMenu({
                            type: 'artist',
                            artist: {
                              id: artist.id,
                              name: artist.name,
                              image: artist.image
                            }
                          });
                        }
                      }
                    },
                      React.createElement('div', {
                        className: 'relative w-36 h-36 rounded-full overflow-hidden bg-gradient-to-br from-purple-500 to-pink-500'
                      },
                        // Placeholder always rendered behind
                        React.createElement('div', {
                          className: 'absolute inset-0 flex items-center justify-center text-white/60'
                        },
                          React.createElement('svg', { className: 'w-12 h-12', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                            React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 1.5, d: 'M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z' })
                          )
                        ),
                        artist.image && React.createElement('img', {
                          src: artist.image,
                          alt: artist.name,
                          className: 'absolute inset-0 w-full h-full object-cover group-hover:scale-110 transition-all duration-300',
                          style: { opacity: 0 },
                          ref: (el) => { if (el && el.complete && el.naturalWidth > 0) el.style.opacity = '1'; },
                          onLoad: (e) => { e.target.style.opacity = '1'; },
                          onError: (e) => { e.target.style.display = 'none'; }
                        }),
                        // Rank badge
                        React.createElement('div', {
                          className: 'absolute top-0 right-0 px-2 py-1 rounded bg-black/70 text-white text-xs font-bold'
                        }, `#${artist.rank}`)
                      ),
                      React.createElement('span', {
                        className: 'mt-3 text-sm font-medium text-gray-700 text-center truncate w-full group-hover:text-purple-600 transition-colors'
                      }, artist.name),
                      React.createElement('span', {
                        className: 'text-xs text-gray-400'
                      }, `${artist.playCount} plays`)
                    )
                  )
                )
            ),

            // TOP ALBUMS TAB
            historyTab === 'topAlbums' && (
              topAlbums.loading ?
                React.createElement('div', {
                  className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-x-4 gap-y-8 pb-6'
                },
                  ...Array(12).fill(null).map((_, i) =>
                    React.createElement('div', { key: `album-skeleton-${i}` },
                      React.createElement('div', { className: 'aspect-square rounded-lg mb-3 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer', style: { backgroundSize: '200% 100%' } }),
                      React.createElement('div', { className: 'space-y-1' },
                        React.createElement('div', { className: 'h-4 w-3/4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer rounded', style: { backgroundSize: '200% 100%' } }),
                        React.createElement('div', { className: 'h-3 w-1/2 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer rounded', style: { backgroundSize: '200% 100%' } })
                      )
                    )
                  )
                )
              : topAlbums.error ?
                React.createElement('div', { className: 'text-center py-12' },
                  React.createElement('div', { className: 'text-gray-400 mb-4' }, topAlbums.error),
                  React.createElement('button', {
                    onClick: () => loadTopAlbums(),
                    className: 'px-4 py-2 bg-gray-900 text-white rounded-lg hover:bg-gray-800 transition-colors'
                  }, 'Try Again')
                )
              : topAlbums.albums.length === 0 ?
                React.createElement('div', { className: 'text-center py-12 text-gray-400' }, 'No top albums found for this period.')
              :
                React.createElement('div', {
                  className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-x-4 gap-y-8 pb-6'
                },
                  ...topAlbums.albums.map((album) =>
                    React.createElement('div', {
                      key: album.id,
                      className: 'group cursor-pointer',
                      onClick: () => openTopAlbum(album)
                    },
                      // Album art with hover overlay
                      // States: shimmer (fetching or loading image), placeholder (no art)
                      React.createElement('div', {
                        className: `aspect-square rounded-lg overflow-hidden mb-3 relative ${
                          // Purple gradient for failed lookups (null or empty) - shows placeholder icon
                          album.image === null || album.image === ''
                            ? 'bg-gradient-to-br from-purple-500 to-pink-500'
                            // Shimmer while fetching OR while image loads from URL
                            : 'bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer'
                        }`,
                        style: album.image === null || album.image === '' ? {} : { backgroundSize: '200% 100%' }
                      },
                        // Placeholder - only show when no art (null or empty string)
                        !album.image && album.image !== undefined && React.createElement('div', {
                          className: 'absolute inset-0 flex items-center justify-center text-white/60'
                        },
                          React.createElement('svg', { className: 'w-16 h-16', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor', strokeWidth: 1 },
                            React.createElement('circle', { cx: 12, cy: 12, r: 10 }),
                            React.createElement('circle', { cx: 12, cy: 12, r: 3 }),
                            React.createElement('circle', { cx: 12, cy: 12, r: 6, strokeDasharray: '2 2' })
                          )
                        ),
                        album.image && typeof album.image === 'string' && React.createElement('img', {
                          src: album.image,
                          alt: album.name,
                          className: 'absolute inset-0 w-full h-full object-cover group-hover:scale-105 transition-all duration-300',
                          ref: (el) => { if (el && el.complete && el.naturalWidth > 0) el.style.opacity = '1'; },
                          style: { opacity: 0 },
                          onLoad: (e) => { e.target.style.opacity = '1'; },
                          onError: (e) => { e.target.style.display = 'none'; }
                        }),
                        // Rank badge
                        React.createElement('div', {
                          className: 'absolute top-2 right-2 px-2 py-1 rounded bg-black/70 text-white text-xs font-bold'
                        }, `#${album.rank}`)
                      ),
                      // Album info
                      React.createElement('div', { className: 'space-y-1' },
                        React.createElement('div', {
                          className: 'font-medium text-gray-900 truncate group-hover:text-purple-600 transition-colors'
                        }, album.name),
                        React.createElement('div', {
                          className: 'text-sm text-gray-500 truncate hover:text-purple-600 hover:underline cursor-pointer transition-colors',
                          onClick: (e) => {
                            e.stopPropagation();
                            fetchArtistData(album.artist);
                          }
                        }, album.artist),
                        React.createElement('div', {
                          className: 'text-xs text-gray-400'
                        }, `${album.playCount} plays`)
                      )
                    )
                  )
                )
            )
          )
        ),

        // Friend History View - matching History page structure exactly
        activeView === 'friendHistory' && currentFriend && (() => {
          return React.createElement('div', {
            className: 'flex-1 flex flex-col h-full',
            style: { overflow: 'hidden', minHeight: 0 }
          },
            // Header section (outside scrollable area) - matching History pattern
            React.createElement('div', {
              className: 'relative',
              style: {
                height: historyHeaderCollapsed ? '80px' : '320px',
                flexShrink: 0,
                transition: 'height 300ms ease-out',
                overflow: 'hidden'
              }
            },
              // Gradient background - purple/magenta theme for friends
              React.createElement('div', {
                className: 'absolute inset-0',
                style: {
                  background: 'linear-gradient(135deg, #9333ea 0%, #c026d3 50%, #e11d48 100%)'
                }
              }),
              // Background pattern - hexagon pattern for friends
              React.createElement('div', {
                className: 'absolute inset-0',
                style: {
                  opacity: 0.1,
                  backgroundImage: 'url("data:image/svg+xml,%3Csvg width=\'60\' height=\'60\' viewBox=\'0 0 60 60\' xmlns=\'http://www.w3.org/2000/svg\'%3E%3Cpolygon fill=\'none\' stroke=\'%23ffffff\' stroke-width=\'1.5\' points=\'30,5 55,20 55,50 30,65 5,50 5,20\'/%3E%3C/svg%3E")'
                }
              }),
              // EXPANDED STATE - Centered content with tabs (matching History exactly)
              !historyHeaderCollapsed && React.createElement('div', {
                className: 'absolute inset-0 flex flex-col items-center justify-center text-center px-6 z-10',
                style: {
                  opacity: historyHeaderCollapsed ? 0 : 1,
                  transition: 'opacity 300ms ease-out'
                }
              },
                // Hexagonal avatar centered
                React.createElement('div', {
                  className: 'w-24 h-24 mb-4 overflow-hidden',
                  style: {
                    clipPath: 'polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%)'
                  }
                },
                  currentFriend.avatarUrl
                    ? React.createElement('img', {
                        src: currentFriend.avatarUrl,
                        alt: currentFriend.displayName,
                        className: 'w-full h-full object-cover'
                      })
                    : React.createElement('div', {
                        className: 'w-full h-full flex items-center justify-center text-3xl font-medium bg-white/20 text-white'
                      }, currentFriend.displayName.charAt(0).toUpperCase())
                ),
                // Name with badges
                React.createElement('div', { className: 'flex items-center gap-3 mb-2' },
                  React.createElement('h1', {
                    className: 'text-4xl font-light text-white',
                    style: {
                      textShadow: '0 2px 20px rgba(0,0,0,0.5)',
                      letterSpacing: '0.2em',
                      textTransform: 'uppercase'
                    }
                  }, currentFriend.displayName),
                  // On-air badge
                  isOnAir(currentFriend) && React.createElement('span', {
                    className: 'px-2 py-1 bg-green-500 text-white text-xs font-medium rounded-full flex items-center gap-1'
                  },
                    React.createElement('span', { className: 'w-2 h-2 bg-white rounded-full animate-pulse' }),
                    'On Air'
                  )
                ),
                // Tabs in expanded state (matching History)
                React.createElement('div', {
                  className: 'flex items-center gap-1 mt-4',
                  style: { textShadow: '0 1px 10px rgba(0,0,0,0.5)' }
                },
                  [
                    { key: 'recent', label: 'Recently Played' },
                    { key: 'topTracks', label: 'Top Tracks' },
                    { key: 'topAlbums', label: 'Top Albums' },
                    { key: 'topArtists', label: 'Top Artists' }
                  ].map((tab, i) => React.createElement(React.Fragment, { key: tab.key },
                    i > 0 && React.createElement('span', {
                      className: 'text-white/50 mx-2'
                    }, '|'),
                    React.createElement('button', {
                      onClick: () => {
                        setFriendHistoryTab(tab.key);
                        if (tab.key === 'recent') loadFriendRecentTracks(currentFriend);
                        else if (tab.key === 'topTracks') loadFriendTopTracks(currentFriend);
                        else if (tab.key === 'topAlbums') loadFriendTopAlbums(currentFriend);
                        else if (tab.key === 'topArtists') loadFriendTopArtists(currentFriend);
                      },
                      className: `px-2 py-1 text-sm font-medium uppercase tracking-wider transition-colors no-drag ${
                        friendHistoryTab === tab.key ? 'text-white' : 'text-white/60 hover:text-white'
                      }`
                    }, tab.label)
                  ))
                ),
                // Service subtitle
                React.createElement('p', {
                  className: 'mt-2 text-white/80 text-sm'
                }, `Listening activity from ${currentFriend.service === 'lastfm' ? 'Last.fm' : 'ListenBrainz'}`)
              ),
              // COLLAPSED STATE - Inline layout with tabs (matching History)
              historyHeaderCollapsed && React.createElement('div', {
                className: 'absolute inset-0 flex items-center px-6 z-10',
                style: {
                  opacity: historyHeaderCollapsed ? 1 : 0,
                  transition: 'opacity 300ms ease-out'
                }
              },
                // Small avatar
                React.createElement('div', {
                  className: 'w-10 h-10 mr-4 overflow-hidden flex-shrink-0',
                  style: {
                    clipPath: 'polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%)'
                  }
                },
                  currentFriend.avatarUrl
                    ? React.createElement('img', {
                        src: currentFriend.avatarUrl,
                        alt: currentFriend.displayName,
                        className: 'w-full h-full object-cover'
                      })
                    : React.createElement('div', {
                        className: 'w-full h-full flex items-center justify-center text-sm font-medium bg-white/20 text-white'
                      }, currentFriend.displayName.charAt(0).toUpperCase())
                ),
                React.createElement('h1', {
                  className: 'text-2xl font-light text-white mr-6',
                  style: {
                    textShadow: '0 2px 10px rgba(0,0,0,0.5)',
                    letterSpacing: '0.2em',
                    textTransform: 'uppercase'
                  }
                }, currentFriend.displayName),
                // On-air dot
                isOnAir(currentFriend) && React.createElement('span', {
                  className: 'w-2.5 h-2.5 bg-green-400 rounded-full mr-4'
                }),
                // Tabs in collapsed mode
                React.createElement('div', {
                  className: 'flex items-center gap-1',
                  style: { textShadow: '0 1px 10px rgba(0,0,0,0.5)' }
                },
                  [
                    { key: 'recent', label: 'Recent' },
                    { key: 'topTracks', label: 'Top Tracks' },
                    { key: 'topAlbums', label: 'Top Albums' },
                    { key: 'topArtists', label: 'Top Artists' }
                  ].map((tab, i) => React.createElement(React.Fragment, { key: `c-${tab.key}` },
                    i > 0 && React.createElement('span', {
                      className: 'text-white/50 mx-2'
                    }, '|'),
                    React.createElement('button', {
                      onClick: () => {
                        setFriendHistoryTab(tab.key);
                        if (tab.key === 'recent') loadFriendRecentTracks(currentFriend);
                        else if (tab.key === 'topTracks') loadFriendTopTracks(currentFriend);
                        else if (tab.key === 'topAlbums') loadFriendTopAlbums(currentFriend);
                        else if (tab.key === 'topArtists') loadFriendTopArtists(currentFriend);
                      },
                      className: `px-2 py-1 text-sm font-medium uppercase tracking-wider transition-colors no-drag ${
                        friendHistoryTab === tab.key ? 'text-white' : 'text-white/60 hover:text-white'
                      }`
                    }, tab.label)
                  ))
                )
              )
            ),
            // Filter bar (outside scrollable area - matching History exactly)
            React.createElement('div', {
              className: 'flex items-center px-6 py-3 bg-white border-b border-gray-200',
              style: { flexShrink: 0 }
            },
              // Sort dropdown for recent, period dropdown for top charts
              friendHistoryTab === 'recent' ?
                React.createElement('div', { className: 'relative' },
                  React.createElement('button', {
                    onClick: (e) => { e.stopPropagation(); setFriendHistorySortDropdownOpen(!friendHistorySortDropdownOpen); },
                    className: 'flex items-center gap-1 px-3 py-1.5 text-sm text-gray-500 hover:text-gray-700 transition-colors'
                  },
                    React.createElement('span', null, historySortOptions.find(o => o.value === friendHistorySort)?.label || 'Sort'),
                    React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                      React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M19 9l-7 7-7-7' })
                    )
                  ),
                  friendHistorySortDropdownOpen && React.createElement('div', {
                    className: 'absolute left-0 top-full mt-1 bg-white rounded-lg shadow-lg py-1 min-w-[160px] z-30 border border-gray-200'
                  },
                    historySortOptions.map(option =>
                      React.createElement('button', {
                        key: option.value,
                        onClick: (e) => {
                          e.stopPropagation();
                          setFriendHistorySort(option.value);
                          setFriendHistorySortDropdownOpen(false);
                        },
                        className: `w-full px-4 py-2 text-left text-sm hover:bg-gray-100 flex items-center justify-between ${
                          friendHistorySort === option.value ? 'text-gray-900 font-medium' : 'text-gray-600'
                        }`
                      },
                        option.label,
                        friendHistorySort === option.value && React.createElement('svg', {
                          className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor'
                        },
                          React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M5 13l4 4L19 7' })
                        )
                      )
                    )
                  )
                )
              :
                React.createElement('div', { className: 'relative' },
                  React.createElement('button', {
                    onClick: (e) => { e.stopPropagation(); setHistoryPeriodDropdownOpen(!historyPeriodDropdownOpen); },
                    className: 'flex items-center gap-1 px-3 py-1.5 text-sm text-gray-500 hover:text-gray-700 transition-colors'
                  },
                    React.createElement('span', null, historyPeriodOptions.find(o => o.value === friendHistoryPeriod)?.label || 'Period'),
                    React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                      React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M19 9l-7 7-7-7' })
                    )
                  ),
                  historyPeriodDropdownOpen && React.createElement('div', {
                    className: 'absolute left-0 top-full mt-1 bg-white rounded-lg shadow-lg py-1 min-w-[160px] z-30 border border-gray-200'
                  },
                    historyPeriodOptions.map(option =>
                      React.createElement('button', {
                        key: option.value,
                        onClick: (e) => {
                          e.stopPropagation();
                          setFriendHistoryPeriod(option.value);
                          setHistoryPeriodDropdownOpen(false);
                          if (friendHistoryTab === 'topTracks') loadFriendTopTracks(currentFriend, option.value);
                          else if (friendHistoryTab === 'topAlbums') loadFriendTopAlbums(currentFriend, option.value);
                          else if (friendHistoryTab === 'topArtists') loadFriendTopArtists(currentFriend, option.value);
                        },
                        className: `w-full px-4 py-2 text-left text-sm hover:bg-gray-100 flex items-center justify-between ${
                          friendHistoryPeriod === option.value ? 'text-gray-900 font-medium' : 'text-gray-600'
                        }`
                      },
                        option.label,
                        friendHistoryPeriod === option.value && React.createElement('svg', {
                          className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor'
                        },
                          React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M5 13l4 4L19 7' })
                        )
                      )
                    )
                  )
                ),
              React.createElement('div', { className: 'flex-1' }),
              // Pin/Unpin button on right side of filter bar
              React.createElement('button', {
                onClick: () => pinnedFriendIds.includes(currentFriend.id) ? unpinFriend(currentFriend.id) : pinFriend(currentFriend.id),
                className: `flex items-center gap-2 px-3 py-1.5 text-sm rounded-full transition-colors ${
                  pinnedFriendIds.includes(currentFriend.id)
                    ? 'bg-purple-100 text-purple-700'
                    : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                }`
              },
                React.createElement('svg', {
                  className: 'w-4 h-4',
                  fill: pinnedFriendIds.includes(currentFriend.id) ? 'currentColor' : 'none',
                  viewBox: '0 0 24 24',
                  stroke: 'currentColor'
                },
                  React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z' })
                ),
                pinnedFriendIds.includes(currentFriend.id) ? 'Pinned' : 'Pin to Sidebar'
              )
            ),
            // Scrollable content area
            React.createElement('div', {
              className: 'flex-1 overflow-y-auto scrollable-content p-6',
              onScroll: (e) => {
                const scrollTop = e.target.scrollTop;
                if (scrollTop > 50 && !historyHeaderCollapsed) {
                  setHistoryHeaderCollapsed(true);
                } else if (scrollTop <= 50 && historyHeaderCollapsed) {
                  setHistoryHeaderCollapsed(false);
                }
              }
            },
                // Loading state
                friendHistoryLoading && React.createElement('div', { className: 'flex items-center justify-center py-12' },
                  React.createElement('div', { className: 'w-8 h-8 border-2 border-purple-500 border-t-transparent rounded-full animate-spin' })
                ),
                // Recent tab content - matching History page layout
                !friendHistoryLoading && friendHistoryTab === 'recent' && (() => {
                  const sorted = sortFriendHistory(friendHistoryData.recent);
                  if (sorted.length === 0) {
                    return React.createElement('p', { className: 'text-center text-gray-400 py-8' }, 'No recent listens');
                  }
                  return React.createElement('div', { className: 'space-y-0' },
                    ...sorted.map((track, index) => {
                      const hasResolved = Object.keys(track.sources || {}).length > 0;
                      const isResolving = Object.keys(track.sources || {}).length === 0;
                      const tracksAfterRecent = sorted.slice(index + 1);

                      return React.createElement('div', {
                        key: track.id || index,
                        draggable: true,
                        onDragStart: (e) => {
                          setDraggingTrackForPlaylist(track);
                          e.dataTransfer.effectAllowed = 'copy';
                          e.dataTransfer.setData('text/plain', JSON.stringify({ type: 'track', track }));
                        },
                        onDragEnd: () => {
                          setDraggingTrackForPlaylist(null);
                          setDropTargetPlaylistId(null);
                          setDropTargetNewPlaylist(false);
                        },
                        className: `flex items-center gap-4 py-2 px-3 border-b border-gray-100 hover:bg-gray-50 cursor-grab active:cursor-grabbing transition-colors group ${isResolving ? 'opacity-60' : ''}`,
                        onClick: () => {
                          const tracksAfter = sorted.slice(index + 1);
                          const context = { type: 'friend', name: currentFriend?.name || 'Friend', tab: 'recent' };
                          setQueueWithContext(tracksAfter, context);
                          handlePlay(track);
                        },
                          onContextMenu: (e) => {
                            e.preventDefault();
                            if (window.electron?.contextMenu?.showTrackMenu) {
                              window.electron.contextMenu.showTrackMenu({ type: 'track', track });
                            }
                          }
                        },
                          React.createElement('span', {
                            className: 'text-sm text-gray-400 flex-shrink-0 text-right',
                            style: { pointerEvents: 'none', width: '32px' }
                          }, String(index + 1).padStart(2, '0')),
                          React.createElement('span', {
                            className: `text-sm font-medium truncate transition-colors ${hasResolved ? 'text-gray-900 group-hover:text-gray-900' : 'text-gray-500'}`,
                            style: { pointerEvents: 'none', width: '360px', flexShrink: 0 }
                          }, track.nowPlaying ? `â–¶ ${track.title}` : track.title),
                          React.createElement('span', {
                            className: 'text-sm text-gray-500 truncate hover:text-purple-600 hover:underline cursor-pointer transition-colors',
                            style: { width: '240px', flexShrink: 0 },
                            onClick: (e) => { e.stopPropagation(); fetchArtistData(track.artist); }
                          }, track.artist),
                          React.createElement('span', {
                            className: 'text-sm text-gray-400 truncate',
                            style: { pointerEvents: 'none', width: '150px', flexShrink: 0 }
                          }, track.album || ''),
                          React.createElement('span', {
                            className: 'text-sm text-gray-400 text-right tabular-nums',
                            style: { pointerEvents: 'none', width: '80px', flexShrink: 0, marginLeft: 'auto' }
                          }, track.timestamp ? formatTimeAgo(track.timestamp) : ''),
                          React.createElement('div', {
                            className: 'flex items-center gap-1 justify-end',
                            style: { width: '100px', flexShrink: 0, minHeight: '24px' }
                          },
                            isResolving ?
                              React.createElement('div', { className: 'flex items-center gap-1' },
                                React.createElement('div', { className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer', title: 'Resolving track...' }),
                                React.createElement('div', { className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer', style: { animationDelay: '0.1s' } })
                              )
                            : hasResolved ?
                              Object.entries(track.sources).sort(([aId], [bId]) => resolverOrder.indexOf(aId) - resolverOrder.indexOf(bId)).map(([resolverId, source]) => {
                                const resolver = allResolvers.find(r => r.id === resolverId);
                                if (!resolver || !resolver.play) return null;
                                return React.createElement('button', {
                                  key: resolverId,
                                  className: 'no-drag',
                                  onClick: (e) => { e.stopPropagation(); const context = { type: 'friend', name: currentFriend?.name || 'Friend', tab: 'recent' }; setQueueWithContext(tracksAfterRecent, context); handlePlay({ ...track, preferredResolver: resolverId }); },
                                  style: { width: '24px', height: '24px', borderRadius: '4px', backgroundColor: resolver.color, border: 'none', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center', pointerEvents: 'auto', opacity: (source.confidence || 0) > 0.8 ? 1 : 0.6, transition: 'transform 0.1s' },
                                  onMouseEnter: (e) => e.currentTarget.style.transform = 'scale(1.1)',
                                  onMouseLeave: (e) => e.currentTarget.style.transform = 'scale(1)',
                                  title: `Play from ${resolver.name}`
                                }, React.createElement(ResolverIcon, { resolverId, size: 14 }));
                              })
                            :
                              React.createElement('div', { className: 'flex items-center gap-1' },
                                React.createElement('div', { className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer', title: 'Resolving track...' }),
                                React.createElement('div', { className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer', style: { animationDelay: '0.1s' } })
                              )
                          )
                      );
                    })
                  );
                })(),
                // Top tracks tab content - matching History page layout
                !friendHistoryLoading && friendHistoryTab === 'topTracks' && React.createElement('div', { className: 'space-y-0' },
                  friendHistoryData.topTracks.length === 0
                    ? React.createElement('p', { className: 'text-center text-gray-400 py-8' }, 'No top tracks data')
                    : friendHistoryData.topTracks.map((track, index) => {
                        const hasResolved = Object.keys(track.sources || {}).length > 0;
                        const isResolving = Object.keys(track.sources || {}).length === 0;

                        return React.createElement('div', {
                          key: track.id || index,
                          draggable: true,
                          onDragStart: (e) => {
                            setDraggingTrackForPlaylist(track);
                            e.dataTransfer.effectAllowed = 'copy';
                            e.dataTransfer.setData('text/plain', JSON.stringify({ type: 'track', track }));
                          },
                          onDragEnd: () => {
                            setDraggingTrackForPlaylist(null);
                            setDropTargetPlaylistId(null);
                            setDropTargetNewPlaylist(false);
                          },
                          className: `flex items-center gap-4 py-2 px-3 border-b border-gray-100 hover:bg-gray-50 cursor-grab active:cursor-grabbing transition-colors group ${isResolving ? 'opacity-60' : ''}`,
                          onClick: () => {
                            const tracksAfter = friendHistoryData.topTracks.slice(index + 1);
                            const context = { type: 'friend', name: currentFriend?.name || 'Friend', tab: 'topTracks' };
                            setQueueWithContext(tracksAfter, context);
                            handlePlay(track);
                          },
                          onContextMenu: (e) => {
                            e.preventDefault();
                            if (window.electron?.contextMenu?.showTrackMenu) {
                              window.electron.contextMenu.showTrackMenu({ type: 'track', track });
                            }
                          }
                        },
                          React.createElement('span', {
                            className: 'text-sm text-gray-500 font-medium flex-shrink-0 text-right',
                            style: { width: '32px' }
                          }, `#${track.rank || index + 1}`),
                          React.createElement('span', {
                            className: `text-sm font-medium truncate transition-colors ${hasResolved ? 'text-gray-900 group-hover:text-gray-900' : 'text-gray-500'}`,
                            style: { width: '360px', flexShrink: 0 }
                          }, track.title),
                          React.createElement('span', {
                            className: 'text-sm text-gray-500 truncate hover:text-purple-600 hover:underline cursor-pointer transition-colors',
                            style: { width: '240px', flexShrink: 0 },
                            onClick: (e) => { e.stopPropagation(); fetchArtistData(track.artist); }
                          }, track.artist),
                          React.createElement('span', {
                            className: 'text-sm text-gray-400 text-right tabular-nums',
                            style: { width: '80px', flexShrink: 0, marginLeft: 'auto' }
                          }, `${track.playCount} plays`),
                          React.createElement('div', {
                            className: 'flex items-center gap-1 justify-end',
                            style: { width: '100px', flexShrink: 0, minHeight: '24px' }
                          },
                            isResolving ?
                              React.createElement('div', { className: 'flex items-center gap-1' },
                                React.createElement('div', { className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer', title: 'Resolving track...' }),
                                React.createElement('div', { className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer', style: { animationDelay: '0.1s' } })
                              )
                            : hasResolved ?
                              Object.entries(track.sources).sort(([aId], [bId]) => resolverOrder.indexOf(aId) - resolverOrder.indexOf(bId)).map(([resolverId, source]) => {
                                const resolver = allResolvers.find(r => r.id === resolverId);
                                if (!resolver || !resolver.play) return null;
                                return React.createElement('button', {
                                  key: resolverId,
                                  className: 'no-drag',
                                  onClick: (e) => { e.stopPropagation(); const context = { type: 'friend', name: currentFriend?.name || 'Friend', tab: 'topTracks' }; setQueueWithContext(friendHistoryData.topTracks.slice(index + 1), context); handlePlay({ ...track, preferredResolver: resolverId }); },
                                  style: { width: '24px', height: '24px', borderRadius: '4px', backgroundColor: resolver.color, border: 'none', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center', pointerEvents: 'auto', opacity: (source.confidence || 0) > 0.8 ? 1 : 0.6, transition: 'transform 0.1s' },
                                  onMouseEnter: (e) => e.currentTarget.style.transform = 'scale(1.1)',
                                  onMouseLeave: (e) => e.currentTarget.style.transform = 'scale(1)',
                                  title: `Play from ${resolver.name}`
                                }, React.createElement(ResolverIcon, { resolverId, size: 14 }));
                              })
                            :
                              React.createElement('div', { className: 'flex items-center gap-1' },
                                React.createElement('div', { className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer', title: 'Resolving track...' }),
                                React.createElement('div', { className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer', style: { animationDelay: '0.1s' } })
                              )
                          )
                        );
                      })
                ),
                // Top albums tab content
                !friendHistoryLoading && friendHistoryTab === 'topAlbums' && React.createElement('div', {
                  className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4'
                },
                  friendHistoryData.topAlbums.length === 0
                    ? React.createElement('p', { className: 'col-span-full text-center text-gray-400 py-8' }, 'No top albums data')
                    : friendHistoryData.topAlbums.map((album, index) =>
                        React.createElement('div', {
                          key: album.id || index,
                          className: 'bg-white rounded-lg overflow-hidden hover:shadow-lg transition-shadow cursor-pointer group',
                          onClick: () => fetchArtistData(album.artist)
                        },
                          React.createElement('div', { className: 'aspect-square bg-gradient-to-br from-purple-500 to-pink-500 relative' },
                            // Placeholder always rendered behind
                            React.createElement('div', { className: 'absolute inset-0 flex items-center justify-center text-white/60' },
                              React.createElement('svg', { className: 'w-12 h-12', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                                React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 1.5, d: 'M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3' })
                              )
                            ),
                            album.image && React.createElement('img', {
                              src: album.image,
                              alt: album.name,
                              className: 'absolute inset-0 w-full h-full object-cover transition-opacity duration-300',
                              style: { opacity: 0 },
                              ref: (el) => { if (el && el.complete && el.naturalWidth > 0) el.style.opacity = '1'; },
                              onLoad: (e) => { e.target.style.opacity = '1'; },
                              onError: (e) => { e.target.style.display = 'none'; }
                            }),
                            React.createElement('div', {
                              className: 'absolute top-2 left-2 px-2 py-0.5 bg-black/60 rounded text-xs text-white font-medium'
                            }, `#${album.rank}`)
                          ),
                          React.createElement('div', { className: 'p-3' },
                            React.createElement('p', { className: 'font-medium text-gray-900 truncate text-sm' }, album.name),
                            React.createElement('p', { className: 'text-xs text-gray-500 truncate' }, album.artist),
                            React.createElement('p', { className: 'text-xs text-gray-400 mt-1' }, `${album.playCount} plays`)
                          )
                        )
                      )
                ),
                // Top artists tab content
                !friendHistoryLoading && friendHistoryTab === 'topArtists' && React.createElement('div', {
                  className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4'
                },
                  friendHistoryData.topArtists.length === 0
                    ? React.createElement('p', { className: 'col-span-full text-center text-gray-400 py-8' }, 'No top artists data')
                    : friendHistoryData.topArtists.map((artist, index) =>
                        React.createElement('div', {
                          key: artist.id || index,
                          className: 'bg-white rounded-lg overflow-hidden hover:shadow-lg transition-shadow cursor-pointer group',
                          onClick: () => fetchArtistData(artist.name)
                        },
                          React.createElement('div', { className: 'aspect-square bg-gradient-to-br from-purple-500 to-pink-500 relative' },
                            // Placeholder always rendered behind
                            React.createElement('div', { className: 'absolute inset-0 flex items-center justify-center text-white/60' },
                              React.createElement('svg', { className: 'w-12 h-12', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                                React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 1.5, d: 'M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z' })
                              )
                            ),
                            artist.image && React.createElement('img', {
                              src: artist.image,
                              alt: artist.name,
                              ref: (el) => { if (el && el.complete && el.naturalWidth > 0) el.style.opacity = '1'; },
                              className: 'absolute inset-0 w-full h-full object-cover transition-opacity duration-300',
                              style: { opacity: 0 },
                              onLoad: (e) => { e.target.style.opacity = '1'; },
                              onError: (e) => { e.target.style.display = 'none'; }
                            }),
                            React.createElement('div', {
                              className: 'absolute top-2 left-2 px-2 py-0.5 bg-black/60 rounded text-xs text-white font-medium'
                            }, `#${artist.rank}`)
                          ),
                          React.createElement('div', { className: 'p-3' },
                            React.createElement('p', { className: 'font-medium text-gray-900 truncate text-sm' }, artist.name),
                            React.createElement('p', { className: 'text-xs text-gray-400 mt-1' }, `${artist.playCount} plays`)
                          )
                        )
                      )
                )
            )
          );
        })(),

        activeView === 'settings' && React.createElement('div', {
          className: 'flex flex-col h-full'
        },
          // Header bar with SETTINGS title and CLOSE button
          React.createElement('div', { className: 'flex items-center justify-between px-8 py-3 border-b border-gray-200 flex-shrink-0' },
            React.createElement('span', { className: 'text-xs font-medium tracking-widest text-gray-400 uppercase' }, 'Settings'),
            React.createElement('button', {
              onClick: () => navigateBack(),
              className: 'flex items-center gap-1 px-3 py-1 text-xs text-gray-500 hover:text-gray-700 border border-gray-300 rounded hover:bg-gray-50 transition-colors no-drag'
            },
              'CLOSE',
              React.createElement('span', { className: 'text-gray-400' }, 'Ã—')
            )
          ),
          // Wrapper for sidebar and content
          React.createElement('div', { className: 'flex flex-1 overflow-hidden' },
            // Settings vertical tabs (left side)
            React.createElement('div', {
              className: 'w-48 border-r border-gray-200 py-6 flex-shrink-0'
            },
              React.createElement('nav', { className: 'space-y-1 px-3' },
              // Marketplace tab
              React.createElement('button', {
                onClick: () => setSettingsTab('marketplace'),
                className: `w-full text-left px-4 py-3 text-sm transition-colors ${
                  settingsTab === 'marketplace'
                    ? 'text-gray-900 font-medium border-l-2 border-purple-600 bg-gray-50'
                    : 'text-gray-600 hover:bg-gray-50 border-l-2 border-transparent'
                }`
              }, 'Marketplace'),
              // Installed Plug-Ins tab
              React.createElement('button', {
                onClick: () => setSettingsTab('installed'),
                className: `w-full text-left px-4 py-3 text-sm transition-colors ${
                  settingsTab === 'installed'
                    ? 'text-gray-900 font-medium border-l-2 border-purple-600 bg-gray-50'
                    : 'text-gray-600 hover:bg-gray-50 border-l-2 border-transparent'
                }`
              }, 'Installed Plug-Ins'),
              // General tab (placeholder)
              React.createElement('button', {
                onClick: () => setSettingsTab('general'),
                className: `w-full text-left px-4 py-3 text-sm transition-colors ${
                  settingsTab === 'general'
                    ? 'text-gray-900 font-medium border-l-2 border-purple-600 bg-gray-50'
                    : 'text-gray-600 hover:bg-gray-50 border-l-2 border-transparent'
                }`
              }, 'General'),
              // About tab (placeholder)
              React.createElement('button', {
                onClick: () => setSettingsTab('about'),
                className: `w-full text-left px-4 py-3 text-sm transition-colors ${
                  settingsTab === 'about'
                    ? 'text-gray-900 font-medium border-l-2 border-purple-600 bg-gray-50'
                    : 'text-gray-600 hover:bg-gray-50 border-l-2 border-transparent'
                }`
              }, 'About')
            )
          ),
          // Settings content area (right side)
          React.createElement('div', {
            className: 'flex-1 overflow-y-auto p-8'
          },
            // Installed Plug-Ins Tab
            settingsTab === 'installed' && React.createElement('div', null,
              // Page Header with Add button
              React.createElement('div', { className: 'flex items-center justify-between mb-8' },
                React.createElement('div', null,
                  React.createElement('h2', { className: 'text-xl font-semibold text-gray-900' }, 'Installed Plug-Ins'),
                  React.createElement('p', { className: 'text-sm text-gray-500 mt-1' },
                    'Manage your installed plug-ins for playback and services.'
                  )
                ),
                // Add from file button
                React.createElement('button', {
                  onClick: handleInstallResolver,
                  className: 'px-4 py-2 border border-gray-300 rounded-lg text-sm text-gray-700 hover:bg-gray-50 transition-colors flex items-center gap-2'
                },
                  React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M9 13h6m-3-3v6m5 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z' })
                  ),
                  'Add from file'
                )
              ),

              // Content Resolvers Section
              React.createElement('div', { className: 'mb-10' },
                React.createElement('div', { className: 'mb-4' },
                  React.createElement('h3', { className: 'text-sm font-semibold text-gray-700 uppercase tracking-wider' }, 'Content Resolvers'),
                  React.createElement('p', { className: 'text-xs text-gray-500 mt-1' },
                    'Drag to reorder playback priority'
                  )
                ),
                // Resolver grid
                React.createElement('div', {
                  className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-6'
                },
                  resolverOrder
                    .filter(resolverId => allResolvers.some(r => r.id === resolverId))
                    .map((resolverId, index) => {
                    const resolver = allResolvers.find(r => r.id === resolverId);

                    const isActive = activeResolvers.includes(resolver.id);

                    // Check if marketplace has a newer version
                    const marketplaceResolver = marketplaceManifest?.resolvers?.find(r => r.id === resolver.id);
                    const hasUpdate = marketplaceResolver &&
                      marketplaceResolver.version !== resolver.version &&
                      marketplaceResolver.version > resolver.version;

                    return React.createElement(ResolverCard, {
                      key: resolver.id,
                      resolver: resolver,
                      isActive: isActive,
                      hasUpdate: hasUpdate,
                      priorityNumber: index + 1,
                      draggable: true,
                      isDragging: draggedResolver === resolver.id,
                      isDragOver: dragOverResolver === resolver.id,
                      onClick: () => setSelectedResolver(resolver),
                      onDragStart: (e) => handleResolverDragStart(e, resolver.id),
                      onDragOver: handleResolverDragOver,
                      onDragEnter: (e) => handleResolverDragEnter(e, resolver.id),
                      onDragLeave: handleResolverDragLeave,
                      onDrop: (e) => handleResolverDrop(e, resolver.id),
                      onDragEnd: handleResolverDragEnd,
                      onContextMenu: (e) => {
                        e.preventDefault();
                        if (window.electron?.resolvers?.showContextMenu) {
                          window.electron.resolvers.showContextMenu(resolver.id);
                        }
                      }
                    });
                  })
                )
              ),

              // Meta Services Section - using same card style as resolvers
              metaServices.length > 0 && React.createElement('div', null,
                React.createElement('div', { className: 'mb-4' },
                  React.createElement('h3', { className: 'text-sm font-semibold text-gray-700 uppercase tracking-wider' }, 'Meta Services'),
                  React.createElement('p', { className: 'text-xs text-gray-500 mt-1' },
                    'Connected services for recommendations and metadata'
                  )
                ),
                // Meta services grid - matching resolver card layout
                React.createElement('div', {
                  className: 'flex flex-wrap gap-6'
                },
                  metaServices.map(service => {
                    const config = metaServiceConfigs[service.id];
                    const requiresAuth = service.settings?.requiresAuth !== false;
                    // All installed meta services show a checkmark
                    const isConnected = true;

                    return React.createElement('div', {
                      key: service.id,
                      className: 'flex flex-col items-center'
                    },
                      // Card with colored background - matching resolver style
                      React.createElement('div', {
                        className: 'relative w-32 h-32 rounded-xl flex items-center justify-center cursor-pointer transition-all hover:scale-105 hover:shadow-lg',
                        style: { backgroundColor: service.color || '#6B7280' },
                        onClick: () => setSelectedResolver(service)
                      },
                        // Centered logo or emoji fallback
                        SERVICE_LOGOS[service.id] ? SERVICE_LOGOS[service.id] : React.createElement('span', {
                          className: 'text-5xl text-white drop-shadow-md'
                        }, service.icon),
                        // Connected indicator (top-right checkmark)
                        isConnected && React.createElement('div', {
                          className: 'absolute top-2 right-2 w-6 h-6 bg-white rounded-full flex items-center justify-center text-xs text-green-600'
                        }, 'âœ“')
                      ),
                      // Name below card
                      React.createElement('span', {
                        className: 'mt-3 text-sm text-gray-900 font-medium text-center truncate w-32'
                      }, service.name)
                    );
                  })
                )
              )
            ),

            // Marketplace Tab
            settingsTab === 'marketplace' && React.createElement('div', null,
              // Header
              React.createElement('div', { className: 'mb-6' },
                React.createElement('h2', { className: 'text-xl font-semibold text-gray-900' }, 'Marketplace'),
                React.createElement('p', { className: 'text-sm text-gray-500 mt-1' },
                  'Discover and install plug-ins to extend Parachord.'
                )
              ),

              // Plug-in architecture description
              React.createElement('div', { className: 'bg-gradient-to-r from-purple-50 to-indigo-50 border border-purple-100 rounded-xl p-5 mb-8' },
                React.createElement('div', { className: 'flex gap-4' },
                  // Icon
                  React.createElement('div', { className: 'flex-shrink-0 w-10 h-10 bg-purple-100 rounded-lg flex items-center justify-center' },
                    React.createElement('svg', { className: 'w-5 h-5 text-purple-600', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                      React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M11 4a2 2 0 114 0v1a1 1 0 001 1h3a1 1 0 011 1v3a1 1 0 01-1 1h-1a2 2 0 100 4h1a1 1 0 011 1v3a1 1 0 01-1 1h-3a1 1 0 01-1-1v-1a2 2 0 10-4 0v1a1 1 0 01-1 1H7a1 1 0 01-1-1v-3a1 1 0 00-1-1H4a2 2 0 110-4h1a1 1 0 001-1V7a1 1 0 011-1h3a1 1 0 001-1V4z' })
                    )
                  ),
                  // Content
                  React.createElement('div', { className: 'flex-1' },
                    React.createElement('h3', { className: 'text-sm font-semibold text-gray-900 mb-2' }, 'Extensible Plug-in Architecture'),
                    React.createElement('p', { className: 'text-sm text-gray-600 leading-relaxed mb-3' },
                      'Parachord\'s plug-in system lets you connect to your favorite music services and customize your listening experience. Each plug-in runs in a secure sandbox, ensuring your data stays safe while enabling powerful integrations.'
                    ),
                    React.createElement('div', { className: 'grid grid-cols-1 sm:grid-cols-3 gap-3' },
                      // Feature 1
                      React.createElement('div', { className: 'flex items-start gap-2' },
                        React.createElement('svg', { className: 'w-4 h-4 text-purple-500 mt-0.5 flex-shrink-0', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                          React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3' })
                        ),
                        React.createElement('span', { className: 'text-xs text-gray-600' }, 'Stream from multiple services in one unified library')
                      ),
                      // Feature 2
                      React.createElement('div', { className: 'flex items-start gap-2' },
                        React.createElement('svg', { className: 'w-4 h-4 text-purple-500 mt-0.5 flex-shrink-0', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                          React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M4 7v10c0 2.21 3.582 4 8 4s8-1.79 8-4V7M4 7c0 2.21 3.582 4 8 4s8-1.79 8-4M4 7c0-2.21 3.582-4 8-4s8 1.79 8 4' })
                        ),
                        React.createElement('span', { className: 'text-xs text-gray-600' }, 'Enrich metadata with artist bios, lyrics, and recommendations')
                      ),
                      // Feature 3
                      React.createElement('div', { className: 'flex items-start gap-2' },
                        React.createElement('svg', { className: 'w-4 h-4 text-purple-500 mt-0.5 flex-shrink-0', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                          React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z' })
                        ),
                        React.createElement('span', { className: 'text-xs text-gray-600' }, 'Sandboxed execution keeps your credentials secure')
                      )
                    )
                  )
                )
              ),

              // Search and filter bar
              React.createElement('div', { className: 'flex items-center gap-4 mb-8' },
                // Search input
                React.createElement('div', { className: 'relative' },
                  React.createElement('svg', {
                    className: 'absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-gray-400',
                    fill: 'none',
                    viewBox: '0 0 24 24',
                    stroke: 'currentColor'
                  },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' })
                  ),
                  React.createElement('input', {
                    type: 'text',
                    placeholder: 'Search plug-ins...',
                    value: marketplaceSearchQuery,
                    onChange: (e) => setMarketplaceSearchQuery(e.target.value),
                    className: 'w-64 pl-9 pr-4 py-2 bg-gray-50 border border-gray-200 rounded-full text-sm text-gray-900 placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent'
                  })
                ),
                // Category filter pills
                React.createElement('div', { className: 'flex gap-2 flex-wrap' },
                  [
                    { value: 'all', label: 'All' },
                    { value: 'streaming', label: 'Streaming' },
                    { value: 'purchase', label: 'Purchase' },
                    { value: 'social', label: 'Social' },
                    { value: 'metadata', label: 'Metadata' },
                    { value: 'ai', label: 'AI' },
                    { value: 'local', label: 'Local' }
                  ].map(({ value, label }) =>
                    React.createElement('button', {
                      key: value,
                      onClick: () => setMarketplaceCategory(value),
                      className: `px-3 py-1.5 rounded-full text-sm transition-all ${
                        marketplaceCategory === value
                          ? 'bg-purple-600 text-white'
                          : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                      }`
                    }, label)
                  )
                )
              ),
              // Loading state
              marketplaceLoading && React.createElement('div', {
                className: 'text-center py-12 text-gray-500'
              }, 'Loading marketplace...'),
              // Empty state
              !marketplaceLoading && marketplaceManifest && marketplaceManifest.resolvers && marketplaceManifest.resolvers.length === 0 &&
                React.createElement('div', {
                  className: 'text-center py-12 text-gray-400'
                }, 'No plug-ins available in marketplace yet.'),
              // Resolver grid
              !marketplaceLoading && marketplaceManifest && marketplaceManifest.resolvers && marketplaceManifest.resolvers.length > 0 &&
                React.createElement('div', {
                  className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-6'
                },
                  marketplaceManifest.resolvers
                    .filter(resolver => {
                      if (marketplaceSearchQuery) {
                        const query = marketplaceSearchQuery.toLowerCase();
                        const matchesName = resolver.name.toLowerCase().includes(query);
                        const matchesDesc = resolver.description.toLowerCase().includes(query);
                        const matchesAuthor = resolver.author.toLowerCase().includes(query);
                        if (!matchesName && !matchesDesc && !matchesAuthor) return false;
                      }
                      if (marketplaceCategory !== 'all') {
                        const matchesCategory = resolver.category === marketplaceCategory;
                        const matchesTag = resolver.tags && resolver.tags.includes(marketplaceCategory);
                        if (!matchesCategory && !matchesTag) return false;
                      }
                      return true;
                    })
                    .map(resolver => {
                      const installedResolver = allResolvers.find(r => r.id === resolver.id);
                      const isInstalled = !!installedResolver;
                      const isInstalling = installingResolvers.has(resolver.id);

                      return React.createElement(ResolverCard, {
                        key: resolver.id,
                        resolver: resolver,
                        isInstalled: isInstalled,
                        isInstalling: isInstalling,
                        onClick: () => setSelectedMarketplaceItem({ ...resolver, isInstalled, installedResolver })
                      });
                    })
                )
            ),

            // General Tab
            settingsTab === 'general' && React.createElement('div', null,
              // Page Header
              React.createElement('div', { className: 'mb-8' },
                React.createElement('h2', { className: 'text-xl font-semibold text-gray-900' }, 'General'),
                React.createElement('p', { className: 'text-sm text-gray-500 mt-1' },
                  'Configure application settings and preferences.'
                )
              ),

              // Settings sections
              React.createElement('div', { className: 'space-y-8' },
                // Cache Management Section
                React.createElement('div', {
                  className: 'bg-white border border-gray-200 rounded-xl p-6 hover:shadow-sm hover:border-gray-300 transition-all'
                },
                  React.createElement('div', { className: 'mb-5' },
                    React.createElement('h3', {
                      className: 'text-sm font-semibold text-gray-700 uppercase tracking-wider'
                    }, 'Cache Management'),
                    React.createElement('p', {
                      className: 'text-xs text-gray-500 mt-1'
                    }, 'Clear cached data to free up space or fix display issues')
                  ),
                  React.createElement('p', {
                    className: 'text-sm text-gray-600 mb-5 leading-relaxed'
                  }, 'This will remove cached artist images, album art, and API responses. Loading may be slower temporarily while data is re-fetched.'),
                  React.createElement('button', {
                    onClick: async () => {
                      // Clear all caches
                      artistImageCache.current = {};
                      albumArtCache.current = {};
                      artistDataCache.current = {};
                      albumToReleaseIdCache.current = {};

                      // Clear persisted caches
                      if (window.electron?.store) {
                        await window.electron.store.set('cache_artist_images', {});
                        await window.electron.store.set('cache_album_art', {});
                        await window.electron.store.set('cache_artist_data', {});
                        await window.electron.store.set('cache_album_release_ids', {});
                      }

                      // Show confirmation (using a simple alert for now)
                      alert('Cache cleared successfully!');
                    },
                    className: 'inline-flex items-center gap-2 px-4 py-2 bg-red-600 text-white text-sm font-medium rounded-lg hover:bg-red-700 transition-colors'
                  },
                    React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                      React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16' })
                    ),
                    'Clear Cache'
                  )
                ),

                // Volume Normalization Section
                React.createElement('div', {
                  className: 'bg-white border border-gray-200 rounded-xl p-6 hover:shadow-sm hover:border-gray-300 transition-all'
                },
                  React.createElement('div', { className: 'mb-5' },
                    React.createElement('h3', {
                      className: 'text-sm font-semibold text-gray-700 uppercase tracking-wider'
                    }, 'Volume Normalization'),
                    React.createElement('p', {
                      className: 'text-xs text-gray-500 mt-1'
                    }, 'Balance loudness between different sources')
                  ),
                  React.createElement('p', {
                    className: 'text-sm text-gray-600 mb-6 leading-relaxed'
                  }, 'Adjust volume offsets per resolver to balance loudness. Negative values reduce volume for louder sources.'),

                  // Resolver volume offset sliders
                  React.createElement('div', { className: 'space-y-3' },
                    // Spotify
                    React.createElement('div', { className: 'flex items-center gap-4 py-2 px-3 rounded-lg hover:bg-gray-50 transition-colors' },
                      React.createElement('span', { className: 'w-28 text-sm text-gray-900 font-medium' }, 'Spotify'),
                      React.createElement('input', {
                        type: 'range',
                        min: '-12',
                        max: '6',
                        step: '1',
                        value: resolverVolumeOffsets.spotify || 0,
                        onChange: (e) => setResolverVolumeOffsets(prev => ({ ...prev, spotify: Number(e.target.value) })),
                        className: 'flex-1 h-2 bg-gray-200 rounded-full appearance-none cursor-pointer accent-purple-600'
                      }),
                      React.createElement('span', {
                        className: 'w-16 text-sm text-gray-600 text-right font-mono tabular-nums'
                      }, `${resolverVolumeOffsets.spotify > 0 ? '+' : ''}${resolverVolumeOffsets.spotify || 0} dB`)
                    ),

                    // Local Files
                    React.createElement('div', { className: 'flex items-center gap-4 py-2 px-3 rounded-lg hover:bg-gray-50 transition-colors' },
                      React.createElement('span', { className: 'w-28 text-sm text-gray-900 font-medium' }, 'Local Files'),
                      React.createElement('input', {
                        type: 'range',
                        min: '-12',
                        max: '6',
                        step: '1',
                        value: resolverVolumeOffsets.localfiles || 0,
                        onChange: (e) => setResolverVolumeOffsets(prev => ({ ...prev, localfiles: Number(e.target.value) })),
                        className: 'flex-1 h-2 bg-gray-200 rounded-full appearance-none cursor-pointer accent-purple-600'
                      }),
                      React.createElement('span', {
                        className: 'w-16 text-sm text-gray-600 text-right font-mono tabular-nums'
                      }, `${resolverVolumeOffsets.localfiles > 0 ? '+' : ''}${resolverVolumeOffsets.localfiles || 0} dB`)
                    ),

                    // Bandcamp
                    React.createElement('div', { className: 'flex items-center gap-4 py-2 px-3 rounded-lg opacity-50' },
                      React.createElement('span', { className: 'w-28 text-sm text-gray-500 font-medium' }, 'Bandcamp'),
                      React.createElement('input', {
                        type: 'range',
                        min: '-12',
                        max: '6',
                        step: '1',
                        value: resolverVolumeOffsets.bandcamp || 0,
                        onChange: (e) => setResolverVolumeOffsets(prev => ({ ...prev, bandcamp: Number(e.target.value) })),
                        className: 'flex-1 h-2 bg-gray-200 rounded-full appearance-none cursor-not-allowed',
                        disabled: true,
                        title: 'Browser playback - volume control not available'
                      }),
                      React.createElement('span', {
                        className: 'w-16 text-xs text-gray-400 text-right italic'
                      }, 'Browser')
                    ),

                    // YouTube
                    React.createElement('div', { className: 'flex items-center gap-4 py-2 px-3 rounded-lg opacity-50' },
                      React.createElement('span', { className: 'w-28 text-sm text-gray-500 font-medium' }, 'YouTube'),
                      React.createElement('input', {
                        type: 'range',
                        min: '-12',
                        max: '6',
                        step: '1',
                        value: resolverVolumeOffsets.youtube || 0,
                        onChange: (e) => setResolverVolumeOffsets(prev => ({ ...prev, youtube: Number(e.target.value) })),
                        className: 'flex-1 h-2 bg-gray-200 rounded-full appearance-none cursor-not-allowed',
                        disabled: true,
                        title: 'Browser playback - volume control not available'
                      }),
                      React.createElement('span', {
                        className: 'w-16 text-xs text-gray-400 text-right italic'
                      }, 'Browser')
                    ),

                    // Qobuz
                    React.createElement('div', { className: 'flex items-center gap-4 py-2 px-3 rounded-lg hover:bg-gray-50 transition-colors' },
                      React.createElement('span', { className: 'w-28 text-sm text-gray-900 font-medium' }, 'Qobuz'),
                      React.createElement('input', {
                        type: 'range',
                        min: '-12',
                        max: '6',
                        step: '1',
                        value: resolverVolumeOffsets.qobuz || 0,
                        onChange: (e) => setResolverVolumeOffsets(prev => ({ ...prev, qobuz: Number(e.target.value) })),
                        className: 'flex-1 h-2 bg-gray-200 rounded-full appearance-none cursor-pointer accent-purple-600'
                      }),
                      React.createElement('span', {
                        className: 'w-16 text-sm text-gray-600 text-right font-mono tabular-nums'
                      }, `${resolverVolumeOffsets.qobuz > 0 ? '+' : ''}${resolverVolumeOffsets.qobuz || 0} dB`)
                    )
                  ),

                  // Reset button
                  React.createElement('div', { className: 'mt-6 pt-5 border-t border-gray-100' },
                    React.createElement('button', {
                      onClick: () => setResolverVolumeOffsets({
                        spotify: 0,
                        localfiles: 0,
                        bandcamp: -3,
                        youtube: -6,
                        qobuz: 0
                      }),
                      className: 'inline-flex items-center gap-2 px-4 py-2 border border-gray-300 text-gray-700 text-sm font-medium rounded-lg hover:bg-gray-50 hover:border-purple-300 transition-colors'
                    },
                      React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                        React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15' })
                      ),
                      'Reset to Defaults'
                    )
                  )
                ),

                // Playback Behavior Section
                React.createElement('div', {
                  className: 'bg-white border border-gray-200 rounded-xl p-6 hover:shadow-sm hover:border-gray-300 transition-all'
                },
                  React.createElement('div', { className: 'mb-5' },
                    React.createElement('h3', {
                      className: 'text-sm font-semibold text-gray-700 uppercase tracking-wider'
                    }, 'Playback Behavior'),
                    React.createElement('p', {
                      className: 'text-xs text-gray-500 mt-1'
                    }, 'Configure how external tracks are handled')
                  ),
                  // Skip external prompt toggle
                  React.createElement('div', { className: 'flex items-center justify-between py-3' },
                    React.createElement('div', null,
                      React.createElement('p', { className: 'text-sm text-gray-900 font-medium' },
                        'Auto-open external tracks'
                      ),
                      React.createElement('p', { className: 'text-xs text-gray-500 mt-0.5' },
                        'Skip the confirmation prompt for Bandcamp, YouTube, etc.'
                      )
                    ),
                    React.createElement('button', {
                      onClick: async () => {
                        const newValue = !skipExternalPrompt;
                        setSkipExternalPrompt(newValue);
                        if (window.electron?.store) {
                          await window.electron.store.set('skip_external_prompt', newValue);
                        }
                      },
                      className: `relative w-11 h-6 rounded-full transition-colors ${skipExternalPrompt ? 'bg-purple-600' : 'bg-gray-300'}`
                    },
                      React.createElement('span', {
                        className: `absolute top-0.5 left-0.5 w-5 h-5 bg-white rounded-full shadow transition-transform ${skipExternalPrompt ? 'translate-x-5' : 'translate-x-0'}`
                      })
                    )
                  ),
                ),

                // Dialogs Section - Reset "Don't show again" preferences
                React.createElement('div', {
                  className: 'bg-white border border-gray-200 rounded-xl p-6 hover:shadow-sm hover:border-gray-300 transition-all'
                },
                  React.createElement('div', { className: 'mb-5' },
                    React.createElement('h3', {
                      className: 'text-sm font-semibold text-gray-700 uppercase tracking-wider'
                    }, 'Dialogs'),
                    React.createElement('p', {
                      className: 'text-xs text-gray-500 mt-1'
                    }, 'Manage confirmation dialogs and prompts')
                  ),
                  // List of dismissed dialogs
                  React.createElement('div', { className: 'space-y-3 mb-5' },
                    // External track prompt
                    React.createElement('div', { className: 'flex items-center justify-between py-2 px-3 rounded-lg bg-gray-50' },
                      React.createElement('div', null,
                        React.createElement('p', { className: 'text-sm text-gray-900' }, 'Open in Browser prompt'),
                        React.createElement('p', { className: 'text-xs text-gray-500' }, 'Confirmation before opening external tracks')
                      ),
                      React.createElement('div', {
                        className: `px-2 py-0.5 rounded text-xs font-medium ${skipExternalPrompt ? 'bg-amber-100 text-amber-700' : 'bg-green-100 text-green-700'}`
                      }, skipExternalPrompt ? 'Hidden' : 'Showing')
                    ),
                    // Unsaved friend unpin warning
                    React.createElement('div', { className: 'flex items-center justify-between py-2 px-3 rounded-lg bg-gray-50' },
                      React.createElement('div', null,
                        React.createElement('p', { className: 'text-sm text-gray-900' }, 'Unsaved friend warning'),
                        React.createElement('p', { className: 'text-xs text-gray-500' }, 'Warning when unpinning friends not saved to collection')
                      ),
                      React.createElement('div', {
                        className: `px-2 py-0.5 rounded text-xs font-medium ${skipUnsavedFriendWarning ? 'bg-amber-100 text-amber-700' : 'bg-green-100 text-green-700'}`
                      }, skipUnsavedFriendWarning ? 'Hidden' : 'Showing')
                    )
                  ),
                  // Reset all button
                  (skipExternalPrompt || skipUnsavedFriendWarning) && React.createElement('button', {
                    onClick: async () => {
                      setSkipExternalPrompt(false);
                      setSkipUnsavedFriendWarning(false);
                      if (window.electron?.store) {
                        await window.electron.store.set('skip_external_prompt', false);
                        await window.electron.store.set('skip_unsaved_friend_warning', false);
                      }
                      showToast('All dialog preferences reset');
                    },
                    className: 'inline-flex items-center gap-2 px-4 py-2 bg-purple-600 text-white text-sm font-medium rounded-lg hover:bg-purple-700 transition-colors'
                  },
                    React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                      React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15' })
                    ),
                    'Reset All Dialogs'
                  ),
                  // All dialogs showing message
                  (!skipExternalPrompt && !skipUnsavedFriendWarning) && React.createElement('p', {
                    className: 'text-sm text-gray-500 italic'
                  }, 'All confirmation dialogs are currently enabled.')
                ),

                // Queue Settings Section
                React.createElement('div', {
                  className: 'bg-white border border-gray-200 rounded-xl p-6 hover:shadow-sm hover:border-gray-300 transition-all'
                },
                  React.createElement('div', { className: 'mb-5' },
                    React.createElement('h3', {
                      className: 'text-sm font-semibold text-gray-700 uppercase tracking-wider'
                    }, 'Queue Settings'),
                    React.createElement('p', {
                      className: 'text-xs text-gray-500 mt-1'
                    }, 'Configure queue persistence')
                  ),
                  // Remember queue toggle
                  React.createElement('div', { className: 'flex items-center justify-between py-3' },
                    React.createElement('div', null,
                      React.createElement('p', { className: 'text-sm text-gray-900 font-medium' },
                        'Remember queue'
                      ),
                      React.createElement('p', { className: 'text-xs text-gray-500 mt-0.5' },
                        'Restore your queue when you reopen the app'
                      )
                    ),
                    React.createElement('button', {
                      onClick: async () => {
                        const newValue = !rememberQueue;
                        setRememberQueue(newValue);
                        if (window.electron?.store) {
                          await window.electron.store.set('remember_queue', newValue);
                          // If turning off, clear the saved queue and context
                          if (!newValue) {
                            await window.electron.store.set('saved_queue', []);
                            await window.electron.store.set('saved_playback_context', null);
                          }
                        }
                      },
                      className: `relative w-11 h-6 rounded-full transition-colors ${rememberQueue ? 'bg-purple-600' : 'bg-gray-300'}`
                    },
                      React.createElement('span', {
                        className: `absolute top-0.5 left-0.5 w-5 h-5 bg-white rounded-full shadow transition-transform ${rememberQueue ? 'translate-x-5' : 'translate-x-0'}`
                      })
                    )
                  )
                ),

                // Scrobbling Section
                React.createElement('div', {
                  className: 'bg-white border border-gray-200 rounded-xl p-6 hover:shadow-sm hover:border-gray-300 transition-all'
                },
                  React.createElement('div', { className: 'mb-5' },
                    React.createElement('h3', {
                      className: 'text-sm font-semibold text-gray-700 uppercase tracking-wider flex items-center gap-2'
                    },
                      // Music note icon
                      React.createElement('svg', {
                        className: 'w-4 h-4',
                        fill: 'none',
                        stroke: 'currentColor',
                        viewBox: '0 0 24 24'
                      },
                        React.createElement('path', {
                          strokeLinecap: 'round',
                          strokeLinejoin: 'round',
                          strokeWidth: 2,
                          d: 'M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3'
                        })
                      ),
                      'Scrobbling'
                    ),
                    React.createElement('p', {
                      className: 'text-xs text-gray-500 mt-1'
                    }, 'Report your listening history to scrobbling services')
                  ),

                  // Global enable/disable toggle
                  React.createElement('div', { className: 'flex items-center justify-between py-3 px-3 bg-gray-50 rounded-lg' },
                    React.createElement('div', null,
                      React.createElement('p', { className: 'text-sm text-gray-900 font-medium' },
                        'Enable Scrobbling'
                      ),
                      React.createElement('p', { className: 'text-xs text-gray-500 mt-0.5' },
                        'Send your listening activity to connected services'
                      )
                    ),
                    React.createElement('button', {
                      onClick: async () => {
                        const newValue = !scrobblingEnabled;
                        setScrobblingEnabled(newValue);
                        if (window.electron?.store) {
                          await window.electron.store.set('scrobbling-enabled', newValue);
                        }
                      },
                      className: `relative w-11 h-6 rounded-full transition-colors ${scrobblingEnabled ? 'bg-purple-600' : 'bg-gray-300'}`
                    },
                      React.createElement('span', {
                        className: `absolute top-0.5 left-0.5 w-5 h-5 bg-white rounded-full shadow transition-transform ${scrobblingEnabled ? 'translate-x-5' : 'translate-x-0'}`
                      })
                    )
                  ),

                  // Note about configuring scrobblers
                  React.createElement('p', {
                    className: 'text-xs text-gray-500 mt-4 text-center'
                  }, 'Configure scrobbling services in their respective settings: Last.fm, ListenBrainz, and Libre.fm.')
                ),

                // Reset Application Section
                React.createElement('div', {
                  className: 'bg-white border border-red-200 rounded-xl p-6 hover:shadow-sm hover:border-red-300 transition-all'
                },
                  React.createElement('div', { className: 'mb-5' },
                    React.createElement('h3', {
                      className: 'text-sm font-semibold text-red-700 uppercase tracking-wider'
                    }, 'Reset Application'),
                    React.createElement('p', {
                      className: 'text-xs text-gray-500 mt-1'
                    }, 'Clear all data and start fresh')
                  ),
                  React.createElement('p', {
                    className: 'text-sm text-gray-600 mb-5 leading-relaxed'
                  }, 'This will permanently delete all your data including your collection, playlists, friends, listening history, connected accounts, and all settings. The app will restart as if it was freshly installed.'),
                  React.createElement('button', {
                    onClick: async () => {
                      // Show confirmation dialog
                      const confirmed = window.confirm(
                        'Are you sure you want to reset the application?\n\n' +
                        'This will permanently delete:\n' +
                        'â€¢ Your music collection\n' +
                        'â€¢ All playlists\n' +
                        'â€¢ Friends list\n' +
                        'â€¢ Connected accounts (Spotify, Last.fm, etc.)\n' +
                        'â€¢ All settings and preferences\n' +
                        'â€¢ Cached data\n\n' +
                        'This action cannot be undone.'
                      );

                      if (confirmed) {
                        try {
                          // Clear electron store (all persisted data)
                          if (window.electron?.store?.clear) {
                            await window.electron.store.clear();
                          }

                          // Clear in-memory caches
                          artistImageCache.current = {};
                          albumArtCache.current = {};
                          artistDataCache.current = {};
                          albumToReleaseIdCache.current = {};

                          // Reload the app
                          window.location.reload();
                        } catch (error) {
                          console.error('Failed to reset application:', error);
                          alert('Failed to reset application. Please try again.');
                        }
                      }
                    },
                    className: 'inline-flex items-center gap-2 px-4 py-2 bg-red-600 text-white text-sm font-medium rounded-lg hover:bg-red-700 transition-colors'
                  },
                    React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                      React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z' })
                    ),
                    'Reset Application'
                  )
                )
              ) // Close space-y-8 wrapper
            ),

            // About Tab
            settingsTab === 'about' && React.createElement('div', {
              className: 'flex flex-col items-center justify-center py-12'
            },
              // Parachord Logo
              React.createElement('img', {
                src: './assets/logo-wordmark.png',
                alt: 'Parachord',
                className: 'h-16 mb-6'
              }),

              // Version
              React.createElement('p', { className: 'text-lg text-gray-600 mb-2' }, 'Version 1.0.0'),

              // Tagline
              React.createElement('p', { className: 'text-gray-500 mb-8 text-center max-w-md' },
                'A modern multi-source music player inspired by ',
                React.createElement('a', {
                  href: '#',
                  onClick: (e) => {
                    e.preventDefault();
                    if (window.electron?.shell?.openExternal) {
                      window.electron.shell.openExternal('https://github.com/tomahawk-player/tomahawk');
                    }
                  },
                  className: 'text-purple-600 hover:text-purple-700 hover:underline'
                }, 'Tomahawk'),
                '.'
              ),

              // Divider
              React.createElement('div', { className: 'w-48 h-px bg-gray-200 mb-8' }),

              // Open Source info
              React.createElement('div', { className: 'text-center mb-8' },
                React.createElement('p', { className: 'text-sm text-gray-500 mb-2' }, 'Open Source Software'),
                React.createElement('p', { className: 'text-xs text-gray-400' },
                  'Built with Electron, React, and Tailwind CSS'
                ),
                React.createElement('a', {
                  href: '#',
                  onClick: (e) => {
                    e.preventDefault();
                    if (window.electron?.shell?.openExternal) {
                      window.electron.shell.openExternal('https://github.com/jherskowitz/parachord');
                    }
                  },
                  className: 'text-xs text-purple-600 hover:text-purple-700 mt-2 inline-block'
                }, 'View on GitHub')
              ),

              // Copyright
              React.createElement('p', { className: 'text-xs text-gray-400' },
                'Â© ', new Date().getFullYear(), ' Parachord. All rights reserved.'
              ),

              // License
              React.createElement('p', { className: 'text-xs text-gray-400 mt-1' },
                'Licensed under the MIT License'
              )
            )
          )
        ) // Close content area
      ) // Close wrapper (sidebar + content)
    ) // Close settings container
    )
    ), // Close outer wrappers

    // Player bar (always visible) - New Tomahawk-inspired layout
    // Layout: [Left: transport + queue] [Center: track info] [Right: progress + shuffle + repeat + volume]
    // z-50 to stay above queue drawer
    React.createElement('div', {
      className: 'bg-gray-800/95 backdrop-blur-xl border-t border-gray-700 py-3 no-drag flex-shrink-0 relative z-50',
      style: { minHeight: '85px', paddingLeft: '26px', paddingRight: '26px' }
    },
      React.createElement('div', { className: 'flex items-center justify-between gap-4' },
        // LEFT: Transport controls + Queue button
        React.createElement('div', { className: 'flex items-center gap-2' },
          React.createElement('button', {
            onClick: handlePrevious,
            disabled: !currentTrack,
            className: `p-2 rounded hover:bg-white/10 transition-colors ${!currentTrack ? 'text-gray-600 cursor-not-allowed' : 'text-white'}`,
            style: { display: 'flex', alignItems: 'center', justifyContent: 'center' }
          }, React.createElement(SkipBack, { size: 18 })),
          React.createElement('button', {
            onClick: handlePlayPause,
            disabled: !currentTrack,
            className: `p-2 rounded hover:bg-white/10 transition-colors ${!currentTrack ? 'text-gray-600 cursor-not-allowed' : 'text-white'}`,
            style: { width: '38px', height: '38px', display: 'flex', alignItems: 'center', justifyContent: 'center' }
          }, isPlaying ? React.createElement(Pause, { size: 22 }) : React.createElement(Play, { size: 22 })),
          React.createElement('button', {
            onClick: handleNext,
            disabled: !currentTrack,
            className: `p-2 rounded hover:bg-white/10 transition-colors ${!currentTrack ? 'text-gray-600 cursor-not-allowed' : 'text-white'}`,
            style: { display: 'flex', alignItems: 'center', justifyContent: 'center' }
          }, React.createElement(SkipForward, { size: 18 })),
          // Queue button (hamburger style)
          React.createElement('button', {
            onClick: () => setQueueDrawerOpen(!queueDrawerOpen),
            className: `relative p-2 ml-1 rounded hover:bg-white/10 transition-colors ${queueDrawerOpen ? 'bg-white/20 text-white' : 'text-gray-400'} ${queueAnimating ? 'queue-pulse' : ''}`,
            style: { display: 'flex', alignItems: 'center', justifyContent: 'center' },
            title: `Queue (${currentQueue.length} tracks)`
          },
            React.createElement(List, { size: 15 }),
            currentQueue.length > 0 && React.createElement('span', {
              className: `absolute -top-1 -right-1 bg-green-500 text-white text-xs rounded-full min-w-[16px] h-[16px] flex items-center justify-center px-1 text-[10px] font-medium ${queueAnimating ? 'badge-flash' : ''}`
            }, currentQueue.length > 99 ? '99+' : currentQueue.length)
          ),
          // AI Playlist Generation button (sparkle icon)
          (() => {
            const aiResolvers = getAiServices();
            const hasEnabledAi = aiResolvers.some(s => {
              const config = metaServiceConfigs[s.id] || {};
              return config.enabled && config.apiKey;
            });
            return React.createElement('button', {
              onClick: () => setAiPromptOpen(!aiPromptOpen),
              disabled: !hasEnabledAi,
              className: `p-2 ml-1 rounded transition-colors ${
                aiPromptOpen
                  ? 'bg-purple-500/30 text-purple-300'
                  : hasEnabledAi
                    ? 'text-gray-400 hover:bg-white/10 hover:text-white'
                    : 'text-gray-600 cursor-not-allowed'
              }`,
              title: hasEnabledAi
                ? 'Generate playlist with AI'
                : 'Enable an AI plugin in Settings â†’ Plug-ins'
            },
              React.createElement('svg', {
                className: 'w-4 h-4',
                viewBox: '0 0 56 56',
                fill: 'currentColor'
              },
                // Sparkle icon
                React.createElement('path', {
                  d: 'M 26.6875 12.6602 C 26.9687 12.6602 27.1094 12.4961 27.1797 12.2383 C 27.9062 8.3242 27.8594 8.2305 31.9375 7.4570 C 32.2187 7.4102 32.3828 7.2461 32.3828 6.9648 C 32.3828 6.6836 32.2187 6.5195 31.9375 6.4726 C 27.8828 5.6524 28.0000 5.5586 27.1797 1.6914 C 27.1094 1.4336 26.9687 1.2695 26.6875 1.2695 C 26.4062 1.2695 26.2656 1.4336 26.1953 1.6914 C 25.3750 5.5586 25.5156 5.6524 21.4375 6.4726 C 21.1797 6.5195 20.9922 6.6836 20.9922 6.9648 C 20.9922 7.2461 21.1797 7.4102 21.4375 7.4570 C 25.5156 8.2774 25.4687 8.3242 26.1953 12.2383 C 26.2656 12.4961 26.4062 12.6602 26.6875 12.6602 Z M 15.3438 28.7852 C 15.7891 28.7852 16.0938 28.5039 16.1406 28.0821 C 16.9844 21.8242 17.1953 21.8242 23.6641 20.5821 C 24.0860 20.5117 24.3906 20.2305 24.3906 19.7852 C 24.3906 19.3633 24.0860 19.0586 23.6641 18.9883 C 17.1953 18.0977 16.9609 17.8867 16.1406 11.5117 C 16.0938 11.0899 15.7891 10.7852 15.3438 10.7852 C 14.9219 10.7852 14.6172 11.0899 14.5703 11.5352 C 13.7969 17.8164 13.4687 17.7930 7.0469 18.9883 C 6.6250 19.0821 6.3203 19.3633 6.3203 19.7852 C 6.3203 20.2539 6.6250 20.5117 7.1406 20.5821 C 13.5156 21.6133 13.7969 21.7774 14.5703 28.0352 C 14.6172 28.5039 14.9219 28.7852 15.3438 28.7852 Z M 31.2344 54.7305 C 31.8438 54.7305 32.2891 54.2852 32.4062 53.6524 C 34.0703 40.8086 35.8750 38.8633 48.5781 37.4570 C 49.2344 37.3867 49.6797 36.8945 49.6797 36.2852 C 49.6797 35.6758 49.2344 35.2070 48.5781 35.1133 C 35.8750 33.7070 34.0703 31.7617 32.4062 18.9180 C 32.2891 18.2852 31.8438 17.8633 31.2344 17.8633 C 30.6250 17.8633 30.1797 18.2852 30.0860 18.9180 C 28.4219 31.7617 26.5938 33.7070 13.9140 35.1133 C 13.2344 35.2070 12.7891 35.6758 12.7891 36.2852 C 12.7891 36.8945 13.2344 37.3867 13.9140 37.4570 C 26.5703 39.1211 28.3281 40.8321 30.0860 53.6524 C 30.1797 54.2852 30.6250 54.7305 31.2344 54.7305 Z'
                })
              )
            );
          })()
        ),

        // CENTER: Track info (album art + metadata)
        React.createElement('div', {
          className: 'flex items-center gap-3 relative',
          style: { width: '340px', flexShrink: 0 },
          onDragEnter: (e) => handleDragEnter(e, 'now-playing'),
          onDragOver: (e) => handleDragOver(e, 'now-playing'),
          onDragLeave: handleDragLeave,
          onDrop: (e) => handleDrop(e, 'now-playing')
        },
          React.createElement(DropZoneOverlay, {
            zone: 'now-playing',
            isActive: isDraggingUrl && dropZoneTarget === 'now-playing'
          }),
          currentTrack ? [
            React.createElement('div', {
              key: 'album-art-button',
              draggable: true,
              onDragStart: (e) => {
                // Set track data for playlists
                const trackData = {
                  type: 'track',
                  track: {
                    title: currentTrack.title,
                    artist: currentTrack.artist,
                    album: currentTrack.album,
                    duration: currentTrack.duration,
                    id: `${currentTrack.artist}-${currentTrack.title}`.toLowerCase().replace(/[^a-z0-9-]/g, '')
                  }
                };
                e.dataTransfer.effectAllowed = 'copy';
                e.dataTransfer.setData('text/plain', JSON.stringify(trackData));
                // Also set state for immediate access
                setDraggingTrackForPlaylist(trackData.track);
              },
              onDragEnd: () => {
                setDraggingTrackForPlaylist(null);
                setDropTargetPlaylistId(null);
                setDropTargetNewPlaylist(false);
              },
              onContextMenu: (e) => {
                e.preventDefault();
                if (window.electron?.contextMenu?.showTrackMenu) {
                  window.electron.contextMenu.showTrackMenu({
                    type: 'track',
                    track: currentTrack,
                    isNowPlaying: true
                  });
                }
              },
              onClick: async () => {
                // Search for the album and open its page
                if (currentTrack.album && currentTrack.artist) {
                  try {
                    // Search MusicBrainz for the release
                    const query = encodeURIComponent(`"${currentTrack.album}" AND artist:"${currentTrack.artist}"`);
                    const response = await fetch(
                      `https://musicbrainz.org/ws/2/release-group?query=${query}&fmt=json&limit=1`,
                      { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }}
                    );
                    if (response.ok) {
                      const data = await response.json();
                      if (data['release-groups']?.length > 0) {
                        const album = data['release-groups'][0];
                        handleAlbumClick(album);
                      }
                    }
                  } catch (error) {
                    console.error('Error searching for album:', error);
                  }
                }
              },
              className: 'flex-shrink-0 hover:opacity-80 transition-opacity cursor-grab active:cursor-grabbing no-drag',
              title: currentTrack.album ? `Drag to add to playlist â€¢ Click to open "${currentTrack.album}"` : 'Drag to add to playlist'
            },
              React.createElement('div', {
                className: 'bg-gray-700 rounded flex items-center justify-center overflow-hidden relative',
                style: { width: '61px', height: '61px' }
              },
                // Previous album art (fading out)
                playbarAlbumArt.previous && React.createElement('img', {
                  key: 'prev-art-' + playbarAlbumArt.previous,
                  src: playbarAlbumArt.previous,
                  alt: '',
                  className: 'absolute inset-0 w-full h-full object-cover',
                  style: {
                    opacity: playbarAlbumArt.isLoaded ? 0 : 1,
                    transition: 'opacity 0.3s ease-out'
                  }
                }),
                // Current album art (fading in)
                playbarAlbumArt.current && React.createElement('img', {
                  key: 'curr-art-' + playbarAlbumArt.current,
                  src: playbarAlbumArt.current,
                  alt: currentTrack.album,
                  className: 'absolute inset-0 w-full h-full object-cover',
                  style: {
                    opacity: playbarAlbumArt.isLoaded ? 1 : 0,
                    transition: 'opacity 0.3s ease-in'
                  },
                  onLoad: () => setPlaybarAlbumArt(prev => ({ ...prev, isLoaded: true })),
                  onError: (e) => { e.target.style.display = 'none'; }
                }),
                React.createElement(Music, { size: 20, className: 'text-gray-500' })
              )
            ),
            React.createElement('div', {
              key: 'track-info',
              className: 'min-w-0',
              onContextMenu: (e) => {
                e.preventDefault();
                if (window.electron?.contextMenu?.showTrackMenu) {
                  window.electron.contextMenu.showTrackMenu({
                    type: 'track',
                    track: currentTrack,
                    isNowPlaying: true
                  });
                }
              }
            },
              // Line 1: Track title
              React.createElement('div', { className: 'text-sm font-medium text-white truncate' }, currentTrack.title),
              // Line 2: Artist name
              React.createElement('div', { className: 'text-xs text-gray-400 truncate' },
                React.createElement('button', {
                  onClick: () => fetchArtistData(currentTrack.artist),
                  className: 'hover:text-white hover:underline transition-colors cursor-pointer no-drag'
                }, currentTrack.artist)
              ),
              // Line 3: Resolver + browser indicator
              (() => {
                const resolverId = determineResolverIdFromTrack(currentTrack);
                const resolver = allResolvers.find(r => r.id === resolverId);
                if (resolver) {
                  const meta = {
                    spotify: { color: 'text-green-400' },
                    bandcamp: { color: 'text-cyan-400' },
                    qobuz: { color: 'text-blue-400' },
                    youtube: { color: 'text-red-400' }
                  }[resolverId] || { color: 'text-purple-400' };
                  return React.createElement('div', { className: 'flex items-center gap-1 mt-0.5' },
                    React.createElement('span', { className: `text-xs ${meta.color}` }, resolver.name),
                    // Browser indicator pill for external playback
                    isExternalPlayback && React.createElement('span', {
                      className: 'inline-flex items-center gap-0.5 px-1.5 py-0.5 rounded-full text-[10px] font-medium bg-cyan-500/20 text-cyan-300',
                      title: 'Playing in browser'
                    },
                      React.createElement('svg', {
                        className: 'w-2.5 h-2.5',
                        fill: 'none',
                        viewBox: '0 0 24 24',
                        stroke: 'currentColor',
                        strokeWidth: 2.5
                      },
                        React.createElement('circle', { cx: 12, cy: 12, r: 10 }),
                        React.createElement('path', { d: 'M2 12h20M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z' })
                      ),
                      'browser'
                    )
                  );
                }
                return null;
              })()
            )
          ] : React.createElement(React.Fragment, null,
            // Skeleton album art
            React.createElement('div', {
              className: `flex-shrink-0 rounded ${trackLoading ? 'bg-gradient-to-r from-gray-700 via-gray-600 to-gray-700 animate-shimmer' : 'bg-gray-700'}`,
              style: { width: '61px', height: '61px', ...(trackLoading ? { backgroundSize: '200% 100%' } : {}) }
            }),
            // Skeleton track info - matches actual track info layout
            React.createElement('div', { className: 'min-w-0' },
              // Track title skeleton (text-sm = 14px, but skeleton slightly smaller)
              React.createElement('div', {
                className: `h-3.5 rounded ${trackLoading ? 'bg-gradient-to-r from-gray-700 via-gray-600 to-gray-700 animate-shimmer' : 'bg-gray-700'}`,
                style: { width: '200px', ...(trackLoading ? { backgroundSize: '200% 100%' } : {}) }
              }),
              // Artist skeleton (text-xs = 12px)
              React.createElement('div', {
                className: `h-3 rounded mt-1 ${trackLoading ? 'bg-gradient-to-r from-gray-700 via-gray-600 to-gray-700 animate-shimmer' : 'bg-gray-700'}`,
                style: { width: '140px', ...(trackLoading ? { backgroundSize: '200% 100%' } : {}) }
              }),
              // Source skeleton (text-xs with mt-0.5)
              React.createElement('div', {
                className: `h-3 rounded mt-1 ${trackLoading ? 'bg-gradient-to-r from-gray-700 via-gray-600 to-gray-700 animate-shimmer' : 'bg-gray-700'}`,
                style: { width: '80px', ...(trackLoading ? { backgroundSize: '200% 100%' } : {}) }
              })
            )
          )
        ),

        // RIGHT: Heart + Progress bar + Shuffle + Repeat + Volume
        React.createElement('div', { className: 'flex items-center gap-3' },
          // Heart/favorite button
          (() => {
            if (!currentTrack) return null;
            const trackId = `${currentTrack.artist || 'unknown'}-${currentTrack.title || 'untitled'}-${currentTrack.album || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
            const isInCollection = collectionData.tracks.some(t => t.id === trackId);
            return React.createElement('button', {
              onClick: () => {
                if (!isInCollection) {
                  // Get sources from trackSources state as fallback (keyed by position-title)
                  const trackSourceKey = `${currentTrack.position || 0}-${currentTrack.title}`;
                  const stateSources = trackSources[trackSourceKey];
                  // Also check cache
                  const cacheKey = `${(currentTrack.artist || '').toLowerCase()}|${(currentTrack.title || '').toLowerCase()}|${currentTrack.position || 0}`;
                  const cachedSources = trackSourcesCache.current[cacheKey]?.sources;
                  // Merge sources: currentTrack.sources > cached > state
                  const effectiveSources = {
                    ...(stateSources || {}),
                    ...(cachedSources || {}),
                    ...(currentTrack.sources || {})
                  };
                  addTrackToCollection({ ...currentTrack, sources: effectiveSources });
                } else {
                  showToast(`${currentTrack.title} is already in your collection`);
                }
              },
              className: `p-1.5 rounded-full transition-colors ${isInCollection ? 'text-red-500 hover:text-red-400' : 'text-gray-400 hover:text-white'}`,
              title: isInCollection ? 'In your collection' : 'Add to collection'
            },
              React.createElement('svg', {
                className: 'w-5 h-5',
                viewBox: '0 0 24 24',
                fill: isInCollection ? 'currentColor' : 'none',
                stroke: 'currentColor',
                strokeWidth: isInCollection ? 0 : 2
              },
                React.createElement('path', {
                  strokeLinecap: 'round',
                  strokeLinejoin: 'round',
                  d: 'M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z'
                })
              )
            );
          })(),
          // Progress section
          React.createElement('div', { className: 'flex items-center gap-2 min-w-[200px]' },
            React.createElement('span', {
              className: 'text-xs text-gray-400 tabular-nums',
              style: { width: '36px', textAlign: 'right', fontVariantNumeric: 'tabular-nums', lineHeight: '1' }
            },
              currentTrack && !browserPlaybackActive ? formatTime(progress) : '0:00'
            ),
            React.createElement('div', { className: 'flex-1 w-24 flex items-center' },
              (() => {
                // Check if current track is Spotify (seeking not supported)
                const isSpotifyTrack = currentTrack && (currentTrack.sources?.spotify || currentTrack.spotifyUri || currentTrack.resolver === 'spotify');
                const isSeekDisabled = !currentTrack || browserPlaybackActive || isSpotifyTrack;

                return React.createElement('input', {
                  type: 'range',
                  min: '0',
                  max: currentTrack?.duration || 100,
                  value: currentTrack && !browserPlaybackActive ? progress : 0,
                  disabled: isSeekDisabled,
                  onChange: async (e) => {
                    if (browserPlaybackActive || !currentTrack || isSpotifyTrack) return;
                    const newPosition = Number(e.target.value);
                    setProgress(newPosition);
                    if (currentTrack?.sources?.localfiles && audioRef.current) {
                      audioRef.current.currentTime = newPosition;
                    }
                  },
                  className: `progress-slider w-full h-1 rounded-full ${isSeekDisabled ? 'bg-gray-700' : 'bg-gray-600'}`,
                  title: isSpotifyTrack ? 'Seeking not available for Spotify tracks' : undefined
                });
              })()
            ),
            React.createElement('span', {
              className: 'text-xs text-gray-400 tabular-nums',
              style: { width: '36px', textAlign: 'left', fontVariantNumeric: 'tabular-nums', lineHeight: '1' }
            },
              currentTrack ? formatTime(currentTrack.duration) : '0:00'
            )
          ),
          // Shuffle button (placeholder)
          React.createElement('button', {
            disabled: true,
            className: 'p-2 rounded text-gray-600 cursor-not-allowed',
            title: 'Shuffle (coming soon)'
          },
            React.createElement('svg', { className: 'w-4 h-4', viewBox: '0 0 18 18', fill: 'currentColor' },
              React.createElement('path', { d: 'M17.5,1.5l-8.6,7l-8.4-7v14.9l8.3-6.9l8.8,7.1V1.5z M1.5,14.2V3.6l6.4,5.3L1.5,14.2z M16.5,14.4L9.8,9l6.7-5.4V14.4z' })
            )
          ),
          // Repeat button (placeholder) - disabled for now
          // React.createElement('button', {
          //   disabled: true,
          //   className: 'p-2 rounded text-gray-600 cursor-not-allowed',
          //   title: 'Repeat (coming soon)'
          // },
          //   React.createElement('svg', { className: 'w-4 h-4', viewBox: '0 0 16 16', fill: 'currentColor' },
          //     React.createElement('path', { d: 'M8,16c-1.3,0-2.7-0.3-3.8-1c-0.8-0.4-1.4-0.9-2-1.6c-0.5-0.5-0.9-1.1-1.3-1.8C0.3,10.5,0,9.3,0,8c0-4.4,3.6-8,8-8c1.1,0,2.1,0.2,3,0.6l-0.4,0.9C9.8,1.2,8.9,1,8,1C4.1,1,1,4.1,1,8c0,1.1,0.3,2.2,0.8,3.2c0.3,0.6,0.7,1.1,1.1,1.6c0.5,0.5,1.1,1,1.8,1.4C5.7,14.7,6.8,15,8,15c3.9,0,7-3.1,7-7c0-1-0.2-2-0.6-2.9l0.9-0.4C15.8,5.7,16,6.8,16,8C16,12.4,12.4,16,8,16z' })
          //   )
          // ),
          // Volume - only enabled for local files and Spotify on Computer devices
          (() => {
            const currentResolverId = determineResolverIdFromTrack(currentTrack);
            const isSpotify = currentResolverId === 'spotify';
            // For Spotify, only enable volume on Computer devices (desktop app)
            // TVs, speakers, and other devices don't respond to remote volume commands reliably
            const spotifyVolumeSupported = !isSpotify || spotifyDevice?.type === 'Computer';
            const volumeSupported = !currentTrack || currentResolverId === 'localfiles' || (isSpotify && spotifyVolumeSupported);
            const isDisabled = !volumeSupported || browserPlaybackActive || isExternalPlayback;
            const resolverOffset = currentResolverId ? (resolverVolumeOffsets[currentResolverId] || 0) : 0;
            const hasOffset = resolverOffset !== 0;
            const effectiveVolume = isMuted ? 0 : volume;

            // Toggle mute handler
            const handleMuteToggle = () => {
              if (isDisabled) return;
              const activeResolverId = determineResolverIdFromTrack(currentTrackRef.current);
              if (isMuted) {
                // Unmute: restore previous volume
                const restoredVolume = preMuteVolumeRef.current || 70;
                setIsMuted(false);
                setVolume(restoredVolume);
                if (activeResolverId === 'localfiles' && audioRef.current) {
                  applyLocalFileVolume(restoredVolume, currentTrackRef.current?.id);
                }
                if (activeResolverId === 'spotify') {
                  setSpotifyVolume(restoredVolume, true);
                }
              } else {
                // Mute: save current volume and set to 0
                preMuteVolumeRef.current = volume;
                setIsMuted(true);
                if (activeResolverId === 'localfiles' && audioRef.current) {
                  audioRef.current.volume = 0;
                }
                if (activeResolverId === 'spotify') {
                  setSpotifyVolume(0, false);
                }
              }
            };

            // Determine appropriate tooltip
            const getTooltip = () => {
              if (isDisabled) {
                if (browserPlaybackActive || isExternalPlayback) {
                  return 'Volume control not available for browser playback';
                }
                if (isSpotify && spotifyDevice && spotifyDevice.type !== 'Computer') {
                  return `Volume control not available on ${spotifyDevice.name || spotifyDevice.type}`;
                }
                return 'Volume control not available';
              }
              if (isMuted) return 'Click to unmute';
              if (hasOffset) return `Volume (${resolverOffset > 0 ? '+' : ''}${resolverOffset}dB normalization applied) - Click to mute`;
              return 'Click to mute';
            };

            return React.createElement('div', {
              className: 'flex items-center gap-1',
              title: getTooltip()
            },
              React.createElement('button', {
                className: `${isDisabled ? 'text-gray-600 cursor-not-allowed' : 'text-gray-400 hover:text-white cursor-pointer'} transition-colors`,
                onClick: handleMuteToggle,
                disabled: isDisabled
              },
                React.createElement('svg', { width: 16, height: 16, viewBox: '0 0 18 18', fill: 'currentColor' },
                  isMuted || effectiveVolume === 0
                    // Muted icon (speaker with diagonal slash)
                    ? React.createElement('g', null,
                        React.createElement('path', { d: 'M16,17.4l-6.1-3.8H2V5.1h6.9L16,0.6V17.4z M3,12.6h7.2l4.8,3V2.4L9.1,6.1H3V12.6z' }),
                        React.createElement('line', { x1: '1', y1: '17', x2: '17', y2: '1', stroke: 'currentColor', strokeWidth: '2', strokeLinecap: 'round' })
                      )
                    // Normal volume icon
                    : React.createElement('path', { d: 'M16,17.4l-6.1-3.8H2V5.1h6.9L16,0.6V17.4z M3,12.6h7.2l4.8,3V2.4L9.1,6.1H3V12.6z' })
                )
              ),
              React.createElement('input', {
                type: 'range',
                min: '0',
                max: '100',
                value: effectiveVolume,
                disabled: isDisabled,
                onChange: (e) => {
                    const newVolume = Number(e.target.value);
                    // If user moves slider while muted, unmute
                    if (isMuted && newVolume > 0) {
                      setIsMuted(false);
                    }
                    setVolume(newVolume);
                    // Re-determine resolver from current track ref to avoid stale closure
                    const activeResolverId = determineResolverIdFromTrack(currentTrackRef.current);
                    // Local files: apply normalized volume immediately
                    if (activeResolverId === 'localfiles' && audioRef.current) {
                      applyLocalFileVolume(newVolume, currentTrackRef.current?.id);
                    }
                    // Spotify: debounced API call to prevent rate limiting
                    if (activeResolverId === 'spotify') {
                      setSpotifyVolumeDebounced(newVolume, true);
                    }
                  },
                className: `volume-slider w-20 h-1 rounded-full ${isDisabled ? 'disabled cursor-not-allowed opacity-50' : 'cursor-pointer'}`
              })
            );
          })()
        )
      )
    ),

    // AI Prompt Input Panel (floating above playbar, aligned with AI button on left)
    aiPromptOpen && React.createElement('div', {
      className: 'fixed bottom-24 left-4 z-50 bg-gray-800/95 backdrop-blur-xl border border-gray-700 rounded-xl shadow-2xl p-4',
      style: { width: '380px' }
    },
      // Header
      React.createElement('div', { className: 'flex items-center justify-between mb-3' },
        React.createElement('div', { className: 'flex items-center gap-2' },
          React.createElement('span', { className: 'text-purple-400' }, 'âœ¨'),
          React.createElement('span', { className: 'text-sm font-medium text-white' }, 'Generate Playlist')
        ),
        React.createElement('button', {
          onClick: () => {
            setAiPromptOpen(false);
            setAiPrompt('');
            setAiError(null);
          },
          className: 'p-1 rounded hover:bg-white/10 text-gray-400 hover:text-white transition-colors'
        },
          React.createElement('svg', { className: 'w-4 h-4', viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2 },
            React.createElement('path', { d: 'M6 18L18 6M6 6l12 12' })
          )
        )
      ),

      // Input
      React.createElement('div', { className: 'relative' },
        React.createElement('input', {
          type: 'text',
          value: aiPrompt,
          onChange: (e) => setAiPrompt(e.target.value),
          onKeyDown: (e) => {
            if (e.key === 'Enter' && aiPrompt.trim() && !aiLoading) {
              handleAiGenerate(aiPrompt.trim());
            }
            if (e.key === 'Escape') {
              setAiPromptOpen(false);
              setAiPrompt('');
              setAiError(null);
            }
          },
          placeholder: 'What do you want to listen to?',
          disabled: aiLoading,
          autoFocus: true,
          className: 'w-full bg-gray-700/50 border border-gray-600 rounded-lg px-4 py-3 pr-12 text-white placeholder-gray-400 focus:outline-none focus:border-purple-500 focus:ring-1 focus:ring-purple-500 disabled:opacity-50'
        }),
        React.createElement('button', {
          onClick: () => aiPrompt.trim() && !aiLoading && handleAiGenerate(aiPrompt.trim()),
          disabled: !aiPrompt.trim() || aiLoading,
          className: 'absolute right-2 top-1/2 -translate-y-1/2 p-2 rounded-lg transition-colors disabled:opacity-30 disabled:cursor-not-allowed bg-purple-600 hover:bg-purple-500 text-white'
        },
          aiLoading
            ? React.createElement('svg', { className: 'w-4 h-4 animate-spin', viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2 },
                React.createElement('circle', { cx: 12, cy: 12, r: 10, strokeOpacity: 0.25 }),
                React.createElement('path', { d: 'M12 2a10 10 0 0 1 10 10', strokeLinecap: 'round' })
              )
            : React.createElement('svg', { className: 'w-4 h-4', viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2 },
                React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', d: 'M14 5l7 7m0 0l-7 7m7-7H3' })
              )
        )
      ),

      // Provider selector row (right-aligned)
      (() => {
        const aiResolvers = getAiServices();
        if (aiResolvers.length <= 1) return null;
        return React.createElement('div', { className: 'mt-3 flex items-center justify-end gap-2' },
          React.createElement('span', { className: 'text-xs text-gray-500' }, 'Provider:'),
          React.createElement('select', {
            value: selectedAiResolver || aiResolvers[0]?.id || '',
            onChange: (e) => setSelectedAiResolver(e.target.value),
            className: 'bg-gray-700 border border-gray-600 rounded px-2 py-1 text-xs text-gray-300 focus:outline-none focus:border-purple-500'
          },
            aiResolvers.map(r =>
              React.createElement('option', { key: r.id, value: r.id }, r.name)
            )
          )
        );
      })(),

      // Listening history toggle (if scrobbler connected)
      hasScrobblerConnected() && React.createElement('div', {
        className: 'mt-3 flex items-center justify-between'
      },
        React.createElement('label', {
          htmlFor: 'ai-include-history',
          className: 'text-xs text-gray-400 cursor-pointer select-none'
        }, 'Use my listening history'),
        React.createElement('label', { className: 'relative inline-block w-10 h-5 cursor-pointer' },
          React.createElement('input', {
            type: 'checkbox',
            id: 'ai-include-history',
            checked: aiIncludeHistory,
            onChange: (e) => setAiIncludeHistory(e.target.checked),
            className: 'sr-only peer'
          }),
          React.createElement('div', {
            className: 'w-full h-full bg-gray-600 rounded-full peer-checked:bg-purple-600 transition-colors'
          }),
          React.createElement('div', {
            className: 'absolute left-0.5 top-0.5 w-4 h-4 bg-white rounded-full shadow transition-transform peer-checked:translate-x-5'
          })
        )
      ),

      // Surprise Me button (own row, only when listening history is enabled)
      hasScrobblerConnected() && aiIncludeHistory && React.createElement('div', {
        className: 'mt-3'
      },
        React.createElement('button', {
          onClick: () => !aiLoading && handleAiGenerate('Surprise me! Based on my listening history, create a playlist of songs I might love but haven\'t discovered yet. Mix familiar vibes with fresh discoveries.'),
          disabled: aiLoading,
          className: 'w-full py-2 px-3 rounded-lg text-sm font-medium transition-colors ' +
            (aiLoading ? 'bg-gray-700 text-gray-500 cursor-not-allowed' : 'bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-500 hover:to-pink-500 text-white')
        },
          React.createElement('span', { className: 'flex items-center justify-center gap-2' },
            React.createElement('svg', {
              className: 'w-4 h-4',
              viewBox: '0 0 482 511.93',
              fill: 'currentColor',
              xmlns: 'http://www.w3.org/2000/svg'
            },
              React.createElement('path', {
                fillRule: 'nonzero',
                d: 'm277.15 355.47-129.39-67.81L115.79 327c47.18 24.94 89.8 47.83 137 72.79l24.36-44.32zM191.5 208.38c4.84 0 8.77 3.92 8.77 8.76s-3.93 8.77-8.77 8.77-8.76-3.93-8.76-8.77 3.92-8.76 8.76-8.76zm185.52 9.13c4.84 0 8.76 3.92 8.76 8.76s-3.92 8.77-8.76 8.77c-4.85 0-8.77-3.93-8.77-8.77s3.92-8.76 8.77-8.76zm74.65-148.53c5.38 0 9.74 4.36 9.74 9.75 0 5.38-4.36 9.74-9.74 9.74s-9.74-4.36-9.74-9.74c0-5.39 4.36-9.75 9.74-9.75zm-274.01 9.88c6.35 0 11.49 5.15 11.49 11.5s-5.14 11.49-11.49 11.49c-6.35 0-11.5-5.14-11.5-11.49 0-6.35 5.15-11.5 11.5-11.5zm-34.45 89.91c7.17 0 12.98 5.81 12.98 12.98 0 7.16-5.81 12.97-12.98 12.97-7.16 0-12.97-5.81-12.97-12.97 0-7.17 5.81-12.98 12.97-12.98zM231.86 0l17.02 29.17 32.89-2.76-21 24.78 12.54 30.75-30.13-12.48-24.72 21.12 2.21-32.72-28.62-17.44 33.19-7.38L231.86 0zm118.07 161.29c4.84 0 8.77 3.92 8.77 8.77 0 4.84-3.93 8.76-8.77 8.76s-8.77-3.92-8.77-8.76c0-4.85 3.93-8.77 8.77-8.77zm82.72 38.11-1.25-.35c2.88-10.22 1.58-20.22-3.91-30-5.48-9.79-13.33-16.12-23.54-19l.35-1.25c10.22 2.88 20.21 1.58 30-3.93 9.79-5.5 16.13-13.34 18.99-23.52l1.26.35c-2.88 10.22-1.58 20.21 3.9 30 5.49 9.79 13.34 16.12 23.55 19l-.35 1.25c-10.22-2.88-20.22-1.58-30 3.9-9.79 5.49-16.12 13.34-19 23.55zm-61.45-98.38h-1.62c0-13.19-4.93-24.73-14.8-34.59-9.86-9.87-21.4-14.8-34.6-14.8v-1.62c13.2 0 24.74-4.93 34.6-14.82 9.87-9.89 14.8-21.42 14.8-34.58h1.62c0 13.2 4.93 24.73 14.8 34.6 9.87 9.87 21.4 14.8 34.6 14.8v1.62c-13.2 0-24.73 4.93-34.6 14.8-9.87 9.86-14.8 21.4-14.8 34.59zM68.87 128.06l-1.44.75c-6.12-11.69-15.84-19.62-29.16-23.78s-25.82-3.18-37.52 2.94L0 106.54c11.7-6.13 19.62-15.85 23.77-29.18 4.15-13.34 3.17-25.85-2.93-37.5l1.43-.75C28.4 50.8 38.12 58.73 51.44 62.89c13.31 4.16 25.82 3.18 37.51-2.94l.75 1.43C78.01 67.5 70.08 77.23 65.92 90.54c-4.16 13.32-3.18 25.83 2.95 37.52zM291.4 287.62a6.511 6.511 0 0 1-5.98 3.69c-1.08.75-2.4 1.17-3.81 1.14-.48-.01-.94-.07-1.39-.18a6.5 6.5 0 0 1-8.2-3.94c-14.91-41.24-38.21-76.53-67.05-105.6-31.26-31.53-69.05-55.8-109.73-72.53-3.32-1.36-4.9-5.16-3.54-8.48 1.37-3.32 5.17-4.90 8.48-3.54 42.24 17.37 81.5 42.6 114.01 75.38 20.91 21.08 39.03 45.29 53.37 72.53L244.59 98.46c-.55-3.55 1.88-6.87 5.42-7.41a6.495 6.495 0 0 1 7.41 5.42l22.67 145.62c2.81-14.15 6.76-28.09 11.66-41.7 10.98-30.51 26.68-59.38 44.9-85.52a6.495 6.495 0 0 1 9.06-1.63c2.96 2.05 3.68 6.11 1.63 9.06-17.66 25.35-32.83 53.21-43.36 82.47-7.01 19.47-11.99 39.6-14.31 60.05 10.23-15.34 25.53-33.46 45.01-50.01 20.18-17.15 44.95-32.73 73.34-41.94 3.42-1.11 7.09.76 8.2 4.18a6.507 6.507 0 0 1-4.18 8.2c-26.61 8.64-49.91 23.31-68.95 39.49-26 22.09-43.97 46.81-51.69 62.88zM187.97 261.3l-30.77 14.87 126.99 66.84 127.01-66.97-27.9-13.98c4.13-3.04 8.31-5.97 12.49-8.8l23.44 10.08 37.73-35.71-12.34-6.54c3.18-2.29 6.18-4.55 8.94-6.82l19.76 10.44c.44.24.85.54 1.22.92a4.982 4.982 0 0 1-.06 7.06l-44.81 44.02 43.4 51.94a5.015 5.015 0 0 1-.63 7.04c-.32.26-.66.49-1.02.66l-38.96 20.6v77.21a5.01 5.01 0 0 1-3.09 4.62l-140.86 71.5a4.97 4.97 0 0 1-3.7 1.65c-1.96 0-3.65-1.12-4.47-2.76l-141.13-70.55a4.984 4.984 0 0 1-2.76-4.46l-.02-76.83-39.69-20.98c-.36-.17-.69-.4-1.01-.66a4.997 4.997 0 0 1-.63-7.04l42.28-50.59-49.05-46.48c-1.82-2.07-1.6-5.22.47-7.04.31-.26.62-.49.96-.66l22.88-12.95c3.05 2.91 5.97 5.39 8.53 7.34l-15.75 8.8 41.39 37.97 36.57-17.7c1.5 4.72 3.04 9.43 4.59 13.96zm232.81 27.53-126.5 63.38 27.88 48.05 133.28-69.41-34.66-42.02z'
              })
            ),
            'Surprise Me'
          )
        )
      ),

      // Scrobbler not connected - show link to marketplace
      !hasScrobblerConnected() && React.createElement('div', {
        className: 'mt-3 flex items-center justify-between'
      },
        React.createElement('span', { className: 'text-xs text-gray-500' },
          'Connect a scrobbler for personalized recommendations'
        ),
        React.createElement('button', {
          onClick: () => {
            setAiPromptOpen(false);
            setActiveView('marketplace');
            setMarketplaceCategory('scrobblers');
          },
          className: 'text-xs text-purple-400 hover:text-purple-300 transition-colors'
        }, 'Browse â†’')
      ),

      // Error message
      aiError && React.createElement('div', { className: 'mt-3 p-2 bg-red-500/20 border border-red-500/30 rounded-lg' },
        React.createElement('p', { className: 'text-xs text-red-300' }, aiError)
      ),

      // Hint
      !aiError && React.createElement('p', { className: 'mt-3 text-xs text-gray-500' },
        'Try: "upbeat 90s hip hop" or "relaxing jazz for studying"'
      )
    ),

    // Results Sidebar (slides in from right, above playbar)
    resultsSidebar && React.createElement('div', {
      className: 'fixed top-0 right-0 z-40 flex',
      style: { bottom: '80px' } // Leave room for playbar
    },
      // Backdrop (click to close)
      React.createElement('div', {
        className: 'flex-1 bg-black/30 backdrop-blur-sm',
        onClick: () => setResultsSidebar(null)
      }),

      // Sidebar panel
      React.createElement('div', {
        className: 'w-80 bg-gray-900 border-l border-gray-700 flex flex-col shadow-2xl',
        style: { animation: 'slideInRight 0.2s ease-out' }
      },
        // Header
        React.createElement('div', { className: 'p-4 border-b border-gray-700' },
          React.createElement('div', { className: 'flex items-center justify-between' },
            React.createElement('h3', { className: 'text-lg font-semibold text-white' }, resultsSidebar.title),
            React.createElement('button', {
              onClick: () => setResultsSidebar(null),
              className: 'p-1 rounded hover:bg-white/10 text-gray-400 hover:text-white transition-colors'
            },
              React.createElement('svg', { className: 'w-5 h-5', viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2 },
                React.createElement('path', { d: 'M6 18L18 6M6 6l12 12' })
              )
            )
          ),
          resultsSidebar.subtitle && React.createElement('p', {
            className: 'text-sm text-gray-400 mt-1 truncate'
          }, resultsSidebar.subtitle)
        ),

        // Track list or loading skeletons
        React.createElement('div', { className: 'flex-1 overflow-y-auto p-2' },
          // Loading skeletons
          resultsSidebar.loading
            ? Array.from({ length: 12 }).map((_, index) =>
                React.createElement('div', {
                  key: `skeleton-${index}`,
                  className: 'flex items-center gap-3 p-2'
                },
                  // Skeleton track number
                  React.createElement('div', {
                    className: 'w-6 h-4 bg-gray-700 rounded animate-pulse'
                  }),
                  // Skeleton track info
                  React.createElement('div', { className: 'flex-1 min-w-0 space-y-2' },
                    React.createElement('div', {
                      className: 'h-4 bg-gray-700 rounded animate-pulse',
                      style: { width: `${60 + Math.random() * 30}%`, animationDelay: `${index * 0.05}s` }
                    }),
                    React.createElement('div', {
                      className: 'h-3 bg-gray-700/60 rounded animate-pulse',
                      style: { width: `${40 + Math.random() * 25}%`, animationDelay: `${index * 0.05 + 0.1}s` }
                    })
                  )
                )
              )
            : resultsSidebar.tracks.map((track, index) =>
                React.createElement('div', {
                  key: track.id || index,
                  className: 'group flex items-center gap-3 p-2 rounded-lg hover:bg-white/5 transition-colors'
                },
                  // Track number
                  React.createElement('span', { className: 'w-6 text-center text-xs text-gray-500' }, index + 1),

                  // Track info
                  React.createElement('div', { className: 'flex-1 min-w-0' },
                    React.createElement('div', { className: 'text-sm text-white truncate' }, track.title),
                    React.createElement('div', { className: 'text-xs text-gray-400 truncate' }, track.artist)
                  ),

                  // Remove button
                  React.createElement('button', {
                    onClick: () => {
                      setResultsSidebar(prev => ({
                        ...prev,
                        tracks: prev.tracks.filter((_, i) => i !== index)
                      }));
                    },
                    className: 'opacity-0 group-hover:opacity-100 p-1 rounded hover:bg-red-500/20 text-gray-500 hover:text-red-400 transition-all'
                  },
                    React.createElement('svg', { className: 'w-4 h-4', viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2 },
                      React.createElement('path', { d: 'M6 18L18 6M6 6l12 12' })
                    )
                  )
                )
              )
        ),

        // Empty state (only show when not loading and no tracks)
        !resultsSidebar.loading && resultsSidebar.tracks.length === 0 && React.createElement('div', {
          className: 'flex-1 flex items-center justify-center p-4'
        },
          React.createElement('p', { className: 'text-sm text-gray-500' }, 'No tracks remaining')
        ),

        // Actions
        React.createElement('div', { className: 'p-4 border-t border-gray-700 space-y-2' },
          React.createElement('button', {
            onClick: handleAiAddToQueue,
            disabled: resultsSidebar.loading || resultsSidebar.tracks.length === 0,
            className: 'w-full py-2.5 px-4 bg-purple-600 hover:bg-purple-500 disabled:bg-gray-700 disabled:text-gray-500 text-white font-medium rounded-lg transition-colors disabled:cursor-not-allowed'
          }, resultsSidebar.loading ? 'Generating...' : `Add ${resultsSidebar.tracks.length} to Queue`),
          React.createElement('button', {
            onClick: handleAiSavePlaylist,
            disabled: resultsSidebar.loading || resultsSidebar.tracks.length === 0,
            className: 'w-full py-2.5 px-4 bg-gray-700 hover:bg-gray-600 disabled:bg-gray-800 disabled:text-gray-500 text-white font-medium rounded-lg transition-colors disabled:cursor-not-allowed'
          }, 'Save as Playlist')
        )
      )
    ),

    // AI Save Playlist Dialog
    aiSaveDialogOpen && React.createElement('div', {
      className: 'fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50',
      onClick: (e) => {
        if (e.target === e.currentTarget) {
          setAiSaveDialogOpen(false);
        }
      }
    },
      React.createElement('div', {
        className: 'bg-gray-900 rounded-xl p-6 max-w-md w-full mx-4 shadow-xl border border-gray-700'
      },
        // Header
        React.createElement('div', { className: 'flex items-center justify-between mb-4' },
          React.createElement('h2', { className: 'text-lg font-semibold text-white' }, 'Save Playlist'),
          React.createElement('button', {
            onClick: () => setAiSaveDialogOpen(false),
            className: 'p-1 rounded hover:bg-white/10 text-gray-400 hover:text-white transition-colors'
          },
            React.createElement('svg', { className: 'w-5 h-5', viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2 },
              React.createElement('path', { d: 'M6 18L18 6M6 6l12 12' })
            )
          )
        ),

        // Provider info
        resultsSidebar?.provider && React.createElement('p', {
          className: 'text-xs text-gray-500 mb-4'
        }, `Generated by ${resultsSidebar.provider.name}`),

        // Name input
        React.createElement('div', { className: 'mb-4' },
          React.createElement('label', {
            htmlFor: 'playlist-name',
            className: 'block text-sm text-gray-400 mb-2'
          }, 'Playlist Name'),
          React.createElement('input', {
            id: 'playlist-name',
            type: 'text',
            value: aiSavePlaylistName,
            onChange: (e) => setAiSavePlaylistName(e.target.value),
            onKeyDown: (e) => {
              if (e.key === 'Enter' && aiSavePlaylistName.trim()) {
                handleAiSavePlaylistConfirm();
              }
            },
            autoFocus: true,
            className: 'w-full bg-gray-800 border border-gray-600 rounded-lg px-4 py-3 text-white placeholder-gray-500 focus:outline-none focus:border-purple-500 focus:ring-1 focus:ring-purple-500'
          })
        ),

        // Actions
        React.createElement('div', { className: 'flex gap-3' },
          React.createElement('button', {
            onClick: () => setAiSaveDialogOpen(false),
            className: 'flex-1 py-2.5 px-4 bg-gray-700 hover:bg-gray-600 text-white font-medium rounded-lg transition-colors'
          }, 'Cancel'),
          React.createElement('button', {
            onClick: handleAiSavePlaylistConfirm,
            disabled: !aiSavePlaylistName.trim(),
            className: 'flex-1 py-2.5 px-4 bg-purple-600 hover:bg-purple-500 disabled:bg-gray-700 disabled:text-gray-500 text-white font-medium rounded-lg transition-colors disabled:cursor-not-allowed'
          }, 'Save')
        )
      )
    ),

    // Queue Save Playlist Dialog
    queueSaveDialogOpen && React.createElement('div', {
      className: 'fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50',
      onClick: (e) => {
        if (e.target === e.currentTarget) {
          setQueueSaveDialogOpen(false);
        }
      }
    },
      React.createElement('div', {
        className: 'bg-gray-900 rounded-xl p-6 max-w-md w-full mx-4 shadow-xl border border-gray-700'
      },
        // Header
        React.createElement('div', { className: 'flex items-center justify-between mb-4' },
          React.createElement('h2', { className: 'text-lg font-semibold text-white' }, 'Save Queue as Playlist'),
          React.createElement('button', {
            onClick: () => setQueueSaveDialogOpen(false),
            className: 'p-1 rounded hover:bg-white/10 text-gray-400 hover:text-white transition-colors'
          },
            React.createElement('svg', { className: 'w-5 h-5', viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2 },
              React.createElement('path', { d: 'M6 18L18 6M6 6l12 12' })
            )
          )
        ),

        // Track count info
        React.createElement('p', {
          className: 'text-xs text-gray-500 mb-4'
        }, `${(currentTrack ? 1 : 0) + currentQueue.length} track${((currentTrack ? 1 : 0) + currentQueue.length) !== 1 ? 's' : ''} will be saved`),

        // Name input
        React.createElement('div', { className: 'mb-4' },
          React.createElement('label', {
            htmlFor: 'queue-playlist-name',
            className: 'block text-sm text-gray-400 mb-2'
          }, 'Playlist Name'),
          React.createElement('input', {
            id: 'queue-playlist-name',
            type: 'text',
            value: queueSavePlaylistName,
            onChange: (e) => setQueueSavePlaylistName(e.target.value),
            onKeyDown: (e) => {
              if (e.key === 'Enter' && queueSavePlaylistName.trim()) {
                handleSaveQueueConfirm();
              }
            },
            autoFocus: true,
            className: 'w-full bg-gray-800 border border-gray-600 rounded-lg px-4 py-3 text-white placeholder-gray-500 focus:outline-none focus:border-purple-500 focus:ring-1 focus:ring-purple-500'
          })
        ),

        // Actions
        React.createElement('div', { className: 'flex gap-3' },
          React.createElement('button', {
            onClick: () => setQueueSaveDialogOpen(false),
            className: 'flex-1 py-2.5 px-4 bg-gray-700 hover:bg-gray-600 text-white font-medium rounded-lg transition-colors'
          }, 'Cancel'),
          React.createElement('button', {
            onClick: handleSaveQueueConfirm,
            disabled: !queueSavePlaylistName.trim(),
            className: 'flex-1 py-2.5 px-4 bg-purple-600 hover:bg-purple-500 disabled:bg-gray-700 disabled:text-gray-500 text-white font-medium rounded-lg transition-colors disabled:cursor-not-allowed'
          }, 'Save')
        )
      )
    ),

    // Import Playlist Dialog Modal
    showUrlImportDialog && React.createElement('div', {
      className: 'fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50',
      onClick: (e) => {
        // Close when clicking backdrop
        if (e.target === e.currentTarget) {
          setShowUrlImportDialog(false);
          setUrlImportValue('');
        }
      }
    },
      React.createElement('div', {
        className: 'bg-white rounded-xl p-6 max-w-md w-full mx-4 shadow-xl'
      },
        // Header
        React.createElement('div', {
          className: 'flex items-center justify-between mb-6'
        },
          React.createElement('h2', { className: 'text-xl font-bold text-gray-900' }, 'ðŸ“¥ Import Playlist'),
          React.createElement('button', {
            onClick: () => {
              setShowUrlImportDialog(false);
              setUrlImportValue('');
            },
            className: 'p-2 hover:bg-gray-100 rounded-lg transition-colors text-gray-500'
          }, React.createElement(X))
        ),

        // Option 1: Import from file
        React.createElement('div', { className: 'mb-6' },
          React.createElement('h3', { className: 'text-sm font-semibold text-gray-700 mb-2' }, 'ðŸ“ From File'),
          React.createElement('p', { className: 'text-xs text-gray-500 mb-3' }, 'Import an XSPF playlist file from your computer.'),
          React.createElement('button', {
            onClick: async () => {
              setShowUrlImportDialog(false);
              await handleImportPlaylist();
            },
            className: 'w-full px-4 py-3 bg-green-600 hover:bg-green-700 text-white rounded-lg transition-colors flex items-center justify-center gap-2',
            disabled: urlImportLoading
          },
            React.createElement('span', null, 'ðŸ“'),
            'Choose File...'
          )
        ),

        // Divider
        React.createElement('div', { className: 'flex items-center gap-4 mb-6' },
          React.createElement('div', { className: 'flex-1 h-px bg-gray-200' }),
          React.createElement('span', { className: 'text-gray-400 text-sm' }, 'or'),
          React.createElement('div', { className: 'flex-1 h-px bg-gray-200' })
        ),

        // Option 2: Import from URL
        React.createElement('div', null,
          React.createElement('h3', { className: 'text-sm font-semibold text-gray-700 mb-2' }, 'ðŸŒ From URL'),
          React.createElement('p', { className: 'text-xs text-gray-500 mb-3' }, 'Import a hosted XSPF playlist. It will auto-update when the source changes.'),
          React.createElement('input', {
            type: 'url',
            value: urlImportValue,
            onChange: (e) => setUrlImportValue(e.target.value),
            placeholder: 'https://example.com/playlist.xspf',
            className: 'w-full px-4 py-3 bg-gray-50 rounded-lg border border-gray-200 focus:border-green-500 focus:outline-none text-gray-900 mb-3',
            disabled: urlImportLoading
          }),
          React.createElement('button', {
            onClick: async () => {
              if (!urlImportValue.trim()) return;
              setUrlImportLoading(true);
              try {
                const result = await handleImportPlaylistFromUrl(urlImportValue.trim());
                setShowUrlImportDialog(false);
                setUrlImportValue('');
                showConfirmDialog({
                  type: 'success',
                  title: result.updated ? 'Playlist Updated' : 'Playlist Imported',
                  message: result.playlist.title
                });
              } catch (error) {
                showConfirmDialog({
                  type: 'error',
                  title: 'Import Failed',
                  message: error.message
                });
              } finally {
                setUrlImportLoading(false);
              }
            },
            disabled: urlImportLoading || !urlImportValue.trim(),
            className: `w-full px-4 py-3 bg-blue-600 hover:bg-blue-700 rounded-lg transition-colors flex items-center justify-center gap-2 ${
              (urlImportLoading || !urlImportValue.trim()) ? 'opacity-50 cursor-not-allowed' : ''
            }`
          },
            urlImportLoading ? 'â³ Importing...' : 'ðŸŒ Import from URL'
          )
        )
      )
    ),

    // Add Friend Modal
    addFriendModalOpen && React.createElement('div', {
      className: 'fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50',
      onClick: (e) => {
        if (e.target === e.currentTarget) {
          setAddFriendModalOpen(false);
          setAddFriendInput('');
        }
      }
    },
      React.createElement('div', {
        className: 'bg-white rounded-2xl shadow-2xl max-w-md w-full mx-4 overflow-hidden',
        onClick: (e) => e.stopPropagation()
      },
        // Header
        React.createElement('div', { className: 'px-6 py-4 border-b border-gray-200 flex items-center justify-between' },
          React.createElement('h3', { className: 'text-lg font-semibold text-gray-900' }, 'Add Friend'),
          React.createElement('button', {
            onClick: () => {
              setAddFriendModalOpen(false);
              setAddFriendInput('');
            },
            className: 'p-1.5 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-lg transition-colors'
          },
            React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
              React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M6 18L18 6M6 6l12 12' })
            )
          )
        ),
        // Body
        React.createElement('div', { className: 'p-6' },
          React.createElement('p', { className: 'text-sm text-gray-600 mb-4' },
            'Enter a Last.fm or ListenBrainz username, or paste a profile URL.'
          ),
          React.createElement('input', {
            type: 'text',
            value: addFriendInput,
            onChange: (e) => setAddFriendInput(e.target.value),
            onKeyDown: (e) => {
              if (e.key === 'Enter' && addFriendInput.trim()) {
                addFriend(addFriendInput);
              }
            },
            placeholder: 'Username or profile URL',
            className: 'w-full px-4 py-3 border border-gray-200 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent',
            autoFocus: true
          }),
          // Example hints
          React.createElement('div', { className: 'mt-3 text-xs text-gray-400' },
            React.createElement('p', null, 'Examples:'),
            React.createElement('p', { className: 'mt-1' }, 'â€¢ username'),
            React.createElement('p', null, 'â€¢ https://www.last.fm/user/username'),
            React.createElement('p', null, 'â€¢ https://listenbrainz.org/user/username')
          )
        ),
        // Footer
        React.createElement('div', { className: 'px-6 py-4 bg-gray-50 flex justify-end gap-3' },
          React.createElement('button', {
            onClick: () => {
              setAddFriendModalOpen(false);
              setAddFriendInput('');
            },
            className: 'px-4 py-2 text-sm text-gray-600 hover:text-gray-800 transition-colors'
          }, 'Cancel'),
          React.createElement('button', {
            onClick: () => addFriend(addFriendInput),
            disabled: addFriendLoading || !addFriendInput.trim(),
            className: 'px-4 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded-lg text-sm font-medium transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2'
          },
            addFriendLoading && React.createElement('svg', {
              className: 'w-4 h-4 animate-spin',
              fill: 'none',
              viewBox: '0 0 24 24'
            },
              React.createElement('circle', { className: 'opacity-25', cx: '12', cy: '12', r: '10', stroke: 'currentColor', strokeWidth: '4' }),
              React.createElement('path', { className: 'opacity-75', fill: 'currentColor', d: 'M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z' })
            ),
            addFriendLoading ? 'Adding...' : 'Add Friend'
          )
        )
      )
    ),

    // Resolver Detail Modal
    selectedResolver && React.createElement('div', {
      className: 'fixed inset-0 bg-black/50 flex items-center justify-center z-50',
      onClick: (e) => { if (e.target === e.currentTarget) setSelectedResolver(null); }
    },
      React.createElement('div', {
        className: 'bg-white rounded-2xl shadow-2xl max-w-md w-full mx-4 overflow-hidden'
      },
        // Modal header with colored background
        React.createElement('div', {
          className: 'p-6 flex items-center gap-4',
          style: { backgroundColor: selectedResolver.color || '#6B7280' }
        },
          // Logo
          React.createElement('div', {
            className: 'w-16 h-16 flex items-center justify-center'
          }, SERVICE_LOGOS[selectedResolver.id] || React.createElement('span', { className: 'text-4xl' }, selectedResolver.icon)),
          // Name and version
          React.createElement('div', { className: 'flex-1 text-white' },
            React.createElement('div', { className: 'flex items-center gap-2' },
              React.createElement('h2', { className: 'text-xl font-bold' }, selectedResolver.name),
              selectedResolver.version && React.createElement('span', {
                className: 'px-2 py-0.5 bg-white/20 rounded text-xs'
              }, 'v', selectedResolver.version)
            ),
            React.createElement('p', { className: 'text-white/80 text-sm' }, selectedResolver.author || 'Parachord Team')
          ),
          // Close button
          React.createElement('button', {
            onClick: () => setSelectedResolver(null),
            className: 'w-8 h-8 rounded-full bg-white/20 hover:bg-white/30 flex items-center justify-center text-white transition-colors'
          }, 'âœ•')
        ),
        // Modal body
        React.createElement('div', { className: 'p-6 space-y-6 max-h-[60vh] overflow-y-auto' },
          // Description
          React.createElement('p', { className: 'text-gray-600 text-sm' }, selectedResolver.description),

          // Capabilities
          React.createElement('div', null,
            React.createElement('h3', { className: 'text-sm font-semibold text-gray-900 mb-2' }, 'Capabilities'),
            React.createElement('div', { className: 'flex flex-wrap gap-2' },
              Object.entries(selectedResolver.capabilities || {}).map(([cap, enabled]) => {
                if (!enabled) return null;
                const capLabels = {
                  resolve: 'Resolve',
                  search: 'Search',
                  stream: 'Stream',
                  browse: 'Browse',
                  urlLookup: 'URL Lookup',
                  recommendations: 'Recommendations',
                  metadata: 'Metadata',
                  generate: 'AI Playlist Generation'
                };
                const label = capLabels[cap] || cap;
                return React.createElement('span', {
                  key: cap,
                  className: 'px-3 py-1 bg-purple-100 text-purple-700 rounded-full text-xs font-medium'
                }, label);
              })
            )
          ),

          // Enable/Disable toggle (only for content resolvers, not meta services)
          selectedResolver.type !== 'meta-service' && React.createElement('div', {
            className: 'flex items-center justify-between py-3 border-t border-gray-100'
          },
            React.createElement('div', null,
              React.createElement('span', { className: 'font-medium text-gray-900' }, 'Enable Resolver'),
              React.createElement('p', { className: 'text-xs text-gray-500' }, 'Include in search and playback')
            ),
            React.createElement('label', { className: 'relative inline-block w-12 h-6' },
              React.createElement('input', {
                type: 'checkbox',
                checked: activeResolvers.includes(selectedResolver.id),
                onChange: () => toggleResolver(selectedResolver.id),
                className: 'sr-only peer'
              }),
              React.createElement('div', {
                className: 'w-full h-full bg-gray-300 rounded-full peer-checked:bg-purple-600 transition-colors'
              }),
              React.createElement('div', {
                className: 'absolute left-1 top-1 w-4 h-4 bg-white rounded-full shadow transition-transform peer-checked:translate-x-6'
              })
            )
          ),

          // Authentication section (for services that require it)
          selectedResolver.id === 'spotify' && React.createElement('div', {
            className: 'py-3 border-t border-gray-100'
          },
            React.createElement('div', { className: 'flex items-center justify-between' },
              React.createElement('div', null,
                React.createElement('span', { className: 'font-medium text-gray-900' }, 'Spotify Account'),
                React.createElement('p', { className: 'text-xs text-gray-500' },
                  spotifyConnected ? 'Connected and ready' : 'Sign in to enable streaming'
                )
              ),
              spotifyConnected
                ? React.createElement('button', {
                    onClick: disconnectSpotify,
                    className: 'px-4 py-2 text-sm text-red-600 hover:bg-red-50 rounded-lg transition-colors'
                  }, 'Disconnect')
                : React.createElement('button', {
                    onClick: connectSpotify,
                    className: 'px-4 py-2 text-sm text-white bg-green-500 hover:bg-green-600 rounded-lg transition-colors'
                  }, 'Connect')
            ),
            spotifyConnected && React.createElement('div', {
              className: 'mt-3 flex items-center gap-2 text-green-600 text-sm'
            },
              React.createElement('span', null, 'âœ“'),
              React.createElement('span', null, 'Spotify Premium connected')
            )
          ),

          // Qobuz authentication section
          selectedResolver.id === 'qobuz' && React.createElement('div', {
            className: 'py-3 border-t border-gray-100'
          },
            React.createElement('div', null,
              React.createElement('span', { className: 'font-medium text-gray-900' }, 'Qobuz Streaming'),
              React.createElement('p', { className: 'text-xs text-gray-500 mt-1' },
                'Currently using 30-second previews. Full streaming requires Qobuz subscription.'
              )
            )
          ),

          // Last.fm authentication section
          selectedResolver.id === 'lastfm' && React.createElement('div', {
            className: 'py-3 border-t border-gray-100'
          },
            // Connected state
            metaServiceConfigs.lastfm?.username
              ? React.createElement('div', null,
                  React.createElement('div', { className: 'flex items-center justify-between' },
                    React.createElement('div', null,
                      React.createElement('span', { className: 'font-medium text-gray-900' }, 'Last.fm Account'),
                      React.createElement('p', { className: 'text-xs text-gray-500' },
                        `Connected as ${metaServiceConfigs.lastfm.username}`
                      )
                    ),
                    React.createElement('button', {
                      onClick: disconnectLastfm,
                      className: 'px-4 py-2 text-sm text-red-600 hover:bg-red-50 rounded-lg transition-colors'
                    }, 'Disconnect')
                  ),
                  React.createElement('div', {
                    className: 'mt-3 flex items-center gap-2 text-green-600 text-sm'
                  },
                    React.createElement('span', null, 'âœ“'),
                    React.createElement('span', null, 'Connected to Last.fm')
                  ),
                  // Show API key status if configured
                  metaServiceConfigs.lastfm.apiKey && React.createElement('p', {
                    className: 'mt-2 text-xs text-gray-500'
                  }, 'ðŸ”‘ Using custom API key'),

                  // Scrobbling section for Last.fm
                  React.createElement('div', {
                    className: 'mt-4 pt-4 border-t border-gray-100'
                  },
                    React.createElement('div', { className: 'flex items-center justify-between mb-3' },
                      React.createElement('div', null,
                        React.createElement('span', { className: 'font-medium text-gray-900' }, 'Scrobbling'),
                        React.createElement('p', { className: 'text-xs text-gray-500 mt-0.5' },
                          'Report your listening history to Last.fm'
                        )
                      )
                    ),
                    // Scrobbler card for Last.fm
                    window.scrobblers && window.scrobblers.find(s => s.id === 'lastfm') &&
                      React.createElement(ScrobblerSettingsCard, {
                        scrobbler: window.scrobblers.find(s => s.id === 'lastfm'),
                        config: scrobblerConfigs['lastfm'],
                        onConfigChange: (id, newConfig) => {
                          setScrobblerConfigs(prev => ({ ...prev, [id]: newConfig }));
                        }
                      })
                  )
                )
              // Not connected state
              : React.createElement('div', null,
                  React.createElement('span', { className: 'font-medium text-gray-900' }, 'Last.fm Account'),
                  React.createElement('p', { className: 'text-xs text-gray-500 mt-1 mb-4' },
                    'Enter your Last.fm username to enable personalized recommendations.'
                  ),
                  // Username input
                  React.createElement('div', { className: 'mb-4' },
                    React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-1' }, 'Username'),
                    React.createElement('input', {
                      type: 'text',
                      value: lastfmUsernameInput,
                      onChange: (e) => setLastfmUsernameInput(e.target.value),
                      placeholder: 'Your Last.fm username',
                      className: 'w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent'
                    })
                  ),
                  // Advanced accordion
                  React.createElement('div', { className: 'mb-4' },
                    React.createElement('button', {
                      onClick: () => setLastfmAdvancedOpen(!lastfmAdvancedOpen),
                      className: 'text-xs text-gray-500 hover:text-gray-700 flex items-center gap-1'
                    },
                      React.createElement('span', {
                        className: `transform transition-transform ${lastfmAdvancedOpen ? 'rotate-90' : ''}`
                      }, 'â–¶'),
                      'Advanced'
                    ),
                    lastfmAdvancedOpen && React.createElement('div', {
                      className: 'mt-3 p-3 bg-gray-50 rounded-lg space-y-3'
                    },
                      React.createElement('p', { className: 'text-xs text-gray-500' },
                        'Optional: Use your own Last.fm API credentials to avoid rate limiting.'
                      ),
                      React.createElement('div', null,
                        React.createElement('label', { className: 'block text-xs font-medium text-gray-600 mb-1' }, 'API Key'),
                        React.createElement('input', {
                          type: 'text',
                          value: lastfmApiKeyInput,
                          onChange: (e) => setLastfmApiKeyInput(e.target.value),
                          placeholder: 'Your Last.fm API key',
                          className: 'w-full px-2 py-1.5 border border-gray-200 rounded text-xs focus:outline-none focus:ring-1 focus:ring-purple-500'
                        })
                      ),
                      React.createElement('div', null,
                        React.createElement('label', { className: 'block text-xs font-medium text-gray-600 mb-1' }, 'API Secret'),
                        React.createElement('input', {
                          type: 'password',
                          value: lastfmApiSecretInput,
                          onChange: (e) => setLastfmApiSecretInput(e.target.value),
                          placeholder: 'Your Last.fm API secret',
                          className: 'w-full px-2 py-1.5 border border-gray-200 rounded text-xs focus:outline-none focus:ring-1 focus:ring-purple-500'
                        })
                      )
                    )
                  ),
                  // Connect button
                  React.createElement('button', {
                    onClick: () => connectLastfm(lastfmUsernameInput, lastfmApiKeyInput, lastfmApiSecretInput),
                    disabled: lastfmConnecting || !lastfmUsernameInput.trim(),
                    className: 'w-full px-4 py-2 text-sm text-white bg-red-600 hover:bg-red-700 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed'
                  }, lastfmConnecting ? 'Connecting...' : 'Connect')
                )
          ),

          // ListenBrainz authentication section
          selectedResolver.id === 'listenbrainz' && React.createElement('div', {
            className: 'py-3 border-t border-gray-100'
          },
            // Connected state
            metaServiceConfigs.listenbrainz?.username
              ? React.createElement('div', null,
                  React.createElement('div', { className: 'flex items-center justify-between' },
                    React.createElement('div', null,
                      React.createElement('span', { className: 'font-medium text-gray-900' }, 'ListenBrainz Account'),
                      React.createElement('p', { className: 'text-xs text-gray-500' },
                        `Connected as ${metaServiceConfigs.listenbrainz.username}`
                      )
                    ),
                    React.createElement('button', {
                      onClick: disconnectListenbrainz,
                      className: 'px-4 py-2 text-sm text-red-600 hover:bg-red-50 rounded-lg transition-colors'
                    }, 'Disconnect')
                  ),
                  React.createElement('div', {
                    className: 'mt-3 flex items-center gap-2 text-green-600 text-sm'
                  },
                    React.createElement('span', null, 'âœ“'),
                    React.createElement('span', null, 'Connected to ListenBrainz')
                  ),
                  // Show token status if configured
                  metaServiceConfigs.listenbrainz.userToken && React.createElement('p', {
                    className: 'mt-2 text-xs text-gray-500'
                  }, 'ðŸ”‘ User token configured'),

                  // Scrobbling section for ListenBrainz
                  React.createElement('div', {
                    className: 'mt-4 pt-4 border-t border-gray-100'
                  },
                    React.createElement('div', { className: 'flex items-center justify-between mb-3' },
                      React.createElement('div', null,
                        React.createElement('span', { className: 'font-medium text-gray-900' }, 'Scrobbling'),
                        React.createElement('p', { className: 'text-xs text-gray-500 mt-0.5' },
                          'Report your listening history to ListenBrainz'
                        )
                      )
                    ),
                    // Scrobbler card for ListenBrainz
                    window.scrobblers && window.scrobblers.find(s => s.id === 'listenbrainz') &&
                      React.createElement(ScrobblerSettingsCard, {
                        scrobbler: window.scrobblers.find(s => s.id === 'listenbrainz'),
                        config: scrobblerConfigs['listenbrainz'],
                        onConfigChange: (id, newConfig) => {
                          setScrobblerConfigs(prev => ({ ...prev, [id]: newConfig }));
                        }
                      })
                  )
                )
              // Not connected state
              : React.createElement('div', null,
                  React.createElement('span', { className: 'font-medium text-gray-900' }, 'ListenBrainz Account'),
                  React.createElement('p', { className: 'text-xs text-gray-500 mt-1 mb-4' },
                    'Enter your ListenBrainz username to enable open-source music recommendations and history.'
                  ),
                  // Username input
                  React.createElement('div', { className: 'mb-4' },
                    React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-1' }, 'Username'),
                    React.createElement('input', {
                      type: 'text',
                      value: listenbrainzUsernameInput,
                      onChange: (e) => setListenbrainzUsernameInput(e.target.value),
                      placeholder: 'Your ListenBrainz username',
                      className: 'w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent'
                    })
                  ),
                  // Advanced accordion
                  React.createElement('div', { className: 'mb-4' },
                    React.createElement('button', {
                      onClick: () => setListenbrainzAdvancedOpen(!listenbrainzAdvancedOpen),
                      className: 'text-xs text-gray-500 hover:text-gray-700 flex items-center gap-1'
                    },
                      React.createElement('span', {
                        className: `transform transition-transform ${listenbrainzAdvancedOpen ? 'rotate-90' : ''}`
                      }, 'â–¶'),
                      'Advanced'
                    ),
                    listenbrainzAdvancedOpen && React.createElement('div', {
                      className: 'mt-3 p-3 bg-gray-50 rounded-lg space-y-3'
                    },
                      React.createElement('p', { className: 'text-xs text-gray-500' },
                        'Optional: Add your user token to enable listen submissions and access private data. Find it at listenbrainz.org/settings/'
                      ),
                      React.createElement('div', null,
                        React.createElement('label', { className: 'block text-xs font-medium text-gray-600 mb-1' }, 'User Token'),
                        React.createElement('input', {
                          type: 'password',
                          value: listenbrainzTokenInput,
                          onChange: (e) => setListenbrainzTokenInput(e.target.value),
                          placeholder: 'Your ListenBrainz user token',
                          className: 'w-full px-2 py-1.5 border border-gray-200 rounded text-xs focus:outline-none focus:ring-1 focus:ring-purple-500'
                        })
                      )
                    )
                  ),
                  // Connect button
                  React.createElement('button', {
                    onClick: () => connectListenbrainz(listenbrainzUsernameInput, listenbrainzTokenInput),
                    disabled: listenbrainzConnecting || !listenbrainzUsernameInput.trim(),
                    className: 'w-full px-4 py-2 text-sm text-white bg-indigo-600 hover:bg-indigo-700 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed'
                  }, listenbrainzConnecting ? 'Connecting...' : 'Connect')
                )
          ),

          // AI Service configuration (ChatGPT and Gemini)
          (selectedResolver.id === 'chatgpt' || selectedResolver.id === 'gemini') && React.createElement('div', {
            className: 'py-3 border-t border-gray-100'
          },
            React.createElement('span', { className: 'font-medium text-gray-900' }, 'API Configuration'),
            React.createElement('p', { className: 'text-xs text-gray-500 mt-1 mb-4' },
              selectedResolver.id === 'chatgpt'
                ? 'Enter your OpenAI API key to enable AI playlist generation.'
                : 'Enter your Google API key to enable AI playlist generation.'
            ),
            // API Key input
            React.createElement('div', { className: 'mb-4' },
              React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-1' }, 'API Key'),
              React.createElement('input', {
                type: 'password',
                defaultValue: metaServiceConfigs[selectedResolver.id]?.apiKey || '',
                onBlur: (e) => {
                  saveMetaServiceConfig(selectedResolver.id, {
                    ...metaServiceConfigs[selectedResolver.id],
                    apiKey: e.target.value,
                    enabled: !!e.target.value
                  });
                },
                placeholder: selectedResolver.id === 'chatgpt' ? 'sk-...' : 'AIza...',
                className: 'w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent'
              }),
              React.createElement('a', {
                href: '#',
                onClick: (e) => {
                  e.preventDefault();
                  const url = selectedResolver.id === 'chatgpt'
                    ? 'https://platform.openai.com/api-keys'
                    : 'https://aistudio.google.com/app/apikey';
                  window.electron?.shell?.openExternal?.(url);
                },
                className: 'text-xs text-purple-600 hover:text-purple-700 mt-1 inline-block'
              }, 'Get your API key â†’')
            ),
            // Model selector
            React.createElement('div', { className: 'mb-4' },
              React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-1' }, 'Model'),
              React.createElement('select', {
                value: metaServiceConfigs[selectedResolver.id]?.model || (selectedResolver.id === 'chatgpt' ? 'gpt-4o-mini' : 'gemini-2.5-flash'),
                onChange: (e) => {
                  saveMetaServiceConfig(selectedResolver.id, {
                    ...metaServiceConfigs[selectedResolver.id],
                    model: e.target.value
                  });
                },
                className: 'w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent bg-white'
              },
                selectedResolver.id === 'chatgpt' ? [
                  React.createElement('option', { key: 'gpt-4o-mini', value: 'gpt-4o-mini' }, 'GPT-4o Mini (Recommended)'),
                  React.createElement('option', { key: 'gpt-4o', value: 'gpt-4o' }, 'GPT-4o'),
                  React.createElement('option', { key: 'gpt-3.5-turbo', value: 'gpt-3.5-turbo' }, 'GPT-3.5 Turbo')
                ] : [
                  React.createElement('option', { key: 'gemini-2.5-flash', value: 'gemini-2.5-flash' }, 'Gemini 2.5 Flash (Recommended)'),
                  React.createElement('option', { key: 'gemini-2.5-pro', value: 'gemini-2.5-pro' }, 'Gemini 2.5 Pro')
                ]
              )
            ),
            // Connection status
            metaServiceConfigs[selectedResolver.id]?.apiKey && React.createElement('div', {
              className: 'flex items-center gap-2 text-green-600 text-sm'
            },
              React.createElement('span', null, 'âœ“'),
              React.createElement('span', null, 'API key configured')
            )
          ),

          // Libre.fm scrobbling section
          selectedResolver.id === 'librefm' && React.createElement('div', {
            className: 'py-3 border-t border-gray-100'
          },
            React.createElement('div', { className: 'mb-4' },
              React.createElement('span', { className: 'font-medium text-gray-900' }, 'Libre.fm Scrobbling'),
              React.createElement('p', { className: 'text-xs text-gray-500 mt-1' },
                'Open-source scrobbling service - an alternative to Last.fm. Report your listening history to Libre.fm.'
              )
            ),
            // Scrobbler card for Libre.fm
            window.scrobblers && window.scrobblers.find(s => s.id === 'librefm') &&
              React.createElement(ScrobblerSettingsCard, {
                scrobbler: window.scrobblers.find(s => s.id === 'librefm'),
                config: scrobblerConfigs['librefm'],
                onConfigChange: (id, newConfig) => {
                  setScrobblerConfigs(prev => ({ ...prev, [id]: newConfig }));
                }
              })
          ),

          // Local Files settings section
          selectedResolver.id === 'localfiles' && React.createElement('div', {
            className: 'py-3 border-t border-gray-100'
          },
            React.createElement('h3', { className: 'font-medium text-gray-900 mb-3' }, 'Watch Folders'),
            React.createElement('p', { className: 'text-xs text-gray-500 mb-4' },
              'Add folders containing your music files. Parachord will automatically index and watch them for changes.'
            ),

            // Watch folders list
            React.createElement('div', { className: 'space-y-2 mb-4' },
              watchFolders.length === 0
                ? React.createElement('p', { className: 'text-sm text-gray-400 italic' }, 'No watch folders configured')
                : watchFolders.map(folder =>
                    React.createElement('div', {
                      key: folder.path,
                      className: 'flex items-center justify-between p-3 bg-gray-50 rounded-lg'
                    },
                      React.createElement('div', { className: 'flex-1 min-w-0' },
                        React.createElement('p', { className: 'text-sm font-medium text-gray-900 truncate' }, folder.path),
                        React.createElement('p', { className: 'text-xs text-gray-500' },
                          `${folder.track_count || 0} tracks`
                        )
                      ),
                      React.createElement('div', { className: 'flex items-center gap-2 ml-4' },
                        React.createElement('button', {
                          onClick: () => handleRescanFolder(folder.path),
                          disabled: isScanning,
                          className: 'p-1.5 text-gray-500 hover:text-gray-700 hover:bg-gray-200 rounded transition-colors disabled:opacity-50',
                          title: 'Rescan folder'
                        }, '\u21BB'),
                        React.createElement('button', {
                          onClick: () => handleRemoveWatchFolder(folder.path),
                          className: 'p-1.5 text-gray-500 hover:text-red-600 hover:bg-red-50 rounded transition-colors',
                          title: 'Remove folder'
                        }, '\u2715')
                      )
                    )
                  )
            ),

            // Add folder button
            React.createElement('button', {
              onClick: handleAddWatchFolder,
              disabled: isScanning,
              className: 'w-full px-4 py-2 border border-dashed border-gray-300 rounded-lg text-sm text-gray-600 hover:bg-gray-50 hover:border-gray-400 transition-colors disabled:opacity-50 flex items-center justify-center gap-2'
            },
              React.createElement('span', null, '+'),
              'Add Watch Folder'
            ),

            // Scan progress
            isScanning && React.createElement('div', { className: 'mt-4' },
              React.createElement('div', { className: 'flex items-center gap-2 mb-2' },
                React.createElement('div', { className: 'animate-spin w-4 h-4 border-2 border-purple-600 border-t-transparent rounded-full' }),
                React.createElement('span', { className: 'text-sm text-gray-600' }, 'Scanning...')
              ),
              React.createElement('div', { className: 'w-full bg-gray-200 rounded-full h-2' },
                React.createElement('div', {
                  className: 'bg-purple-600 h-2 rounded-full transition-all',
                  style: { width: `${scanProgress.total > 0 ? (scanProgress.current / scanProgress.total) * 100 : 0}%` }
                })
              ),
              React.createElement('p', { className: 'text-xs text-gray-500 mt-1 truncate' },
                scanProgress.file || 'Preparing...'
              )
            ),

            // Stats
            React.createElement('div', { className: 'mt-6 pt-4 border-t border-gray-200' },
              React.createElement('h4', { className: 'text-sm font-medium text-gray-900 mb-2' }, 'Library Stats'),
              React.createElement('div', { className: 'grid grid-cols-2 gap-4 text-sm' },
                React.createElement('div', null,
                  React.createElement('p', { className: 'text-gray-500' }, 'Total Tracks'),
                  React.createElement('p', { className: 'font-medium text-gray-900' }, localFilesStats.totalTracks.toLocaleString())
                ),
                React.createElement('div', null,
                  React.createElement('p', { className: 'text-gray-500' }, 'Last Scan'),
                  React.createElement('p', { className: 'font-medium text-gray-900' },
                    localFilesStats.lastScan
                      ? new Date(localFilesStats.lastScan).toLocaleDateString()
                      : 'Never'
                  )
                )
              ),
              React.createElement('button', {
                onClick: handleRescanAll,
                disabled: isScanning || watchFolders.length === 0,
                className: 'mt-4 px-4 py-2 text-sm text-purple-600 hover:bg-purple-50 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed'
              }, 'Rescan All Folders')
            )
          )
        ),

        // Modal footer with action buttons
        React.createElement('div', {
          className: 'px-6 py-4 bg-gray-50 flex items-center justify-between'
        },
          // Left side: Remove button (only for user-installed resolvers)
          React.createElement('div', null,
            // Check if this is a user-installed resolver (not built-in)
            !['spotify', 'bandcamp', 'qobuz', 'musicbrainz'].includes(selectedResolver.id) &&
              React.createElement('button', {
                onClick: async () => {
                  await handleUninstallResolver(selectedResolver.id);
                  setSelectedResolver(null);
                },
                className: 'px-4 py-2 text-sm font-medium text-red-600 hover:bg-red-50 rounded-lg transition-colors'
              }, 'Remove')
          ),
          // Right side: Update button (if available) and Done
          React.createElement('div', { className: 'flex items-center gap-2' },
            // Update button - show if marketplace has newer version
            (() => {
              const marketplaceResolver = marketplaceManifest?.resolvers?.find(r => r.id === selectedResolver.id);
              const hasUpdate = marketplaceResolver &&
                marketplaceResolver.version !== selectedResolver.version &&
                marketplaceResolver.version > selectedResolver.version;
              if (hasUpdate) {
                return React.createElement('button', {
                  onClick: async () => {
                    await handleInstallFromMarketplace(marketplaceResolver);
                    setSelectedResolver(null);
                  },
                  disabled: installingResolvers.has(selectedResolver.id),
                  className: `px-4 py-2 text-sm font-medium text-white bg-orange-500 hover:bg-orange-600 rounded-lg transition-colors ${
                    installingResolvers.has(selectedResolver.id) ? 'opacity-50 cursor-not-allowed' : ''
                  }`
                }, installingResolvers.has(selectedResolver.id) ? 'Updating...' : `Update to v${marketplaceResolver.version}`);
              }
              return null;
            })(),
            React.createElement('button', {
              onClick: () => setSelectedResolver(null),
              className: 'px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-100 rounded-lg transition-colors'
            }, 'Done')
          )
        )
      )
    ),

    // Marketplace Item Detail Modal
    selectedMarketplaceItem && React.createElement('div', {
      className: 'fixed inset-0 bg-black/50 flex items-center justify-center z-50',
      onClick: (e) => { if (e.target === e.currentTarget) setSelectedMarketplaceItem(null); }
    },
      React.createElement('div', {
        className: 'bg-white rounded-2xl shadow-2xl max-w-md w-full mx-4 overflow-hidden'
      },
        // Modal header with colored background
        React.createElement('div', {
          className: 'p-6 flex items-center gap-4',
          style: { backgroundColor: selectedMarketplaceItem.color || '#6B7280' }
        },
          // Logo
          React.createElement('div', {
            className: 'w-16 h-16 flex items-center justify-center'
          }, SERVICE_LOGOS[selectedMarketplaceItem.id] || React.createElement('span', { className: 'text-4xl' }, selectedMarketplaceItem.icon)),
          // Name and version
          React.createElement('div', { className: 'flex-1 text-white' },
            React.createElement('div', { className: 'flex items-center gap-2' },
              React.createElement('h2', { className: 'text-xl font-bold' }, selectedMarketplaceItem.name),
              selectedMarketplaceItem.version && React.createElement('span', {
                className: 'px-2 py-0.5 bg-white/20 rounded text-xs'
              }, 'v', selectedMarketplaceItem.version)
            ),
            React.createElement('p', { className: 'text-white/80 text-sm' }, selectedMarketplaceItem.author || 'Unknown')
          ),
          // Close button
          React.createElement('button', {
            onClick: () => setSelectedMarketplaceItem(null),
            className: 'w-8 h-8 rounded-full bg-white/20 hover:bg-white/30 flex items-center justify-center text-white transition-colors'
          }, 'âœ•')
        ),
        // Modal body
        React.createElement('div', { className: 'p-6 space-y-6' },
          // Description
          React.createElement('p', { className: 'text-gray-600 text-sm' }, selectedMarketplaceItem.description),

          // Capabilities
          selectedMarketplaceItem.capabilities && React.createElement('div', null,
            React.createElement('h3', { className: 'text-sm font-semibold text-gray-900 mb-2' }, 'Capabilities'),
            React.createElement('div', { className: 'flex flex-wrap gap-2' },
              Object.entries(selectedMarketplaceItem.capabilities || {}).map(([cap, enabled]) => {
                if (!enabled) return null;
                const capLabels = {
                  resolve: 'Resolve',
                  search: 'Search',
                  stream: 'Stream',
                  browse: 'Browse',
                  urlLookup: 'URL Lookup',
                  recommendations: 'Recommendations',
                  metadata: 'Metadata',
                  generate: 'AI Playlist Generation'
                };
                const label = capLabels[cap] || cap;
                return React.createElement('span', {
                  key: cap,
                  className: 'px-3 py-1 bg-purple-100 text-purple-700 rounded-full text-xs font-medium'
                }, label);
              })
            )
          ),

          // Category
          selectedMarketplaceItem.category && React.createElement('div', null,
            React.createElement('h3', { className: 'text-sm font-semibold text-gray-900 mb-2' }, 'Category'),
            React.createElement('span', {
              className: 'px-3 py-1 bg-purple-100 text-purple-700 rounded-full text-xs capitalize'
            }, selectedMarketplaceItem.category)
          ),

          // API Key Configuration (for AI services with generate capability)
          selectedMarketplaceItem.capabilities?.generate && React.createElement('div', {
            className: 'border-t border-gray-100 pt-4'
          },
            React.createElement('h3', { className: 'text-sm font-semibold text-gray-900 mb-3' }, 'Configuration'),
            // API Key input
            React.createElement('div', { className: 'space-y-2' },
              React.createElement('label', { className: 'block text-sm text-gray-600' }, 'API Key'),
              React.createElement('input', {
                type: 'password',
                defaultValue: metaServiceConfigs[selectedMarketplaceItem.id]?.apiKey || '',
                onBlur: (e) => {
                  saveMetaServiceConfig(selectedMarketplaceItem.id, {
                    ...metaServiceConfigs[selectedMarketplaceItem.id],
                    apiKey: e.target.value,
                    enabled: true
                  });
                },
                placeholder: selectedMarketplaceItem.id === 'chatgpt' ? 'sk-...' : 'AIza...',
                className: 'w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent'
              }),
              React.createElement('a', {
                href: '#',
                onClick: (e) => {
                  e.preventDefault();
                  const url = selectedMarketplaceItem.id === 'chatgpt'
                    ? 'https://platform.openai.com/api-keys'
                    : 'https://aistudio.google.com/app/apikey';
                  window.electron?.shell?.openExternal?.(url);
                },
                className: 'text-xs text-purple-600 hover:text-purple-700 inline-block'
              }, 'Get your API key â†’')
            ),
            // Model selector
            React.createElement('div', { className: 'mt-4 space-y-2' },
              React.createElement('label', { className: 'block text-sm text-gray-600' }, 'Model'),
              React.createElement('select', {
                defaultValue: metaServiceConfigs[selectedMarketplaceItem.id]?.model || (selectedMarketplaceItem.id === 'chatgpt' ? 'gpt-4o-mini' : 'gemini-2.5-flash'),
                onChange: (e) => {
                  saveMetaServiceConfig(selectedMarketplaceItem.id, {
                    ...metaServiceConfigs[selectedMarketplaceItem.id],
                    model: e.target.value
                  });
                },
                className: 'w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent bg-white'
              },
                selectedMarketplaceItem.id === 'chatgpt' ? [
                  React.createElement('option', { key: 'gpt-4o-mini', value: 'gpt-4o-mini' }, 'GPT-4o Mini (Recommended)'),
                  React.createElement('option', { key: 'gpt-4o', value: 'gpt-4o' }, 'GPT-4o'),
                  React.createElement('option', { key: 'gpt-3.5-turbo', value: 'gpt-3.5-turbo' }, 'GPT-3.5 Turbo')
                ] : [
                  React.createElement('option', { key: 'gemini-2.5-flash', value: 'gemini-2.5-flash' }, 'Gemini 2.5 Flash (Recommended)'),
                  React.createElement('option', { key: 'gemini-2.5-pro', value: 'gemini-2.5-pro' }, 'Gemini 2.5 Pro')
                ]
              )
            )
          ),

          // Update available notice (only when installed and update exists)
          selectedMarketplaceItem.isInstalled &&
            selectedMarketplaceItem.installedResolver?.version !== selectedMarketplaceItem.version &&
            React.createElement('div', {
              className: 'flex items-center gap-2 py-3 border-t border-gray-100 text-orange-500 text-sm'
            },
              React.createElement('span', null, 'â¬†'),
              React.createElement('span', null, `Update available: v${selectedMarketplaceItem.version}`)
            )
        ),
        // Modal footer with action buttons
        React.createElement('div', {
          className: 'px-6 py-4 bg-gray-50 flex items-center justify-between'
        },
          selectedMarketplaceItem.isInstalled
            ? React.createElement(React.Fragment, null,
                // Remove button on the left (disabled for built-in)
                React.createElement('button', {
                  onClick: async () => {
                    await handleUninstallResolver(selectedMarketplaceItem.id);
                    setSelectedMarketplaceItem(null);
                  },
                  disabled: ['spotify', 'bandcamp', 'qobuz', 'youtube', 'localfiles', 'applemusic', 'chatgpt', 'gemini'].includes(selectedMarketplaceItem.id),
                  className: 'px-4 py-2 text-sm font-medium text-red-600 hover:text-red-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed',
                  title: ['spotify', 'bandcamp', 'qobuz', 'youtube', 'localfiles', 'applemusic', 'chatgpt', 'gemini'].includes(selectedMarketplaceItem.id)
                    ? 'Built-in plug-ins cannot be removed'
                    : 'Remove this plug-in'
                }, 'Remove'),
                // Right side buttons
                React.createElement('div', { className: 'flex items-center gap-2' },
                  // Update button if newer version available
                  selectedMarketplaceItem.installedResolver?.version !== selectedMarketplaceItem.version &&
                    React.createElement('button', {
                      onClick: async () => {
                        await handleInstallFromMarketplace(selectedMarketplaceItem);
                        setSelectedMarketplaceItem(null);
                      },
                      disabled: installingResolvers.has(selectedMarketplaceItem.id),
                      className: 'px-4 py-2 text-sm font-medium text-white bg-orange-500 hover:bg-orange-600 rounded-lg transition-colors disabled:opacity-50'
                    }, installingResolvers.has(selectedMarketplaceItem.id) ? 'Updating...' : 'Update'),
                  // Done button
                  React.createElement('button', {
                    onClick: () => setSelectedMarketplaceItem(null),
                    className: 'px-4 py-2 text-sm font-medium text-gray-700 hover:text-gray-900 transition-colors'
                  }, 'Done')
                )
              )
            : React.createElement(React.Fragment, null,
                // Empty left side for non-installed
                React.createElement('div', null),
                // Right side with Install and Done buttons
                React.createElement('div', { className: 'flex items-center gap-2' },
                  React.createElement('button', {
                    onClick: async () => {
                      await handleInstallFromMarketplace(selectedMarketplaceItem);
                      setSelectedMarketplaceItem(null);
                    },
                    disabled: installingResolvers.has(selectedMarketplaceItem.id),
                    className: 'px-4 py-2 text-sm font-medium text-white bg-purple-600 hover:bg-purple-700 rounded-lg transition-colors disabled:opacity-50'
                  }, installingResolvers.has(selectedMarketplaceItem.id) ? 'Installing...' : 'Install'),
                  React.createElement('button', {
                    onClick: () => setSelectedMarketplaceItem(null),
                    className: 'px-4 py-2 text-sm font-medium text-gray-700 hover:text-gray-900 transition-colors'
                  }, 'Done')
                )
              )
        )
      )
    ),

    // Add to Playlist Slide-out Panel
    addToPlaylistPanel.open && React.createElement('div', {
      className: 'fixed inset-0 z-50',
      style: { pointerEvents: 'none' }
    },
      // Backdrop (only covers area outside sidebar)
      React.createElement('div', {
        className: 'absolute inset-0 bg-black/30 transition-opacity',
        style: { left: '256px', pointerEvents: 'auto' },
        onClick: () => {
          setAddToPlaylistPanel(prev => ({ ...prev, open: false }));
          setSelectedPlaylistsForAdd([]);
          setNewPlaylistFormOpen(false);
          setNewPlaylistName('');
        },
        onDragOver: (e) => {
          e.preventDefault();
        },
        onDrop: (e) => {
          e.preventDefault();
        }
      }),

      // Panel - positioned at right edge of sidebar
      React.createElement('div', {
        className: 'absolute w-96 bg-white shadow-2xl flex flex-col',
        style: { left: '256px', top: '28px', bottom: '85px', pointerEvents: 'auto' }, // Account for title bar and player
        onDragOver: (e) => {
          // Allow drag events to pass through to children
          e.preventDefault();
        },
        onDrop: (e) => {
          e.preventDefault();
        }
      },
        // Dark header with title
        React.createElement('div', {
          className: 'bg-gray-700 px-5 py-4'
        },
          React.createElement('div', {
            className: 'flex items-center gap-2 text-white'
          },
            React.createElement('span', { className: 'text-lg' }, '+'),
            React.createElement('span', { className: 'w-4 h-4 rounded-full bg-gray-500' }),
            React.createElement('span', {
              className: 'text-sm font-medium tracking-wide'
            }, 'ADD TO PLAYLIST')
          )
        ),

        // Track info section with DONE button
        React.createElement('div', {
          className: 'px-5 py-4 bg-gray-100 border-b border-gray-200'
        },
          React.createElement('div', {
            className: 'flex items-center gap-3'
          },
            // Album art thumbnail (gray placeholder or actual art)
            React.createElement('div', {
              className: 'w-12 h-12 rounded bg-gray-300 flex-shrink-0 flex items-center justify-center overflow-hidden relative'
            },
              // Placeholder always rendered behind
              React.createElement(Music, { size: 20, className: 'text-gray-400' }),
              addToPlaylistPanel.tracks[0]?.albumArt && React.createElement('img', {
                src: addToPlaylistPanel.tracks[0].albumArt,
                className: 'absolute inset-0 w-full h-full object-cover',
                onError: (e) => { e.target.style.display = 'none'; }
              })
            ),
            // Track/source info
            React.createElement('div', {
              className: 'flex-1 min-w-0'
            },
              React.createElement('p', {
                className: 'text-sm font-medium text-gray-900 truncate'
              }, addToPlaylistPanel.sourceName),
              React.createElement('p', {
                className: 'text-xs text-gray-500'
              }, addToPlaylistPanel.tracks[0]?.artist || `${addToPlaylistPanel.tracks.length} tracks`)
            ),
            // DONE button - just closes the panel (tracks are added on click)
            React.createElement('button', {
              onClick: () => {
                setAddToPlaylistPanel(prev => ({ ...prev, open: false }));
                setSelectedPlaylistsForAdd([]);
                setNewPlaylistFormOpen(false);
                setNewPlaylistName('');
              },
              className: 'px-5 py-1.5 bg-green-500 hover:bg-green-600 text-white text-sm font-medium rounded-full transition-colors'
            }, 'DONE')
          )
        ),

        // PLAYLISTS section header
        React.createElement('div', {
          className: 'px-5 py-3 text-xs font-medium text-gray-400 uppercase tracking-wider'
        }, 'PLAYLISTS'),

        // Playlist list (scrollable) - includes New Playlist row at top
        React.createElement('div', {
          className: 'flex-1 overflow-y-auto min-h-0'
        },
          // New Playlist row (always shown at top)
          // TODO: Fix drag-and-drop to create new playlist - onDrop events not firing in Electron
          // The visual highlight works (onDragEnter/onDragLeave) but onDrop never fires.
          // Attempted: dataTransfer fallback, mouseUp fallback, pointerEvents:none on children.
          // For now, users must click "New Playlist" row to open form, then drag to existing playlists works.
          React.createElement('div', {
            key: 'new-playlist-row',
            onClick: () => {
              if (!newPlaylistFormOpen) {
                setNewPlaylistFormOpen(true);
                setNewPlaylistName('');
                setDroppedTrackForNewPlaylist(null);
              }
            },
            onMouseUp: () => {
              // Fallback for drop - if we're hovering while a track is being dragged
              if (dropTargetNewPlaylist && draggingTrackForPlaylist) {
                console.log('ðŸ–±ï¸ MouseUp on New Playlist row while dragging:', draggingTrackForPlaylist.title);
                setDroppedTrackForNewPlaylist(draggingTrackForPlaylist);
                setNewPlaylistFormOpen(true);
                setNewPlaylistName('');
                setDropTargetNewPlaylist(false);
              }
            },
            onDragEnter: (e) => {
              e.preventDefault();
              e.stopPropagation();
              if (draggingTrackForPlaylist) {
                setDropTargetNewPlaylist(true);
              }
            },
            onDragOver: (e) => {
              e.preventDefault();
              e.stopPropagation();
              e.dataTransfer.dropEffect = 'copy';
            },
            onDragLeave: (e) => {
              e.preventDefault();
              e.stopPropagation();
              if (!e.currentTarget.contains(e.relatedTarget)) {
                setDropTargetNewPlaylist(false);
              }
            },
            onDrop: (e) => {
              e.preventDefault();
              e.stopPropagation();
              console.log('ðŸŽ¯ Drop on New Playlist row');

              // Try to get track from state or dataTransfer
              let trackToUse = draggingTrackForPlaylist;
              if (!trackToUse) {
                try {
                  const data = JSON.parse(e.dataTransfer.getData('text/plain'));
                  if (data.type === 'track' && data.track) {
                    trackToUse = data.track;
                  }
                } catch (err) {
                  // ignore
                }
              }

              if (trackToUse) {
                setDroppedTrackForNewPlaylist(trackToUse);
                setNewPlaylistFormOpen(true);
                setNewPlaylistName('');
                setDropTargetNewPlaylist(false);
              }
            },
            className: `flex items-center gap-3 px-5 py-2.5 cursor-pointer transition-all border-b border-gray-100 ${
              dropTargetNewPlaylist
                ? 'bg-purple-100 border-l-4 border-l-purple-500 pl-4'
                : newPlaylistFormOpen
                  ? 'bg-gray-100'
                  : 'hover:bg-gray-50'
            }`
          },
            // Plus icon in square (like playlist thumbnail)
            React.createElement('div', {
              className: 'w-10 h-10 rounded bg-gray-200 flex-shrink-0 flex items-center justify-center',
              style: { pointerEvents: 'none' } // Let parent handle all events
            },
              React.createElement('span', { className: 'text-gray-500 text-xl font-light' }, '+')
            ),
            // "New Playlist" text or input form
            newPlaylistFormOpen ?
              React.createElement('div', {
                className: 'flex-1 flex gap-2',
                onClick: (e) => e.stopPropagation(), // Prevent row click when interacting with form
                style: { pointerEvents: 'auto' } // Allow form interaction
              },
                React.createElement('input', {
                  type: 'text',
                  value: newPlaylistName,
                  onChange: (e) => setNewPlaylistName(e.target.value),
                  onKeyDown: (e) => {
                    if (e.key === 'Enter' && newPlaylistName.trim()) {
                      // Create new playlist with the tracks
                      const playlistId = newPlaylistName.trim().toLowerCase().replace(/[^a-z0-9]/g, '-') + '-' + Date.now();
                      // Use dropped track if available, otherwise use panel tracks
                      const sourceTracks = droppedTrackForNewPlaylist ? [droppedTrackForNewPlaylist] : addToPlaylistPanel.tracks;
                      const tracksToAdd = sourceTracks.map(t => ({
                        title: t.title,
                        artist: t.artist,
                        album: t.album,
                        duration: t.duration,
                        id: t.id || `${t.artist}-${t.title}`.toLowerCase().replace(/[^a-z0-9-]/g, '')
                      }));
                      const newPlaylist = {
                        id: playlistId,
                        filename: `${playlistId}.xspf`,
                        title: newPlaylistName.trim(),
                        creator: 'Me',
                        tracks: tracksToAdd,
                        createdAt: Date.now(),
                        addedAt: Date.now(),
                        lastModified: Date.now()
                      };
                      setPlaylists(prev => [newPlaylist, ...prev]);
                      fetchPlaylistCovers(playlistId, newPlaylist.tracks);
                      setSelectedPlaylistsForAdd(prev => [...prev, playlistId]);
                      savePlaylistToStore(newPlaylist); // Save to disk
                      showSidebarBadge('playlists', tracksToAdd.length);
                      setNewPlaylistFormOpen(false);
                      setNewPlaylistName('');
                      setDroppedTrackForNewPlaylist(null); // Clear dropped track
                    } else if (e.key === 'Escape') {
                      setNewPlaylistFormOpen(false);
                      setNewPlaylistName('');
                      setDroppedTrackForNewPlaylist(null); // Clear dropped track
                    }
                  },
                  placeholder: 'Playlist name...',
                  autoFocus: true,
                  className: 'flex-1 px-3 py-1.5 text-sm border border-gray-300 rounded focus:outline-none focus:border-purple-500 focus:ring-1 focus:ring-purple-500'
                }),
                React.createElement('button', {
                  onClick: () => {
                    if (!newPlaylistName.trim()) return;
                    // Create new playlist with the tracks
                    const playlistId = newPlaylistName.trim().toLowerCase().replace(/[^a-z0-9]/g, '-') + '-' + Date.now();
                    // Use dropped track if available, otherwise use panel tracks
                    const sourceTracks = droppedTrackForNewPlaylist ? [droppedTrackForNewPlaylist] : addToPlaylistPanel.tracks;
                    const tracksToAdd = sourceTracks.map(t => ({
                      title: t.title,
                      artist: t.artist,
                      album: t.album,
                      duration: t.duration,
                      id: t.id || `${t.artist}-${t.title}`.toLowerCase().replace(/[^a-z0-9-]/g, '')
                    }));
                    const newPlaylist = {
                      id: playlistId,
                      filename: `${playlistId}.xspf`,
                      title: newPlaylistName.trim(),
                      creator: 'Me',
                      tracks: tracksToAdd,
                      createdAt: Date.now(),
                      addedAt: Date.now(),
                      lastModified: Date.now()
                    };
                    setPlaylists(prev => [newPlaylist, ...prev]);
                    fetchPlaylistCovers(playlistId, newPlaylist.tracks);
                    setSelectedPlaylistsForAdd(prev => [...prev, playlistId]);
                    savePlaylistToStore(newPlaylist); // Save to disk
                    showSidebarBadge('playlists', tracksToAdd.length);
                    setNewPlaylistFormOpen(false);
                    setNewPlaylistName('');
                    setDroppedTrackForNewPlaylist(null); // Clear dropped track
                  },
                  disabled: !newPlaylistName.trim(),
                  className: `px-3 py-1.5 text-sm font-medium rounded transition-colors ${
                    newPlaylistName.trim()
                      ? 'bg-green-500 hover:bg-green-600 text-white'
                      : 'bg-gray-200 text-gray-400 cursor-not-allowed'
                  }`
                }, 'Create')
              )
            :
              React.createElement('span', {
                className: 'flex-1 text-sm text-gray-600',
                style: { pointerEvents: 'none' } // Let parent handle all events
              }, 'New Playlist')
          ),

          // Existing playlists
          playlists.length === 0 ?
            React.createElement('div', {
              className: 'px-5 py-8 text-center text-gray-400 text-sm'
            }, 'No playlists yet')
          :
            playlists.map(playlist => {
              const isAdded = selectedPlaylistsForAdd.includes(playlist.id);
              const isDropTarget = dropTargetPlaylistId === playlist.id;

              // Helper to add tracks to this playlist
              const addTracksToPlaylistHelper = (tracks) => {
                if (isAdded || !tracks || tracks.length === 0) return;

                // Add tracks to this playlist immediately
                const tracksToAdd = tracks.map(t => ({
                  title: t.title,
                  artist: t.artist,
                  album: t.album,
                  duration: t.duration,
                  id: t.id || `${t.artist}-${t.title}`.toLowerCase().replace(/[^a-z0-9-]/g, '')
                }));

                // Build updated playlist for saving
                const updatedPlaylist = {
                  ...playlist,
                  tracks: [...(playlist.tracks || []), ...tracksToAdd],
                  lastModified: Date.now()
                };

                setPlaylists(prev => prev.map(p => {
                  if (p.id === playlist.id) {
                    return updatedPlaylist;
                  }
                  return p;
                }));

                // Save to disk
                savePlaylistToStore(updatedPlaylist);

                // Mark as added
                setSelectedPlaylistsForAdd(prev => [...prev, playlist.id]);

                // Show sidebar badge
                showSidebarBadge('playlists', tracks.length);
              };

              return React.createElement('div', {
                key: playlist.id,
                onClick: () => addTracksToPlaylistHelper(addToPlaylistPanel.tracks),
                onDragEnter: (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  if (!isAdded) {
                    setDropTargetPlaylistId(playlist.id);
                  }
                },
                onDragOver: (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  e.dataTransfer.dropEffect = 'copy';
                  if (!isAdded && dropTargetPlaylistId !== playlist.id) {
                    setDropTargetPlaylistId(playlist.id);
                  }
                },
                onDragLeave: (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  // Only clear if we're actually leaving this element
                  if (!e.currentTarget.contains(e.relatedTarget)) {
                    setDropTargetPlaylistId(null);
                  }
                },
                onDrop: (e) => {
                  e.preventDefault();
                  e.stopPropagation();

                  // Try to get track from state first, then dataTransfer as fallback
                  let trackFromDrag = draggingTrackForPlaylist;
                  if (!trackFromDrag) {
                    try {
                      const data = JSON.parse(e.dataTransfer.getData('text/plain'));
                      if (data.type === 'track' && data.track) {
                        trackFromDrag = data.track;
                      }
                    } catch (err) {
                      // ignore parse errors
                    }
                  }

                  const tracksToUse = trackFromDrag
                    ? [trackFromDrag]
                    : addToPlaylistPanel.tracks;
                  addTracksToPlaylistHelper(tracksToUse);
                  // Clear the dragging state
                  setDraggingTrackForPlaylist(null);
                  setDropTargetPlaylistId(null);
                },
                className: `flex items-center gap-3 px-5 py-2.5 cursor-pointer transition-all border-b border-gray-100 ${
                  isAdded
                    ? 'bg-green-50'
                    : isDropTarget
                      ? 'bg-purple-100 border-l-4 border-l-purple-500 pl-4'
                      : 'hover:bg-gray-50'
                }`
              },
                // Playlist thumbnail (gray square)
                React.createElement('div', {
                  className: 'w-10 h-10 rounded bg-gray-200 flex-shrink-0 flex items-center justify-center overflow-hidden'
                },
                  // Could show playlist cover here if available
                  allPlaylistCovers[playlist.id]?.[0] ?
                    React.createElement('img', {
                      src: allPlaylistCovers[playlist.id][0],
                      className: 'w-full h-full object-cover'
                    })
                  :
                    React.createElement(Music, { size: 16, className: 'text-gray-400' })
                ),
                // Playlist name
                React.createElement('span', {
                  className: 'flex-1 text-sm text-gray-900 truncate'
                }, playlist.title),
                // Song count - shows updated count from playlists state
                React.createElement('span', {
                  className: `text-sm flex-shrink-0 ${isAdded ? 'text-green-600 font-medium' : 'text-gray-400'}`
                }, `${playlist.tracks?.length || 0} songs`),
                // Checkmark if added
                isAdded && React.createElement('svg', {
                  className: 'w-5 h-5 text-green-500 flex-shrink-0',
                  fill: 'none',
                  viewBox: '0 0 24 24',
                  stroke: 'currentColor'
                },
                  React.createElement('path', {
                    strokeLinecap: 'round',
                    strokeLinejoin: 'round',
                    strokeWidth: 2,
                    d: 'M5 13l4 4L19 7'
                  })
                )
              );
            })
        )
      )
    ),

    // ID3 Tag Editor Modal
    id3EditorOpen && React.createElement('div', {
      className: 'fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-[60]',
      onClick: (e) => {
        if (e.target === e.currentTarget && !id3EditorSaving) {
          setId3EditorOpen(false);
          setId3EditorTrack(null);
        }
      }
    },
      React.createElement('div', {
        className: 'bg-white rounded-2xl shadow-2xl max-w-md w-full mx-4 overflow-hidden',
        onClick: (e) => e.stopPropagation()
      },
        // Header
        React.createElement('div', {
          className: 'px-6 py-4 bg-gradient-to-r from-purple-600 to-indigo-600 text-white'
        },
          React.createElement('h2', { className: 'text-lg font-semibold' }, 'Edit ID3 Tags'),
          React.createElement('p', { className: 'text-sm text-white/80 mt-1 truncate' },
            id3EditorTrack?.filePath?.split('/').pop() || 'Unknown file'
          )
        ),
        // Body
        React.createElement('div', {
          className: 'p-6 space-y-4 max-h-[60vh] overflow-y-auto'
        },
          // Title field
          React.createElement('div', null,
            React.createElement('label', {
              className: 'block text-sm font-medium text-gray-700 mb-1'
            }, 'Title'),
            React.createElement('input', {
              type: 'text',
              value: id3EditorValues.title,
              onChange: (e) => setId3EditorValues(v => ({ ...v, title: e.target.value })),
              className: 'w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent',
              placeholder: 'Track title'
            })
          ),
          // Artist field
          React.createElement('div', null,
            React.createElement('label', {
              className: 'block text-sm font-medium text-gray-700 mb-1'
            }, 'Artist'),
            React.createElement('input', {
              type: 'text',
              value: id3EditorValues.artist,
              onChange: (e) => setId3EditorValues(v => ({ ...v, artist: e.target.value })),
              className: 'w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent',
              placeholder: 'Artist name'
            })
          ),
          // Album field
          React.createElement('div', null,
            React.createElement('label', {
              className: 'block text-sm font-medium text-gray-700 mb-1'
            }, 'Album'),
            React.createElement('input', {
              type: 'text',
              value: id3EditorValues.album,
              onChange: (e) => setId3EditorValues(v => ({ ...v, album: e.target.value })),
              className: 'w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent',
              placeholder: 'Album name'
            })
          ),
          // Track Number and Year row
          React.createElement('div', { className: 'flex gap-4' },
            // Track Number field
            React.createElement('div', { className: 'flex-1' },
              React.createElement('label', {
                className: 'block text-sm font-medium text-gray-700 mb-1'
              }, 'Track #'),
              React.createElement('input', {
                type: 'text',
                value: id3EditorValues.trackNumber,
                onChange: (e) => setId3EditorValues(v => ({ ...v, trackNumber: e.target.value })),
                className: 'w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent',
                placeholder: '1'
              })
            ),
            // Year field
            React.createElement('div', { className: 'flex-1' },
              React.createElement('label', {
                className: 'block text-sm font-medium text-gray-700 mb-1'
              }, 'Year'),
              React.createElement('input', {
                type: 'text',
                value: id3EditorValues.year,
                onChange: (e) => setId3EditorValues(v => ({ ...v, year: e.target.value })),
                className: 'w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent',
                placeholder: '2024'
              })
            )
          ),

          // Album Art section
          React.createElement('div', { className: 'pt-4 border-t border-gray-200' },
            React.createElement('div', { className: 'flex items-center justify-between mb-3' },
              React.createElement('label', {
                className: 'block text-sm font-medium text-gray-700'
              }, 'Album Art'),
              id3ArtLoading && React.createElement('span', {
                className: 'text-sm text-purple-600 flex items-center gap-1'
              },
                React.createElement('span', { className: 'animate-spin' }, 'âŸ³'),
                'Searching...'
              )
            ),

            // Current selection
            id3SelectedArt && React.createElement('div', {
              className: 'mb-3 p-2 bg-green-50 border border-green-200 rounded-lg flex items-center gap-3'
            },
              React.createElement('img', {
                src: id3SelectedArt.thumbnailUrl,
                alt: 'Selected album art',
                className: 'w-16 h-16 rounded object-cover'
              }),
              React.createElement('div', { className: 'flex-1 min-w-0' },
                React.createElement('div', { className: 'text-sm font-medium text-green-800 truncate' }, id3SelectedArt.releaseName),
                React.createElement('div', { className: 'text-xs text-green-600 truncate' }, id3SelectedArt.artistName),
                id3SelectedArt.year && React.createElement('div', { className: 'text-xs text-green-600' }, id3SelectedArt.year)
              ),
              React.createElement('button', {
                onClick: () => setId3SelectedArt(null),
                className: 'text-green-600 hover:text-green-800 p-1'
              }, 'âœ•')
            ),

            // Art suggestions grid
            id3ArtSuggestions.length > 0 && !id3SelectedArt && React.createElement('div', {
              className: 'grid grid-cols-4 gap-2'
            },
              id3ArtSuggestions.map((art, idx) =>
                React.createElement('button', {
                  key: art.releaseId || idx,
                  onClick: () => setId3SelectedArt(art),
                  className: 'relative group rounded-lg overflow-hidden border-2 border-transparent hover:border-purple-500 transition-colors',
                  title: `${art.releaseName} by ${art.artistName}${art.year ? ` (${art.year})` : ''}`
                },
                  React.createElement('img', {
                    src: art.thumbnailUrl,
                    alt: art.releaseName,
                    className: 'w-full aspect-square object-cover'
                  }),
                  React.createElement('div', {
                    className: 'absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center'
                  },
                    React.createElement('span', { className: 'text-white text-xs font-medium' }, 'Select')
                  )
                )
              )
            ),

            // Empty state messages
            !id3ArtLoading && id3ArtSuggestions.length === 0 && !id3SelectedArt && React.createElement('div', {
              className: 'text-center py-4 text-gray-400 text-sm'
            },
              (!id3EditorValues.artist || !id3EditorValues.album)
                ? 'Enter artist and album to see artwork suggestions'
                : 'No artwork found for this album'
            )
          )
        ),
        // Footer with buttons
        React.createElement('div', {
          className: 'px-6 py-4 bg-gray-50 border-t border-gray-200 flex justify-end gap-3'
        },
          React.createElement('button', {
            onClick: () => {
              setId3EditorOpen(false);
              setId3EditorTrack(null);
            },
            disabled: id3EditorSaving,
            className: 'px-4 py-2 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-50 transition-colors disabled:opacity-50'
          }, 'Cancel'),
          React.createElement('button', {
            onClick: async () => {
              if (!id3EditorTrack?.filePath) return;

              setId3EditorSaving(true);
              try {
                const tagsToSave = {
                  title: id3EditorValues.title,
                  artist: id3EditorValues.artist,
                  album: id3EditorValues.album,
                  trackNumber: id3EditorValues.trackNumber ? parseInt(id3EditorValues.trackNumber, 10) : null,
                  year: id3EditorValues.year ? parseInt(id3EditorValues.year, 10) : null
                };

                // If album art was selected, include it
                if (id3SelectedArt?.fullUrl) {
                  tagsToSave.albumArtUrl = id3SelectedArt.fullUrl;
                }

                const result = await window.electron.localFiles.saveId3Tags(
                  id3EditorTrack.filePath,
                  tagsToSave
                );

                if (result.success) {
                  console.log('ðŸ·ï¸ ID3 tags saved successfully');
                  // Update track in library
                  setLibrary(prev => prev.map(t =>
                    t.filePath === id3EditorTrack.filePath
                      ? {
                          ...t,
                          ...id3EditorValues,
                          trackNumber: id3EditorValues.trackNumber ? parseInt(id3EditorValues.trackNumber, 10) : t.trackNumber,
                          year: id3EditorValues.year ? parseInt(id3EditorValues.year, 10) : t.year,
                          albumArt: id3SelectedArt?.fullUrl || t.albumArt
                        }
                      : t
                  ));
                  setId3EditorOpen(false);
                  setId3EditorTrack(null);
                  setId3SelectedArt(null);
                  setId3ArtSuggestions([]);
                } else {
                  alert('Failed to save ID3 tags: ' + result.error);
                }
              } catch (error) {
                console.error('Error saving ID3 tags:', error);
                alert('Failed to save ID3 tags: ' + error.message);
              } finally {
                setId3EditorSaving(false);
              }
            },
            disabled: id3EditorSaving,
            className: 'px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors disabled:opacity-50 flex items-center gap-2'
          },
            id3EditorSaving && React.createElement('span', { className: 'animate-spin' }, 'âŸ³'),
            id3EditorSaving ? 'Saving...' : 'Save'
          )
        )
      )
    ),

    // Confirmation Dialog Modal
    confirmDialog.show && React.createElement('div', {
      className: 'fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-[60]',
      onClick: (e) => {
        if (e.target === e.currentTarget) closeConfirmDialog();
      }
    },
      React.createElement('div', {
        className: 'bg-white rounded-2xl shadow-2xl max-w-sm w-full mx-4 overflow-hidden transform transition-all',
        onClick: (e) => e.stopPropagation()
      },
        // Header with colored indicator
        React.createElement('div', {
          className: `px-6 pt-6 pb-4 flex flex-col items-center text-center`
        },
          // Icon based on type
          React.createElement('div', {
            className: `w-16 h-16 rounded-full flex items-center justify-center mb-4 ${
              confirmDialog.type === 'success' ? 'bg-green-100' :
              confirmDialog.type === 'error' ? 'bg-red-100' :
              'bg-purple-100'
            }`
          },
            React.createElement('span', {
              className: 'text-3xl'
            }, confirmDialog.type === 'success' ? 'âœ“' :
               confirmDialog.type === 'error' ? 'âœ•' : 'â„¹')
          ),
          // Title
          confirmDialog.title && React.createElement('h3', {
            className: `text-lg font-semibold mb-2 ${
              confirmDialog.type === 'success' ? 'text-green-800' :
              confirmDialog.type === 'error' ? 'text-red-800' :
              'text-gray-900'
            }`
          }, confirmDialog.title),
          // Message
          confirmDialog.message && React.createElement('p', {
            className: 'text-gray-600 text-sm leading-relaxed'
          }, confirmDialog.message)
        ),
        // Footer with button
        React.createElement('div', { className: 'px-6 pb-6 pt-2' },
          React.createElement('button', {
            onClick: () => {
              if (confirmDialog.onConfirm) confirmDialog.onConfirm();
              closeConfirmDialog();
            },
            className: `w-full py-3 px-4 rounded-xl font-medium transition-colors ${
              confirmDialog.type === 'success' ? 'bg-green-600 hover:bg-green-700 text-white' :
              confirmDialog.type === 'error' ? 'bg-red-600 hover:bg-red-700 text-white' :
              'bg-purple-600 hover:bg-purple-700 text-white'
            }`
          }, 'OK')
        )
      )
    ),

    // Queue Drawer - slides up above the playbar with matching dark theme
    // Gradient transparency: more opaque near playbar, more transparent at top
    React.createElement('div', {
      className: 'fixed left-0 right-0 backdrop-blur-md border-t border-gray-700/50 shadow-2xl transition-all duration-300 ease-in-out z-40',
      style: {
        bottom: queueDrawerOpen ? '85px' : -queueDrawerHeight, // Position above the playbar (85px height)
        height: queueDrawerHeight + 'px',
        background: 'linear-gradient(to top, rgba(17, 24, 39, 0.9), rgba(17, 24, 39, 0.5))'
      }
    },
      // Drawer header with drag handle - dark translucent theme
      // Clicking anywhere on header (except drag handle and Clear) closes drawer
      React.createElement('div', {
        className: 'flex items-center justify-between px-4 py-2 bg-gray-900/60 border-b border-gray-700/50 cursor-pointer hover:bg-gray-800/60 transition-colors',
        onClick: () => setQueueDrawerOpen(false)
      },
        React.createElement('div', {
          className: 'flex items-center gap-3'
        },
          // Drag handle for resizing - stops click propagation
          React.createElement('div', {
            className: 'w-8 h-1 bg-gray-600 rounded-full cursor-ns-resize',
            onClick: (e) => e.stopPropagation(),
            onMouseDown: (e) => {
              e.stopPropagation();
              const startY = e.clientY;
              const startHeight = queueDrawerHeight;

              const handleMouseMove = (moveEvent) => {
                const deltaY = startY - moveEvent.clientY;
                const newHeight = Math.max(200, Math.min(600, startHeight + deltaY));
                setQueueDrawerHeight(newHeight);
              };

              const handleMouseUp = () => {
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
              };

              document.addEventListener('mousemove', handleMouseMove);
              document.addEventListener('mouseup', handleMouseUp);
            }
          }),
          React.createElement('span', {
            className: 'text-sm font-medium text-gray-200'
          }, 'Queue'),
          React.createElement('span', {
            className: 'text-xs text-gray-400'
          }, `${currentQueue.length} track${currentQueue.length !== 1 ? 's' : ''}`)
        ),
        React.createElement('div', {
          className: 'flex items-center gap-2'
        },
          // Save as Playlist button - shows when there's a current track or queue
          (currentTrack || currentQueue.length > 0) && React.createElement('button', {
            onClick: (e) => { e.stopPropagation(); handleSaveQueueAsPlaylist(); },
            className: 'px-3 py-1 text-xs text-gray-400 hover:text-white border border-gray-600 rounded hover:bg-white/10 transition-colors'
          }, 'SAVE'),
          // Clear button
          currentQueue.length > 0 && React.createElement('button', {
            onClick: (e) => { e.stopPropagation(); clearQueue(); },
            className: 'px-3 py-1 text-xs text-gray-400 hover:text-white border border-gray-600 rounded hover:bg-white/10 transition-colors'
          }, 'CLEAR'),
          // Close button
          React.createElement('button', {
            onClick: () => setQueueDrawerOpen(false),
            className: 'flex items-center gap-1 px-3 py-1 text-xs text-gray-400 hover:text-white border border-gray-600 rounded hover:bg-white/10 transition-colors'
          },
            'CLOSE',
            React.createElement('span', { className: 'text-gray-500' }, 'Ã—')
          )
        )
      ),

      // Queue content - dark theme
      React.createElement('div', {
        ref: queueContentRef,
        className: 'overflow-y-auto relative',
        style: { height: (queueDrawerHeight - 44 - (playbackContext ? 32 : 0)) + 'px' },
        onDragEnter: (e) => handleDragEnter(e, 'queue'),
        onDragOver: (e) => handleDragOver(e, 'queue'),
        onDragLeave: handleDragLeave,
        onDrop: (e) => handleDrop(e, 'queue')
      },
        // Drop zone overlay
        React.createElement(DropZoneOverlay, {
          zone: 'queue',
          isActive: isDraggingUrl && dropZoneTarget === 'queue'
        }),
        currentQueue.length === 0 ?
          React.createElement('div', {
            className: 'flex flex-col items-center justify-center h-full text-gray-500'
          },
            React.createElement('svg', { className: 'w-10 h-10 text-gray-300 mb-2', fill: 'currentColor', viewBox: '0 0 24 24' },
              React.createElement('path', { d: 'M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z' })
            ),
            React.createElement('span', { className: 'text-gray-400' }, 'Queue is empty'),
            React.createElement('span', { className: 'text-sm text-gray-500 mt-1' }, 'Play a playlist to add tracks')
          )
        :
          // flex-col-reverse reverses the main axis (bottom to top)
          // justify-start pins items to the START of that axis = BOTTOM of the container
          // min-h-full ensures it fills the container when there's little content
          React.createElement('div', { className: 'flex flex-col-reverse justify-start min-h-full' },
            currentQueue.map((track, index) => {
              const isCurrentTrack = currentTrack?.id === track.id;
              const isLoading = track.status === 'loading';
              const isError = track.status === 'error';
              // Sort by priority order (left to right = highest to lowest priority)
              const availableSources = Object.keys(track.sources || {}).sort((a, b) => {
                const aIndex = resolverOrder.indexOf(a);
                const bIndex = resolverOrder.indexOf(b);
                return aIndex - bIndex;
              });

              const isDraggedOver = queueDropTarget === index;
              const isDragging = draggedQueueTrack === index;
              const isInserted = insertedTrackId === track.id;
              // With flex-col-reverse + justify-start, index 0 is at the bottom (near player)
              // When clicking a track, all tracks at index <= droppingFromIndex fall down into player
              // Remaining tracks (index > droppingFromIndex) stay in place - they'll naturally be
              // at the bottom after state change thanks to flex-col-reverse + justify-start
              const isFallingDown = droppingFromIndex !== null && index <= droppingFromIndex;

              return React.createElement('div', {
                key: track.id,
                draggable: !isLoading && !isError,
                onDragStart: (e) => {
                  if (!isLoading && !isError) {
                    setDraggedQueueTrack(index);
                    setDraggingTrackForPlaylist(track); // Track for potential playlist drop
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', JSON.stringify({ type: 'track', track }));
                  }
                },
                onDragEnd: () => {
                  setDraggedQueueTrack(null);
                  setQueueDropTarget(null);
                  setDraggingTrackForPlaylist(null);
                  setDropTargetPlaylistId(null);
                  setDropTargetNewPlaylist(false);
                  // Close panel if it was opened by drag and nothing was dropped
                  if (addToPlaylistPanel.open && selectedPlaylistsForAdd.length === 0) {
                    setAddToPlaylistPanel(prev => ({ ...prev, open: false }));
                  }
                },
                onDragOver: (e) => {
                  e.preventDefault();
                  e.dataTransfer.dropEffect = 'move';
                  if (draggedQueueTrack !== null && draggedQueueTrack !== index) {
                    setQueueDropTarget(index);
                  }
                },
                onDragLeave: () => {
                  setQueueDropTarget(null);
                },
                onDrop: (e) => {
                  e.preventDefault();
                  if (draggedQueueTrack !== null && draggedQueueTrack !== index) {
                    moveInQueue(draggedQueueTrack, index);
                  }
                  setDraggedQueueTrack(null);
                  setQueueDropTarget(null);
                },
                onContextMenu: (e) => {
                  e.preventDefault();
                  if (!isLoading && !isError && window.electron?.contextMenu?.showTrackMenu) {
                    window.electron.contextMenu.showTrackMenu({
                      type: 'track',
                      track: track
                    });
                  }
                },
                className: `group flex items-center gap-3 py-2 px-3 border-b border-gray-600/30 hover:bg-white/10 transition-all duration-300 ${
                  isCurrentTrack ? 'bg-purple-900/40' : ''
                } ${isDragging ? 'opacity-50 bg-gray-700/50' : ''} ${
                  isError ? 'opacity-50' : ''
                } ${isDraggedOver ? 'border-t-2 border-t-purple-400' : ''} ${
                  isLoading || isError ? '' : 'cursor-grab active:cursor-grabbing'} ${
                  isFallingDown ? 'queue-track-drop' : ''} ${
                  isInserted ? 'queue-track-insert' : ''}`
              },
                // Track number / status indicator - fixed width
                React.createElement('span', {
                  className: 'text-sm text-gray-500 text-right',
                  style: { width: '28px', flexShrink: 0 }
                },
                  isLoading ? React.createElement('span', { className: 'animate-spin inline-block' }, 'â—Œ') :
                  isError ? 'âš ' :
                  isCurrentTrack ? 'â–¶' : String(index + 1).padStart(2, '0')
                ),

                // Track title - flexible column that grows
                // First track gets font-medium to indicate it's next (matches playbar styling)
                React.createElement('span', {
                  className: `text-sm truncate cursor-pointer ${index === 0 ? 'font-medium' : ''} ${
                    isLoading ? 'text-gray-500' :
                    isError ? 'text-red-400' :
                    isCurrentTrack ? 'text-purple-400' : 'text-gray-200 group-hover:text-white'
                  }`,
                  style: { flex: '1 1 0', minWidth: 0 },
                  onClick: () => {
                    if (isLoading || isError) return;
                    // Trigger drop animation for all tracks at index <= clicked index
                    // These tracks will fall down into the player together
                    setDroppingFromIndex(index);
                    // After animation, play the track
                    setTimeout(() => {
                      setCurrentQueue(prev => prev.slice(index + 1));
                      handlePlay(track);
                      setDroppingFromIndex(null);
                    }, 300);
                  }
                },
                  isLoading ? 'Loading...' :
                  isError ? 'Could not load track' :
                  track.title
                ),

                // Artist name - flexible column, clickable
                React.createElement('span', {
                  className: 'text-sm text-gray-400 truncate hover:text-purple-400 hover:underline cursor-pointer transition-colors',
                  style: { flex: '0.7 1 0', minWidth: 0 },
                  onClick: (e) => {
                    e.stopPropagation();
                    if (!isLoading && !isError && track.artist) {
                      fetchArtistData(track.artist);
                    }
                  }
                },
                  isLoading ? `from ${track.sourceDomain || 'unknown'}` :
                  isError ? (track.errorMessage || 'Unknown error') :
                  track.artist
                ),

                // Duration - fixed width column (before resolver icons)
                React.createElement('span', {
                  className: 'text-sm text-gray-500 text-right tabular-nums',
                  style: { width: '50px', flexShrink: 0 }
                }, !isLoading && !isError ? formatTime(track.duration || 0) : ''),

                // Resolver icons - fixed width column (last before remove button)
                React.createElement('div', {
                  className: 'flex items-center gap-1 justify-end',
                  style: { width: '100px', flexShrink: 0, minHeight: '24px' }
                },
                  isError ?
                    React.createElement('button', {
                      onClick: (e) => {
                        e.stopPropagation();
                        if (track.sourceUrl) {
                          removeFromQueue(track.id);
                          handleUrlDrop(track.sourceUrl, 'queue');
                        }
                      },
                      className: 'px-2 py-0.5 text-xs text-gray-400 hover:text-white hover:bg-white/10 rounded transition-colors',
                      title: 'Retry'
                    }, 'â†»')
                  : isLoading ?
                    React.createElement('div', {
                      className: 'flex items-center gap-1'
                    },
                      React.createElement('div', {
                        className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-700 via-gray-600 to-gray-700 bg-[length:200%_100%] animate-shimmer'
                      }),
                      React.createElement('div', {
                        className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-700 via-gray-600 to-gray-700 bg-[length:200%_100%] animate-shimmer',
                        style: { animationDelay: '0.1s' }
                      })
                    )
                  : availableSources.length > 0 ?
                    availableSources.map(resolverId => {
                      const resolver = allResolvers.find(r => r.id === resolverId);
                      if (!resolver) return null;
                      const source = track.sources?.[resolverId];
                      const confidence = source?.confidence || 0;
                      return React.createElement('button', {
                        key: resolverId,
                        onClick: (e) => {
                          e.stopPropagation();
                          handlePlay({ ...track, preferredResolver: resolverId });
                        },
                        className: 'no-drag',
                        style: {
                          width: '24px',
                          height: '24px',
                          borderRadius: '4px',
                          backgroundColor: resolver.color,
                          border: 'none',
                          cursor: 'pointer',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          opacity: confidence > 0.8 ? 1 : 0.6,
                          transition: 'transform 0.1s'
                        },
                        onMouseEnter: (e) => e.currentTarget.style.transform = 'scale(1.1)',
                        onMouseLeave: (e) => e.currentTarget.style.transform = 'scale(1)',
                        title: `Play via ${resolver.name}${confidence ? ` (${Math.round(confidence * 100)}% match)` : ''}`
                      }, React.createElement(ResolverIcon, { resolverId, size: 14 }));
                    })
                  :
                    // Show shimmer skeletons while resolving (match resolver icon size)
                    React.createElement('div', {
                      className: 'flex items-center gap-1'
                    },
                      React.createElement('div', {
                        className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-700 via-gray-600 to-gray-700 bg-[length:200%_100%] animate-shimmer',
                        title: 'Resolving track...'
                      }),
                      React.createElement('div', {
                        className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-700 via-gray-600 to-gray-700 bg-[length:200%_100%] animate-shimmer',
                        style: { animationDelay: '0.1s' }
                      })
                    )
                ),

                // Remove button
                React.createElement('button', {
                  onClick: (e) => {
                    e.stopPropagation();
                    removeFromQueue(track.id);
                  },
                  className: 'flex-shrink-0 p-1 text-gray-500 hover:text-red-400 hover:bg-white/10 rounded transition-colors opacity-0 group-hover:opacity-100',
                  title: isLoading ? 'Cancel' : 'Remove from queue'
                }, React.createElement(X, { size: 14 }))
              );
            })
          )
      ),

      // Playback context banner - shows where playback originated from (at bottom of queue)
      playbackContext && React.createElement('div', {
        className: 'flex items-center justify-between px-4 py-1.5 bg-purple-900/40 border-t border-purple-700/30 cursor-pointer hover:bg-purple-900/50 transition-colors',
        onClick: () => {
          // Navigate to the context source (skip if already on target page)
          if (playbackContext.type === 'playlist' && playbackContext.id) {
            const playlist = playlists.find(p => p.id === playbackContext.id);
            if (playlist) {
              loadPlaylist(playlist); // loadPlaylist has its own "already viewing" check
            }
          } else if (playbackContext.type === 'album' && playbackContext.artist) {
            // handleCollectionAlbumClick has its own "already viewing" check
            handleCollectionAlbumClick({
              title: playbackContext.name,
              artist: playbackContext.artist
            });
          } else if (playbackContext.type === 'search') {
            navigateTo('search'); // navigateTo skips if already on page
          } else if (playbackContext.type === 'library') {
            // Skip if already on library with tracks tab
            if (activeView !== 'library' || collectionTab !== 'tracks') {
              setCollectionTab('tracks');
              navigateTo('library');
            }
          } else if (playbackContext.type === 'recommendations') {
            navigateTo('recommendations');
          } else if (playbackContext.type === 'history') {
            navigateTo('history');
          } else if (playbackContext.type === 'friend') {
            navigateTo('friendHistory');
          } else if (playbackContext.type === 'url' && playbackContext.url) {
            // Open the source URL in the default browser
            window.electron.shell.openExternal(playbackContext.url);
          }
          setQueueDrawerOpen(false);
        },
        title: playbackContext.type === 'url' ? 'Open source page' : 'Go to source'
      },
        React.createElement('div', { className: 'flex items-center gap-2' },
          React.createElement('span', { className: 'text-xs text-purple-300' }, 'Playing from'),
          React.createElement('span', { className: 'text-xs font-medium text-purple-100' },
            playbackContext.type === 'playlist' ? `${playbackContext.name || 'Playlist'}` :
            playbackContext.type === 'album' ? `${playbackContext.name || 'Album'} by ${playbackContext.artist || 'Unknown'}` :
            playbackContext.type === 'search' ? `"${playbackContext.name || 'Search'}"` :
            playbackContext.type === 'library' ? 'Collection' :
            playbackContext.type === 'recommendations' ? 'Recommendations' :
            playbackContext.type === 'history' ? 'History' :
            playbackContext.type === 'friend' ? `${playbackContext.name || 'Friend'}'s ${playbackContext.tab === 'topTracks' ? 'top tracks' : 'recent listens'}` :
            playbackContext.type === 'url' ? playbackContext.name || 'External link' :
            playbackContext.name || 'Unknown'
          )
        ),
        React.createElement('svg', {
          className: 'w-4 h-4 text-purple-400',
          fill: 'none',
          stroke: 'currentColor',
          viewBox: '0 0 24 24'
        },
          playbackContext.type === 'url'
            ? React.createElement('path', {
                strokeLinecap: 'round',
                strokeLinejoin: 'round',
                strokeWidth: 2,
                d: 'M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14'
              })
            : React.createElement('path', {
                strokeLinecap: 'round',
                strokeLinejoin: 'round',
                strokeWidth: 2,
                d: 'M14 5l7 7m0 0l-7 7m7-7H3'
              })
        )
      )
    )
  );
};

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(React.createElement(Parachord));