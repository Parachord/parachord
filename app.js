// Parachord Desktop App - Electron Version
const { useState, useEffect, useRef, useCallback, useMemo } = React;

// Normalize a string for ID generation (must match sync-providers/spotify.js)
const normalizeForId = (str) => {
  return (str || '').toLowerCase().replace(/[^a-z0-9]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
};

// Generate a consistent track ID (must match sync-providers/spotify.js)
const generateTrackId = (artist, title, album) => {
  return `${normalizeForId(artist || 'unknown')}-${normalizeForId(title || 'untitled')}-${normalizeForId(album || 'noalbum')}`;
};

// Generate a consistent album ID (must match sync-providers/spotify.js)
const generateAlbumId = (artist, title) => {
  return `${normalizeForId(artist || 'unknown')}-${normalizeForId(title || 'untitled')}`;
};

// Generate a consistent artist ID (must match sync-providers/spotify.js)
const generateArtistId = (name) => {
  return normalizeForId(name || 'unknown');
};

// Generate a unique hash from a string (for deterministic pattern generation)
const hashString = (str) => {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  return Math.abs(hash);
};

// Generate a unique pattern/gradient for an artist based on their name
// Returns an object with CSS gradient and optional SVG pattern
const generateArtistPattern = (artistName) => {
  const hash = hashString(artistName.toLowerCase());

  // Color palettes - warm, cool, earthy, vibrant, muted - avoiding generic purple/pink
  const palettes = [
    ['#1a1a2e', '#16213e', '#0f3460', '#e94560'], // Deep blue/red
    ['#2d3436', '#636e72', '#b2bec3', '#dfe6e9'], // Slate monochrome
    ['#0c0c0c', '#1c1c1c', '#2d2d2d', '#ff6b35'], // Dark with orange
    ['#1e3a5f', '#3d5a80', '#98c1d9', '#e0fbfc'], // Ocean blues
    ['#2b2d42', '#8d99ae', '#edf2f4', '#ef233c'], // Navy/red
    ['#003049', '#d62828', '#f77f00', '#fcbf49'], // French flag warm
    ['#0a0908', '#22333b', '#eae0d5', '#c6ac8f'], // Coffee tones
    ['#10002b', '#240046', '#3c096c', '#5a189a'], // Deep purple (different from old)
    ['#1b4332', '#2d6a4f', '#40916c', '#52b788'], // Forest green
    ['#212529', '#343a40', '#495057', '#adb5bd'], // Cool gray
    ['#003459', '#007ea7', '#00a8e8', '#ffffff'], // Bright blue
    ['#1d3557', '#457b9d', '#a8dadc', '#f1faee'], // Teal slate
    ['#283618', '#606c38', '#dda15e', '#bc6c25'], // Earth tones
    ['#231942', '#5e548e', '#9f86c0', '#be95c4'], // Lavender depth
    ['#0b090a', '#161a1d', '#660708', '#a4161a'], // Dark red
  ];

  const paletteIndex = hash % palettes.length;
  const palette = palettes[paletteIndex];

  // Different gradient patterns based on hash
  const patternType = (hash >> 4) % 6;
  const angle = ((hash >> 8) % 12) * 30; // 0, 30, 60, ... 330 degrees

  let gradient;
  switch (patternType) {
    case 0: // Linear gradient
      gradient = `linear-gradient(${angle}deg, ${palette[0]} 0%, ${palette[1]} 50%, ${palette[2]} 100%)`;
      break;
    case 1: // Radial gradient
      gradient = `radial-gradient(circle at ${30 + (hash % 40)}% ${30 + ((hash >> 2) % 40)}%, ${palette[2]} 0%, ${palette[1]} 40%, ${palette[0]} 100%)`;
      break;
    case 2: // Diagonal split
      gradient = `linear-gradient(${angle}deg, ${palette[0]} 0%, ${palette[0]} 45%, ${palette[2]} 45%, ${palette[2]} 55%, ${palette[1]} 55%, ${palette[1]} 100%)`;
      break;
    case 3: // Soft radial
      gradient = `radial-gradient(ellipse at ${(hash % 80) + 10}% ${((hash >> 3) % 80) + 10}%, ${palette[3] || palette[2]} 0%, ${palette[1]} 50%, ${palette[0]} 100%)`;
      break;
    case 4: // Corner gradient
      const corners = ['top left', 'top right', 'bottom left', 'bottom right'];
      const corner = corners[(hash >> 6) % 4];
      gradient = `radial-gradient(circle at ${corner}, ${palette[2]} 0%, ${palette[1]} 40%, ${palette[0]} 100%)`;
      break;
    default: // Mesh-like
      gradient = `linear-gradient(${angle}deg, ${palette[0]} 0%, ${palette[1]} 25%, ${palette[2]} 50%, ${palette[1]} 75%, ${palette[0]} 100%)`;
  }

  // Generate initials for overlay
  const initials = artistName.split(' ')
    .map(word => word.charAt(0).toUpperCase())
    .slice(0, 2)
    .join('');

  return {
    gradient,
    initials,
    textColor: palette[3] || palette[2], // Lighter color for text
    accentColor: palette[3] || palette[2]
  };
};

// Global Set to track prefetch in-progress state (on window to survive any reloads)
window._prefetchInProgress = window._prefetchInProgress || new Set();
const prefetchInProgress = window._prefetchInProgress;

// Use lucide-react icons if available, otherwise fallback to emoji
const Icons = typeof lucideReact !== 'undefined' ? lucideReact : {
  Play: () => React.createElement('span', null, 'â–¶'),
  Pause: () => React.createElement('span', null, 'â¸'),
  SkipForward: () => React.createElement('span', null, 'â­'),
  SkipBack: () => React.createElement('span', null, 'â®'),
  Volume2: () => React.createElement('span', null, 'ðŸ”Š'),
  Music: () => React.createElement('span', null, 'â™«'),
  List: ({ size = 24 }) => React.createElement('svg', { width: size, height: size, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2, strokeLinecap: 'round', strokeLinejoin: 'round' },
    React.createElement('line', { x1: 4, y1: 6, x2: 20, y2: 6 }),
    React.createElement('line', { x1: 4, y1: 12, x2: 20, y2: 12 }),
    React.createElement('line', { x1: 4, y1: 18, x2: 20, y2: 18 })
  ),
  Users: () => React.createElement('span', null, 'ðŸ‘¥'),
  Radio: () => React.createElement('span', null, 'ðŸ“»'),
  Heart: () => React.createElement('span', null, 'â™¥'),
  Search: () => React.createElement('span', null, 'ðŸ”'),
  Settings: () => React.createElement('span', null, 'âš™'),
  Plus: () => React.createElement('span', null, '+'),
  X: () => React.createElement('span', null, 'âœ•'),
};

const { Play, Pause, SkipForward, SkipBack, Volume2, Search, List, Settings, Plus, Music, Radio, Users, Heart, X } = Icons;

// Custom PlayTop10Icon - Play button with "10" badge for artist top tracks
const PlayTop10Icon = ({ size = 24, className = '' }) => {
  return React.createElement('svg', {
    width: size,
    height: size,
    viewBox: '0 0 24 24',
    fill: 'none',
    className
  },
    // Play triangle (slightly offset left to make room for badge)
    React.createElement('path', {
      d: 'M6 4.75L17.5 12L6 19.25V4.75Z',
      fill: 'currentColor',
      stroke: 'currentColor',
      strokeWidth: 1.5,
      strokeLinecap: 'round',
      strokeLinejoin: 'round'
    }),
    // Badge circle background
    React.createElement('circle', {
      cx: 19,
      cy: 17,
      r: 6,
      fill: '#10b981'
    }),
    // "10" text in badge
    React.createElement('text', {
      x: 19,
      y: 17,
      textAnchor: 'middle',
      dominantBaseline: 'central',
      fill: 'white',
      fontSize: 7,
      fontWeight: 'bold',
      fontFamily: 'system-ui, -apple-system, sans-serif'
    }, '10')
  );
};

// Custom QueueTop10Icon - Queue/list icon with "10" badge for artist top tracks
const QueueTop10Icon = ({ size = 24, className = '' }) => {
  return React.createElement('svg', {
    width: size,
    height: size,
    viewBox: '0 0 24 24',
    fill: 'none',
    stroke: 'currentColor',
    strokeWidth: 2,
    strokeLinecap: 'round',
    strokeLinejoin: 'round',
    className
  },
    // Queue/list lines
    React.createElement('line', { x1: '8', y1: '6', x2: '18', y2: '6' }),
    React.createElement('line', { x1: '8', y1: '12', x2: '18', y2: '12' }),
    React.createElement('line', { x1: '8', y1: '18', x2: '14', y2: '18' }),
    React.createElement('line', { x1: '3', y1: '6', x2: '3.01', y2: '6' }),
    React.createElement('line', { x1: '3', y1: '12', x2: '3.01', y2: '12' }),
    React.createElement('line', { x1: '3', y1: '18', x2: '3.01', y2: '18' }),
    // Badge circle background (no stroke)
    React.createElement('circle', {
      cx: 19,
      cy: 17,
      r: 5.5,
      fill: '#10b981',
      stroke: 'none'
    }),
    // "10" text in badge
    React.createElement('text', {
      x: 19,
      y: 17,
      textAnchor: 'middle',
      dominantBaseline: 'central',
      fill: 'white',
      fontSize: 6.5,
      fontWeight: 'bold',
      fontFamily: 'system-ui, -apple-system, sans-serif',
      stroke: 'none'
    }, '10')
  );
};

// Resolution scheduler priority levels (lower = higher priority)
const CONTEXT_PRIORITY = {
  queue: 1,
  hover: 2,
  pool: 3,
  page: 4,
  sidebar: 5
};

/**
 * ResolutionScheduler - Manages track resolution across visibility contexts
 *
 * Resolves only imminently-playable tracks based on:
 * 1. Queue (viewport + overscan + playback lookahead)
 * 2. Hover (single hovered track)
 * 3. Pools (spinoff/listen-along next 5)
 * 4. Page (viewport + overscan)
 * 5. Sidebar (visible friend tracks)
 */
class ResolutionScheduler {
  constructor() {
    // Map of contextId -> { type, abortController, visibleTracks }
    this.contexts = new Map();

    // Map of trackKey -> { contextId, data, abortController, priority }
    this.pending = new Map();

    // Set of trackKeys currently being resolved
    this.inProgress = new Set();

    // Set of trackKeys that have been successfully resolved (to avoid re-resolution)
    this.resolved = new Set();

    // Currently hovered track
    this.hoverTrack = null;

    // Processing state
    this.isProcessing = false;
    this.resolveCallback = null;
  }

  /**
   * Set the resolve callback function
   * @param {Function} callback - (trackData, signal) => Promise
   */
  setResolveCallback(callback) {
    this.resolveCallback = callback;
  }

  /**
   * Register a visibility context
   * @param {string} id - Unique context ID
   * @param {'queue'|'pool'|'page'|'sidebar'} type - Context type
   * @param {object} options - Context options
   * @param {number} options.playbackLookahead - Number of tracks ahead to keep resolved
   */
  registerContext(id, type, options = {}) {
    if (!CONTEXT_PRIORITY[type]) {
      throw new Error(`Invalid context type: ${type}`);
    }

    this.contexts.set(id, {
      type,
      abortController: new AbortController(),
      visibleTracks: new Set(),
      playbackLookahead: options.playbackLookahead || 0,
      playbackIndex: 0
    });
  }

  /**
   * Unregister a context and abort its pending tracks
   * @param {string} id - Context ID
   */
  unregisterContext(id) {
    const context = this.contexts.get(id);
    if (!context) return;

    // Abort all tracks in this context
    this.abortContext(id);

    this.contexts.delete(id);
  }

  /**
   * Check if a context exists
   * @param {string} id - Context ID
   * @returns {boolean}
   */
  hasContext(id) {
    return this.contexts.has(id);
  }

  /**
   * Update which tracks are visible in a context
   * @param {string} contextId - Context ID
   * @param {Array<{key: string, data: object}>} visibleTracks - Currently visible tracks
   */
  updateVisibility(contextId, visibleTracks) {
    const context = this.contexts.get(contextId);
    if (!context) return;

    const newVisibleKeys = new Set(visibleTracks.map(t => t.key));
    const oldVisibleKeys = context.visibleTracks;

    // Abort tracks that scrolled out of view
    for (const key of oldVisibleKeys) {
      if (!newVisibleKeys.has(key)) {
        this.abort(key);
      }
    }

    // Enqueue new visible tracks
    for (const track of visibleTracks) {
      if (!oldVisibleKeys.has(track.key) && !this.pending.has(track.key)) {
        this.enqueue(track.key, contextId, track.data);
      }
    }

    context.visibleTracks = newVisibleKeys;
  }

  /**
   * Enqueue a track for resolution
   * @param {string} trackKey - Unique track key
   * @param {string} contextId - Context ID
   * @param {object} data - Track data
   */
  enqueue(trackKey, contextId, data) {
    if (this.pending.has(trackKey)) return; // Already pending
    if (this.resolved.has(trackKey)) return; // Already resolved

    const context = this.contexts.get(contextId);
    if (!context) return;

    const priority = CONTEXT_PRIORITY[context.type];

    this.pending.set(trackKey, {
      contextId,
      data,
      priority,
      abortController: new AbortController()
    });

    // Start processing if not already
    this._maybeProcess();
  }

  /**
   * Set the currently hovered track (promotes to priority 2)
   * @param {string} trackKey - Track key
   * @param {string} contextId - Context ID
   */
  setHoverTrack(trackKey, contextId) {
    this.hoverTrack = { trackKey, contextId };
  }

  /**
   * Clear the hover track
   */
  clearHoverTrack() {
    this.hoverTrack = null;
  }

  /**
   * Peek at the next track to resolve (highest priority)
   * @returns {object|null}
   */
  peekNext() {
    let best = null;
    let bestPriority = Infinity;

    for (const [trackKey, entry] of this.pending) {
      let priority = entry.priority;
      let isHover = false;

      // Check if this is the hover track
      if (this.hoverTrack?.trackKey === trackKey) {
        priority = CONTEXT_PRIORITY.hover;
        isHover = true;
      }

      if (priority < bestPriority) {
        bestPriority = priority;
        best = { trackKey, ...entry, isHover };
      }
    }

    return best;
  }

  /**
   * Dequeue a track (mark as no longer pending)
   * @param {string} trackKey - Track key
   */
  dequeue(trackKey) {
    const entry = this.pending.get(trackKey);
    if (entry) {
      this.pending.delete(trackKey);
      this.inProgress.delete(trackKey);

      // Remove from context's visible set
      const context = this.contexts.get(entry.contextId);
      if (context) {
        context.visibleTracks.delete(trackKey);
      }
    }
  }

  /**
   * Get abort signal for a track
   * @param {string} trackKey - Track key
   * @returns {AbortSignal|null}
   */
  getAbortSignal(trackKey) {
    const entry = this.pending.get(trackKey);
    return entry?.abortController.signal || null;
  }

  /**
   * Abort a specific track's resolution
   * @param {string} trackKey - Track key
   */
  abort(trackKey) {
    const entry = this.pending.get(trackKey);
    if (entry) {
      entry.abortController.abort();
      this.pending.delete(trackKey);
      this.inProgress.delete(trackKey);
    }

    // Clear hover if this was the hover track
    if (this.hoverTrack?.trackKey === trackKey) {
      this.hoverTrack = null;
    }
  }

  /**
   * Abort all pending tracks in a context
   * @param {string} contextId - Context ID
   * @param {object} options - Options
   * @param {boolean} options.afterCurrentBatch - If true, preserve in-progress tracks
   */
  abortContext(contextId, options = {}) {
    const { afterCurrentBatch = false } = options;
    const context = this.contexts.get(contextId);
    if (!context) return;

    // Abort context-level controller
    context.abortController.abort();

    // Abort all tracks in this context (except in-progress if afterCurrentBatch)
    for (const [trackKey, entry] of this.pending) {
      if (entry.contextId === contextId) {
        if (afterCurrentBatch && this.inProgress.has(trackKey)) {
          continue; // Preserve in-progress track
        }
        entry.abortController.abort();
        this.pending.delete(trackKey);
      }
    }

    context.visibleTracks.clear();

    // Create new controller for future use
    context.abortController = new AbortController();
  }

  /**
   * Check if a track is pending resolution
   * @param {string} trackKey - Track key
   * @returns {boolean}
   */
  hasPending(trackKey) {
    return this.pending.has(trackKey);
  }

  /**
   * Get count of pending tracks
   * @returns {number}
   */
  getPendingCount() {
    return this.pending.size;
  }

  /**
   * Mark a track as in-progress (currently being resolved)
   * @param {string} trackKey - Track key
   */
  markInProgress(trackKey) {
    if (this.pending.has(trackKey)) {
      this.inProgress.add(trackKey);
    }
  }

  /**
   * Get count of in-progress tracks
   * @returns {number}
   */
  getInProgressCount() {
    return this.inProgress.size;
  }

  /**
   * Set the current playback index for a context
   * @param {string} contextId - Context ID
   * @param {number} index - Current playback index
   */
  setPlaybackIndex(contextId, index) {
    const context = this.contexts.get(contextId);
    if (context) {
      context.playbackIndex = index;
    }
  }

  /**
   * Get the playback lookahead range for a context
   * @param {string} contextId - Context ID
   * @returns {{start: number, end: number}|null}
   */
  getPlaybackLookaheadRange(contextId) {
    const context = this.contexts.get(contextId);
    if (!context || !context.playbackLookahead) return null;

    return {
      start: context.playbackIndex,
      end: context.playbackIndex + context.playbackLookahead
    };
  }

  /**
   * Check if an index is within the playback lookahead range
   * @param {string} contextId - Context ID
   * @param {number} index - Index to check
   * @returns {boolean}
   */
  isInPlaybackLookahead(contextId, index) {
    const range = this.getPlaybackLookaheadRange(contextId);
    if (!range) return false;

    return index >= range.start && index < range.end;
  }

  /**
   * Start processing if not already
   * @private
   */
  _maybeProcess() {
    if (this.isProcessing || !this.resolveCallback) return;
    this._processNext();
  }

  /**
   * Process the next track in the queue
   * @private
   */
  async _processNext() {
    const next = this.peekNext();
    if (!next) {
      this.isProcessing = false;
      return;
    }

    this.isProcessing = true;
    const { trackKey, data, abortController } = next;

    // Mark this track as in-progress before resolving
    this.markInProgress(trackKey);

    try {
      // Check if still visible before resolving
      if (!this.pending.has(trackKey)) {
        // Already aborted, move on
        this._processNext();
        return;
      }

      await this.resolveCallback(data, abortController.signal);

      // Mark as resolved so we don't re-resolve on future visibility updates
      this.resolved.add(trackKey);

      // Remove from pending after successful resolution
      this.dequeue(trackKey);
    } catch (error) {
      if (error.name !== 'AbortError') {
        console.error(`Resolution error for ${trackKey}:`, error);
      }
      // Don't add to resolved on error - allow retry
      this.dequeue(trackKey);
    }

    // Rate limit: 150ms between resolutions
    await new Promise(resolve => setTimeout(resolve, 150));

    this._processNext();
  }
}

// Function to sync plugins with marketplace (runs in background)
const syncPluginsWithMarketplace = async () => {
  if (window.electron?.resolvers?.syncMarketplace) {
    console.log('ðŸ”„ Syncing plugins with marketplace...');
    try {
      const result = await window.electron.resolvers.syncMarketplace();
      if (result.success) {
        const { added, updated, failed } = result;
        if (added.length > 0 || updated.length > 0) {
          console.log(`âœ… Plugin sync complete: ${added.length} added, ${updated.length} updated`);
          // Reload plugins after sync if there were changes
          return true; // Signal that plugins were updated
        }
        console.log('âœ… All plugins up to date');
      } else {
        console.log('âš ï¸ Plugin sync failed (offline?):', result.error);
      }
    } catch (error) {
      console.error('âš ï¸ Plugin sync error:', error);
    }
  }
  return false;
};

// Function to load plugins from cache
const loadBuiltinResolvers = async () => {
  // Check if we're in Electron
  if (window.electron?.resolvers?.loadBuiltin) {
    console.log('ðŸ“ Loading plugins from cache...');
    try {
      // First sync with marketplace (in background, don't block)
      syncPluginsWithMarketplace().then(async (pluginsUpdated) => {
        if (pluginsUpdated) {
          // Plugins were updated, notify user they may want to restart
          console.log('ðŸ”„ New plugin versions available - restart app to use them');
        }
      });

      // Load cached plugins immediately
      const resolvers = await window.electron.resolvers.loadBuiltin();
      return resolvers;
    } catch (error) {
      console.error('âŒ Failed to load plugins:', error);
      return [];
    }
  } else {
    // Fallback for web/dev environment - try fetch
    console.log('ðŸ“ Loading resolvers via fetch (web mode)...');
    const resolverFiles = [
      'resolvers/builtin/spotify.axe',
      'resolvers/builtin/bandcamp.axe',
      'resolvers/builtin/qobuz.axe'
    ];
    
    const resolvers = [];
    
    for (const file of resolverFiles) {
      try {
        const response = await fetch(file);
        if (!response.ok) {
          console.error(`âŒ Failed to load ${file}: ${response.status}`);
          continue;
        }
        const axe = await response.json();
        resolvers.push(axe);
        console.log(`âœ… Loaded ${axe.manifest.name} resolver from ${file}`);
      } catch (error) {
        console.error(`âŒ Error loading ${file}:`, error);
      }
    }
    
    return resolvers;
  }
};

// Fallback embedded resolvers (used if .axe files can't be loaded)
const FALLBACK_RESOLVERS = [
  {"manifest":{"id":"spotify","name":"Spotify","version":"1.0.0","author":"Parachord Team","description":"Stream from Spotify via Spotify Connect API. Requires Spotify Premium for remote playback.","icon":"â™«","color":"#1DB954","homepage":"https://spotify.com","email":"support@harmonix.app"},"capabilities":{"resolve":true,"search":true,"stream":true,"browse":false,"urlLookup":false},"settings":{"requiresAuth":true,"authType":"oauth","scopes":["user-read-playback-state","user-modify-playback-state","user-read-currently-playing"],"configurable":{"clientId":{"type":"text","label":"Client ID","default":"c040c0ee133344b282e6342198bcbeea","readonly":true}}},"implementation":{"search":"async function(query, config) { if (!config.token) return []; try { const response = await fetch(`https://api.spotify.com/v1/search?q=${encodeURIComponent(query)}&type=track&limit=20`, { headers: { 'Authorization': `Bearer ${config.token}` } }); if (!response.ok) { console.error('Spotify search failed:', response.status); return []; } const data = await response.json(); return data.tracks.items.map(track => ({ id: `spotify-${track.id}`, title: track.name, artist: track.artists.map(a => a.name).join(', '), album: track.album.name, duration: Math.floor(track.duration_ms / 1000), sources: ['spotify'], spotifyUri: track.uri, spotifyId: track.id, albumArt: track.album.images[0]?.url })); } catch (error) { console.error('Spotify search error:', error); return []; } }","resolve":"async function(artist, track, album, config) { const query = `artist:${artist} track:${track}`; const results = await this.search(query, config); return results[0] || null; }","play":"async function(track, config) { if (!config.token) { console.error('Spotify not connected'); return false; } try { const devicesResponse = await fetch('https://api.spotify.com/v1/me/player/devices', { headers: { 'Authorization': `Bearer ${config.token}` } }); if (!devicesResponse.ok) return false; const devicesData = await devicesResponse.json(); const devices = devicesData.devices || []; if (devices.length === 0) { console.error('No Spotify devices found'); return false; } const controllable = devices.filter(d => !d.is_restricted); const available = controllable.length > 0 ? controllable : devices; const computer = available.find(d => d.type === 'Computer'); const phone = available.find(d => d.type === 'Smartphone'); const speaker = available.find(d => d.type === 'Speaker'); const nonWebActive = available.find(d => d.is_active && !d.name.toLowerCase().includes('web')); const nonWeb = available.find(d => !d.name.toLowerCase().includes('web')); let activeDevice = computer || phone || speaker || nonWebActive || nonWeb || available[0]; console.log('Selected device:', activeDevice.name, activeDevice.type); if (!activeDevice.is_active) { const transferResponse = await fetch('https://api.spotify.com/v1/me/player', { method: 'PUT', headers: { 'Authorization': `Bearer ${config.token}`, 'Content-Type': 'application/json' }, body: JSON.stringify({ device_ids: [activeDevice.id], play: true }) }); if (!transferResponse.ok && transferResponse.status !== 204) { console.error('Failed to transfer playback'); } await new Promise(resolve => setTimeout(resolve, 1000)); } const playResponse = await fetch(`https://api.spotify.com/v1/me/player/play?device_id=${activeDevice.id}`, { method: 'PUT', headers: { 'Authorization': `Bearer ${config.token}`, 'Content-Type': 'application/json' }, body: JSON.stringify({ uris: [track.spotifyUri] }) }); return playResponse.ok || playResponse.status === 204; } catch (error) { console.error('Spotify play error:', error); return false; } }","init":"async function(config) { console.log('Spotify resolver initialized'); }","cleanup":"async function() { console.log('Spotify resolver cleanup'); }"}},
  {"manifest":{"id":"bandcamp","name":"Bandcamp","version":"1.0.0","author":"Parachord Team","description":"Find and purchase music on Bandcamp. Opens tracks in browser for streaming.","icon":"ðŸŽ¸","color":"#629AA9","homepage":"https://bandcamp.com","email":"support@harmonix.app"},"capabilities":{"resolve":true,"search":true,"stream":false,"browse":false,"urlLookup":true},"settings":{"requiresAuth":false,"authType":"none","configurable":{}},"implementation":{"search":"async function(query, config) { try { console.log('Searching Bandcamp for:', query); const response = await fetch(`https://bandcamp.com/search?q=${encodeURIComponent(query)}&item_type=t`, { method: 'GET', headers: { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36' } }); if (!response.ok) { console.error('Bandcamp search failed:', response.status); return []; } const html = await response.text(); const results = []; const parser = new DOMParser(); const doc = parser.parseFromString(html, 'text/html'); const searchResults = doc.querySelectorAll('.searchresult'); searchResults.forEach((item, index) => { if (index >= 20) return; try { const heading = item.querySelector('.heading'); const subhead = item.querySelector('.subhead'); const itemUrl = item.querySelector('.itemurl'); if (heading && itemUrl) { const title = heading.textContent.trim(); const artistInfo = subhead ? subhead.textContent.trim() : 'Unknown Artist'; const byMatch = artistInfo.match(/by\\\\s+([^,]+)/); const fromMatch = artistInfo.match(/from\\\\s+(.+)/); const artist = byMatch ? byMatch[1].trim() : 'Unknown Artist'; const album = fromMatch ? fromMatch[1].trim() : (byMatch ? byMatch[1].trim() : 'Single'); const url = itemUrl.textContent.trim(); results.push({ id: `bandcamp-${Date.now()}-${index}`, title: title, artist: artist, album: album, duration: 210, sources: ['bandcamp'], bandcampUrl: url }); } } catch (itemError) { console.error('Error parsing Bandcamp result:', itemError); } }); console.log(`Found ${results.length} Bandcamp results`); return results; } catch (error) { console.error('Bandcamp search error:', error); return []; } }","resolve":"async function(artist, track, album, config) { const query = `${artist} ${track}`; const results = await this.search(query, config); return results[0] || null; }","play":"async function(track, config) { if (!track.bandcampUrl) { console.error('No Bandcamp URL found'); return false; } try { if (window.electron?.shell?.openExternal) { const result = await window.electron.shell.openExternal(track.bandcampUrl); return result && result.success; } else { const newWindow = window.open(track.bandcampUrl, '_blank'); return !!newWindow; } } catch (error) { console.error('Failed to open Bandcamp link:', error); return false; } }","init":"async function(config) { console.log('Bandcamp resolver initialized'); }","cleanup":"async function() { console.log('Bandcamp resolver cleanup'); }"}},
  {"manifest":{"id":"qobuz","name":"Qobuz","version":"1.0.0","author":"Parachord Team","description":"High-quality audio streaming with 30-second previews. Subscription required for full playback.","icon":"ðŸŽµ","color":"#0E7EBF","homepage":"https://qobuz.com","email":"support@harmonix.app"},"capabilities":{"resolve":true,"search":true,"stream":true,"browse":false,"urlLookup":false},"settings":{"requiresAuth":false,"authType":"apikey","configurable":{"appId":{"type":"text","label":"App ID","default":"285473059","readonly":true,"description":"Public demo app ID"}}},"implementation":{"search":"async function(query, config) { try { console.log('Searching Qobuz for:', query); const appId = config.appId || '285473059'; const response = await fetch(`https://www.qobuz.com/api.json/0.2/track/search?query=${encodeURIComponent(query)}&limit=20&app_id=${appId}`, { headers: { 'User-Agent': 'Parachord/1.0.0' } }); if (!response.ok) { console.error('Qobuz search failed:', response.status); return []; } const data = await response.json(); if (!data.tracks || !data.tracks.items) { console.log('No Qobuz results found'); return []; } const results = data.tracks.items.map(track => ({ id: `qobuz-${track.id}`, title: track.title, artist: track.performer?.name || track.album?.artist?.name || 'Unknown Artist', album: track.album?.title || 'Unknown Album', duration: track.duration || 180, sources: ['qobuz'], qobuzId: track.id, albumArt: track.album?.image?.small || track.album?.image?.thumbnail, previewUrl: track.preview_url, streamable: track.streamable, quality: track.maximum_bit_depth ? `${track.maximum_bit_depth}bit/${track.maximum_sampling_rate}kHz` : 'CD Quality' })); console.log(`Found ${results.length} Qobuz results`); return results; } catch (error) { console.error('Qobuz search error:', error); return []; } }","resolve":"async function(artist, track, album, config) { const query = `${artist} ${track}`; const results = await this.search(query, config); return results[0] || null; }","play":"async function(track, config) { if (!track.previewUrl) { console.error('No Qobuz preview URL'); return false; } try { const audio = new Audio(track.previewUrl); audio.volume = config.volume || 0.7; await audio.play(); console.log('Playing Qobuz 30-second preview'); return true; } catch (error) { console.error('Failed to play Qobuz preview:', error); return false; } }","init":"async function(config) { console.log('Qobuz resolver initialized'); }","cleanup":"async function() { console.log('Qobuz resolver cleanup'); }"}},
];


// Tooltip component - reusable tooltip with Cinematic Light styling
// position: 'top' | 'bottom' | 'left' | 'right'
// variant: 'light' | 'dark' (dark variant for dark backgrounds)
// className: additional CSS classes (e.g., 'tooltip-bio' for bio tooltips)
const Tooltip = ({ children, content, position = 'top', variant = 'light', className = '' }) => {
  return React.createElement('div', {
    className: `tooltip-container ${variant === 'dark' ? 'tooltip-dark' : ''} ${className}`.trim()
  },
    children,
    React.createElement('span', {
      className: `tooltip-content tooltip-${position}`
    }, content)
  );
};

// TrackRow component - defined outside to prevent recreation on every render
const TrackRow = React.memo(({ track, isPlaying, handlePlay, onArtistClick, onContextMenu, allResolvers, resolverOrder, activeResolvers }) => {
  // Get available sources (track.sources is an object with resolver IDs as keys)
  // Sort by priority order (left to right = highest to lowest priority)
  const availableSources = track.sources && typeof track.sources === 'object' && !Array.isArray(track.sources)
    ? Object.keys(track.sources).sort((a, b) => {
        const aIndex = resolverOrder?.indexOf(a) ?? 999;
        const bIndex = resolverOrder?.indexOf(b) ?? 999;
        return aIndex - bIndex;
      })
    : [];

  // Resolver metadata for badge display
  const resolverMeta = {
    spotify: { label: 'Spotify', bgColor: 'bg-green-600/20', textColor: 'text-green-400' },
    youtube: { label: 'YouTube', bgColor: 'bg-red-600/20', textColor: 'text-red-400' },
    bandcamp: { label: 'Bandcamp', bgColor: 'bg-cyan-600/20', textColor: 'text-cyan-400' },
    qobuz: { label: 'Qobuz', bgColor: 'bg-blue-600/20', textColor: 'text-blue-400' }
  };

  // Determine which resolver will be used (based on priority)
  const getPrimaryResolver = () => {
    if (!availableSources.length || !resolverOrder || !activeResolvers || !allResolvers) return null;

    const sortedSources = availableSources
      .map(resId => ({
        resolverId: resId,
        priority: resolverOrder.indexOf(resId)
      }))
      .filter(s => activeResolvers.includes(s.resolverId))
      .sort((a, b) => a.priority - b.priority);

    if (sortedSources.length === 0) return null;

    const primaryResolverId = sortedSources[0].resolverId;
    return allResolvers.find(r => r.id === primaryResolverId);
  };

  const primaryResolver = getPrimaryResolver();

  return React.createElement('div', {
    className: 'group flex items-center gap-4 p-3 rounded-lg hover:bg-gray-100 transition-colors no-drag',
    onContextMenu: (e) => {
      e.preventDefault();
      if (onContextMenu) {
        onContextMenu(track);
      }
    }
  },
    // Album art or play button
    React.createElement('div', { className: 'relative w-12 h-12 flex-shrink-0' },
      React.createElement('div', {
        className: 'w-12 h-12 bg-gradient-to-br from-purple-500 to-pink-500 rounded flex items-center justify-center overflow-hidden'
      },
        track.albumArt && React.createElement('img', {
          src: track.albumArt,
          alt: track.album,
          className: 'absolute inset-0 w-full h-full object-cover transition-opacity duration-300',
          style: { opacity: 0 },
          ref: (el) => { if (el && el.complete && el.naturalWidth > 0) el.style.opacity = '1'; },
          onLoad: (e) => { e.target.style.opacity = '1'; },
          onError: (e) => { e.target.style.display = 'none'; }
        }),
        React.createElement(Music)
      ),
      React.createElement('button', {
        onClick: () => handlePlay(track),
        className: 'absolute inset-0 flex items-center justify-center rounded bg-black/60 opacity-0 group-hover:opacity-100 transition-opacity'
      },
        React.createElement('div', { className: 'w-8 h-8 flex items-center justify-center rounded-full bg-purple-600 text-sm' },
          isPlaying ? React.createElement(Pause) : React.createElement(Play)
        )
      )
    ),
    React.createElement('div', { className: 'flex-1 min-w-0' },
      React.createElement('div', { className: `text-xs font-medium truncate ${isPlaying ? 'text-purple-600' : 'text-gray-900'}` }, track.title),
      React.createElement('div', { className: 'flex items-center gap-2' },
        React.createElement('button', {
          onClick: (e) => {
            e.stopPropagation();
            if (onArtistClick) {
              onArtistClick(track.artist);
            }
          },
          className: 'text-xs text-gray-500 truncate hover:text-purple-600 hover:underline cursor-pointer transition-colors',
          title: `View ${track.artist}'s discography`
        }, track.artist),
        // Resolver badges - clickable for manual override
        ...availableSources.map(resolverId => {
          const meta = resolverMeta[resolverId];
          if (!meta) return null;

          return React.createElement('button', {
            key: resolverId,
            onClick: (e) => {
              e.stopPropagation();
              // Play from this specific resolver
              handlePlay(track.sources[resolverId]);
            },
            className: `text-xs px-2 py-0.5 ${meta.bgColor} ${meta.textColor} rounded-full hover:opacity-80 transition-opacity cursor-pointer`,
            title: `Play from ${meta.label} (manual override)`
          }, meta.label);
        })
      ),
      primaryResolver && React.createElement('div', { className: 'text-xs text-gray-400 mt-0.5' }, `via ${primaryResolver.name}`)
    ),
    React.createElement('div', { className: 'text-xs text-gray-500 truncate max-w-[200px]' }, track.album),
    React.createElement('div', { className: 'text-xs text-gray-500 w-12 text-right' },
      `${Math.floor(track.duration / 60)}:${(track.duration % 60).toString().padStart(2, '0')}`
    )
  );
});

// Service logo SVG paths - reusable for different sizes
const SERVICE_LOGO_PATHS = {
  spotify: 'M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.419 1.56-.299.421-1.02.599-1.559.3z',
  bandcamp: 'M0 18.75l7.437-13.5H24l-7.438 13.5H0z',
  qobuz: 'M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 14.5c-2.49 0-4.5-2.01-4.5-4.5S9.51 7.5 12 7.5s4.5 2.01 4.5 4.5-2.01 4.5-4.5 4.5zm0-7c-1.38 0-2.5 1.12-2.5 2.5s1.12 2.5 2.5 2.5 2.5-1.12 2.5-2.5-1.12-2.5-2.5-2.5z',
  youtube: 'M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z',
  localfiles: 'M20 6h-8l-2-2H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm-6 10h-4v-4H8l4-4 4 4h-2v4z',
  applemusic: 'M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z',
  wikipedia: 'M12.09 13.119c-.936 1.932-2.217 4.548-2.853 5.728-.616 1.074-1.127.931-1.532.029-1.406-3.321-4.293-9.144-5.651-12.409-.251-.601-.441-.987-.619-1.139-.181-.15-.554-.24-1.122-.271C.103 5.033 0 4.982 0 4.898v-.455l.052-.045c.924-.005 5.401 0 5.401 0l.051.045v.434c0 .119-.075.176-.225.176l-.564.031c-.485.029-.727.164-.727.436 0 .135.053.33.166.601 1.082 2.646 4.818 10.521 4.818 10.521l2.681-5.476-2.607-5.24c-.237-.477-.42-.752-.545-.825-.126-.073-.437-.123-.934-.147l-.356-.022c-.152 0-.228-.053-.228-.166v-.457c0-.119.085-.17.253-.15l4.834.045.042.045v.447c0 .119-.07.176-.212.176l-.453.022c-.454.022-.681.155-.681.4 0 .106.043.274.133.502l2.008 4.097 1.905-3.971c.09-.183.137-.38.137-.597 0-.243-.233-.383-.7-.424l-.453-.022c-.152 0-.228-.058-.228-.176v-.457c0-.085.058-.134.176-.15l4.063-.045.042.045v.457c0 .106-.07.164-.212.164l-.534.031c-.391.022-.681.142-.863.36-.182.218-.404.573-.668 1.068l-2.388 4.786 2.715 5.455s3.767-7.894 4.916-10.442c.15-.326.223-.586.223-.78 0-.263-.233-.405-.7-.427l-.534-.022c-.152 0-.228-.058-.228-.176v-.457c0-.085.058-.129.176-.129h4.863l.033.045v.457c0 .106-.07.164-.212.164-.609.014-1.055.089-1.34.22-.285.133-.542.398-.767.792-.346.6-4.608 9.075-5.906 11.667-.377.755-.882.939-1.268.047-.54-1.254-2.7-5.471-2.7-5.471l-2.625 5.42c-.27.549-.748.704-1.14.013-.54-1.125-2.841-5.773-2.841-5.773z',
  discogs: 'M12 0C5.372 0 0 5.372 0 12s5.372 12 12 12 12-5.372 12-12S18.628 0 12 0zm0 21.6c-5.304 0-9.6-4.296-9.6-9.6S6.696 2.4 12 2.4s9.6 4.296 9.6 9.6-4.296 9.6-9.6 9.6zm0-16.8c-3.972 0-7.2 3.228-7.2 7.2s3.228 7.2 7.2 7.2 7.2-3.228 7.2-7.2-3.228-7.2-7.2-7.2zm0 12c-2.652 0-4.8-2.148-4.8-4.8s2.148-4.8 4.8-4.8 4.8 2.148 4.8 4.8-2.148 4.8-4.8 4.8zm0-7.2c-1.326 0-2.4 1.074-2.4 2.4s1.074 2.4 2.4 2.4 2.4-1.074 2.4-2.4-1.074-2.4-2.4-2.4z'
};

// Helper to create resolver icon at any size
const ResolverIcon = ({ resolverId, size = 14, fill = 'white' }) => {
  const path = SERVICE_LOGO_PATHS[resolverId];
  if (!path) return null;
  return React.createElement('svg', {
    viewBox: '0 0 24 24',
    width: size,
    height: size,
    fill: fill,
    style: { flexShrink: 0 }
  }, React.createElement('path', { d: path }));
};

// Service logo SVGs - white versions for colored backgrounds
const SERVICE_LOGOS = {
  spotify: React.createElement('svg', { viewBox: '0 0 24 24', className: 'w-16 h-16', fill: 'white' },
    React.createElement('path', { d: 'M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.419 1.56-.299.421-1.02.599-1.559.3z' })
  ),
  bandcamp: React.createElement('svg', { viewBox: '0 0 24 24', className: 'w-16 h-16', fill: 'white' },
    React.createElement('path', { d: 'M0 18.75l7.437-13.5H24l-7.438 13.5H0z' })
  ),
  qobuz: React.createElement('svg', { viewBox: '0 0 24 24', className: 'w-16 h-16', fill: 'white' },
    React.createElement('path', { d: 'M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 14.5c-2.49 0-4.5-2.01-4.5-4.5S9.51 7.5 12 7.5s4.5 2.01 4.5 4.5-2.01 4.5-4.5 4.5zm0-7c-1.38 0-2.5 1.12-2.5 2.5s1.12 2.5 2.5 2.5 2.5-1.12 2.5-2.5-1.12-2.5-2.5-2.5z' })
  ),
  youtube: React.createElement('svg', { viewBox: '0 0 24 24', className: 'w-16 h-16', fill: 'white' },
    React.createElement('path', { d: 'M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z' })
  ),
  soundcloud: React.createElement('svg', { viewBox: '0 0 24 24', className: 'w-16 h-16', fill: 'white' },
    React.createElement('path', { d: 'M1.175 12.225c-.051 0-.094.046-.101.1l-.233 2.154.233 2.105c.007.058.05.098.101.098.05 0 .09-.04.099-.098l.255-2.105-.27-2.154c-.009-.06-.052-.1-.084-.1zm-.899.828c-.06 0-.091.037-.104.094L0 14.479l.165 1.308c.014.057.045.094.09.094.049 0 .084-.037.09-.094l.195-1.308-.196-1.332c-.006-.057-.04-.094-.068-.094zm1.83-1.229c-.06 0-.12.037-.12.1l-.21 2.563.225 2.458c0 .06.045.1.105.1.074 0 .12-.04.12-.1l.24-2.458-.24-2.563c0-.06-.03-.1-.12-.1zm.945-.089c-.075 0-.135.045-.15.105l-.18 2.647.18 2.456c.015.06.075.105.15.105.075 0 .135-.045.15-.105l.21-2.456-.21-2.647c-.015-.06-.075-.105-.15-.105zm1.065.285c-.09 0-.15.045-.165.105l-.15 2.382.15 2.423c.015.075.075.12.165.12.09 0 .15-.045.165-.12l.18-2.423-.195-2.382c-.015-.06-.06-.105-.15-.105zm1.08-1.5c-.09 0-.18.06-.18.135l-.15 3.762.15 2.4c0 .09.09.149.18.149.09 0 .165-.06.18-.135l.165-2.414-.165-3.762c-.015-.09-.09-.135-.18-.135zm1.05-.706c-.105 0-.195.075-.195.165l-.12 4.333.12 2.37c0 .09.09.165.195.165.09 0 .18-.075.195-.165l.135-2.37-.135-4.333c-.015-.09-.09-.165-.195-.165zm1.14-.255c-.105 0-.21.075-.21.165l-.105 4.59.105 2.34c.015.09.105.165.21.165.105 0 .195-.075.21-.165l.12-2.355-.12-4.575c0-.09-.09-.165-.21-.165zm1.11-.165c-.12 0-.225.09-.225.18l-.09 4.74.09 2.31c.015.105.105.18.225.18.12 0 .21-.075.225-.18l.105-2.31-.105-4.74c-.015-.09-.105-.18-.225-.18zm1.17-.225c-.135 0-.24.09-.24.195l-.075 4.785.075 2.28c0 .12.105.21.24.21.12 0 .225-.09.24-.21l.09-2.28-.09-4.785c-.015-.105-.12-.195-.24-.195zm1.2.045c-.135 0-.255.105-.255.21l-.06 4.545.06 2.25c.015.12.12.21.255.21.15 0 .255-.09.27-.21l.075-2.25-.075-4.545c-.015-.105-.12-.21-.27-.21zm1.2.375c-.15 0-.27.105-.285.225l-.045 4.17.045 2.22c.015.12.135.225.285.225.135 0 .27-.105.27-.225l.06-2.22-.06-4.17c0-.12-.12-.225-.27-.225zm3.98-1.62c-.36 0-.705.06-1.035.18-.21-2.37-2.19-4.215-4.59-4.215-.615 0-1.2.135-1.725.36-.195.09-.255.18-.255.36v8.94c0 .18.15.345.33.36h7.275c1.665 0 3.015-1.35 3.015-3.015 0-1.665-1.35-3.015-3.015-3.015v.045z' })
  ),
  applemusic: React.createElement('svg', { viewBox: '0 0 361 361', className: 'w-16 h-16', fill: 'white' },
    React.createElement('path', { d: 'M263.54,234.26c0,4.56-0.04,8.7-1,13.26c-0.93,4.43-2.63,8.6-5.24,12.35c-2.61,3.74-5.95,6.81-9.85,9.11c-3.95,2.33-8.08,3.66-12.5,4.55c-8.3,1.67-13.97,2.05-19.31,0.98c-5.14-1.03-9.5-3.4-12.99-6.6c-5.17-4.74-8.39-11.14-9.09-17.82c-0.82-7.84,1.79-16.21,7.67-22.38c2.97-3.11,6.7-5.57,11.68-7.51c5.21-2.02,10.96-3.23,19.8-5.01c2.33-0.47,4.66-0.94,6.99-1.41c3.06-0.62,5.69-1.4,7.81-3.99c2.13-2.61,2.17-5.78,2.17-8.92l0-79.29c0-6.07-2.72-7.72-8.52-6.61c-4.14,0.81-93.09,18.75-93.09,18.75c-5.02,1.21-6.78,2.85-6.78,9.08l0,116.15c0,4.56-0.24,8.7-1.19,13.26c-0.93,4.43-2.63,8.6-5.24,12.35c-2.61,3.74-5.95,6.81-9.85,9.11c-3.95,2.33-8.08,3.72-12.5,4.61c-8.3,1.67-13.97,2.05-19.31,0.98c-5.14-1.03-9.5-3.47-12.99-6.66c-5.17-4.74-8.17-11.14-8.88-17.82c-0.82-7.84,1.57-16.21,7.46-22.38c2.97-3.11,6.7-5.57,11.68-7.51c5.21-2.02,10.96-3.23,19.8-5.01c2.33-0.47,4.66-0.94,6.99-1.41c3.06-0.62,5.69-1.4,7.81-3.99c2.12-2.59,2.37-5.64,2.37-8.76c0-24.6,0-133.92,0-133.92c0-1.8,0.15-3.02,0.24-3.62c0.43-2.82,1.56-5.24,3.6-6.95c1.7-1.42,3.88-2.41,6.67-3l0.04-0.01l107-21.59c0.93-0.19,8.66-1.56,9.53-1.64c5.78-0.5,9.03,3.3,9.03,9.46V234.26z' })
  ),
  localfiles: React.createElement('svg', { viewBox: '0 0 24 24', className: 'w-16 h-16', fill: 'white' },
    React.createElement('path', { d: 'M20 6h-8l-2-2H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm-6 10h-4v-4H8l4-4 4 4h-2v4z' })
  ),
  musicbrainz: React.createElement('svg', { viewBox: '0 0 24 24', className: 'w-16 h-16', fill: 'white' },
    React.createElement('path', { d: 'M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z' })
  ),
  lastfm: React.createElement('svg', { viewBox: '0 0 24 24', className: 'w-16 h-16', fill: 'white' },
    React.createElement('path', { d: 'M10.584 17.209l-.88-2.392s-1.43 1.595-3.573 1.595c-1.897 0-3.244-1.65-3.244-4.289 0-3.381 1.704-4.591 3.382-4.591 2.419 0 3.188 1.567 3.849 3.574l.88 2.75c.879 2.667 2.528 4.811 7.284 4.811 3.409 0 5.719-1.044 5.719-3.793 0-2.227-1.265-3.381-3.629-3.932l-1.76-.385c-1.209-.275-1.566-.77-1.566-1.594 0-.935.742-1.485 1.952-1.485 1.319 0 2.034.495 2.144 1.677l2.749-.33c-.22-2.474-1.924-3.491-4.729-3.491-2.474 0-4.893.935-4.893 3.931 0 1.87.907 3.052 3.188 3.602l1.869.439c1.402.33 1.869.907 1.869 1.705 0 1.017-.989 1.43-2.858 1.43-2.776 0-3.932-1.457-4.591-3.464l-.907-2.749c-1.155-3.574-2.997-4.894-6.653-4.894-4.041-.001-6.186 2.556-6.186 6.899 0 4.179 2.145 6.433 5.993 6.433 3.107.001 4.591-1.457 4.591-1.457z' })
  ),
  librefm: React.createElement('svg', { viewBox: '0 0 240 80', className: 'w-16 h-16', fill: 'white' },
    React.createElement('path', { d: 'm 19.97125,26.36764 c 0,-1.23526 0.41912,-2.20585 1.25736,-2.91176 0.70587,-0.70585 1.63234,-1.05879 2.77941,-1.05883 0.88234,4e-5 1.76469,0.37504 2.64706,1.125 0.7941,0.70592 1.19116,1.65445 1.19117,2.84559 l -0.46323,23.69118 9.92647,-0.46323 c 1.01468,0 1.8088,0.39706 2.38235,1.19117 0.57351,0.75001 0.86027,1.78677 0.8603,3.1103 -3e-5,1.05882 -0.28679,1.94117 -0.8603,2.64705 -0.52943,0.70589 -1.32355,1.05883 -2.38235,1.05883 l -13.96324,0 c -0.79412,0 -1.56618,-0.30882 -2.31617,-0.92647 -0.70589,-0.57353 -1.05883,-1.27941 -1.05883,-2.11765 l 0,-28.19118 z m 24.90915,27.26471 -0.2647,-26.93382 c -1e-5,-1.27938 0.39705,-2.31615 1.19117,-3.1103 0.75,-0.66173 1.7647,-0.99261 3.04412,-0.99265 1.2794,4e-5 2.27205,0.33092 2.97794,0.99265 0.70587,0.6618 1.05881,1.56621 1.05883,2.71324 l -0.33089,27.33088 c -1e-5,1.2353 -0.37501,2.22794 -1.125,2.97794 -0.75001,0.70588 -1.63236,1.05883 -2.64706,1.05882 -1.14706,1e-5 -2.07353,-0.35294 -2.77941,-1.05882 -0.75,-0.70588 -1.125,-1.69853 -1.125,-2.97794 l 0,0 z m 13.31406,-27.26471 c 0,-0.88232 0.30882,-1.72055 0.92647,-2.5147 0.61764,-0.88232 1.32353,-1.3235 2.11765,-1.32353 l 12.04412,0 c 2.16174,3e-5 4.03674,0.9265 5.625,2.77941 1.58821,1.85297 2.38232,3.9265 2.38235,6.22059 -3e-5,2.86767 -1.27944,5.09561 -3.83823,6.68382 2.24997,0.35296 3.97056,1.36767 5.16176,3.04412 1.0588,1.50001 1.58821,3.35295 1.58824,5.55882 -3e-5,2.82354 -0.79415,5.29413 -2.38236,7.41177 -1.76473,2.33823 -3.97061,3.50735 -6.61764,3.50735 l -13.96324,0 c -0.79412,0 -1.50001,-0.24265 -2.11765,-0.72794 -0.61765,-0.48529 -0.92647,-1.125 -0.92647,-1.91912 l 0,-28.72059 z m 13.89706,15.81618 -5.82353,0 0,8.60294 5.82353,0 c 1.80881,1e-5 3.13233,-0.37499 3.97059,-1.125 0.70586,-0.70587 1.0588,-1.52205 1.05882,-2.44853 -2e-5,-0.57352 -0.11031,-1.30146 -0.33088,-2.18382 -0.22061,-0.88234 -0.48531,-1.47793 -0.79412,-1.78677 -0.7059,-0.70586 -2.00737,-1.0588 -3.90441,-1.05882 l 0,0 z m -1.19117,-11.97794 -4.63236,0 0,7.34559 5.82353,0 c 1.32351,2e-5 1.98528,-0.97057 1.9853,-2.91177 -2e-5,-1.58821 -0.22061,-2.73527 -0.66177,-3.44117 -0.39708,-0.66174 -1.23531,-0.99262 -2.5147,-0.99265 l 0,0 z m 17.02995,-5.09559 c -10e-6,-0.61761 0.2647,-1.30144 0.79412,-2.05147 0.61764,-0.70585 1.23528,-1.05879 1.85294,-1.05882 l 13.10294,0 c 2.60292,3e-5 4.87498,1.08091 6.81618,3.24264 1.89703,2.25003 2.84556,4.6765 2.84559,7.27941 -3e-5,2.02944 -0.61768,3.86032 -1.85295,5.49265 -1.36767,1.72061 -3.4412,3.0662 -6.22058,4.03677 l 7.875,7.94117 c 0.8382,0.9706 1.25732,2.00736 1.25735,3.1103 -3e-5,1.05883 -0.35297,1.94118 -1.05882,2.64706 -0.26474,0.35294 -0.69489,0.79412 -1.29045,1.32353 -0.59561,0.52941 -1.11399,0.79411 -1.55514,0.79411 -1.50003,0 -2.86767,-0.74999 -4.10294,-2.25 l -10.45589,-12.83823 0,10.52206 c -1e-5,1.27941 -0.41913,2.38235 -1.25735,3.30882 -0.79413,0.79412 -1.76472,1.19118 -2.91177,1.19118 -1.10294,0 -2.00735,-0.39706 -2.71323,-1.19118 -0.75001,-0.70588 -1.12501,-1.80882 -1.125,-3.30882 l 0,-28.19118 z m 8.00735,3.77206 0,8.13971 5.88971,0 c 1.63233,2e-5 2.75733,-0.39704 3.375,-1.19118 0.66174,-0.7941 1.01468,-1.85292 1.05882,-3.17647 -2e-5,-0.74998 -0.35296,-1.61027 -1.05882,-2.58088 -0.61767,-0.79409 -1.74267,-1.19115 -3.375,-1.19118 l -5.88971,0 z m 22.69014,-3.04412 c -1e-5,-1.05879 0.30881,-1.89702 0.92647,-2.51471 0.70587,-0.61761 1.52205,-0.92643 2.44853,-0.92647 l 12.83823,0 c 1.19116,4e-5 2.09557,0.44122 2.71324,1.32353 0.61762,0.83827 0.92644,1.7868 0.92647,2.84559 -3e-5,1.19121 -0.24267,2.13974 -0.72794,2.84559 -0.52944,0.70591 -1.27944,1.05885 -2.25,1.05882 l -10.58824,-0.39705 0,6.75 9.92647,-0.39706 c 0.92645,2e-5 1.65439,0.37502 2.18383,1.125 0.5735,0.75002 0.86027,1.78678 0.86029,3.11029 -2e-5,1.05884 -0.22061,1.96325 -0.66176,2.71324 -0.52944,0.70589 -1.21326,1.05883 -2.05148,1.05882 l -10.25735,-0.33088 0,6.22059 9.92647,-0.46324 c 1.23527,1e-5 2.1838,0.39707 2.84559,1.19118 0.66174,0.70589 0.99262,1.74265 0.99265,3.11029 -3e-5,0.92648 -0.26473,1.72059 -0.79412,2.38235 -0.48532,0.70589 -1.12502,1.05883 -1.91912,1.05883 l -14.69118,0 c -0.52941,0 -1.10294,-0.30882 -1.72058,-0.92647 -0.61766,-0.48529 -0.92648,-1.08088 -0.92647,-1.78677 l 0,-29.05147 z m 29.13024,23.42647 c 1.23528,1e-5 2.20587,0.41913 2.91176,1.25736 0.70587,0.92647 1.05881,1.94118 1.05882,3.04411 -1e-5,1.10295 -0.33089,2.05148 -0.99264,2.84559 -0.75001,0.88236 -1.74266,1.32353 -2.97794,1.32353 -1.32354,0 -2.38236,-0.44117 -3.17648,-1.32353 -0.70588,-0.92647 -1.05882,-1.91911 -1.05882,-2.97794 0,-1.10294 0.375,-2.07352 1.125,-2.91176 0.70588,-0.83823 1.74264,-1.25735 3.1103,-1.25736 l 0,0 z m 8.83665,4.63236 0,-27.8603 c 0,-2.29408 0.99264,-3.44114 2.97794,-3.44118 l 13.56618,0 c 1.10292,4e-5 1.98527,0.3971 2.64706,1.19118 0.61762,0.83827 0.92645,1.76474 0.92647,2.77941 -2e-5,1.32356 -0.22061,2.25003 -0.66176,2.77941 -0.48532,0.6618 -1.16915,0.99268 -2.05148,0.99265 l -10.78676,-0.39706 0,5.625 9.52941,-0.39706 c 1.01469,3e-5 1.78674,0.35297 2.31618,1.05883 0.5735,0.7059 0.86027,1.72061 0.86029,3.04412 -2e-5,0.92648 -0.26473,1.7206 -0.79412,2.38235 -0.57355,0.79413 -1.36766,1.19119 -2.38235,1.19117 l -9.52941,0 0,11.05148 c -1e-5,1.23529 -0.39707,2.18382 -1.19118,2.84558 -0.75001,0.66177 -1.63236,0.99265 -2.64706,0.99265 -0.44118,0 -0.76103,-0.0772 -0.95956,-0.23162 -0.19853,-0.15441 -0.43015,-0.40808 -0.69485,-0.76103 -0.75,-0.61764 -1.125,-1.56617 -1.125,-2.84558 l 0,0 z m 37.4617,-27.00001 5.36029,15.88236 5.75736,-15.88236 c 0.52938,-1.32349 1.27938,-2.3382 2.25,-3.04411 0.97055,-0.70585 2.02937,-1.05879 3.17647,-1.05883 1.19114,4e-5 2.24996,0.3971 3.17647,1.19118 1.01466,0.88239 1.65437,2.11768 1.91911,3.70588 l 4.36765,25.94118 0,0.86029 c -4e-5,1.05883 -0.33093,1.91912 -0.99265,2.58089 -0.75004,0.61764 -1.87504,0.92647 -3.375,0.92647 -0.97062,0 -1.83092,-0.30883 -2.58088,-0.92647 -0.48533,-0.39706 -0.99268,-2.22794 -1.52206,-5.49265 l -1.98529,-16.21324 -0.0662,0 c -0.13239,3e-5 -0.2868,0.0441 -0.46323,0.13236 l -5.02941,16.08088 c -1.36768,4.2353 -2.77944,6.35294 -4.2353,6.35294 -1.36767,0 -2.80149,-2.11764 -4.30147,-6.35294 l -5.22794,-15.08824 -0.19853,-0.33088 -0.0662,0 c -0.13237,2e-5 -0.33089,0.0883 -0.59559,0.26471 l -0.99264,13.96323 c -0.26472,1.94118 -0.77207,3.69486 -1.52206,5.26103 -0.75001,1.56618 -1.67648,2.34927 -2.77941,2.34927 -1.85295,0 -3.15442,-0.375 -3.90442,-1.125 -0.79412,-0.70588 -1.19118,-1.61029 -1.19117,-2.71324 l 0,-0.59559 4.5,-25.875 c 0.2647,-1.54408 0.9044,-2.75732 1.91912,-3.6397 1.10293,-0.88232 2.24998,-1.3235 3.44117,-1.32353 2.47057,3e-5 4.19116,1.38974 5.16177,4.16911 l 0,0 z' })
  ),
  listenbrainz: React.createElement('svg', { viewBox: '0 0 146 160', className: 'w-16 h-16', fill: 'white' },
    React.createElement('path', { d: 'm75.354 7.823v144l61-35v-74z' }),
    React.createElement('path', { d: 'm70.354 7.823-61 35v74l61 35z' })
  ),
  chatgpt: React.createElement('svg', { viewBox: '-0.17090198558635983 0.482230148717937 41.14235318283891 40.0339509076386', className: 'w-16 h-16', fill: 'white' },
    React.createElement('path', { d: 'M37.532 16.87a9.963 9.963 0 0 0-.856-8.184 10.078 10.078 0 0 0-10.855-4.835A9.964 9.964 0 0 0 18.306.5a10.079 10.079 0 0 0-9.614 6.977 9.967 9.967 0 0 0-6.664 4.834 10.08 10.08 0 0 0 1.24 11.817 9.965 9.965 0 0 0 .856 8.185 10.079 10.079 0 0 0 10.855 4.835 9.965 9.965 0 0 0 7.516 3.35 10.078 10.078 0 0 0 9.617-6.981 9.967 9.967 0 0 0 6.663-4.834 10.079 10.079 0 0 0-1.243-11.813zM22.498 37.886a7.474 7.474 0 0 1-4.799-1.735c.061-.033.168-.091.237-.134l7.964-4.6a1.294 1.294 0 0 0 .655-1.134V19.054l3.366 1.944a.12.12 0 0 1 .066.092v9.299a7.505 7.505 0 0 1-7.49 7.496zM6.392 31.006a7.471 7.471 0 0 1-.894-5.023c.06.036.162.099.237.141l7.964 4.6a1.297 1.297 0 0 0 1.308 0l9.724-5.614v3.888a.12.12 0 0 1-.048.103l-8.051 4.649a7.504 7.504 0 0 1-10.24-2.744zM4.297 13.62A7.469 7.469 0 0 1 8.2 10.333c0 .068-.004.19-.004.274v9.201a1.294 1.294 0 0 0 .654 1.132l9.723 5.614-3.366 1.944a.12.12 0 0 1-.114.01L7.04 23.856a7.504 7.504 0 0 1-2.743-10.237zm27.658 6.437l-9.724-5.615 3.367-1.943a.121.121 0 0 1 .113-.01l8.052 4.648a7.498 7.498 0 0 1-1.158 13.528v-9.476a1.293 1.293 0 0 0-.65-1.132zm3.35-5.043c-.059-.037-.162-.099-.236-.141l-7.965-4.6a1.298 1.298 0 0 0-1.308 0l-9.723 5.614v-3.888a.12.12 0 0 1 .048-.103l8.05-4.645a7.497 7.497 0 0 1 11.135 7.763zm-21.063 6.929l-3.367-1.944a.12.12 0 0 1-.065-.092v-9.299a7.497 7.497 0 0 1 12.293-5.756 6.94 6.94 0 0 0-.236.134l-7.965 4.6a1.294 1.294 0 0 0-.654 1.132l-.006 11.225zm1.829-3.943l4.33-2.501 4.332 2.5v5l-4.331 2.5-4.331-2.5V18z' })
  ),
  wikipedia: React.createElement('svg', { viewBox: '0 0 98.05 98.05', className: 'w-16 h-16', fill: 'white' },
    React.createElement('path', { d: 'M98.023,17.465l-19.584-0.056c-0.004,0.711-0.006,1.563-0.017,2.121c1.664,0.039,5.922,0.822,7.257,4.327L66.92,67.155c-0.919-2.149-9.643-21.528-10.639-24.02l9.072-18.818c1.873-2.863,5.455-4.709,8.918-4.843l-0.01-1.968L55.42,17.489c-0.045,0.499,0.001,1.548-0.068,2.069c5.315,0.144,7.215,1.334,5.941,4.508c-2.102,4.776-6.51,13.824-7.372,15.475c-2.696-5.635-4.41-9.972-7.345-16.064c-1.266-2.823,1.529-3.922,4.485-4.004v-1.981l-21.82-0.067c0.016,0.93-0.021,1.451-0.021,2.131c3.041,0.046,6.988,0.371,8.562,3.019c2.087,4.063,9.044,20.194,11.149,24.514c-2.685,5.153-9.207,17.341-11.544,21.913c-3.348-7.43-15.732-36.689-19.232-44.241c-1.304-3.218,3.732-5.077,6.646-5.213l0.019-2.148L0,17.398c0.005,0.646,0.027,1.71,0.029,2.187c4.025-0.037,9.908,6.573,11.588,10.683c7.244,16.811,14.719,33.524,21.928,50.349c0.002,0.029,2.256,0.059,2.281,0.008c4.717-9.653,10.229-19.797,15.206-29.56L63.588,80.64c0.005,0.004,2.082,0.016,2.093,0.007c7.962-18.196,19.892-46.118,23.794-54.933c1.588-3.767,4.245-6.064,8.543-6.194l0.032-1.956L98.023,17.465z' })
  ),
  discogs: React.createElement('svg', { viewBox: '0 0 24 24', className: 'w-16 h-16', fill: 'white' },
    React.createElement('path', { d: 'M12 0C5.372 0 0 5.372 0 12s5.372 12 12 12 12-5.372 12-12S18.628 0 12 0zm0 21.6c-5.304 0-9.6-4.296-9.6-9.6S6.696 2.4 12 2.4s9.6 4.296 9.6 9.6-4.296 9.6-9.6 9.6zm0-16.8c-3.972 0-7.2 3.228-7.2 7.2s3.228 7.2 7.2 7.2 7.2-3.228 7.2-7.2-3.228-7.2-7.2-7.2zm0 12c-2.652 0-4.8-2.148-4.8-4.8s2.148-4.8 4.8-4.8 4.8 2.148 4.8 4.8-2.148 4.8-4.8 4.8zm0-7.2c-1.326 0-2.4 1.074-2.4 2.4s1.074 2.4 2.4 2.4 2.4-1.074 2.4-2.4-1.074-2.4-2.4-2.4z' })
  )
};

// Parachord wordmark logo component
const ParachordWordmark = ({ fill = 'black', height = 40 }) => React.createElement('svg', {
  viewBox: '0 0 1046 273',
  style: { height: height + 'px', width: 'auto' },
  fill: 'none',
  xmlns: 'http://www.w3.org/2000/svg'
},
  React.createElement('path', { d: 'M764.5 102.5C788.725 102.5 809.5 123.347 809.5 150.5C809.5 177.654 788.725 198.5 764.5 198.5C740.275 198.5 719.5 177.654 719.5 150.5C719.5 123.347 740.275 102.5 764.5 102.5Z', stroke: fill, strokeWidth: 27 }),
  React.createElement('path', { d: 'M237.5 102.5C261.725 102.5 282.5 123.347 282.5 150.5C282.5 177.654 261.725 198.5 237.5 198.5C213.275 198.5 192.5 177.654 192.5 150.5C192.5 123.347 213.275 102.5 237.5 102.5Z', stroke: fill, strokeWidth: 27 }),
  React.createElement('rect', { x: 271, y: 89.0005, width: 25, height: 123, fill: fill }),
  React.createElement('path', { d: 'M424.5 102.5C448.725 102.5 469.5 123.347 469.5 150.5C469.5 177.654 448.725 198.5 424.5 198.5C400.275 198.5 379.5 177.654 379.5 150.5C379.5 123.347 400.275 102.5 424.5 102.5Z', stroke: fill, strokeWidth: 27 }),
  React.createElement('rect', { x: 458, y: 89.0005, width: 25, height: 123, fill: fill }),
  React.createElement('rect', { x: 307, y: 152, width: 27, height: 60, fill: fill }),
  React.createElement('path', { d: 'M307 152C307 117.207 333.191 89.0005 365.5 89.0005C365.667 89.0005 365.833 89.0029 366 89.0044L366 116.008C365.833 116.005 365.667 116 365.5 116C350.195 116 334.499 129.759 334.012 150.984L334 152L307 152Z', fill: fill }),
  React.createElement('rect', { x: 828, y: 152, width: 27, height: 60, fill: fill }),
  React.createElement('path', { d: 'M828 152C828 117.207 854.191 89.0005 886.5 89.0005C886.667 89.0005 886.833 89.0029 887 89.0044L887 116.008C886.833 116.005 886.667 116 886.5 116C871.195 116 855.499 129.759 855.012 150.984L855 152L828 152Z', fill: fill }),
  React.createElement('rect', { x: 676, y: 152, width: 25, height: 60, fill: fill }),
  React.createElement('rect', { x: 597, y: 45.8784, width: 25, height: 165, fill: fill }),
  React.createElement('path', { d: 'M622 38.0005V50.5005L597 45.8784L622 38.0005Z', fill: fill }),
  React.createElement('path', { d: 'M648.702 96.0005C675.533 96.0005 698.054 122.271 700.898 156H675.816C673.171 131.764 657.459 121 648.702 121C640.176 121 624.661 131.504 622.075 156H597C599.787 122.271 621.871 96.0005 648.702 96.0005Z', fill: fill }),
  React.createElement('path', { d: 'M547.5 92.0005C565.823 92.0005 582.177 100.857 592.903 114.719L569.128 128.445C563.289 122.472 555.491 119 547.5 119C531.36 119 516 133.158 516 153.5C516 173.843 531.36 188 547.5 188C554.915 188 562.163 185.011 567.835 179.808L591.812 193.651C581.084 206.724 565.212 215 547.5 215C515.191 215 489 187.466 489 153.5C489 119.535 515.191 92.0005 547.5 92.0005Z', fill: fill }),
  React.createElement('rect', { x: 1004.01, y: 151.398, width: 25, height: 100.266, transform: 'rotate(-180 1004.01 151.398)', fill: fill }),
  React.createElement('path', { d: 'M1039.72 33.8887C1042.39 35.348 1042.43 39.1612 1039.8 40.6846L984.893 72.4893C982.313 73.9831 979.08 72.1478 979.039 69.167L978.192 6.85254C978.152 3.86674 981.345 1.94449 983.965 3.37793L1039.72 33.8887Z', fill: '#E12949', stroke: 'white', strokeWidth: 0.2 }),
  React.createElement('path', { d: 'M945.5 102.5C969.725 102.5 990.5 123.347 990.5 150.5C990.5 177.654 969.725 198.5 945.5 198.5C921.275 198.5 900.5 177.654 900.5 150.5C900.5 123.347 921.275 102.5 945.5 102.5Z', stroke: fill, strokeWidth: 27 }),
  React.createElement('path', { d: 'M945.5 102.5C969.725 102.5 990.5 123.347 990.5 150.5C990.5 177.654 969.725 198.5 945.5 198.5C921.275 198.5 900.5 177.654 900.5 150.5C900.5 123.347 921.275 102.5 945.5 102.5Z', stroke: fill, strokeOpacity: 0.2, strokeWidth: 27 }),
  React.createElement('path', { d: 'M59 260.805L59 242.676M59 203.856L59 224.803', stroke: 'white', strokeWidth: 0.2, strokeLinecap: 'round' }),
  React.createElement('path', { d: 'M7.29194 100.001C7.32449 100.03 7.16169 101.377 6.90132 102.986C6.08765 108.341 5.46898 114.633 5.14351 121.363C4.16715 140.559 7.45444 156.098 14.3544 165.316C18.3253 170.612 26.072 175.44 40.8486 181.878C49.0502 185.448 52.3379 187.262 56.2109 190.334L58.8476 192.412V186.211H63.4042C63.4041 257.673 63.3388 265.772 62.8837 266.359C62.5258 266.827 62.0696 267.002 61.1259 267.002C59.0103 267.002 58.8476 266.534 58.8476 260.477V255.238L57.1875 252.722C54.0629 247.923 51.0032 244.411 46.5117 240.373C41.6947 236.042 38.3425 233.818 32.6142 231.126C26.3002 228.112 22.6871 225.742 18.5537 221.821C8.39888 212.194 2.14945 198.528 0.261671 181.761C-0.226521 177.518 0.0335781 163.501 0.684523 158.994C1.0425 156.39 1.07508 155.512 0.684523 153.288C0.0336106 149.542 -0.226209 135.731 0.229445 130.902C1.01061 122.738 3.06059 113.081 5.8271 104.215C6.57471 101.848 7.22547 99.9476 7.29194 100.001ZM5.66499 172.338C6.28338 178.015 7.8456 184.628 9.53804 188.871C12.4673 196.187 16.0803 200.635 22.3945 204.673C27.8298 208.184 31.7356 210.145 44.2011 215.588C46.6096 216.641 49.7671 218.222 51.1992 219.07C52.6312 219.89 54.9417 221.587 56.3085 222.757L58.8476 224.952V223.986C58.8475 223.372 58.2943 222.143 57.3505 220.651C51.492 211.433 42.7362 203.649 33.1347 199.113C30.9543 198.089 28.1881 196.656 26.9511 195.924C18.4889 190.891 11.8166 183.341 6.5439 172.777L5.43648 170.582L5.66499 172.338Z', fill: '#767575' }),
  React.createElement('path', { d: 'M115.5 102.5C139.725 102.5 160.5 123.346 160.5 150.5C160.5 177.654 139.725 198.5 115.5 198.5C91.2754 198.5 70.5 177.654 70.5 150.5C70.5 123.346 91.2754 102.5 115.5 102.5Z', stroke: fill, strokeWidth: 27 }),
  React.createElement('path', { d: 'M82 256.261L57 272.5L57 255.66L57 238.819L82 256.261Z', fill: fill }),
  React.createElement('rect', { x: 57, y: 148, width: 25, height: 108.261, fill: fill })
);

// VirtualizedQueueList component - Renders queue tracks efficiently using windowing
// Only renders visible tracks + overscan buffer, dramatically reducing DOM nodes for large queues
const VirtualizedQueueList = React.memo(({
  queue,
  currentTrack,
  resolverOrder,
  allResolvers,
  queueDropTarget,
  draggedQueueTrack,
  insertedTrackId,
  droppingFromIndex,
  spinoffMode,
  playbackContext,
  listenAlongFriend,
  addToPlaylistPanel,
  selectedPlaylistsForAdd,
  containerHeight,
  parentRef,
  // Callbacks
  setDraggedQueueTrack,
  setDraggingTrackForPlaylist,
  setQueueDropTarget,
  setDropTargetPlaylistId,
  setDropTargetNewPlaylist,
  setAddToPlaylistPanel,
  moveInQueue,
  setDroppingFromIndex,
  setCurrentQueue,
  handlePlay,
  exitSpinoff,
  fetchArtistData,
  removeFromQueue,
  handleUrlDrop,
  formatTime,
  // New props for resolution scheduler
  onVisibilityChange,
  onTrackHover,
  onTrackHoverEnd,
  currentTrackIndex
}) => {
  const TRACK_HEIGHT = 36; // Approximate height of each track row in pixels

  // Use @tanstack/react-virtual for efficient rendering
  // ReactVirtual is loaded from CDN as a global
  const virtualizer = typeof ReactVirtual !== 'undefined' ? ReactVirtual.useVirtualizer({
    count: queue.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => TRACK_HEIGHT,
    overscan: 10 // Render 10 extra items above/below viewport for smooth scrolling
  }) : null;

  // Track visible items for resolution scheduler
  useEffect(() => {
    if (!virtualizer || !onVisibilityChange || !queue || queue.length === 0) return;

    const visibleRange = virtualizer.getVirtualItems();
    if (visibleRange.length === 0) return;

    // IMPORTANT: The queue is displayed in REVERSE order (next track at bottom, last track at top)
    // virtualizer indices are visual (top-to-bottom), so we need to reverse-map to queue indices:
    // - visibleRange[0].index (top of viewport) = queue[queue.length - 1 - index] (end of queue)
    // - visibleRange[last].index (bottom of viewport) = queue[queue.length - 1 - index] (start of queue)
    const visualStartIndex = visibleRange[0].index;
    const visualEndIndex = visibleRange[visibleRange.length - 1].index;

    // Convert visual indices to queue array indices (reversed)
    const queueEndIndex = queue.length - 1 - visualStartIndex;   // Top of viewport = higher queue indices
    const queueStartIndex = queue.length - 1 - visualEndIndex;   // Bottom of viewport = lower queue indices

    // Clamp to valid range
    const startIndex = Math.max(0, queueStartIndex);
    const endIndex = Math.min(queue.length - 1, queueEndIndex);

    // Plus playback lookahead (5 from current track)
    const lookaheadStart = currentTrackIndex ?? 0;
    const lookaheadEnd = lookaheadStart + 5;

    // Build visible tracks list
    const visibleTracks = [];
    const seen = new Set();

    // Add viewport + overscan (reversed mapping applied above)
    for (let i = startIndex; i <= endIndex; i++) {
      const track = queue[i];
      if (track && !seen.has(track.id)) {
        seen.add(track.id);
        visibleTracks.push({
          key: track.id,
          data: { track, artistName: track.artist, isQueueResolution: true }
        });
      }
    }

    // Add playback lookahead
    for (let i = lookaheadStart; i < Math.min(queue.length, lookaheadEnd); i++) {
      const track = queue[i];
      if (track && !seen.has(track.id)) {
        seen.add(track.id);
        visibleTracks.push({
          key: track.id,
          data: { track, artistName: track.artist, isQueueResolution: true }
        });
      }
    }

    onVisibilityChange(visibleTracks);
  }, [virtualizer?.range?.startIndex, virtualizer?.range?.endIndex, queue.length, currentTrackIndex, onVisibilityChange]);

  // Helper to render a single queue track row
  const renderQueueTrackRow = (track, index, virtualRow) => {
    const isCurrentTrack = currentTrack?.id === track.id;
    const isLoading = track.status === 'loading';
    const isError = track.status === 'error';
    const availableSources = Object.keys(track.sources || {}).sort((a, b) => {
      const aIndex = resolverOrder.indexOf(a);
      const bIndex = resolverOrder.indexOf(b);
      return aIndex - bIndex;
    });

    const isDraggedOver = queueDropTarget === index;
    const isDragging = draggedQueueTrack === index;
    const isInserted = insertedTrackId === track.id;
    const isFallingDown = droppingFromIndex !== null && index <= droppingFromIndex;

    return React.createElement('div', {
      key: track.id,
      'data-index': index,
      ref: virtualRow ? virtualizer.measureElement : undefined,
      draggable: !isLoading && !isError,
      onDragStart: (e) => {
        if (!isLoading && !isError) {
          setDraggedQueueTrack(index);
          setDraggingTrackForPlaylist(track);
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', JSON.stringify({ type: 'track', track }));
        }
      },
      onDragEnd: () => {
        setDraggedQueueTrack(null);
        setQueueDropTarget(null);
        setDraggingTrackForPlaylist(null);
        setDropTargetPlaylistId(null);
        setDropTargetNewPlaylist(false);
        if (addToPlaylistPanel.open && selectedPlaylistsForAdd.length === 0) {
          setAddToPlaylistPanel(prev => ({ ...prev, open: false }));
        }
      },
      onDragOver: (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        if (draggedQueueTrack !== null && draggedQueueTrack !== index) {
          setQueueDropTarget(index);
        }
      },
      onDragLeave: () => {
        setQueueDropTarget(null);
      },
      onDrop: (e) => {
        e.preventDefault();
        if (draggedQueueTrack !== null && draggedQueueTrack !== index) {
          moveInQueue(draggedQueueTrack, index);
        }
        setDraggedQueueTrack(null);
        setQueueDropTarget(null);
      },
      onContextMenu: (e) => {
        e.preventDefault();
        if (!isLoading && !isError && window.electron?.contextMenu?.showTrackMenu) {
          window.electron.contextMenu.showTrackMenu({ type: 'track', track });
        }
      },
      onClick: () => {
        if (isLoading || isError) return;
        setDroppingFromIndex(index);
        setTimeout(() => {
          setCurrentQueue(prev => prev.slice(index + 1));
          handlePlay(track);
          setDroppingFromIndex(null);
        }, 300);
      },
      onMouseEnter: () => {
        if (onTrackHover) onTrackHover(track.id);
      },
      onMouseLeave: () => {
        if (onTrackHoverEnd) onTrackHoverEnd();
      },
      className: `group flex items-center gap-3 py-1.5 px-3 hover:bg-white/10 transition-all duration-300 ${
        isCurrentTrack ? 'bg-purple-900/40' : ''
      } ${isDragging ? 'opacity-50 bg-gray-700/50' : ''} ${
        isError ? 'opacity-50' : ''
      } ${isDraggedOver ? 'border-t-2 border-t-purple-400' : ''} ${
        isLoading || isError ? 'cursor-default' : 'cursor-pointer'} ${
        isFallingDown ? 'queue-track-drop' : ''} ${
        isInserted ? 'queue-track-insert' : ''} ${
        (spinoffMode || playbackContext?.type === 'spinoff' || playbackContext?.type === 'friend') && !isCurrentTrack ? 'opacity-50' : ''} ${
        listenAlongFriend ? 'opacity-40 pointer-events-none' : ''}`,
      style: virtualRow ? {
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: `${virtualRow.size}px`,
        transform: `translateY(${virtualRow.start}px)`,
        borderRadius: '6px'
      } : {
        borderRadius: '6px',
        marginBottom: '1px'
      }
    },
      // Track number
      React.createElement('span', {
        className: 'text-right',
        style: {
          width: '28px',
          flexShrink: 0,
          fontSize: '12px',
          fontWeight: '500',
          color: (spinoffMode || playbackContext?.type === 'spinoff' || playbackContext?.type === 'friend')
            ? 'rgba(156, 163, 175, 0.5)' : 'rgba(156, 163, 175, 0.7)'
        }
      },
        listenAlongFriend ? 'â€“' :
        isLoading ? React.createElement('span', { className: 'animate-spin inline-block' }, 'â—Œ') :
        isError ? 'âš ' :
        isCurrentTrack ? 'â–¶' :
        (spinoffMode || playbackContext?.type === 'spinoff' || playbackContext?.type === 'friend')
          ? 'Â·Â·' : String(index + 1).padStart(2, '0')
      ),
      // Track title
      React.createElement('span', {
        className: 'truncate group-hover:text-white transition-colors',
        style: {
          flex: '1 1 0',
          minWidth: 0,
          fontSize: '13px',
          fontWeight: index === 0 ? '500' : '400',
          color: isLoading ? 'rgba(156, 163, 175, 0.6)' :
                 isError ? '#f87171' :
                 isCurrentTrack ? '#a78bfa' : 'rgba(229, 231, 235, 0.9)'
        },
        onClick: () => {
          if (isLoading || isError) return;
          if (spinoffMode) exitSpinoff();
          setDroppingFromIndex(index);
          setTimeout(() => {
            setCurrentQueue(prev => prev.slice(index + 1));
            handlePlay(track);
            setDroppingFromIndex(null);
          }, 300);
        }
      },
        isLoading ? 'Loading...' :
        isError ? 'Could not load track' :
        track.title
      ),
      // Artist name
      React.createElement('span', {
        className: 'truncate hover:text-purple-400 hover:underline cursor-pointer transition-colors',
        style: { flex: '0.7 1 0', minWidth: 0, fontSize: '12px', color: 'rgba(156, 163, 175, 0.7)' },
        onClick: (e) => {
          e.stopPropagation();
          if (!isLoading && !isError && track.artist) fetchArtistData(track.artist);
        }
      },
        isLoading ? `from ${track.sourceDomain || 'unknown'}` :
        isError ? (track.errorMessage || 'Unknown error') :
        track.artist
      ),
      // Duration
      React.createElement('span', {
        className: 'text-right tabular-nums',
        style: { width: '50px', flexShrink: 0, fontSize: '12px', color: 'rgba(156, 163, 175, 0.5)' }
      }, !isLoading && !isError ? formatTime(track.duration || 0) : ''),
      // Resolver icons
      React.createElement('div', {
        className: 'flex items-center gap-1 justify-end',
        style: { width: '90px', flexShrink: 0, minHeight: '20px' }
      },
        isError ?
          React.createElement('button', {
            onClick: (e) => {
              e.stopPropagation();
              if (track.sourceUrl) {
                removeFromQueue(track.id);
                handleUrlDrop(track.sourceUrl, 'queue');
              }
            },
            className: 'px-2 py-0.5 text-xs text-gray-400 hover:text-white hover:bg-white/10 rounded transition-colors',
            title: 'Retry'
          }, 'â†»')
        : isLoading ?
          React.createElement('div', { className: 'flex items-center gap-1' },
            React.createElement('div', {
              className: 'rounded bg-gradient-to-r from-gray-700 via-gray-600 to-gray-700 bg-[length:200%_100%] animate-shimmer',
              style: { width: '20px', height: '20px' }
            }),
            React.createElement('div', {
              className: 'rounded bg-gradient-to-r from-gray-700 via-gray-600 to-gray-700 bg-[length:200%_100%] animate-shimmer',
              style: { width: '20px', height: '20px', animationDelay: '0.1s' }
            })
          )
        : availableSources.length > 0 ?
          availableSources.map(resolverId => {
            const resolver = allResolvers.find(r => r.id === resolverId);
            if (!resolver) return null;
            const source = track.sources?.[resolverId];
            const confidence = source?.confidence || 0;
            return React.createElement('button', {
              key: resolverId,
              onClick: (e) => {
                e.stopPropagation();
                handlePlay({ ...track, preferredResolver: resolverId });
              },
              className: 'no-drag',
              style: {
                width: '20px',
                height: '20px',
                borderRadius: '4px',
                backgroundColor: resolver.color,
                border: 'none',
                cursor: 'pointer',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                opacity: confidence > 0.8 ? 0.7 : 0.5,
                filter: 'saturate(0.7)',
                transition: 'opacity 0.15s, filter 0.15s, transform 0.1s'
              },
              onMouseEnter: (e) => { e.currentTarget.style.transform = 'scale(1.1)'; e.currentTarget.style.opacity = '1'; e.currentTarget.style.filter = 'saturate(1)'; },
              onMouseLeave: (e) => { e.currentTarget.style.transform = 'scale(1)'; e.currentTarget.style.opacity = confidence > 0.8 ? '0.7' : '0.5'; e.currentTarget.style.filter = 'saturate(0.7)'; },
              title: `Play via ${resolver.name}${confidence ? ` (${Math.round(confidence * 100)}% match)` : ''}`
            }, React.createElement(ResolverIcon, { resolverId, size: 12 }));
          })
        :
          React.createElement('div', { className: 'flex items-center gap-1' },
            React.createElement('div', {
              className: 'rounded bg-gradient-to-r from-gray-700 via-gray-600 to-gray-700 bg-[length:200%_100%] animate-shimmer',
              style: { width: '20px', height: '20px' },
              title: 'Resolving track...'
            }),
            React.createElement('div', {
              className: 'rounded bg-gradient-to-r from-gray-700 via-gray-600 to-gray-700 bg-[length:200%_100%] animate-shimmer',
              style: { width: '20px', height: '20px', animationDelay: '0.1s' }
            })
          )
      ),
      // Remove button
      React.createElement('button', {
        onClick: (e) => {
          e.stopPropagation();
          removeFromQueue(track.id);
        },
        className: 'flex-shrink-0 p-1 text-gray-500 hover:text-red-400 hover:bg-white/10 rounded transition-colors opacity-0 group-hover:opacity-100',
        title: isLoading ? 'Cancel' : 'Remove from queue'
      }, React.createElement(X, { size: 14 }))
    );
  };

  // Fallback if ReactVirtual not loaded OR small queue - render all (original behavior)
  // Virtualization only helps for large queues (100+ items)
  if (!virtualizer || queue.length < 100) {
    return React.createElement('div', { className: 'flex flex-col-reverse justify-start min-h-full' },
      queue.map((track, index) => renderQueueTrackRow(track, index, null))
    );
  }

  const virtualItems = virtualizer.getVirtualItems();

  // Virtualized rendering with reversed order display
  // The virtualizer gives us indices 0, 1, 2... from top of scroll area
  // We want index 0 (next track) at the BOTTOM, so we reverse the mapping:
  // - virtualRow.index 0 (top of scroll) -> queue[queue.length - 1] (last track)
  // - virtualRow.index N (bottom of scroll) -> queue[0] (next track)
  return React.createElement('div', {
    style: {
      height: `${virtualizer.getTotalSize()}px`,
      width: '100%',
      position: 'relative'
    }
  },
    virtualItems.map(virtualRow => {
      // Map virtual index to reversed queue index
      const reversedQueueIndex = queue.length - 1 - virtualRow.index;
      const track = queue[reversedQueueIndex];
      // Use original virtualRow positioning (top-to-bottom), but with reversed queue data
      return renderQueueTrackRow(track, reversedQueueIndex, virtualRow);
    })
  );
});

// ResolverCard component - Tomahawk-style colored card with centered logo
const ResolverCard = React.memo(({
  resolver,
  isActive,
  isInstalled,
  hasUpdate,
  isInstalling,
  needsConfiguration,
  priorityNumber,
  onClick,
  onDragStart,
  onDragOver,
  onDragEnter,
  onDragLeave,
  onDrop,
  onDragEnd,
  onContextMenu,
  draggable = false,
  isDragOver = false,
  isDragging = false
}) => {
  // Get the logo SVG or fall back to emoji icon
  const logo = SERVICE_LOGOS[resolver.id];

  return React.createElement('div', {
    className: `flex flex-col items-center relative ${isDragging ? 'opacity-50' : ''}`,
    draggable: draggable,
    onDragStart: draggable ? onDragStart : undefined,
    onDragOver: draggable ? onDragOver : undefined,
    onDragEnter: draggable ? onDragEnter : undefined,
    onDragLeave: draggable ? onDragLeave : undefined,
    onDrop: draggable ? onDrop : undefined,
    onDragEnd: draggable ? onDragEnd : undefined,
    onContextMenu: onContextMenu
  },
    // Drop indicator - shown when dragging over this card
    isDragOver && React.createElement('div', {
      className: 'absolute -left-3 top-0 bottom-6 w-1 rounded-full',
      style: {
        backgroundColor: '#7c3aed',
        boxShadow: '0 0 8px rgba(124, 58, 237, 0.6)',
        zIndex: 10
      }
    }),
    // Card with colored background - refined styling
    React.createElement('div', {
      className: `relative flex items-center justify-center cursor-pointer transition-all ${
        isActive === false ? 'opacity-50 grayscale' : ''
      }`,
      style: {
        width: '120px',
        height: '120px',
        borderRadius: '16px',
        backgroundColor: resolver.color || '#6B7280',
        boxShadow: isDragOver
          ? '0 0 0 3px #7c3aed, 0 4px 12px rgba(0, 0, 0, 0.15)'
          : '0 2px 8px rgba(0, 0, 0, 0.1), 0 4px 16px rgba(0, 0, 0, 0.05)'
      },
      onClick: onClick
    },
      // Priority number badge (top-left) - refined
      priorityNumber && React.createElement('div', {
        className: 'absolute flex items-center justify-center',
        style: {
          top: '8px',
          left: '8px',
          width: '22px',
          height: '22px',
          backgroundColor: 'rgba(255, 255, 255, 0.95)',
          borderRadius: '6px',
          fontSize: '11px',
          fontWeight: '600',
          color: '#374151',
          boxShadow: '0 1px 3px rgba(0, 0, 0, 0.1)'
        }
      }, priorityNumber),
      // Centered logo or emoji fallback
      logo ? logo : React.createElement('span', {
        className: 'text-5xl text-white drop-shadow-md'
      }, resolver.icon),
      // Status overlay for installed/update (marketplace view)
      isInstalled && React.createElement('div', {
        className: 'absolute flex items-center justify-center',
        style: {
          top: '8px',
          right: '8px',
          width: '22px',
          height: '22px',
          backgroundColor: hasUpdate ? '#f97316' : 'rgba(255, 255, 255, 0.95)',
          borderRadius: '6px',
          fontSize: '11px',
          fontWeight: '600',
          color: hasUpdate ? '#ffffff' : '#22c55e'
        }
      }, hasUpdate ? 'â†‘' : 'âœ“'),
      // Active checkmark for installed tab (when not in marketplace view and no update)
      !isInstalled && !hasUpdate && React.createElement('div', {
        className: 'absolute flex items-center justify-center',
        style: {
          top: '8px',
          right: '8px',
          width: '22px',
          height: '22px',
          backgroundColor: 'rgba(255, 255, 255, 0.95)',
          borderRadius: '6px',
          fontSize: '11px',
          fontWeight: '600',
          color: '#22c55e'
        }
      }, 'âœ“'),
      // Update badge for installed tab (top-right, only when not showing installed badge)
      !isInstalled && hasUpdate && React.createElement('div', {
        className: 'absolute flex items-center justify-center',
        style: {
          top: '8px',
          right: '8px',
          width: '22px',
          height: '22px',
          backgroundColor: '#f97316',
          borderRadius: '6px',
          fontSize: '11px',
          fontWeight: '600',
          color: '#ffffff'
        }
      }, 'â†‘'),
      // Installing spinner
      isInstalling && React.createElement('div', {
        className: 'absolute inset-0 flex items-center justify-center',
        style: {
          backgroundColor: 'rgba(0, 0, 0, 0.4)',
          borderRadius: '16px'
        }
      },
        React.createElement('span', { className: 'text-white text-2xl animate-spin' }, 'â³')
      ),
      // Needs configuration warning badge (bottom-right)
      needsConfiguration && !isInstalling && React.createElement('div', {
        className: 'absolute flex items-center justify-center',
        style: {
          bottom: '8px',
          right: '8px',
          width: '22px',
          height: '22px',
          backgroundColor: '#fbbf24',
          borderRadius: '6px',
          fontSize: '12px',
          fontWeight: '600',
          color: '#78350f',
          boxShadow: '0 1px 3px rgba(0, 0, 0, 0.2)'
        },
        title: 'Needs configuration'
      }, '!')
    ),
    // Name below card - refined typography
    React.createElement('span', {
      style: {
        marginTop: '10px',
        fontSize: '13px',
        fontWeight: '500',
        color: '#1f2937',
        textAlign: 'center',
        width: '120px',
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        whiteSpace: 'nowrap'
      }
    }, resolver.name),
    // Needs setup label below name
    needsConfiguration && React.createElement('span', {
      style: {
        fontSize: '10px',
        fontWeight: '500',
        color: '#d97706',
        marginTop: '2px'
      }
    }, 'Setup required')
  );
});

// ScrobblerSettingsCard component - Settings card for individual scrobbler services
const ScrobblerSettingsCard = React.memo(({ scrobbler, config, onConfigChange }) => {
  const [connecting, setConnecting] = useState(false);
  const [error, setError] = useState(null);
  const [tokenInput, setTokenInput] = useState('');

  const isConnected = config?.enabled && (config?.sessionKey || config?.userToken);

  const handleConnect = async () => {
    setConnecting(true);
    setError(null);

    try {
      if (scrobbler.id === 'listenbrainz') {
        // Token-based auth
        await scrobbler.connect(tokenInput);
        onConfigChange(scrobbler.id, await scrobbler.getConfig());
        setTokenInput('');
      } else {
        // OAuth flow (Last.fm, Libre.fm)
        const { authUrl } = await scrobbler.startAuth();
        window.electron.shell.openExternal(authUrl);
        // Update config to show pending state
        onConfigChange(scrobbler.id, await scrobbler.getConfig());
      }
    } catch (err) {
      setError(err.message);
    } finally {
      setConnecting(false);
    }
  };

  const handleCompleteAuth = async () => {
    setConnecting(true);
    setError(null);

    try {
      await scrobbler.completeAuth();
      onConfigChange(scrobbler.id, await scrobbler.getConfig());
    } catch (err) {
      setError(err.message);
    } finally {
      setConnecting(false);
    }
  };

  const handleDisconnect = async () => {
    setError(null);
    try {
      await scrobbler.disconnect();
      onConfigChange(scrobbler.id, {});
    } catch (err) {
      setError(err.message);
    }
  };

  const handleToggleEnabled = async () => {
    setError(null);
    try {
      const newConfig = { ...config, enabled: !config?.enabled };
      await scrobbler.setConfig(newConfig);
      onConfigChange(scrobbler.id, newConfig);
    } catch (err) {
      setError(err.message);
    }
  };

  // Get scrobbler-specific styling
  const getScrobblerColor = () => {
    switch (scrobbler.id) {
      case 'lastfm': return 'bg-red-500';
      case 'listenbrainz': return 'bg-orange-500';
      case 'librefm': return 'bg-green-500';
      default: return 'bg-gray-500';
    }
  };

  return React.createElement('div', {
    className: 'bg-white rounded-xl p-4 shadow-sm border border-gray-200 hover:shadow-md hover:border-gray-300 transition-all'
  },
    // Header row with icon, name, and toggle
    React.createElement('div', { className: 'flex items-center justify-between mb-3' },
      React.createElement('div', { className: 'flex items-center gap-3' },
        // Service icon
        React.createElement('div', {
          className: `w-10 h-10 rounded-lg flex items-center justify-center ${getScrobblerColor()}`
        },
          React.createElement('span', { className: 'text-white text-lg font-bold' },
            scrobbler.name[0]
          )
        ),
        // Service name and connection status
        React.createElement('div', null,
          React.createElement('h3', { className: 'font-medium text-gray-900' }, scrobbler.name),
          isConnected && config?.username && React.createElement('p', {
            className: 'text-sm text-gray-500'
          }, `Connected as ${config.username}`)
        )
      ),
      // Enabled toggle (only when connected)
      isConnected && React.createElement('button', {
        onClick: handleToggleEnabled,
        className: `relative w-11 h-6 rounded-full transition-colors ${config?.enabled ? 'bg-purple-600' : 'bg-gray-300'}`
      },
        React.createElement('span', {
          className: `absolute top-0.5 left-0.5 w-5 h-5 bg-white rounded-full shadow transition-transform ${config?.enabled ? 'translate-x-5' : 'translate-x-0'}`
        })
      )
    ),

    // Error message
    error && React.createElement('div', {
      className: 'mb-3 p-2 bg-red-50 text-red-600 text-sm rounded-lg'
    }, error),

    // Connection UI
    !isConnected ? React.createElement('div', { className: 'space-y-3' },
      // ListenBrainz token input
      scrobbler.id === 'listenbrainz' && React.createElement('div', null,
        React.createElement('label', { className: 'block text-sm text-gray-600 mb-1' },
          'User Token',
          React.createElement('a', {
            href: '#',
            onClick: (e) => {
              e.preventDefault();
              window.electron.shell.openExternal('https://listenbrainz.org/settings/');
            },
            className: 'ml-2 text-purple-600 hover:underline'
          }, 'Get token')
        ),
        React.createElement('input', {
          type: 'text',
          value: tokenInput,
          onChange: (e) => setTokenInput(e.target.value),
          placeholder: 'Enter your ListenBrainz token',
          className: 'w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent'
        })
      ),

      // Connect button
      React.createElement('button', {
        onClick: handleConnect,
        disabled: connecting || (scrobbler.id === 'listenbrainz' && !tokenInput),
        className: 'w-full py-2 px-4 bg-purple-600 text-white rounded-lg font-medium hover:bg-purple-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors'
      }, connecting ? 'Connecting...' : 'Connect'),

      // Complete Authorization button (for OAuth services with pending token)
      config?.pendingToken && React.createElement('button', {
        onClick: handleCompleteAuth,
        disabled: connecting,
        className: 'w-full py-2 px-4 bg-green-600 text-white rounded-lg font-medium hover:bg-green-700 disabled:opacity-50 transition-colors'
      }, connecting ? 'Completing...' : 'Complete Authorization')
    ) : (
      // Disconnect button (when connected)
      React.createElement('button', {
        onClick: handleDisconnect,
        className: 'w-full py-2 px-4 bg-gray-100 text-gray-700 rounded-lg font-medium hover:bg-gray-200 transition-colors'
      }, 'Disconnect')
    )
  );
});

// RelatedArtistCard component - Shows artist image with name below
const RelatedArtistCard = ({ artist, getArtistImage, onNavigate }) => {
  // undefined = loading, null = no image found, string = image URL
  const [imageUrl, setImageUrl] = useState(undefined);

  // Generate unique pattern for this artist (memoized)
  const pattern = useMemo(() => generateArtistPattern(artist.name), [artist.name]);

  useEffect(() => {
    let cancelled = false;
    setImageUrl(undefined); // Reset to loading state on artist change
    const loadImage = async () => {
      const result = await getArtistImage(artist.name);
      if (!cancelled) {
        setImageUrl(result?.url || null); // null = no image, string = image URL
      }
    };
    loadImage();
    return () => { cancelled = true; };
    // Note: getArtistImage excluded from deps - function identity changes but behavior doesn't
  }, [artist.name]);

  return React.createElement('button', {
    onClick: onNavigate,
    className: 'text-left group cursor-grab active:cursor-grabbing',
    draggable: true,
    onDragStart: (e) => {
      e.dataTransfer.effectAllowed = 'copy';
      e.dataTransfer.setData('text/plain', JSON.stringify({
        type: 'artist',
        artist: {
          id: (artist.name || 'unknown').toLowerCase().replace(/[^a-z0-9-]/g, ''),
          name: artist.name,
          image: imageUrl
        }
      }));
    },
    onContextMenu: (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (window.electron?.contextMenu?.showTrackMenu) {
        window.electron.contextMenu.showTrackMenu({
          type: 'artist',
          artist: {
            id: (artist.name || 'unknown').toLowerCase().replace(/[^a-z0-9-]/g, ''),
            name: artist.name,
            image: imageUrl
          }
        });
      }
    }
  },
    // Artist image square - gray bg while loading, pattern only when no image found
    React.createElement('div', {
      className: 'w-full aspect-square mb-2 relative overflow-hidden rounded-lg',
      style: { background: imageUrl === null ? pattern.gradient : '#e5e7eb' }
    },
      // Loading shimmer (only while fetching - imageUrl is undefined)
      imageUrl === undefined && React.createElement('div', {
        className: 'absolute inset-0 bg-gradient-to-r from-gray-300 via-gray-200 to-gray-300 animate-shimmer',
        style: { backgroundSize: '200% 100%' }
      }),
      // Image (fades in when loaded - imageUrl is a string)
      typeof imageUrl === 'string' && React.createElement('img', {
        src: imageUrl,
        alt: artist.name,
        className: 'absolute inset-0 w-full h-full object-cover transition-opacity duration-300',
        style: { opacity: 0 },
        ref: (el) => { if (el && el.complete && el.naturalWidth > 0) el.style.opacity = '1'; },
        onLoad: (e) => { e.target.style.opacity = '1'; }
      }),
      // Initials fallback when no image found (imageUrl is null)
      imageUrl === null && React.createElement('div', {
        className: 'absolute inset-0 flex items-center justify-center',
        style: { color: pattern.textColor, opacity: 0.4 }
      },
        React.createElement('span', {
          className: 'font-bold tracking-wider',
          style: { fontSize: '2rem', textShadow: '0 2px 8px rgba(0,0,0,0.3)' }
        }, pattern.initials)
      )
    ),
    // Artist name
    React.createElement('div', { className: 'text-sm font-medium text-gray-900 truncate' }, artist.name)
  );
};

// SearchArtistCard component - Square card design with rounded corners
const SearchArtistCard = ({ artist, getArtistImage, onClick, onContextMenu, onPlayTopTracks, onAddToQueue, itemWidth, animationDelay = 0 }) => {
  // undefined = loading, null = no image found, string = image URL
  const [imageUrl, setImageUrl] = useState(undefined);

  // Generate unique pattern for this artist (memoized)
  const pattern = useMemo(() => generateArtistPattern(artist.name), [artist.name]);

  useEffect(() => {
    let cancelled = false;
    setImageUrl(undefined); // Reset to loading state on artist change
    const loadImage = async () => {
      const result = await getArtistImage(artist.name);
      if (!cancelled) {
        setImageUrl(result?.url || null); // null = no image, string = image URL
      }
    };
    loadImage();
    return () => { cancelled = true; };
  }, [artist.name]);

  return React.createElement('div', {
    onClick: onClick,
    className: 'bg-white rounded-lg overflow-hidden hover:shadow-lg transition-shadow cursor-pointer group release-card card-fade-up flex-shrink-0',
    style: { animationDelay: `${animationDelay}ms`, width: itemWidth || 160 },
    draggable: true,
    onDragStart: (e) => {
      e.dataTransfer.effectAllowed = 'copy';
      e.dataTransfer.setData('text/plain', JSON.stringify({
        type: 'artist',
        artist: {
          id: (artist.name || 'unknown').toLowerCase().replace(/[^a-z0-9-]/g, ''),
          name: artist.name,
          image: imageUrl
        }
      }));
    },
    onContextMenu: (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (onContextMenu) {
        onContextMenu(artist);
      }
    }
  },
    // Square image container - gray bg while loading, pattern only when no image found
    React.createElement('div', {
      className: 'aspect-square relative group/art',
      style: { background: imageUrl === null ? pattern.gradient : '#e5e7eb' }
    },
      // Initials overlay (only show when no image found - imageUrl is null)
      imageUrl === null && React.createElement('div', {
        className: 'absolute inset-0 flex items-center justify-center',
        style: { color: pattern.textColor, opacity: 0.4 }
      },
        React.createElement('span', {
          className: 'font-bold tracking-wider',
          style: { fontSize: '2.5rem', textShadow: '0 2px 8px rgba(0,0,0,0.3)' }
        }, pattern.initials)
      ),
      // Image (fades in on load - imageUrl is a string)
      typeof imageUrl === 'string' && React.createElement('img', {
        src: imageUrl,
        alt: artist.name,
        className: 'absolute inset-0 w-full h-full object-cover transition-all duration-300 group-hover/art:scale-105',
        style: { opacity: 0 },
        ref: (el) => { if (el && el.complete && el.naturalWidth > 0) el.style.opacity = '1'; },
        onLoad: (e) => { e.target.style.opacity = '1'; },
        onError: (e) => { e.target.style.display = 'none'; }
      }),
      // Shimmer loading state (only while fetching - imageUrl is undefined)
      imageUrl === undefined && React.createElement('div', {
        className: 'absolute inset-0 bg-gradient-to-r from-gray-300 via-gray-200 to-gray-300 animate-shimmer',
        style: { backgroundSize: '200% 100%' }
      }),
      // Hover overlay with action buttons (Play, Queue)
      React.createElement('div', {
        className: 'absolute inset-0 bg-black/50 opacity-0 group-hover/art:opacity-100 transition-opacity duration-200 flex items-center justify-center gap-3',
        style: { pointerEvents: 'auto' }
      },
        // Play top 10 button (center, larger)
        onPlayTopTracks && React.createElement('button', {
          onClick: (e) => {
            e.stopPropagation();
            onPlayTopTracks(artist);
          },
          className: 'w-12 h-12 bg-white rounded-full flex items-center justify-center shadow-lg transition-all hover:scale-110',
          style: { border: 'none', cursor: 'pointer' },
          title: 'Play top 10 tracks'
        },
          React.createElement(PlayTop10Icon, { size: 26, className: 'text-gray-800' })
        ),
        // Add top 10 to Queue button
        onAddToQueue && React.createElement('button', {
          onClick: (e) => {
            e.stopPropagation();
            onAddToQueue(artist);
          },
          className: 'w-10 h-10 rounded-full flex items-center justify-center transition-all hover:scale-110',
          style: { backgroundColor: 'rgba(255, 255, 255, 0.15)', color: '#ffffff', border: 'none', cursor: 'pointer' },
          onMouseEnter: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.25)',
          onMouseLeave: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.15)',
          title: 'Add top 10 to queue'
        },
          React.createElement(QueueTop10Icon, { size: 20 })
        )
      )
    ),
    // Artist name section
    React.createElement('div', { className: 'p-3' },
      React.createElement('p', {
        className: 'font-medium text-gray-900 truncate text-sm'
      }, artist.name)
    )
  );
};

// Search history item for empty search page
const SearchHistoryItem = ({ entry, onQueryClick, onResultClick, onRemove }) => {
  const { query, selectedResult, timestamp } = entry;

  // Click handler for the whole row - navigate to result if available, otherwise search
  const handleRowClick = () => {
    if (selectedResult) {
      onResultClick(selectedResult);
    } else {
      onQueryClick(query);
    }
  };

  return React.createElement('div', {
    className: 'flex items-center gap-3 p-3 rounded-lg hover:bg-gray-50 group transition-colors cursor-pointer',
    onClick: handleRowClick
  },
    // Result thumbnail or search icon
    selectedResult?.imageUrl ?
      React.createElement('img', {
        src: selectedResult.imageUrl,
        className: 'w-12 h-12 rounded object-cover',
        onError: (e) => { e.target.style.display = 'none'; }
      }) :
      React.createElement('div', {
        className: 'w-12 h-12 rounded bg-gray-100 flex items-center justify-center'
      },
        React.createElement('svg', {
          className: 'w-5 h-5 text-gray-400',
          fill: 'none',
          stroke: 'currentColor',
          viewBox: '0 0 24 24'
        },
          React.createElement('path', {
            strokeLinecap: 'round',
            strokeLinejoin: 'round',
            strokeWidth: 2,
            d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z'
          })
        )
      ),

    // Query and result info
    React.createElement('div', { className: 'flex-1 min-w-0' },
      React.createElement('button', {
        onClick: (e) => { e.stopPropagation(); onQueryClick(query); },
        className: 'text-sm font-medium text-gray-900 hover:text-blue-600 truncate block text-left w-full'
      }, `"${query}"`),
      selectedResult && React.createElement('button', {
        onClick: (e) => { e.stopPropagation(); onResultClick(selectedResult); },
        className: 'text-xs text-gray-500 hover:text-blue-600 truncate block text-left w-full'
      },
        `${selectedResult.type}: ${selectedResult.name}${selectedResult.artist ? ` â€¢ ${selectedResult.artist}` : ''}`
      )
    ),

    // Remove button
    React.createElement('button', {
      onClick: (e) => { e.stopPropagation(); onRemove(query); },
      className: 'opacity-0 group-hover:opacity-100 p-1 text-gray-400 hover:text-red-500 transition-opacity'
    },
      React.createElement('svg', {
        className: 'w-4 h-4',
        fill: 'none',
        stroke: 'currentColor',
        viewBox: '0 0 24 24'
      },
        React.createElement('path', {
          strokeLinecap: 'round',
          strokeLinejoin: 'round',
          strokeWidth: 2,
          d: 'M6 18L18 6M6 6l12 12'
        })
      )
    )
  );
};

// CollectionArtistCard component - Square card design with rounded corners
const CollectionArtistCard = ({ artist, getArtistImage, onNavigate, onPlayTopTracks, onAddToQueue, animationDelay = 0 }) => {
  // States: undefined (fetching), null (no image found), string (URL)
  const [imageUrl, setImageUrl] = useState(undefined);

  // Generate unique pattern for this artist (memoized)
  const pattern = useMemo(() => generateArtistPattern(artist.name), [artist.name]);

  useEffect(() => {
    let cancelled = false;
    setImageUrl(undefined); // Reset to loading state immediately on artist change
    const loadImage = async () => {
      const result = await getArtistImage(artist.name);
      if (!cancelled) {
        setImageUrl(result?.url || null); // null if not found
      }
    };
    loadImage();
    return () => { cancelled = true; };
  }, [artist.name]);

  return React.createElement('div', {
    onClick: onNavigate,
    className: 'bg-white rounded-lg overflow-hidden hover:shadow-lg transition-shadow cursor-pointer group release-card card-fade-up',
    style: { animationDelay: `${animationDelay}ms` }
  },
    // Square image container - gray bg while loading, pattern only when no image found
    React.createElement('div', {
      className: 'aspect-square relative group/art',
      style: { background: imageUrl === null ? pattern.gradient : '#e5e7eb' }
    },
      // Initials overlay (only show when no image found, not while loading)
      imageUrl === null && React.createElement('div', {
        className: 'absolute inset-0 flex items-center justify-center',
        style: { color: pattern.textColor, opacity: 0.4 }
      },
        React.createElement('span', {
          className: 'font-bold tracking-wider',
          style: { fontSize: '3rem', textShadow: '0 2px 8px rgba(0,0,0,0.3)' }
        }, pattern.initials)
      ),
      // Image (fades in on load)
      imageUrl && typeof imageUrl === 'string' && React.createElement('img', {
        src: imageUrl,
        alt: artist.name,
        className: 'absolute inset-0 w-full h-full object-cover transition-all duration-300 group-hover/art:scale-105',
        style: { opacity: 0 },
        ref: (el) => { if (el && el.complete && el.naturalWidth > 0) el.style.opacity = '1'; },
        onLoad: (e) => { e.target.style.opacity = '1'; },
        onError: (e) => { e.target.style.display = 'none'; }
      }),
      // Shimmer loading state (only while fetching)
      imageUrl === undefined && React.createElement('div', {
        className: 'absolute inset-0 bg-gradient-to-r from-gray-300 via-gray-200 to-gray-300 animate-shimmer',
        style: { backgroundSize: '200% 100%' }
      }),
      // Hover overlay with action buttons (Play, Queue)
      React.createElement('div', {
        className: 'absolute inset-0 bg-black/50 opacity-0 group-hover/art:opacity-100 transition-opacity duration-200 flex items-center justify-center gap-3',
        style: { pointerEvents: 'auto' }
      },
        // Play top 10 button (center, larger)
        onPlayTopTracks && React.createElement('button', {
          onClick: (e) => {
            e.stopPropagation();
            onPlayTopTracks(artist);
          },
          className: 'w-12 h-12 bg-white rounded-full flex items-center justify-center shadow-lg transition-all hover:scale-110',
          style: { border: 'none', cursor: 'pointer' },
          title: 'Play top 10 tracks'
        },
          React.createElement(PlayTop10Icon, { size: 26, className: 'text-gray-800' })
        ),
        // Add top 10 to Queue button
        onAddToQueue && React.createElement('button', {
          onClick: (e) => {
            e.stopPropagation();
            onAddToQueue(artist);
          },
          className: 'w-10 h-10 rounded-full flex items-center justify-center transition-all hover:scale-110',
          style: { backgroundColor: 'rgba(255, 255, 255, 0.15)', color: '#ffffff', border: 'none', cursor: 'pointer' },
          onMouseEnter: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.25)',
          onMouseLeave: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.15)',
          title: 'Add top 10 to queue'
        },
          React.createElement(QueueTop10Icon, { size: 20 })
        )
      )
    ),
    // Artist name and track count section
    React.createElement('div', { className: 'p-3' },
      React.createElement('p', {
        className: 'font-medium text-gray-900 truncate text-sm transition-colors'
      }, artist.name),
      // Track count (only show if > 0)
      artist.trackCount > 0 && React.createElement('p', {
        className: 'text-xs text-gray-400 mt-1'
      }, `${artist.trackCount} track${artist.trackCount !== 1 ? 's' : ''}`)
    )
  );
};

// CollectionAlbumCard component - Cinematic Light design
const CollectionAlbumCard = ({ album, getAlbumArt, onNavigate, animationDelay = 0 }) => {
  // States: undefined (fetching), null (no art found), string (URL)
  const [imageUrl, setImageUrl] = useState(album.art || undefined);

  useEffect(() => {
    // If we already have embedded art, don't fetch
    if (album.art) {
      setImageUrl(album.art);
      return;
    }

    let cancelled = false;
    const loadImage = async () => {
      setImageUrl(undefined); // Loading state
      const artUrl = await getAlbumArt(album.artist, album.title);
      if (!cancelled) {
        setImageUrl(artUrl || null); // null if not found
      }
    };
    loadImage();
    return () => { cancelled = true; };
  }, [album.artist, album.title, album.art]);

  return React.createElement('button', {
    onClick: onNavigate,
    className: 'group text-left release-card card-fade-up',
    style: {
      padding: '10px',
      borderRadius: '10px',
      backgroundColor: '#ffffff',
      border: 'none',
      boxShadow: '0 1px 3px rgba(0, 0, 0, 0.05), 0 4px 12px rgba(0, 0, 0, 0.03)',
      animationDelay: `${animationDelay}ms`
    }
  },
    // Album art - shimmer while fetching, dark placeholder if no art
    React.createElement('div', {
      className: `album-art-container ${imageUrl === undefined ? 'animate-shimmer' : ''}`,
      style: {
        width: '100%',
        aspectRatio: '1',
        borderRadius: '6px',
        marginBottom: '10px',
        overflow: 'hidden',
        position: 'relative',
        background: imageUrl === null
          ? 'linear-gradient(145deg, #1f1f1f 0%, #2d2d2d 50%, #1a1a1a 100%)'
          : imageUrl === undefined
            ? 'linear-gradient(to right, #f3f4f6, #e5e7eb, #f3f4f6)'
            : '#f3f4f6',
        backgroundSize: imageUrl === undefined ? '200% 100%' : undefined
      }
    },
      // Show image when URL exists (fades in when loaded)
      imageUrl && typeof imageUrl === 'string' && React.createElement('img', {
        src: imageUrl,
        alt: album.title,
        style: {
          width: '100%',
          height: '100%',
          objectFit: 'cover',
          opacity: 0,
          transition: 'opacity 0.35s ease-out'
        },
        ref: (el) => { if (el && el.complete && el.naturalWidth > 0) el.style.opacity = '1'; },
        onLoad: (e) => { e.target.style.opacity = '1'; },
        onError: (e) => { e.target.style.display = 'none'; }
      }),
      // Placeholder icon when no art found
      imageUrl === null && React.createElement('div', {
        style: { width: '100%', height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center' }
      },
        React.createElement('svg', {
          style: { width: '36px', height: '36px', color: 'rgba(255, 255, 255, 0.2)' },
          fill: 'none',
          viewBox: '0 0 24 24',
          stroke: 'currentColor'
        },
          React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 1.5, d: 'M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3' })
        )
      )
    ),
    // Album title
    React.createElement('h3', {
      style: {
        fontWeight: '500',
        fontSize: '13px',
        color: '#1f2937',
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        whiteSpace: 'nowrap',
        marginBottom: '2px',
        transition: 'color 0.2s ease'
      },
      className: ''
    }, album.title),
    // Artist name
    React.createElement('p', {
      style: { fontSize: '12px', color: '#6b7280', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }
    }, album.artist),
    // Year and track count
    React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '6px', marginTop: '3px' } },
      album.year && React.createElement('span', {
        style: { fontSize: '11px', color: '#9ca3af' }
      }, album.year),
      React.createElement('span', {
        style: { fontSize: '11px', color: '#9ca3af' }
      }, `${album.trackCount} track${album.trackCount !== 1 ? 's' : ''}`)
    )
  );
};

// FriendMiniPlaybar component - shows friend's current track with album art lookup
const FriendMiniPlaybar = ({ track, getAlbumArt, onPlay, onContextMenu }) => {
  // States: undefined (fetching), null (no art found), string (URL)
  // Don't use Last.fm placeholder art as initial state - only use our cache
  const [artUrl, setArtUrl] = useState(undefined);
  const [isOverflowing, setIsOverflowing] = useState(false);
  const textRef = useRef(null);
  const containerRef = useRef(null);

  useEffect(() => {
    // Always try our cache system - never use Last.fm placeholder art
    if (!track.album || !track.artist) {
      // No album/artist info - show generic placeholder
      setArtUrl(null);
      return;
    }

    let cancelled = false;
    const loadArt = async () => {
      const fetchedArt = await getAlbumArt(track.artist, track.album);
      if (!cancelled) {
        // Only use our cached art, show generic placeholder if not found
        setArtUrl(fetchedArt || null);
      }
    };
    loadArt();
    return () => { cancelled = true; };
  }, [track.name, track.artist, track.album]);

  // Check if text overflows container (after render completes)
  useEffect(() => {
    // Use requestAnimationFrame to ensure DOM is fully rendered and measured
    const checkOverflow = () => {
      if (textRef.current && containerRef.current) {
        const textWidth = textRef.current.scrollWidth;
        const containerWidth = containerRef.current.clientWidth;
        setIsOverflowing(textWidth > containerWidth);
      }
    };

    // Run after paint to get accurate measurements
    const rafId = requestAnimationFrame(() => {
      requestAnimationFrame(checkOverflow);
    });

    return () => cancelAnimationFrame(rafId);
  }, [track.name, track.artist]);

  return React.createElement('div', {
    className: 'mt-1 flex items-center bg-gray-800 rounded cursor-pointer hover:bg-gray-700 transition-colors pr-2',
    style: { maxWidth: '180px', height: '20px' },
    onClick: onPlay,
    onContextMenu: onContextMenu
  },
    // Mini album art
    React.createElement('div', {
      className: 'flex-shrink-0',
      style: { width: '20px', height: '20px' }
    },
      artUrl
        ? React.createElement('img', {
            src: artUrl,
            alt: '',
            className: 'w-full h-full object-cover rounded-l'
          })
        : React.createElement('div', {
            className: 'w-full h-full bg-gray-600 rounded-l flex items-center justify-center'
          },
            React.createElement('span', { className: 'text-gray-400', style: { fontSize: '8px' } }, '\u266A')
          )
    ),
    // Track info - only scrolls if overflowing
    React.createElement('div', {
      ref: containerRef,
      className: `flex-1 min-w-0 pl-2 flex items-center ${isOverflowing ? 'marquee-container' : ''}`,
      style: { overflow: 'hidden', height: '100%' }
    },
      React.createElement('span', {
        ref: textRef,
        className: `whitespace-nowrap inline-block ${isOverflowing ? 'animate-marquee' : ''}`,
        style: { fontSize: '10px', lineHeight: '20px' }
      },
        React.createElement('span', { className: 'text-white font-medium' }, track.name),
        React.createElement('span', { className: 'text-gray-400' }, ` - ${track.artist}`)
      )
    )
  );
};

// ReleaseCard component - Cinematic Light design
const ReleaseCard = ({ release, currentArtist, fetchReleaseData, onContextMenu, onHoverFetch, isVisible = true, animationDelay = 0, onPlay, onAddToQueue, onAddToPlaylist, prefetchedReleasesRef, onCardRef }) => {
  const year = release.date ? release.date.split('-')[0] : '';
  const [imageFailed, setImageFailed] = React.useState(false);
  const [imageLoaded, setImageLoaded] = React.useState(false);

  // Reset image states when album art URL changes
  React.useEffect(() => {
    setImageFailed(false);
    setImageLoaded(false);
  }, [release.albumArt]);

  const handleDragStart = (e) => {
    e.dataTransfer.effectAllowed = 'copy';
    const albumData = {
      type: 'album',
      album: {
        id: `${currentArtist?.name || release.artist?.name || 'unknown'}-${release.title || 'untitled'}`.toLowerCase().replace(/[^a-z0-9-]/g, ''),
        title: release.title,
        artist: currentArtist?.name || release.artist?.name,
        year: year ? parseInt(year) : null,
        art: release.albumArt
      }
    };
    e.dataTransfer.setData('text/plain', JSON.stringify(albumData));
  };

  const handleClick = () => {
    console.log('ðŸŽµ Card clicked:', release.title);
    fetchReleaseData(release, currentArtist);
  };

  // Badge colors - refined palette matching app aesthetic
  const badgeStyles = {
    album: { bg: 'rgba(17, 24, 39, 0.06)', color: '#4b5563' },
    ep: { bg: 'rgba(233, 30, 99, 0.08)', color: '#db2777' },
    single: { bg: 'rgba(139, 92, 246, 0.08)', color: '#7c3aed' },
    live: { bg: 'rgba(245, 158, 11, 0.08)', color: '#d97706' },
    compilation: { bg: 'rgba(20, 184, 166, 0.08)', color: '#0d9488' }
  };
  const badge = badgeStyles[release.releaseType] || badgeStyles.album;

  return React.createElement('button', {
    className: `no-drag release-card card-fade-up`,
    draggable: true,
    onDragStart: handleDragStart,
    'data-release-id': release.id,
    ref: onCardRef,
    style: {
      width: '100%',
      textAlign: 'left',
      display: isVisible ? 'block' : 'none',
      backgroundColor: '#ffffff',
      borderRadius: '10px',
      padding: '10px',
      cursor: 'grab',
      border: 'none',
      boxShadow: '0 1px 3px rgba(0, 0, 0, 0.05), 0 4px 12px rgba(0, 0, 0, 0.03)',
      animationDelay: `${animationDelay}ms`
    },
    onClick: handleClick,
    onContextMenu: (e) => {
      e.preventDefault();
      if (onContextMenu) {
        onContextMenu(release);
      }
    },
    onMouseEnter: (e) => {
      // Prefetch release tracks on hover
      if (onHoverFetch) {
        onHoverFetch(release);
      }
    }
  },
    // Album art container with inner shadow overlay
    React.createElement('div', {
      className: `album-art-container group/art ${(release.albumArt === null || imageFailed || imageLoaded) ? '' : 'animate-shimmer'}`,
      style: {
        width: '100%',
        aspectRatio: '1',
        borderRadius: '6px',
        background: release.albumArt === null || imageFailed
          ? 'linear-gradient(145deg, #1f1f1f 0%, #2d2d2d 50%, #1a1a1a 100%)'
          : imageLoaded
            ? '#f3f4f6'
            : 'linear-gradient(to right, #f3f4f6, #e5e7eb, #f3f4f6)',
        backgroundSize: (release.albumArt === null || imageFailed || imageLoaded) ? undefined : '200% 100%',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        marginBottom: '10px',
        overflow: 'hidden',
        position: 'relative'
      }
    },
      // Album art image with fade-in
      release.albumArt && !imageFailed && React.createElement('img', {
        src: release.albumArt,
        alt: release.title,
        style: {
          width: '100%',
          height: '100%',
          objectFit: 'cover',
          pointerEvents: 'none',
          position: 'absolute',
          top: 0,
          left: 0,
          opacity: imageLoaded ? 1 : 0,
          transition: 'opacity 0.35s ease-out'
        },
        ref: (el) => {
          if (el && el.complete && el.naturalWidth > 0 && !imageLoaded) {
            setImageLoaded(true);
          }
        },
        onLoad: () => setImageLoaded(true),
        onError: () => setImageFailed(true)
      }),

      // Music icon placeholder - refined dark style
      (release.albumArt === null || imageFailed) && React.createElement('svg', {
        style: {
          width: '36px',
          height: '36px',
          color: 'rgba(255, 255, 255, 0.2)',
          pointerEvents: 'none'
        },
        fill: 'none',
        viewBox: '0 0 24 24',
        stroke: 'currentColor',
        strokeWidth: 1.5
      },
        React.createElement('path', {
          strokeLinecap: 'round',
          strokeLinejoin: 'round',
          d: 'M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3'
        })
      ),

      // Hover overlay with action buttons (Add to Playlist, Play, Queue)
      (onPlay || onAddToQueue || onAddToPlaylist) && React.createElement('div', {
        className: 'absolute inset-0 bg-black/50 opacity-0 group-hover/art:opacity-100 transition-opacity duration-200 flex items-center justify-center gap-3',
        style: { pointerEvents: 'auto' }
      },
        // Add to Playlist button
        onAddToPlaylist && React.createElement('button', {
          onClick: (e) => {
            e.stopPropagation();
            onAddToPlaylist(release);
          },
          className: 'w-10 h-10 rounded-full flex items-center justify-center transition-all hover:scale-110',
          style: { backgroundColor: 'rgba(255, 255, 255, 0.15)', color: '#ffffff', border: 'none', cursor: 'pointer' },
          onMouseEnter: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.25)',
          onMouseLeave: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.15)',
          title: 'Add to Playlist'
        },
          React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor', strokeWidth: 2 },
            React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', d: 'M12 4v16m8-8H4' })
          )
        ),
        // Play button (center, larger)
        onPlay && React.createElement('button', {
          onClick: (e) => {
            e.stopPropagation();
            onPlay(release);
          },
          className: 'w-12 h-12 bg-white rounded-full flex items-center justify-center shadow-lg transition-all hover:scale-110',
          style: { border: 'none', cursor: 'pointer' },
          title: 'Play'
        },
          React.createElement(Play, { size: 22, className: 'text-gray-800 ml-0.5' })
        ),
        // Add to Queue button
        onAddToQueue && React.createElement('button', {
          onClick: (e) => {
            e.stopPropagation();
            onAddToQueue(release);
          },
          className: 'w-10 h-10 rounded-full flex items-center justify-center transition-all hover:scale-110',
          style: { backgroundColor: 'rgba(255, 255, 255, 0.15)', color: '#ffffff', border: 'none', cursor: 'pointer' },
          onMouseEnter: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.25)',
          onMouseLeave: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.15)',
          title: 'Add to Queue'
        },
          React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor', strokeWidth: 2 },
            React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', d: 'M4 6h16M4 12h16M4 18h7' })
          )
        )
      )
    ),

    // Title - refined typography
    React.createElement('h3', {
      style: {
        fontWeight: '500',
        fontSize: '13px',
        lineHeight: '1.35',
        marginBottom: '3px',
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        whiteSpace: 'nowrap',
        color: '#1f2937',
        letterSpacing: '0.005em',
        pointerEvents: 'none'
      },
      title: release.title
    }, release.title),

    // Year and badge row
    React.createElement('div', {
      style: {
        display: 'flex',
        alignItems: 'center',
        gap: '6px',
        pointerEvents: 'none'
      }
    },
      // Year
      year && React.createElement('span', {
        style: {
          fontSize: '11px',
          color: '#9ca3af',
          fontWeight: '400'
        }
      }, year),
      // Badge - refined style
      React.createElement('span', {
        className: 'release-badge',
        style: {
          backgroundColor: badge.bg,
          color: badge.color
        }
      }, release.releaseType.toUpperCase())
    )
  );
};

// ReleasePage component - Shows full album/EP/single with tracklist
const ReleasePage = ({
  release,
  handleSearch,
  handlePlay,
  onTrackPlay,
  onTrackContextMenu,
  trackSources = {},
  resolvers = [],
  // Drag and drop props (for adding tracks to playlists)
  onDragStart,
  onDragEnd,
  // Now playing props
  currentTrack,
  playbackContext,
  isPlaying,
  // Visibility tracking props for resolution scheduler
  releaseTrackRowRefs,
  releaseObserverRef,
  // Album action props (hover buttons)
  onAlbumPlay,
  onAlbumAddToQueue,
  onAlbumAddToPlaylist
}) => {
  const formatDuration = (ms) => {
    if (!ms) return '';
    const totalSeconds = Math.floor(ms / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
  };

  // Format full date nicely
  const formatDate = (dateStr) => {
    if (!dateStr) return 'Unknown';
    try {
      const date = new Date(dateStr);
      return date.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
    } catch {
      return dateStr;
    }
  };

  // Use a ref to track container width for responsive layout
  const [containerWidth, setContainerWidth] = React.useState(800);
  const containerRef = React.useRef(null);

  React.useEffect(() => {
    if (!containerRef.current) return;
    const resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        setContainerWidth(entry.contentRect.width);
      }
    });
    resizeObserver.observe(containerRef.current);
    return () => resizeObserver.disconnect();
  }, []);

  // Responsive sizes based on container width
  const isCompact = containerWidth < 700;
  const albumArtSize = isCompact ? 160 : 192; // 160px or 192px (w-40 or w-48)
  const columnWidth = isCompact ? 180 : 240;

  return React.createElement('div', { ref: containerRef, className: 'flex gap-0 p-6' },
    // LEFT COLUMN: Album card - matching ReleaseCard styling
    (() => {
      const year = release.date ? release.date.split('-')[0] : '';
      // Badge colors - matching ReleaseCard palette
      const badgeStyles = {
        album: { bg: 'rgba(17, 24, 39, 0.06)', color: '#4b5563' },
        ep: { bg: 'rgba(233, 30, 99, 0.08)', color: '#db2777' },
        single: { bg: 'rgba(139, 92, 246, 0.08)', color: '#7c3aed' },
        live: { bg: 'rgba(245, 158, 11, 0.08)', color: '#d97706' },
        compilation: { bg: 'rgba(20, 184, 166, 0.08)', color: '#0d9488' }
      };
      const releaseType = release.releaseType || 'album';
      const badge = badgeStyles[releaseType] || badgeStyles.album;

      return React.createElement('div', {
        className: 'flex-shrink-0 pr-4 md:pr-8',
        style: {
          width: `${columnWidth}px`,
          transition: 'width 300ms ease'
        }
      },
        // Card wrapper - matching ReleaseCard styling
        React.createElement('div', {
          draggable: true,
          onDragStart: (e) => {
            e.dataTransfer.effectAllowed = 'copy';
            const albumData = {
              type: 'album',
              album: {
                id: `${release.artist?.name || 'unknown'}-${release.title || 'untitled'}`.toLowerCase().replace(/[^a-z0-9-]/g, ''),
                title: release.title,
                artist: release.artist?.name,
                year: year ? parseInt(year) : null,
                art: release.albumArt
              }
            };
            e.dataTransfer.setData('text/plain', JSON.stringify(albumData));
          },
          className: 'no-drag cursor-grab active:cursor-grabbing',
          style: {
            width: `${albumArtSize}px`,
            backgroundColor: '#ffffff',
            borderRadius: '10px',
            padding: '10px',
            boxShadow: '0 1px 3px rgba(0, 0, 0, 0.05), 0 4px 12px rgba(0, 0, 0, 0.03)',
            transition: 'width 300ms ease'
          }
        },
          // Album art container
          React.createElement('div', {
            className: 'album-art-container group/art',
            style: {
              width: '100%',
              aspectRatio: '1',
              borderRadius: '6px',
              background: 'linear-gradient(145deg, #1f1f1f 0%, #2d2d2d 50%, #1a1a1a 100%)',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              marginBottom: '10px',
              overflow: 'hidden',
              position: 'relative'
            }
          },
            // Image (absolute positioned, fades in on load, hides on error)
            release.albumArt && React.createElement('img', {
              src: release.albumArt,
              alt: release.title,
              style: {
                width: '100%',
                height: '100%',
                objectFit: 'cover',
                pointerEvents: 'none',
                position: 'absolute',
                top: 0,
                left: 0,
                opacity: 0,
                transition: 'opacity 0.35s ease-out'
              },
              ref: (el) => { if (el && el.complete && el.naturalWidth > 0) el.style.opacity = '1'; },
              onLoad: (e) => { e.target.style.opacity = '1'; },
              onError: (e) => { e.target.style.display = 'none'; }
            }),
            // Placeholder icon (always behind) - dark theme
            React.createElement('svg', {
              style: {
                width: '36px',
                height: '36px',
                color: 'rgba(255, 255, 255, 0.2)',
                pointerEvents: 'none'
              },
              fill: 'none',
              viewBox: '0 0 24 24',
              stroke: 'currentColor',
              strokeWidth: 1.5
            },
              React.createElement('path', {
                strokeLinecap: 'round',
                strokeLinejoin: 'round',
                d: 'M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3'
              })
            ),

            // Hover overlay with action buttons (Add to Playlist, Play, Queue)
            (onAlbumPlay || onAlbumAddToQueue || onAlbumAddToPlaylist) && React.createElement('div', {
              className: 'absolute inset-0 bg-black/50 opacity-0 group-hover/art:opacity-100 transition-opacity duration-200 flex items-center justify-center gap-3',
              style: { pointerEvents: 'auto' }
            },
              // Add to Playlist button
              onAlbumAddToPlaylist && React.createElement('button', {
                onClick: (e) => {
                  e.stopPropagation();
                  onAlbumAddToPlaylist(release);
                },
                className: 'w-10 h-10 rounded-full flex items-center justify-center transition-all hover:scale-110',
                style: { backgroundColor: 'rgba(255, 255, 255, 0.15)', color: '#ffffff', border: 'none', cursor: 'pointer' },
                onMouseEnter: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.25)',
                onMouseLeave: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.15)',
                title: 'Add to Playlist'
              },
                React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor', strokeWidth: 2 },
                  React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', d: 'M12 4v16m8-8H4' })
                )
              ),
              // Play button (center, larger)
              onAlbumPlay && React.createElement('button', {
                onClick: (e) => {
                  e.stopPropagation();
                  onAlbumPlay(release);
                },
                className: 'w-12 h-12 bg-white rounded-full flex items-center justify-center shadow-lg transition-all hover:scale-110',
                style: { border: 'none', cursor: 'pointer' },
                title: 'Play'
              },
                React.createElement(Play, { size: 22, className: 'text-gray-800 ml-0.5' })
              ),
              // Add to Queue button
              onAlbumAddToQueue && React.createElement('button', {
                onClick: (e) => {
                  e.stopPropagation();
                  onAlbumAddToQueue(release);
                },
                className: 'w-10 h-10 rounded-full flex items-center justify-center transition-all hover:scale-110',
                style: { backgroundColor: 'rgba(255, 255, 255, 0.15)', color: '#ffffff', border: 'none', cursor: 'pointer' },
                onMouseEnter: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.25)',
                onMouseLeave: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.15)',
                title: 'Add to Queue'
              },
                React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor', strokeWidth: 2 },
                  React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', d: 'M4 6h16M4 12h16M4 18h7' })
                )
              )
            )
          ),

          // Title - matching ReleaseCard typography
          React.createElement('h3', {
            style: {
              fontWeight: '500',
              fontSize: '13px',
              lineHeight: '1.35',
              marginBottom: '3px',
              overflow: 'hidden',
              textOverflow: 'ellipsis',
              whiteSpace: 'nowrap',
              color: '#1f2937',
              letterSpacing: '0.005em',
              pointerEvents: 'none'
            },
            title: release.title
          }, release.title),

          // Year and badge row - matching ReleaseCard
          React.createElement('div', {
            style: {
              display: 'flex',
              alignItems: 'center',
              gap: '6px',
              pointerEvents: 'none'
            }
          },
            // Year
            year && React.createElement('span', {
              style: {
                fontSize: '11px',
                color: '#9ca3af',
                fontWeight: '400'
              }
            }, year),
            // Badge - matching ReleaseCard style
            React.createElement('span', {
              className: 'release-badge',
              style: {
                backgroundColor: badge.bg,
                color: badge.color
              }
            }, releaseType.toUpperCase())
          )
        ),

        // Additional metadata below card
        React.createElement('div', { className: 'mt-3 space-y-1', style: { paddingLeft: '2px' } },
          React.createElement('p', {
            className: 'text-gray-500',
            style: {
              fontSize: isCompact ? '0.75rem' : '0.875rem',
              transition: 'font-size 300ms ease'
            }
          }, formatDate(release.date)),
          React.createElement('p', {
            className: 'text-gray-500',
            style: {
              fontSize: isCompact ? '0.75rem' : '0.875rem',
              transition: 'font-size 300ms ease'
            }
          }, `${release.tracks.length.toString().padStart(2, '0')} Songs`)
        )
      );
    })(),

    // RIGHT COLUMN: Tracklist
    React.createElement('div', { className: 'flex-1 min-w-0' },
      release.tracks.length > 0 ?
        React.createElement('div', { className: 'space-y-0' },
          release.tracks.map((track, index) => {
            // Build track ID first, then use it to look up resolved sources
            const trackId = `${release.artist.name || 'unknown'}-${track.title || 'untitled'}-${release.title || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
            const sources = trackSources[trackId] || {};
            const availableResolvers = Object.keys(sources);

            // Build track object for drag/drop and playback
            const trackForDrag = {
              ...track,
              id: trackId,
              artist: release.artist.name,
              album: release.title,
              albumArt: release.albumArt,
              sources: sources
            };

            // Check if this track is currently playing from this album
            const isCurrentTrack = currentTrack?.id === trackId;
            const isNowPlaying = isCurrentTrack && playbackContext?.type === 'album' && playbackContext?.id === release.id;

            // Debug logging for first track only
            if (index === 0) {
              console.log('ðŸŽ¯ ReleasePage highlight check:', {
                trackId,
                currentTrackId: currentTrack?.id,
                isCurrentTrack,
                playbackContextType: playbackContext?.type,
                playbackContextId: playbackContext?.id,
                releaseId: release.id,
                isNowPlaying
              });
            }

            return React.createElement('div', {
              key: index,
              'data-track-id': trackId,
              ref: (el) => {
                if (releaseTrackRowRefs) {
                  if (el) {
                    releaseTrackRowRefs.current.set(trackId, el);
                    if (releaseObserverRef?.current) {
                      releaseObserverRef.current.observe(el);
                    }
                  } else {
                    releaseTrackRowRefs.current.delete(trackId);
                  }
                }
              },
              draggable: true,
              onDragStart: (e) => {
                e.dataTransfer.effectAllowed = 'copy';
                e.dataTransfer.setData('text/plain', JSON.stringify({ type: 'track', track: trackForDrag }));
                if (onDragStart) {
                  onDragStart(trackForDrag);
                }
              },
              onDragEnd: () => {
                if (onDragEnd) {
                  onDragEnd();
                }
              },
              className: `flex items-center gap-4 py-3 px-4 cursor-grab active:cursor-grabbing transition-all no-drag group ${isNowPlaying ? 'bg-purple-50' : 'hover:bg-gray-50/80'}`,
              style: {
                borderRadius: '8px',
                marginBottom: '2px'
              },
              onClick: () => {
                console.log('Track row clicked:', track.title);

                // Play track with sources if resolved
                if (availableResolvers.length > 0) {
                  // Build queue from remaining tracks (after this one)
                  const tracksAfter = release.tracks.slice(index + 1).map((t, i) => {
                    const tId = `${release.artist.name || 'unknown'}-${t.title || 'untitled'}-${release.title || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
                    const tSources = trackSources[tId] || {};
                    return {
                      ...t,
                      id: tId,
                      artist: release.artist.name,
                      album: release.title,
                      albumArt: release.albumArt,
                      sources: tSources
                    };
                  });

                  if (onTrackPlay) {
                    onTrackPlay(trackForDrag, tracksAfter);
                  } else {
                    handlePlay(trackForDrag);
                  }
                } else {
                  // No resolved sources yet, fall back to search
                  console.log('No resolved sources, searching...');
                  handleSearch(`${release.artist.name} ${track.title}`);
                }
              },
              onContextMenu: (e) => {
                e.preventDefault();
                if (onTrackContextMenu) {
                  onTrackContextMenu(trackForDrag);
                }
              }
            },
              // Track number or playing indicator
              React.createElement('span', {
                className: 'w-6 flex-shrink-0 text-right',
                style: {
                  pointerEvents: 'none',
                  fontSize: '12px',
                  fontWeight: '500',
                  color: isNowPlaying ? '#8b5cf6' : '#9ca3af'
                }
              }, isNowPlaying ? 'â–¶' : String(track.position).padStart(2, '0')),

              // Track title
              React.createElement('span', {
                className: 'flex-1 truncate transition-colors',
                style: {
                  pointerEvents: 'none',
                  fontSize: '13px',
                  fontWeight: isNowPlaying ? '500' : '400',
                  color: isNowPlaying ? '#7c3aed' : '#374151'
                }
              }, track.title),

              // Duration
              track.length && React.createElement('span', {
                className: 'flex-shrink-0 tabular-nums',
                style: {
                  pointerEvents: 'none',
                  fontSize: '12px',
                  color: '#9ca3af'
                }
              }, formatDuration(track.length)),
              
              // Resolver icons (sources available for this track)
              React.createElement('div', {
                className: 'flex items-center gap-1 flex-shrink-0 ml-auto',
                style: { pointerEvents: 'none', minHeight: '24px', width: '100px', justifyContent: 'flex-end' }
              },
                (() => {
                  // Use availableResolvers from outer scope (already looked up via trackId)
                  const availableResolverIds = availableResolvers;

                  if (availableResolverIds.length === 0) {
                    // Show shimmer skeletons while resolving (match resolver icon size)
                    return React.createElement('div', {
                      className: 'flex items-center gap-1'
                    },
                      React.createElement('div', {
                        className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer',
                        title: 'Resolving track...'
                      }),
                      React.createElement('div', {
                        className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer',
                        style: { animationDelay: '0.1s' }
                      })
                    );
                  }

                  // Sort resolvers by priority order (left to right = highest to lowest priority)
                  const sortedResolverIds = [...availableResolverIds].sort((a, b) => {
                    const aIndex = resolvers.findIndex(r => r.id === a);
                    const bIndex = resolvers.findIndex(r => r.id === b);
                    return aIndex - bIndex;
                  });

                  // Show resolver icons for available sources (only if they support playback)
                  return sortedResolverIds.map(resolverId => {
                    const resolver = resolvers.find(r => r.id === resolverId);
                    if (!resolver || !resolver.play) return null;
                    
                    const source = sources[resolverId];
                    const confidence = source.confidence || 0;
                    
                    return React.createElement('button', {
                      key: resolverId,
                      className: 'no-drag',
                      onClick: (e) => {
                        e.stopPropagation(); // Don't trigger row click
                        console.log(`Playing from ${resolver.name}:`, source);

                        // Create track with preferred resolver
                        const trackWithResolver = { ...trackForDrag, preferredResolver: resolverId };

                        // Build queue from remaining tracks (after this one)
                        const tracksAfter = release.tracks.slice(index + 1).map((t, i) => {
                          const tKey = `${t.position}-${t.title}`;
                          const tSources = trackSources[tKey] || {};
                          const tId = `${release.artist.name || 'unknown'}-${t.title || 'untitled'}-${release.title || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
                          return {
                            ...t,
                            id: tId,
                            artist: release.artist.name,
                            album: release.title,
                            albumArt: release.albumArt,
                            sources: tSources
                          };
                        });

                        if (onTrackPlay) {
                          onTrackPlay(trackWithResolver, tracksAfter);
                        } else {
                          handlePlay(trackWithResolver);
                        }
                      },
                      style: {
                        width: '20px',
                        height: '20px',
                        borderRadius: '4px',
                        backgroundColor: resolver.color,
                        border: 'none',
                        cursor: 'pointer',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        pointerEvents: 'auto',
                        opacity: confidence > 0.8 ? 1 : 0.6,
                        transition: 'transform 0.1s'
                      },
                      onMouseEnter: (e) => e.currentTarget.style.transform = 'scale(1.1)',
                      onMouseLeave: (e) => e.currentTarget.style.transform = 'scale(1)',
                      title: `Play from ${resolver.name} (${Math.round(confidence * 100)}% match)`
                    }, React.createElement(ResolverIcon, { resolverId, size: 12 }));
                  });
                })()
              )
            );
          })
        )
      :
        React.createElement('div', { className: 'text-center py-12 text-gray-400' },
          'No track information available'
        )
    )
  );
};

const Parachord = () => {
  const [currentTrack, setCurrentTrack] = useState(null);
  const [currentQueue, setCurrentQueue] = useState([]); // Current playing queue
  // Playback context - tracks where the current track originated from
  // Shape: { type: 'playlist' | 'album' | 'search' | 'library' | 'recommendations', id?, name?, artist? }
  const [playbackContext, setPlaybackContext] = useState(null);
  // Spinoff mode - radio-like playback of similar tracks
  const [spinoffMode, setSpinoffMode] = useState(false);
  const spinoffModeRef = useRef(false); // Ref for spinoff mode to avoid stale closures in handleNext
  // Shuffle mode - randomize queue order
  const [shuffleMode, setShuffleMode] = useState(false);
  const originalQueueRef = useRef(null); // Store original queue order before shuffle for restore
  const [spinoffSourceTrack, setSpinoffSourceTrack] = useState(null); // { title, artist } of original track
  const spinoffSourceTrackRef = useRef(null); // Ref for source track to avoid stale closures
  const [spinoffLoading, setSpinoffLoading] = useState(false);
  const [spinoffAvailable, setSpinoffAvailable] = useState(null); // null = unchecked, true/false = checked
  const spinoffTracksRef = useRef([]); // Pool of similar tracks to play
  const spinoffPreviousContextRef = useRef(null); // Store previous playback context to restore on exit
  const [isPlaying, setIsPlaying] = useState(false);
  const isPlayingRef = useRef(false); // Ref for isPlaying to use in async callbacks
  const [trackLoading, setTrackLoading] = useState(false); // True when loading a track to play
  // Album art crossfade state for smooth transitions in playbar
  const [playbarAlbumArt, setPlaybarAlbumArt] = useState({ current: null, previous: null, isLoaded: false });
  const playbarAlbumArtRef = useRef(null); // Track previous art for comparison
  const [playbarSourceDropdownOpen, setPlaybarSourceDropdownOpen] = useState(false); // Source selector dropdown
  // Track if currentTrack was restored from saved queue and needs explicit playback start
  const trackNeedsExplicitStart = useRef(false);
  const [progress, setProgress] = useState(0);
  const [volume, setVolume] = useState(70);
  const [isMuted, setIsMuted] = useState(false);
  const preMuteVolumeRef = useRef(70); // Remember volume before muting
  const isMutedRef = useRef(false); // Ref for mute state to avoid stale closures
  const spotifyVolumeTimeoutRef = useRef(null); // Debounce Spotify volume API calls

  // Track main content width for responsive layouts
  const [mainContentWidth, setMainContentWidth] = useState(800);
  const mainContentRef = useRef(null);
  // Per-resolver volume offsets (dB adjustment, applied to base volume)
  // Default offsets: Spotify is normalized at -14 LUFS, others may be louder
  const [resolverVolumeOffsets, setResolverVolumeOffsets] = useState({
    spotify: 0,      // Spotify is already normalized
    localfiles: 0,   // Local files vary, start neutral
    bandcamp: -3,    // Bandcamp tends to be slightly louder
    youtube: -6,     // YouTube videos are often much louder
    qobuz: 0         // Qobuz is typically well mastered
  });
  // Per-track volume adjustments (trackId -> dB offset from resolver default)
  const trackVolumeAdjustments = useRef({});

  // AI Playlist Generation state
  const [aiPromptOpen, setAiPromptOpen] = useState(false);
  const [aiPrompt, setAiPrompt] = useState('');
  const [aiLoading, setAiLoading] = useState(false);
  const [aiIncludeHistory, setAiIncludeHistory] = useState(false);
  const [aiError, setAiError] = useState(null);
  const [selectedAiResolver, setSelectedAiResolver] = useState(null);
  const [aiSaveDialogOpen, setAiSaveDialogOpen] = useState(false);
  const [aiSavePlaylistName, setAiSavePlaylistName] = useState('');

  // Results sidebar state (generic/reusable)
  const [resultsSidebar, setResultsSidebar] = useState(null);
  // Shape: { title, subtitle, tracks: [], source: 'ai' | 'search' | etc }

  const [searchQuery, setSearchQuery] = useState('');
  const [searchResults, setSearchResults] = useState({
    artists: [],
    albums: [],
    tracks: [],
    playlists: []
  });
  const [isSearching, setIsSearching] = useState(false);
  const searchTimeoutRef = useRef(null);
  const searchQueryRef = useRef('');
  const abortControllerRef = useRef(null);
  // Recommendations state
  const [recommendations, setRecommendations] = useState({
    artists: [],
    tracks: [],
    loading: true,
    error: null
  });
  // Pagination state - how many items to show per column
  const [displayLimits, setDisplayLimits] = useState({
    artists: 5,
    albums: 5,
    tracks: 8,
    playlists: 5
  });
  const [searchDetailCategory, setSearchDetailCategory] = useState(null); // null = main view, 'artists'|'tracks'|'albums'|'playlists' = detail view
  const [searchPreviewItem, setSearchPreviewItem] = useState(null); // Currently previewed item in detail view
  const searchResultsContainerRef = useRef(null); // Ref for measuring search results container width
  const [searchContainerWidth, setSearchContainerWidth] = useState(800); // Width of search results container for responsive item count
  const [searchPreviewArtistImage, setSearchPreviewArtistImage] = useState(null); // Artist image for preview pane
  const [searchPreviewArtistBio, setSearchPreviewArtistBio] = useState(null); // Artist bio snippet for preview pane
  const [searchHeaderCollapsed, setSearchHeaderCollapsed] = useState(false); // Search detail header collapse state
  const [searchResultsFilter, setSearchResultsFilter] = useState(''); // Filter text for search results
  const [searchResultsFilterOpen, setSearchResultsFilterOpen] = useState(false); // Filter input open state
  const [searchResultsSort, setSearchResultsSort] = useState('relevance'); // Sort option for search results
  const [searchResultsSortDropdownOpen, setSearchResultsSortDropdownOpen] = useState(false); // Sort dropdown open state
  const [searchHistory, setSearchHistory] = useState([]);
  const [activeView, setActiveView] = useState(null); // null until restored from storage or defaults to 'library'
  const [viewHistory, setViewHistory] = useState([]); // Navigation history for back button
  const [forwardHistory, setForwardHistory] = useState([]); // Navigation history for forward button
  const [artistHistory, setArtistHistory] = useState([]); // Stack of previous artist names for back navigation
  const [playlists, setPlaylists] = useState([]);
  const [playlistsLoading, setPlaylistsLoading] = useState(true); // Loading state for playlists
  const [selectedPlaylist, setSelectedPlaylist] = useState(null);
  const [playlistTracks, setPlaylistTracks] = useState([]);
  const [allPlaylistCovers, setAllPlaylistCovers] = useState({}); // { playlistId: [url1, url2, url3, url4] }
  const [draggedPlaylistTrack, setDraggedPlaylistTrack] = useState(null); // For playlist track reordering
  const [playlistDropTarget, setPlaylistDropTarget] = useState(null); // Index where track will be dropped
  const [playlistEditMode, setPlaylistEditMode] = useState(false); // Edit mode for playlist detail view
  const [editedPlaylistData, setEditedPlaylistData] = useState(null); // Buffered changes: { title, creator, tracks }
  const [currentArtist, setCurrentArtist] = useState(null); // Artist page data
  const [artistImage, setArtistImage] = useState(null); // Artist image from Spotify
  const [artistImagePosition, setArtistImagePosition] = useState('center 25%'); // Face-centered position
  const [artistReleases, setArtistReleases] = useState([]); // Discography
  const [releaseTypeFilter, setReleaseTypeFilter] = useState('album'); // album, ep, single, live, compilation
  const [isHeaderCollapsed, setIsHeaderCollapsed] = useState(false); // Artist page header collapse state
  const [artistPageTab, setArtistPageTab] = useState('music'); // music | biography | related
  const [artistSearchOpen, setArtistSearchOpen] = useState(false);
  const [artistSearch, setArtistSearch] = useState('');
  const [artistSortDropdownOpen, setArtistSortDropdownOpen] = useState(false);
  const [artistSort, setArtistSort] = useState('date-desc'); // date-desc, date-asc, alpha-asc, alpha-desc
  const [artistBio, setArtistBio] = useState(null); // Artist biography from Last.fm
  const [artistExtendedInfo, setArtistExtendedInfo] = useState(null); // Extended info from MusicBrainz (founded, location, URLs, members)
  const [loadingExtendedInfo, setLoadingExtendedInfo] = useState(false);
  const [relatedArtists, setRelatedArtists] = useState([]); // Related artists from Last.fm and ListenBrainz
  const [relatedArtistsSourceFilter, setRelatedArtistsSourceFilter] = useState('all'); // 'all' | 'lastfm' | 'listenbrainz' | 'both'
  const [loadingBio, setLoadingBio] = useState(false);
  const [loadingRelated, setLoadingRelated] = useState(false);
  const [loadingArtist, setLoadingArtist] = useState(false);
  const [currentRelease, setCurrentRelease] = useState(null); // Release/Album page data
  const [loadingRelease, setLoadingRelease] = useState(false);
  const [prefetchedReleases, setPrefetchedReleases] = useState({}); // Cache for on-hover prefetched release tracks: { releaseId: { tracks: [...], title, albumArt } }
  const prefetchedReleasesRef = useRef(prefetchedReleases); // Ref to avoid stale closure in context menu handlers
  const prefetchInProgressRef = useRef(new Set()); // Track which releases are currently being prefetched

  // Critic's Picks state
  const [criticsPicks, setCriticsPicks] = useState([]);
  const [criticsPicksLoading, setCriticsPicksLoading] = useState(false);
  const [criticsPicksLoaded, setCriticsPicksLoaded] = useState(false);

  // Charts state
  const [charts, setCharts] = useState([]);
  const [chartsLoading, setChartsLoading] = useState(false);
  const [chartsLoaded, setChartsLoaded] = useState(false);

  const [trackSources, setTrackSources] = useState({}); // Resolved sources for each track: { trackId: { youtube: {...}, soundcloud: {...} } }
  const [activeResolvers, setActiveResolvers] = useState(['spotify', 'bandcamp', 'qobuz', 'youtube']);
  const [resolverOrder, setResolverOrder] = useState(['spotify', 'bandcamp', 'qobuz', 'youtube', 'soundcloud']);
  const resolverSettingsLoaded = useRef(false);  // Track if we've loaded settings from storage
  const activeResolversRef = useRef(activeResolvers);  // Ref to avoid stale closure in save
  const resolverOrderRef = useRef(resolverOrder);  // Ref to avoid stale closure in save
  const [draggedResolver, setDraggedResolver] = useState(null);
  const [dragOverResolver, setDragOverResolver] = useState(null);  // Which resolver is being dragged over
  const [library, setLibrary] = useState([]);
  const [libraryLoading, setLibraryLoading] = useState(true);
  const [audioContext, setAudioContext] = useState(null);
  const [currentSource, setCurrentSource] = useState(null);
  const [startTime, setStartTime] = useState(0);
  const [isExternalPlayback, setIsExternalPlayback] = useState(false);
  const [showExternalPrompt, setShowExternalPrompt] = useState(false);
  const [pendingExternalTrack, setPendingExternalTrack] = useState(null);
  const [pendingExternalResolverId, setPendingExternalResolverId] = useState(null); // Tracks which resolver was selected for external playback
  const [externalTrackCountdown, setExternalTrackCountdown] = useState(15);
  const [skipExternalPrompt, setSkipExternalPrompt] = useState(false); // "Don't show again" preference
  const [autoLaunchSpotify, setAutoLaunchSpotify] = useState(false); // Auto-launch Spotify on app startup
  const [skipUnsavedFriendWarning, setSkipUnsavedFriendWarning] = useState(false); // "Don't show again" for unsaved friend unpin warning
  const [unsavedFriendWarningOpen, setUnsavedFriendWarningOpen] = useState(false); // Warning dialog state
  const [pendingUnpinFriend, setPendingUnpinFriend] = useState(null); // Friend being unpinned (for warning dialog)
  const [rememberQueue, setRememberQueue] = useState(false); // Remember queue on app close/reopen
  const externalTrackTimeoutRef = useRef(null);
  const externalTrackIntervalRef = useRef(null);
  const playbackPollerRef = useRef(null);
  const pollingGenerationRef = useRef(0); // Generation counter to invalidate stale polling callbacks
  const pollingRecoveryRef = useRef(null); // Recovery interval for when Spotify polling fails
  const isAdvancingTrackRef = useRef(false); // Re-entrancy guard for handleNext()
  const waitingForBrowserPlaybackRef = useRef(false); // True when we're waiting for browser to connect after opening external track
  const [settingsTab, setSettingsTab] = useState('marketplace'); // 'marketplace' | 'installed' | 'general' | 'about'
  const [marketplaceManifest, setMarketplaceManifest] = useState(null);
  const [marketplaceLoading, setMarketplaceLoading] = useState(false);
  const [marketplaceSearchQuery, setMarketplaceSearchQuery] = useState('');
  const [marketplaceCategory, setMarketplaceCategory] = useState('all');
  const [installingResolvers, setInstallingResolvers] = useState(new Set());
  const [selectedMarketplaceItem, setSelectedMarketplaceItem] = useState(null); // Marketplace item detail modal
  const [spotifyToken, setSpotifyToken] = useState(null);
  const spotifyTokenRef = useRef(null); // Ref for cleanup on unmount
  const [spotifyConnected, setSpotifyConnected] = useState(false);
  const [spotifyDevice, setSpotifyDevice] = useState(null); // Current Spotify playback device { name, type, supports_volume }
  const [queueDrawerOpen, setQueueDrawerOpen] = useState(false);
  const [queueDrawerHeight, setQueueDrawerHeight] = useState(350); // Default height in pixels
  const [draggedQueueTrack, setDraggedQueueTrack] = useState(null); // For queue reordering
  const [queueDropTarget, setQueueDropTarget] = useState(null); // Index where track will be dropped in queue
  const [droppingFromIndex, setDroppingFromIndex] = useState(null); // Index of clicked track - all tracks at index <= this fall down
  const [insertedTrackId, setInsertedTrackId] = useState(null); // Track ID that was just inserted via "previous"
  const [queueSaveDialogOpen, setQueueSaveDialogOpen] = useState(false); // Save queue as playlist dialog
  const [queueSavePlaylistName, setQueueSavePlaylistName] = useState(''); // Name for saved queue playlist
  const [qobuzToken, setQobuzToken] = useState(null);
  const [qobuzConnected, setQobuzConnected] = useState(false);

  // Meta Services state (Last.fm, ListenBrainz, etc.)
  const [metaServices, setMetaServices] = useState([]); // Loaded meta service plug-ins
  const [metaServiceConfigs, setMetaServiceConfigs] = useState({}); // { lastfm: { username, apiKey }, listenbrainz: { username, userToken } }
  const [lastfmAdvancedOpen, setLastfmAdvancedOpen] = useState(false); // Advanced section accordion state
  const [lastfmUsernameInput, setLastfmUsernameInput] = useState(''); // Input field value
  const [lastfmApiKeyInput, setLastfmApiKeyInput] = useState(''); // Advanced: API key input
  const [lastfmApiSecretInput, setLastfmApiSecretInput] = useState(''); // Advanced: API secret input
  const [lastfmConnecting, setLastfmConnecting] = useState(false); // Loading state during connection

  // ListenBrainz state
  const [listenbrainzAdvancedOpen, setListenbrainzAdvancedOpen] = useState(false); // Advanced section accordion state
  const [listenbrainzUsernameInput, setListenbrainzUsernameInput] = useState(''); // Input field value
  const [listenbrainzTokenInput, setListenbrainzTokenInput] = useState(''); // User token input
  const [listenbrainzConnecting, setListenbrainzConnecting] = useState(false); // Loading state during connection

  // Scrobbler settings state
  const [scrobblersInitialized, setScrobblersInitialized] = useState(false);
  const [scrobblerConfigs, setScrobblerConfigs] = useState({});
  const [scrobblingEnabled, setScrobblingEnabled] = useState(true);

  const [showUrlImportDialog, setShowUrlImportDialog] = useState(false);
  const [urlImportValue, setUrlImportValue] = useState('');
  const [urlImportLoading, setUrlImportLoading] = useState(false);

  // Local Files state
  const [localFilesStats, setLocalFilesStats] = useState({ totalTracks: 0, totalFolders: 0, lastScan: null });
  const [watchFolders, setWatchFolders] = useState([]);

  // Collection page state
  const [collectionTab, setCollectionTab] = useState('tracks'); // 'artists' | 'albums' | 'tracks' | 'friends'
  const [collectionHeaderCollapsed, setCollectionHeaderCollapsed] = useState(false);
  const [collectionSearchOpen, setCollectionSearchOpen] = useState(false);
  const [collectionSearch, setCollectionSearch] = useState('');
  const [collectionSortDropdownOpen, setCollectionSortDropdownOpen] = useState(false);
  const [collectionSort, setCollectionSort] = useState({
    artists: 'alpha-asc',
    albums: 'recent',
    tracks: 'recent',
    friends: 'alpha-asc'
  });

  // Resolver sync settings
  const [resolverSyncSettings, setResolverSyncSettings] = useState({});
  const [syncStatus, setSyncStatus] = useState({}); // { spotify: { lastSyncAt, inProgress, error } }

  // Sync setup modal state
  const [syncSetupModal, setSyncSetupModal] = useState({
    open: false,
    providerId: null,
    step: 'options', // 'options' | 'playlists' | 'syncing' | 'complete'
    playlists: [],
    folders: [],
    selectedPlaylists: [],
    playlistFilter: 'all', // 'all' | 'owned' | 'following'
    settings: {
      syncTracks: true,
      syncAlbums: true,
      syncArtists: true,
      syncPlaylists: true
    },
    progress: null,
    results: null,
    error: null
  });

  // Sync status modal state (quick view from collection)
  const [syncStatusModal, setSyncStatusModal] = useState({ open: false });

  // Stop sync confirmation dialog state
  const [stopSyncDialog, setStopSyncDialog] = useState({
    open: false,
    providerId: null
  });

  // First-run tutorial state
  const [firstRunTutorial, setFirstRunTutorial] = useState({
    open: false,
    step: 'welcome', // 'welcome' | 'sources' | 'social' | 'features' | 'complete'
    selectedSources: ['youtube'], // Default to YouTube as it's free
    selectedScrobblers: [],
    spotifyConnecting: false,
    spotifyConnected: false
  });

  // Background sync timer (every 15 minutes)
  useEffect(() => {
    const SYNC_INTERVAL = 15 * 60 * 1000; // 15 minutes

    const runBackgroundSync = async () => {
      // Check each enabled provider
      for (const [providerId, settings] of Object.entries(resolverSyncSettings)) {
        if (settings.enabled) {
          try {
            const authStatus = await window.electron.sync.checkAuth(providerId);
            if (authStatus.authenticated) {
              console.log(`[Sync] Starting background sync for ${providerId}`);
              const result = await window.electron.sync.start(providerId, { settings });
              if (result.success) {
                // Use collection from sync result for immediate UI update
                if (result.collection) {
                  setCollectionData({
                    tracks: result.collection.tracks || [],
                    albums: result.collection.albums || [],
                    artists: result.collection.artists || []
                  });
                } else {
                  const newCollection = await window.electron.collection.load();
                  setCollectionData(newCollection);
                }
              } else {
                console.warn(`[Sync] Background sync for ${providerId} returned unsuccessful:`, result.error);
              }
            }
          } catch (error) {
            console.error(`[Sync] Background sync failed for ${providerId}:`, error);
          }
        }
      }
    };

    // Run on app start (after initial load)
    const initialSyncTimeout = setTimeout(runBackgroundSync, 5000);

    // Set up interval
    const intervalId = setInterval(runBackgroundSync, SYNC_INTERVAL);

    return () => {
      clearTimeout(initialSyncTimeout);
      clearInterval(intervalId);
    };
  }, [resolverSyncSettings]);

  // Friends state
  const [friends, setFriends] = useState([]);
  const [pinnedFriendIds, setPinnedFriendIds] = useState([]);
  const [autoPinnedFriendIds, setAutoPinnedFriendIds] = useState([]); // Friends auto-pinned due to being on-air
  const [newlyPinnedFriendIds, setNewlyPinnedFriendIds] = useState(new Set()); // Track newly added friends for animation
  const [movedFriendIds, setMovedFriendIds] = useState(new Set()); // Track friends that moved position for animation
  const [currentFriend, setCurrentFriend] = useState(null);
  const [friendHistoryTab, setFriendHistoryTab] = useState('recent');
  const [friendHistoryData, setFriendHistoryData] = useState({
    recent: [],
    topTracks: [],
    topAlbums: [],
    topArtists: []
  });
  const [friendHistoryPeriod, setFriendHistoryPeriod] = useState('7day');
  const [friendHistorySort, setFriendHistorySort] = useState('recent');
  const [friendHistorySortDropdownOpen, setFriendHistorySortDropdownOpen] = useState(false);
  const [friendHistoryLoading, setFriendHistoryLoading] = useState(false);
  const [addFriendModalOpen, setAddFriendModalOpen] = useState(false);
  const [addFriendInput, setAddFriendInput] = useState('');
  const [addFriendLoading, setAddFriendLoading] = useState(false);
  const [friendDragOverSidebar, setFriendDragOverSidebar] = useState(false);
  const friendPollIntervalRef = useRef(null);
  const [listenAlongFriend, setListenAlongFriend] = useState(null); // Friend object when in listen-along mode
  const listenAlongFriendRef = useRef(null); // Ref for use in async callbacks
  const listenAlongLastTrackRef = useRef(null); // Track what we last played in listen-along to detect changes
  const listenAlongPendingTrackRef = useRef(null); // Track queued to play when current song ends (friend is ahead)

  // Playlists page state
  const [playlistsHeaderCollapsed, setPlaylistsHeaderCollapsed] = useState(false);
  const [playlistsSearchOpen, setPlaylistsSearchOpen] = useState(false);
  const [playlistsSearch, setPlaylistsSearch] = useState('');
  const [playlistsSortDropdownOpen, setPlaylistsSortDropdownOpen] = useState(false);
  const [playlistsSort, setPlaylistsSort] = useState('added');
  const [playlistsViewMode, setPlaylistsViewMode] = useState('grid'); // 'grid' | 'table'

  // Charts (Pop of the Tops) page state
  const [chartsHeaderCollapsed, setChartsHeaderCollapsed] = useState(false);
  const [chartsSearchOpen, setChartsSearchOpen] = useState(false);
  const [chartsSearch, setChartsSearch] = useState('');
  const [chartsSortDropdownOpen, setChartsSortDropdownOpen] = useState(false);
  const [chartsSort, setChartsSort] = useState('rank');

  // Critics Picks page state
  const [criticsHeaderCollapsed, setCriticsHeaderCollapsed] = useState(false);
  const [criticsSearchOpen, setCriticsSearchOpen] = useState(false);
  const [criticsSearch, setCriticsSearch] = useState('');
  const [criticsSortDropdownOpen, setCriticsSortDropdownOpen] = useState(false);
  const [criticsSort, setCriticsSort] = useState('recent');

  // Recommendations page state
  const [recommendationsHeaderCollapsed, setRecommendationsHeaderCollapsed] = useState(false);
  const [recommendationsTab, setRecommendationsTab] = useState('artists'); // 'artists' | 'songs'
  const [recommendationsSourceFilter, setRecommendationsSourceFilter] = useState('all'); // 'all' | 'listenbrainz' | 'lastfm'

  // History page state
  const [historyTab, setHistoryTab] = useState('topTracks'); // 'topTracks' | 'topAlbums' | 'topArtists' | 'recent'
  const pendingHistoryLoad = useRef(null); // Track pending history tab load from view restore
  const pendingReleaseLoad = useRef(null); // Track pending release/album load from view restore
  const [pendingPlaylistLoad, setPendingPlaylistLoad] = useState(null); // Track pending playlist load from view restore
  const [pendingFriendLoad, setPendingFriendLoad] = useState(null); // Track pending friend load from view restore
  const [historyPeriod, setHistoryPeriod] = useState('7day'); // 'overall' | '7day' | '1month' | '3month' | '6month' | '12month'
  const [historyPeriodDropdownOpen, setHistoryPeriodDropdownOpen] = useState(false);
  const [historyHeaderCollapsed, setHistoryHeaderCollapsed] = useState(false);
  const [historySearchOpen, setHistorySearchOpen] = useState(false);
  const [historySearch, setHistorySearch] = useState('');
  const [historySortDropdownOpen, setHistorySortDropdownOpen] = useState(false);
  const [historySort, setHistorySort] = useState('recent');
  const [listeningHistory, setListeningHistory] = useState({ tracks: [], loading: true, error: null });
  const [topTracks, setTopTracks] = useState({ tracks: [], loading: false, error: null });
  const [topArtists, setTopArtists] = useState({ artists: [], loading: false, error: null });
  const [topAlbums, setTopAlbums] = useState({ albums: [], loading: false, error: null });

  // Sidebar badge state for visual feedback on additions
  const [sidebarBadges, setSidebarBadges] = useState({
    collection: null,
    playlists: null
  });
  const sidebarBadgeTimeouts = useRef({});

  // Show a "+N" badge on a sidebar item that auto-clears after animation
  const showSidebarBadge = useCallback((item, count = 1) => {
    // Clear any existing timeout for this item
    if (sidebarBadgeTimeouts.current[item]) {
      clearTimeout(sidebarBadgeTimeouts.current[item]);
    }
    // Show the badge
    setSidebarBadges(prev => ({ ...prev, [item]: count }));
    // Clear after animation completes (2s)
    sidebarBadgeTimeouts.current[item] = setTimeout(() => {
      setSidebarBadges(prev => ({ ...prev, [item]: null }));
    }, 2000);
  }, []);

  // Close collection sort dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = () => setCollectionSortDropdownOpen(false);
    if (collectionSortDropdownOpen) {
      document.addEventListener('click', handleClickOutside);
      return () => document.removeEventListener('click', handleClickOutside);
    }
  }, [collectionSortDropdownOpen]);

  // Track main content width for responsive header buttons
  useEffect(() => {
    if (!mainContentRef.current) return;
    const resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        setMainContentWidth(entry.contentRect.width);
      }
    });
    resizeObserver.observe(mainContentRef.current);
    return () => resizeObserver.disconnect();
  }, []);

  // Responsive breakpoints
  const isCompactHeader = mainContentWidth < 700;

  // Close playlists sort dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = () => setPlaylistsSortDropdownOpen(false);
    if (playlistsSortDropdownOpen) {
      document.addEventListener('click', handleClickOutside);
      return () => document.removeEventListener('click', handleClickOutside);
    }
  }, [playlistsSortDropdownOpen]);

  // Close charts sort dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = () => setChartsSortDropdownOpen(false);
    if (chartsSortDropdownOpen) {
      document.addEventListener('click', handleClickOutside);
      return () => document.removeEventListener('click', handleClickOutside);
    }
  }, [chartsSortDropdownOpen]);

  // Close critics sort dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = () => setCriticsSortDropdownOpen(false);
    if (criticsSortDropdownOpen) {
      document.addEventListener('click', handleClickOutside);
      return () => document.removeEventListener('click', handleClickOutside);
    }
  }, [criticsSortDropdownOpen]);

  // Close history sort dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = () => setHistorySortDropdownOpen(false);
    if (historySortDropdownOpen) {
      document.addEventListener('click', handleClickOutside);
      return () => document.removeEventListener('click', handleClickOutside);
    }
  }, [historySortDropdownOpen]);

  // Close friend history sort dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = () => setFriendHistorySortDropdownOpen(false);
    if (friendHistorySortDropdownOpen) {
      document.addEventListener('click', handleClickOutside);
      return () => document.removeEventListener('click', handleClickOutside);
    }
  }, [friendHistorySortDropdownOpen]);

  // Close artist sort dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = () => setArtistSortDropdownOpen(false);
    if (artistSortDropdownOpen) {
      document.addEventListener('click', handleClickOutside);
      return () => document.removeEventListener('click', handleClickOutside);
    }
  }, [artistSortDropdownOpen]);

  // Close search results sort dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = () => setSearchResultsSortDropdownOpen(false);
    if (searchResultsSortDropdownOpen) {
      document.addEventListener('click', handleClickOutside);
      return () => document.removeEventListener('click', handleClickOutside);
    }
  }, [searchResultsSortDropdownOpen]);

  // Reset search results filter/sort when changing categories
  useEffect(() => {
    setSearchResultsFilter('');
    setSearchResultsFilterOpen(false);
    setSearchResultsSort('relevance');
    setSearchResultsSortDropdownOpen(false);
  }, [searchDetailCategory]);

  // Load artist images when artists tab is selected in search results
  useEffect(() => {
    if (searchDetailCategory === 'artists' && searchResults.artists.length > 0) {
      // Check if any artists need images loaded
      const artistsNeedingImages = searchResults.artists.filter(a => !a.image && !a.imageLoaded);
      if (artistsNeedingImages.length > 0) {
        resolveSearchArtistImages(artistsNeedingImages);
      }
    }
  }, [searchDetailCategory, searchResults.artists.length]);

  // Resolve unresolved tracks when songs tab is selected in search results
  useEffect(() => {
    if (searchDetailCategory === 'tracks' && searchResults.tracks.length > 0) {
      // Resolution is now handled by scheduler via IntersectionObserver
    }
  }, [searchDetailCategory, searchResults.tracks.length]);


  // Track if we're opening a release (to prevent header reset during artist change)
  const openingReleaseRef = useRef(false);
  // Track if we're restoring saved state (to prevent tab reset during restore)
  const restoringStateRef = useRef(false);

  // Playlists page scroll handler for header collapse
  const playlistsCollapseLockedRef = useRef(false);
  const handlePlaylistsScroll = useCallback((e) => {
    const scrollTop = e.target.scrollTop;

    // If locked (during transition), ignore scroll events
    if (playlistsCollapseLockedRef.current) return;

    // Only collapse when scrolled down past threshold
    if (scrollTop > 50 && !playlistsHeaderCollapsed) {
      playlistsCollapseLockedRef.current = true;
      setPlaylistsHeaderCollapsed(true);
      // Unlock after transition completes
      setTimeout(() => { playlistsCollapseLockedRef.current = false; }, 350);
    }
    // Only expand when scrolled to very top
    else if (scrollTop === 0 && playlistsHeaderCollapsed) {
      playlistsCollapseLockedRef.current = true;
      setPlaylistsHeaderCollapsed(false);
      setTimeout(() => { playlistsCollapseLockedRef.current = false; }, 350);
    }
  }, [playlistsHeaderCollapsed]);

  // Charts page scroll handler for header collapse
  const handleChartsScroll = useCallback((e) => {
    const scrollTop = e.target.scrollTop;
    setChartsHeaderCollapsed(prev => {
      if (!prev && scrollTop > 50) return true;
      if (prev && scrollTop === 0) return false;
      return prev;
    });
  }, []);

  // Critics page scroll handler for header collapse
  const handleCriticsScroll = useCallback((e) => {
    const scrollTop = e.target.scrollTop;
    setCriticsHeaderCollapsed(prev => {
      if (!prev && scrollTop > 50) return true;
      if (prev && scrollTop === 0) return false;
      return prev;
    });
  }, []);

  // History page scroll handler for header collapse
  const handleHistoryScroll = useCallback((e) => {
    const scrollTop = e.target.scrollTop;
    setHistoryHeaderCollapsed(prev => {
      if (!prev && scrollTop > 50) return true;
      if (prev && scrollTop === 0) return false;
      return prev;
    });
  }, []);

  // Reset collection header collapse when leaving library view
  useEffect(() => {
    if (activeView !== 'library') {
      setCollectionHeaderCollapsed(false);
      setCollectionSearchOpen(false);
      setCollectionSearch('');
    }
  }, [activeView]);

  // Reset playlists header collapse when leaving playlists view
  useEffect(() => {
    if (activeView !== 'playlists') {
      setPlaylistsHeaderCollapsed(false);
      setPlaylistsSearchOpen(false);
      setPlaylistsSearch('');
    }
  }, [activeView]);

  // Reset charts header collapse when leaving charts view
  useEffect(() => {
    if (activeView !== 'discover') {
      setChartsHeaderCollapsed(false);
      setChartsSearchOpen(false);
      setChartsSearch('');
    }
  }, [activeView]);

  // Reset critics header collapse when leaving critics view
  useEffect(() => {
    if (activeView !== 'critics-picks') {
      setCriticsHeaderCollapsed(false);
      setCriticsSearchOpen(false);
      setCriticsSearch('');
    }
  }, [activeView]);

  // Reset recommendations header collapse and tab when leaving recommendations view
  useEffect(() => {
    if (activeView !== 'recommendations') {
      setRecommendationsHeaderCollapsed(false);
      setRecommendationsTab('artists');
    }
  }, [activeView]);

  // Reset history header collapse when leaving history view
  useEffect(() => {
    if (activeView !== 'history') {
      setHistoryHeaderCollapsed(false);
      setHistorySearchOpen(false);
      setHistorySearch('');
    }
  }, [activeView]);

  // Reset artist page filter bar when leaving artist view
  useEffect(() => {
    if (activeView !== 'artist') {
      setArtistSearchOpen(false);
      setArtistSearch('');
      setArtistSortDropdownOpen(false);
    }
  }, [activeView]);

  // Filter collection items by search query
  const filterCollectionItems = useCallback((items, type) => {
    if (!collectionSearch.trim()) return items;
    const query = collectionSearch.toLowerCase();

    if (type === 'artists') {
      return items.filter(a => a.name.toLowerCase().includes(query));
    }
    if (type === 'albums') {
      return items.filter(a =>
        a.title.toLowerCase().includes(query) ||
        a.artist.toLowerCase().includes(query)
      );
    }
    if (type === 'tracks') {
      return items.filter(t =>
        (t.title || '').toLowerCase().includes(query) ||
        (t.artist || '').toLowerCase().includes(query) ||
        (t.album || '').toLowerCase().includes(query)
      );
    }
    return items;
  }, [collectionSearch]);

  // Sort collection items
  const sortCollectionItems = useCallback((items, type) => {
    const sortKey = collectionSort[type];
    const sorted = [...items];

    if (type === 'artists') {
      switch (sortKey) {
        case 'alpha-asc': return sorted.sort((a, b) => a.name.localeCompare(b.name));
        case 'alpha-desc': return sorted.sort((a, b) => b.name.localeCompare(a.name));
        case 'tracks': return sorted.sort((a, b) => b.trackCount - a.trackCount);
        case 'recent': return sorted.sort((a, b) => (b.addedAt || 0) - (a.addedAt || 0));
        default: return sorted;
      }
    }
    if (type === 'albums') {
      switch (sortKey) {
        case 'alpha-asc': return sorted.sort((a, b) => a.title.localeCompare(b.title));
        case 'alpha-desc': return sorted.sort((a, b) => b.title.localeCompare(a.title));
        case 'artist': return sorted.sort((a, b) => a.artist.localeCompare(b.artist));
        case 'year-new': return sorted.sort((a, b) => (b.year || 0) - (a.year || 0));
        case 'year-old': return sorted.sort((a, b) => (a.year || 9999) - (b.year || 9999));
        case 'recent': return sorted.sort((a, b) => (b.addedAt || 0) - (a.addedAt || 0));
        default: return sorted;
      }
    }
    if (type === 'tracks') {
      switch (sortKey) {
        case 'title-asc': return sorted.sort((a, b) => (a.title || '').localeCompare(b.title || ''));
        case 'title-desc': return sorted.sort((a, b) => (b.title || '').localeCompare(a.title || ''));
        case 'artist': return sorted.sort((a, b) => (a.artist || '').localeCompare(b.artist || ''));
        case 'album': return sorted.sort((a, b) => (a.album || '').localeCompare(b.album || ''));
        case 'duration': return sorted.sort((a, b) => (a.duration || 0) - (b.duration || 0));
        case 'recent': return sorted.sort((a, b) => (b.addedAt || 0) - (a.addedAt || 0));
        default: return sorted;
      }
    }
    return sorted;
  }, [collectionSort]);

  // Get sort options for current tab
  const getCollectionSortOptions = (tab) => {
    if (tab === 'artists') {
      return [
        { value: 'alpha-asc', label: 'A-Z' },
        { value: 'alpha-desc', label: 'Z-A' },
        { value: 'tracks', label: 'Most Tracks' },
        { value: 'recent', label: 'Recently Added' }
      ];
    }
    if (tab === 'albums') {
      return [
        { value: 'alpha-asc', label: 'A-Z' },
        { value: 'alpha-desc', label: 'Z-A' },
        { value: 'artist', label: 'Artist Name' },
        { value: 'year-new', label: 'Year (Newest)' },
        { value: 'year-old', label: 'Year (Oldest)' },
        { value: 'recent', label: 'Recently Added' }
      ];
    }
    if (tab === 'friends') {
      return [
        { value: 'alpha-asc', label: 'A-Z' },
        { value: 'alpha-desc', label: 'Z-A' },
        { value: 'recent', label: 'Recently Added' },
        { value: 'on-air', label: 'On Air Now' }
      ];
    }
    return [
      { value: 'title-asc', label: 'Title A-Z' },
      { value: 'title-desc', label: 'Title Z-A' },
      { value: 'artist', label: 'Artist Name' },
      { value: 'album', label: 'Album Name' },
      { value: 'duration', label: 'Duration' },
      { value: 'recent', label: 'Recently Added' }
    ];
  };

  // Filter and sort playlists
  const filterPlaylists = useCallback((items) => {
    if (!playlistsSearch.trim()) return items;
    const query = playlistsSearch.toLowerCase();
    return items.filter(p => p.title.toLowerCase().includes(query));
  }, [playlistsSearch]);

  const sortPlaylists = useCallback((items) => {
    const sorted = [...items];
    switch (playlistsSort) {
      case 'added':
        // Sort by addedAt descending (newest first), fallback to lastModified, then createdAt
        return sorted.sort((a, b) => {
          const aTime = Number(a.addedAt) || Number(a.lastModified) || Number(a.createdAt) || 0;
          const bTime = Number(b.addedAt) || Number(b.lastModified) || Number(b.createdAt) || 0;
          return bTime - aTime; // Descending (newest first)
        });
      case 'created': return sorted.sort((a, b) => (Number(b.createdAt) || 0) - (Number(a.createdAt) || 0));
      case 'modified': return sorted.sort((a, b) => (Number(b.lastModified) || 0) - (Number(a.lastModified) || 0));
      case 'alpha-asc': return sorted.sort((a, b) => (a.title || '').localeCompare(b.title || ''));
      case 'alpha-desc': return sorted.sort((a, b) => (b.title || '').localeCompare(a.title || ''));
      default: return sorted;
    }
  }, [playlistsSort]);

  const playlistsSortOptions = [
    { value: 'added', label: 'Recently Added' },
    { value: 'created', label: 'Date Created' },
    { value: 'modified', label: 'Recently Modified' },
    { value: 'alpha-asc', label: 'A-Z' },
    { value: 'alpha-desc', label: 'Z-A' }
  ];

  // Filter artist releases by search query
  const filterArtistReleases = useCallback((releases) => {
    if (!artistSearch.trim()) return releases;
    const query = artistSearch.toLowerCase();
    return releases.filter(r => r.title.toLowerCase().includes(query));
  }, [artistSearch]);

  // Sort artist releases
  const sortArtistReleases = useCallback((releases) => {
    const sorted = [...releases];
    switch (artistSort) {
      case 'date-desc': return sorted.sort((a, b) => (b.date || '').localeCompare(a.date || ''));
      case 'date-asc': return sorted.sort((a, b) => (a.date || '').localeCompare(b.date || ''));
      case 'alpha-asc': return sorted.sort((a, b) => a.title.localeCompare(b.title));
      case 'alpha-desc': return sorted.sort((a, b) => b.title.localeCompare(a.title));
      default: return sorted;
    }
  }, [artistSort]);

  const artistSortOptions = [
    { value: 'date-desc', label: 'Newest First' },
    { value: 'date-asc', label: 'Oldest First' },
    { value: 'alpha-asc', label: 'A-Z' },
    { value: 'alpha-desc', label: 'Z-A' }
  ];

  // Set smart default release type filter based on available releases
  const setSmartReleaseTypeFilter = useCallback((releases) => {
    const hasAlbums = releases.some(r => r.releaseType === 'album');
    const hasEPs = releases.some(r => r.releaseType === 'ep');
    const hasSingles = releases.some(r => r.releaseType === 'single');

    if (hasAlbums) {
      setReleaseTypeFilter('album');
    } else if (hasEPs) {
      setReleaseTypeFilter('ep');
    } else if (hasSingles) {
      setReleaseTypeFilter('single');
    } else {
      // Fallback to first available type
      const firstType = releases[0]?.releaseType;
      if (firstType) setReleaseTypeFilter(firstType);
    }
  }, []);

  // Filter and sort charts
  const filterCharts = useCallback((items) => {
    if (!chartsSearch.trim()) return items;
    const query = chartsSearch.toLowerCase();
    return items.filter(c =>
      c.title.toLowerCase().includes(query) ||
      c.artist.toLowerCase().includes(query)
    );
  }, [chartsSearch]);

  const sortCharts = useCallback((items) => {
    const sorted = [...items];
    switch (chartsSort) {
      case 'rank': return sorted.sort((a, b) => (a.rank || 999) - (b.rank || 999));
      case 'alpha-asc': return sorted.sort((a, b) => a.title.localeCompare(b.title));
      case 'alpha-desc': return sorted.sort((a, b) => b.title.localeCompare(a.title));
      case 'artist': return sorted.sort((a, b) => a.artist.localeCompare(b.artist));
      default: return sorted;
    }
  }, [chartsSort]);

  const chartsSortOptions = [
    { value: 'rank', label: 'Chart Rank' },
    { value: 'alpha-asc', label: 'A-Z' },
    { value: 'alpha-desc', label: 'Z-A' },
    { value: 'artist', label: 'Artist Name' }
  ];

  // Filter and sort critics picks
  const filterCriticsPicks = useCallback((items) => {
    if (!criticsSearch.trim()) return items;
    const query = criticsSearch.toLowerCase();
    return items.filter(c =>
      c.title.toLowerCase().includes(query) ||
      c.artist.toLowerCase().includes(query)
    );
  }, [criticsSearch]);

  const sortCriticsPicks = useCallback((items) => {
    const sorted = [...items];
    switch (criticsSort) {
      case 'recent': return sorted; // Keep original order (date added)
      case 'score-desc': return sorted.sort((a, b) => (b.score || 0) - (a.score || 0));
      case 'artist': return sorted.sort((a, b) => a.artist.localeCompare(b.artist));
      default: return sorted;
    }
  }, [criticsSort]);

  const criticsSortOptions = [
    { value: 'recent', label: 'Date Added' },
    { value: 'score-desc', label: 'Score' },
    { value: 'artist', label: 'Artist Name' }
  ];

  // Filter and sort history
  const filterHistory = useCallback((items) => {
    if (!historySearch.trim()) return items;
    const query = historySearch.toLowerCase();
    return items.filter(t =>
      t.title.toLowerCase().includes(query) ||
      t.artist.toLowerCase().includes(query) ||
      (t.album && t.album.toLowerCase().includes(query))
    );
  }, [historySearch]);

  const sortHistory = useCallback((items) => {
    const sorted = [...items];
    switch (historySort) {
      case 'recent': return sorted; // Keep original order (most recent first)
      case 'artist': return sorted.sort((a, b) => a.artist.localeCompare(b.artist));
      case 'title': return sorted.sort((a, b) => a.title.localeCompare(b.title));
      default: return sorted;
    }
  }, [historySort]);

  const historySortOptions = [
    { value: 'recent', label: 'Recent' },
    { value: 'artist', label: 'Artist A-Z' },
    { value: 'title', label: 'Title A-Z' }
  ];

  // Sort friend history
  const sortFriendHistory = useCallback((items) => {
    const sorted = [...items];
    switch (friendHistorySort) {
      case 'recent': return sorted; // Keep original order (most recent first)
      case 'artist': return sorted.sort((a, b) => a.artist.localeCompare(b.artist));
      case 'title': return sorted.sort((a, b) => a.title.localeCompare(b.title));
      default: return sorted;
    }
  }, [friendHistorySort]);

  const [isScanning, setIsScanning] = useState(false);
  const [scanProgress, setScanProgress] = useState({ current: 0, total: 0, file: '' });

  // ID3 Tag Editor state
  const [id3EditorOpen, setId3EditorOpen] = useState(false);
  const [id3EditorTrack, setId3EditorTrack] = useState(null);
  const [id3EditorValues, setId3EditorValues] = useState({
    title: '',
    artist: '',
    album: '',
    trackNumber: '',
    year: ''
  });
  const [id3EditorSaving, setId3EditorSaving] = useState(false);
  const [id3ArtSuggestions, setId3ArtSuggestions] = useState([]);
  const [id3ArtLoading, setId3ArtLoading] = useState(false);
  const [id3SelectedArt, setId3SelectedArt] = useState(null);
  const [id3ArtFetchKey, setId3ArtFetchKey] = useState(''); // Track last fetch to avoid duplicates

  // Add to Playlist panel state
  const [addToPlaylistPanel, setAddToPlaylistPanel] = useState({
    open: false,
    tracks: [], // Tracks to add
    sourceName: '', // Name of source (track title, album name, or playlist name)
    sourceType: '' // 'track', 'album', 'playlist'
  });
  const [selectedPlaylistsForAdd, setSelectedPlaylistsForAdd] = useState([]); // Selected playlist IDs for multi-select
  const [newPlaylistFormOpen, setNewPlaylistFormOpen] = useState(false); // Accordion state for new playlist form
  const [newPlaylistName, setNewPlaylistName] = useState(''); // Input value for new playlist name
  const [draggingTrackForPlaylist, setDraggingTrackForPlaylist] = useState(null); // Track being dragged that could be dropped on playlist
  const [toast, setToast] = useState(null); // { message: string, type: 'success' | 'error' | 'info', action?: { label: string, onClick: () => void } }
  const [collectionData, setCollectionData] = useState({ tracks: [], albums: [], artists: [] });
  const [collectionLoading, setCollectionLoading] = useState(true);
  const [collectionDropHighlight, setCollectionDropHighlight] = useState(false);
  const [dropTargetPlaylistId, setDropTargetPlaylistId] = useState(null); // Playlist being hovered during drag
  const [dropTargetNewPlaylist, setDropTargetNewPlaylist] = useState(false); // Hovering over "+ NEW" button during drag
  const [droppedTrackForNewPlaylist, setDroppedTrackForNewPlaylist] = useState(null); // Track dropped on "+ NEW" to be added after creating playlist
  const [addToPlaylistSort, setAddToPlaylistSort] = useState('added'); // Sort option for add-to-playlist panel
  const [addToPlaylistSearch, setAddToPlaylistSearch] = useState(''); // Search filter for add-to-playlist panel
  const [addToPlaylistSearchOpen, setAddToPlaylistSearchOpen] = useState(false); // Search input expanded state
  const [addToPlaylistSortDropdownOpen, setAddToPlaylistSortDropdownOpen] = useState(false); // Sort dropdown open state

  // Confirmation dialog state
  const [confirmDialog, setConfirmDialog] = useState({
    show: false,
    type: 'success', // 'success' | 'error' | 'info'
    title: '',
    message: '',
    onConfirm: null
  });

  // Helper to show styled confirmation dialogs
  const showConfirmDialog = (options) => {
    setConfirmDialog({
      show: true,
      type: options.type || 'info',
      title: options.title || '',
      message: options.message || '',
      onConfirm: options.onConfirm || null
    });
  };

  const closeConfirmDialog = () => {
    setConfirmDialog(prev => ({ ...prev, show: false }));
  };
  const [refreshingPlaylist, setRefreshingPlaylist] = useState(null); // Track which playlist is refreshing

  // Drag & drop URL state
  const [isDraggingUrl, setIsDraggingUrl] = useState(false);
  const [dropZoneTarget, setDropZoneTarget] = useState(null); // 'now-playing' | 'queue' | null
  const queueAnimationRef = useRef(null);
  const [queueAnimating, setQueueAnimating] = useState(false);
  const queueContentRef = useRef(null); // Ref for queue content scrolling
  const resolverLoaderRef = useRef(null);

  // Browser extension state
  const [extensionConnected, setExtensionConnected] = useState(false);
  const [browserPlaybackActive, setBrowserPlaybackActive] = useState(false);
  const [activeExtensionTabId, setActiveExtensionTabId] = useState(null);
  const pendingCloseTabIdRef = useRef(null);
  const streamingPlaybackActiveRef = useRef(false); // Track when playing via Spotify/streaming to ignore browser events

  // Refs to keep current values available in event handlers (avoids stale closure issues)
  const currentQueueRef = useRef([]);
  const currentTrackRef = useRef(null);
  const handleNextRef = useRef(null);
  const playHistoryRef = useRef([]); // Stack of previously played tracks for "previous" navigation
  // Friend function refs (for use in early useEffects before functions are defined)
  const navigateToFriendRef = useRef(null);
  const pinFriendRef = useRef(null);
  const unpinFriendRef = useRef(null);
  const removeFriendRef = useRef(null);
  const saveFriendToCollectionRef = useRef(null);
  const removeFriendFromCollectionRef = useRef(null);
  const activateListenAlongRef = useRef(null);
  const deactivateListenAlongRef = useRef(null);
  const artistPageScrollRef = useRef(null); // Ref for artist page scroll container
  const audioRef = useRef(null); // HTML5 Audio element for local file playback
  const localFilePlaybackTrackRef = useRef(null); // Track being played for fallback handling
  const localFileFallbackInProgressRef = useRef(false); // Prevent duplicate error dialogs during fallback
  const pageResolutionAbortRef = useRef(null); // AbortController for cancelling page resolution

  // Refs for collection tracks visibility tracking
  const collectionTrackRowRefs = useRef(new Map());
  const collectionObserverRef = useRef(null);
  const visibleCollectionTrackIds = useRef(new Set());

  // Refs for release page tracks visibility tracking
  const releaseTrackRowRefs = useRef(new Map());
  const releaseObserverRef = useRef(null);
  const visibleReleaseTrackIds = useRef(new Set());

  // Refs for friends sidebar visibility tracking
  const friendEntryRefs = useRef(new Map());
  const friendsObserverRef = useRef(null);
  const visibleFriendIds = useRef(new Set());

  // Refs for recommendations tracks visibility tracking
  const recommendationsTrackRowRefs = useRef(new Map());
  const recommendationsObserverRef = useRef(null);
  const visibleRecommendationsTrackIds = useRef(new Set());
  const recommendationsTracksRef = useRef([]); // Ref to access current tracks in observer callback
  const recommendationsScrollContainerRef = useRef(null); // Ref to scroll container for IntersectionObserver root
  const [recommendationsScrollContainerReady, setRecommendationsScrollContainerReady] = useState(false);

  // Refs for history tracks visibility tracking
  const historyTrackRowRefs = useRef(new Map());
  const historyObserverRef = useRef(null);
  const visibleHistoryTrackIds = useRef(new Set());
  const historyScrollContainerRef = useRef(null);
  const historyTracksRef = useRef([]); // Ref to access current tracks in observer callback
  const [historyScrollContainerReady, setHistoryScrollContainerReady] = useState(false);

  // Refs for top tracks visibility tracking
  const topTracksRowRefs = useRef(new Map());
  const topTracksObserverRef = useRef(null);
  const visibleTopTrackIds = useRef(new Set());
  const topTracksRef = useRef([]); // Ref to access current tracks in observer callback
  const topTracksScrollContainerRef = useRef(null);
  const [topTracksScrollContainerReady, setTopTracksScrollContainerReady] = useState(false);

  // Refs for friend history tracks visibility tracking
  const friendHistoryTrackRowRefs = useRef(new Map());
  const friendHistoryObserverRef = useRef(null);
  const visibleFriendHistoryTrackIds = useRef(new Set());
  const friendHistoryScrollContainerRef = useRef(null);
  const friendHistoryTracksRef = useRef([]); // Ref to access current tracks in observer callback
  const [friendHistoryScrollContainerReady, setFriendHistoryScrollContainerReady] = useState(false);

  // Refs for search results tracks visibility tracking
  const searchTracksRowRefs = useRef(new Map());
  const searchTracksObserverRef = useRef(null);
  const visibleSearchTrackIds = useRef(new Set());
  const searchScrollContainerRef = useRef(null);
  const searchTracksRef = useRef([]); // Ref to access current tracks in observer callback
  const [searchScrollContainerReady, setSearchScrollContainerReady] = useState(false);

  // Refs for playlist tracks visibility tracking
  const playlistTrackRowRefs = useRef(new Map());
  const playlistObserverRef = useRef(null);
  const visiblePlaylistTrackIds = useRef(new Set());
  const playlistScrollContainerRef = useRef(null);
  const playlistTracksRef = useRef([]); // Ref to access current tracks in observer callback
  const [playlistScrollContainerReady, setPlaylistScrollContainerReady] = useState(false);

  // Refs for collection tracks scroll container
  const collectionScrollContainerRef = useRef(null);
  const collectionTracksRef = useRef([]); // Ref to access current tracks in observer callback
  const [collectionScrollContainerReady, setCollectionScrollContainerReady] = useState(false)

  const [selectedResolver, setSelectedResolver] = useState(null); // Resolver detail modal

  // Close add-to-playlist sort dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = () => setAddToPlaylistSortDropdownOpen(false);
    if (addToPlaylistSortDropdownOpen) {
      document.addEventListener('click', handleClickOutside);
      return () => document.removeEventListener('click', handleClickOutside);
    }
  }, [addToPlaylistSortDropdownOpen]);

  // Close playbar source dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = () => setPlaybarSourceDropdownOpen(false);
    if (playbarSourceDropdownOpen) {
      document.addEventListener('click', handleClickOutside);
      return () => document.removeEventListener('click', handleClickOutside);
    }
  }, [playbarSourceDropdownOpen]);

  // Keep refs in sync with state
  useEffect(() => { currentQueueRef.current = currentQueue; }, [currentQueue]);
  useEffect(() => { currentTrackRef.current = currentTrack; }, [currentTrack]);
  useEffect(() => { spotifyTokenRef.current = spotifyToken; }, [spotifyToken]);
  useEffect(() => { isMutedRef.current = isMuted; }, [isMuted]);
  useEffect(() => { spinoffModeRef.current = spinoffMode; }, [spinoffMode]);
  useEffect(() => { spinoffSourceTrackRef.current = spinoffSourceTrack; }, [spinoffSourceTrack]);
  useEffect(() => { isPlayingRef.current = isPlaying; }, [isPlaying]);
  useEffect(() => { listenAlongFriendRef.current = listenAlongFriend; }, [listenAlongFriend]);

  // Handle album art crossfade transitions in playbar
  useEffect(() => {
    const newArt = currentTrack?.albumArt || null;
    const prevArt = playbarAlbumArtRef.current;

    if (newArt !== prevArt) {
      // Album art changed - trigger crossfade
      setPlaybarAlbumArt({
        current: newArt,
        previous: prevArt,
        isLoaded: !newArt // If no new art, mark as loaded immediately
      });
      playbarAlbumArtRef.current = newArt;

      // Clear previous art after transition completes to free memory
      if (prevArt) {
        const clearPrevious = setTimeout(() => {
          setPlaybarAlbumArt(prev => ({ ...prev, previous: null }));
        }, 400); // Slightly longer than transition duration
        return () => clearTimeout(clearPrevious);
      }
    }
  }, [currentTrack?.albumArt]);

  // Check if spinoff is available for the current track
  useEffect(() => {
    // Reset availability when track changes
    setSpinoffAvailable(null);

    if (!currentTrack?.artist || !currentTrack?.title) {
      return;
    }

    // Don't check while in spinoff mode (we already know it works)
    if (spinoffMode) {
      setSpinoffAvailable(true);
      return;
    }

    let cancelled = false;
    const checkAvailability = async () => {
      const available = await checkSpinoffAvailability(currentTrack.artist, currentTrack.title);
      if (!cancelled) {
        setSpinoffAvailable(available);
      }
    };

    checkAvailability();
    return () => { cancelled = true; };
  }, [currentTrack?.artist, currentTrack?.title, spinoffMode]);

  // Scroll queue to bottom when opened (so track 1 is visible at the bottom)
  useEffect(() => {
    if (queueDrawerOpen && queueContentRef.current) {
      // Small delay to ensure the drawer has animated open
      setTimeout(() => {
        if (queueContentRef.current) {
          queueContentRef.current.scrollTop = queueContentRef.current.scrollHeight;
        }
      }, 50);
    }
  }, [queueDrawerOpen]);

  // Artist page scroll handler for header collapse
  const artistCollapseLockedRef = useRef(false);
  const artistLastScrollTopRef = useRef(0);
  const handleArtistPageScroll = useCallback((e) => {
    const scrollTop = e.target.scrollTop;
    const lastScrollTop = artistLastScrollTopRef.current;
    const isScrollingUp = scrollTop < lastScrollTop;
    artistLastScrollTopRef.current = scrollTop;

    // If locked (during transition), ignore scroll events
    if (artistCollapseLockedRef.current) return;

    // Collapse when scrolled down past threshold
    if (scrollTop > 50 && !isHeaderCollapsed && !isScrollingUp) {
      artistCollapseLockedRef.current = true;
      setIsHeaderCollapsed(true);
      // Unlock after transition completes
      setTimeout(() => { artistCollapseLockedRef.current = false; }, 350);
    }
    // Expand when scrolling up near the top (within 100px) or at very top
    else if (isHeaderCollapsed && isScrollingUp && scrollTop < 100) {
      artistCollapseLockedRef.current = true;
      setIsHeaderCollapsed(false);
      setTimeout(() => { artistCollapseLockedRef.current = false; }, 350);
    }
  }, [isHeaderCollapsed]);

  // Search detail page scroll handler for header collapse and infinite scroll
  const handleSearchDetailScroll = useCallback((e) => {
    const { scrollTop, scrollHeight, clientHeight } = e.target;
    // Header collapse
    setSearchHeaderCollapsed(scrollTop > 100);
    // Infinite scroll - load more when within 200px of bottom
    if (scrollHeight - scrollTop - clientHeight < 200 && searchDetailCategory) {
      handleLoadMore(searchDetailCategory);
    }
  }, [searchDetailCategory]);

  // Reset search header collapse when leaving detail view
  useEffect(() => {
    if (!searchDetailCategory) {
      setSearchHeaderCollapsed(false);
    }
  }, [searchDetailCategory]);

  // Reset header collapse and tab when navigating to a new artist (but not when opening a release or restoring state)
  useEffect(() => {
    // Don't reset header if we're opening a release - it should stay collapsed
    if (openingReleaseRef.current) {
      openingReleaseRef.current = false;
    } else {
      setIsHeaderCollapsed(false);
    }
    // Don't reset tab or clear data if we're restoring saved state
    if (restoringStateRef.current) {
      restoringStateRef.current = false;
    } else {
      setArtistPageTab('music');
      setArtistBio(null);
      setArtistExtendedInfo(null);
      setRelatedArtists([]);
    }
  }, [currentArtist]);

  // Fetch tab data when restored to biography or related artists tab
  useEffect(() => {
    if (!currentArtist) return;

    if (artistPageTab === 'biography') {
      // Fetch bio if not already loaded
      if (artistBio === null && !loadingBio) {
        setLoadingBio(true); // Set loading immediately before async call
        (async () => {
          const bioData = await getArtistBio(currentArtist.name, currentArtist.mbid);
          setArtistBio(bioData === null ? false : bioData); // Use false to indicate "fetched but no bio"
        })();
      }

      // Fetch extended info if not already loaded
      if (artistExtendedInfo === null && !loadingExtendedInfo && currentArtist.mbid) {
        (async () => {
          const extInfo = await fetchArtistExtendedInfo(currentArtist.mbid);
          setArtistExtendedInfo(extInfo === null ? false : extInfo);
        })();
      }
    }

    if (artistPageTab === 'related' && relatedArtists.length === 0 && !loadingRelated) {
      (async () => {
        const related = await getRelatedArtists(currentArtist.name, currentArtist.mbid);
        if (related.length > 0) {
          setRelatedArtists(related);
          resolveRelatedArtistImages(related);
        }
      })();
    }
  }, [artistPageTab, currentArtist]);

  // Load local files data when resolver modal is opened
  useEffect(() => {
    if (selectedResolver?.id === 'localfiles' && window.electron?.localFiles) {
      window.electron.localFiles.getStats().then(setLocalFilesStats);
      window.electron.localFiles.getWatchFolders().then(setWatchFolders);
    }
  }, [selectedResolver]);

  // Listen for local files scan progress and library changes
  useEffect(() => {
    if (window.electron?.localFiles?.onScanProgress) {
      window.electron.localFiles.onScanProgress((data) => {
        setScanProgress(data);
      });
    }
    if (window.electron?.localFiles?.onLibraryChanged) {
      window.electron.localFiles.onLibraryChanged((changes) => {
        // Refresh stats when library changes
        if (window.electron?.localFiles) {
          window.electron.localFiles.getStats().then(setLocalFilesStats);
          window.electron.localFiles.getWatchFolders().then(setWatchFolders);
        }
      });
    }
  }, []);

  // URL drag & drop helpers
  const isValidUrl = (string) => {
    try {
      const url = new URL(string);
      return url.protocol === 'http:' || url.protocol === 'https:' || string.startsWith('spotify:');
    } catch {
      return false;
    }
  };

  const extractUrlFromDrop = (dataTransfer) => {
    // Try text/uri-list first (standard for URL drops)
    let url = dataTransfer.getData('text/uri-list');
    if (url && isValidUrl(url.split('\n')[0])) {
      return url.split('\n')[0].trim();
    }

    // Fallback to text/plain
    url = dataTransfer.getData('text/plain');
    if (url && isValidUrl(url.trim())) {
      return url.trim();
    }

    return null;
  };

  const getUrlDomain = (url) => {
    try {
      if (url.startsWith('spotify:')) return 'spotify.com';
      const urlObj = new URL(url);
      return urlObj.hostname.replace(/^www\./, '');
    } catch {
      return 'unknown';
    }
  };

  // Convert raw track metadata to a proper track object with sources
  const createTrackFromMeta = (trackMeta, resolverId, sourceUrl = null) => {
    const trackId = `${trackMeta.artist}-${trackMeta.title}-${trackMeta.album || 'Single'}`.toLowerCase().replace(/[^a-z0-9]/g, '-');
    const track = {
      id: trackId,
      status: 'ready',
      title: trackMeta.title,
      artist: trackMeta.artist,
      album: trackMeta.album || 'Single',
      duration: trackMeta.duration || 180,
      albumArt: trackMeta.albumArt,
      sourceUrl: sourceUrl,
      sources: {}
    };

    // Add source-specific data
    const sourceData = {};
    if (trackMeta.spotifyId) sourceData.spotifyId = trackMeta.spotifyId;
    if (trackMeta.spotifyUri) sourceData.spotifyUri = trackMeta.spotifyUri;
    if (trackMeta.youtubeId) sourceData.youtubeId = trackMeta.youtubeId;
    if (trackMeta.bandcampUrl) sourceData.bandcampUrl = trackMeta.bandcampUrl;
    if (trackMeta.appleMusicId) sourceData.appleMusicId = trackMeta.appleMusicId;
    if (trackMeta.previewUrl) sourceData.previewUrl = trackMeta.previewUrl;

    if (Object.keys(sourceData).length > 0) {
      track.sources[resolverId] = {
        ...sourceData,
        confidence: 1.0
      };
    }

    return track;
  };

  // Handle URL drop - main entry point
  const handleUrlDrop = async (url, zone) => {
    console.log(`ðŸ”— URL dropped on ${zone}:`, url);

    // Find resolver for this URL
    const resolverId = resolverLoaderRef.current?.findResolverForUrl(url);
    if (!resolverId) {
      console.error('âŒ No resolver found for URL:', url);
      return;
    }

    console.log(`ðŸ“Ž Matched resolver: ${resolverId}`);

    // Detect URL type (track, album, or playlist)
    const urlType = resolverLoaderRef.current.getUrlType(url);
    console.log(`ðŸ“Ž URL type: ${urlType}`);

    // Handle album/playlist URLs
    if (urlType === 'album' || urlType === 'playlist') {
      await handleCollectionUrlDrop(url, resolverId, urlType, zone);
      return;
    }

    // Handle single track URL (existing logic)
    await handleSingleTrackUrlDrop(url, zone, resolverId);
  };

  // Handle album or playlist URL drop
  const handleCollectionUrlDrop = async (url, resolverId, urlType, zone) => {
    console.log(`ðŸ“€ Loading ${urlType} from URL (zone: ${zone}):`, url);
    console.log(`ðŸ“€ Resolver ID: ${resolverId}`);

    try {
      const config = await getResolverConfig(resolverId);
      console.log(`ðŸ“€ Config has token: ${!!config.token}`);
      let result;

      if (urlType === 'album') {
        console.log(`ðŸ“€ Calling lookupAlbum...`);
        result = await resolverLoaderRef.current.lookupAlbum(url, config);
        console.log(`ðŸ“€ lookupAlbum result:`, result);
        if (!result || !result.album) {
          throw new Error('Could not load album');
        }
      } else {
        // Check if resolver has lookupPlaylist
        const resolver = resolverLoaderRef.current.getResolver(resolverId);
        console.log(`ðŸ“€ Resolver has lookupPlaylist: ${!!resolver?.lookupPlaylist}`);
        console.log(`ðŸ“€ Calling lookupPlaylist...`);
        result = await resolverLoaderRef.current.lookupPlaylist(url, config);
        console.log(`ðŸ“€ lookupPlaylist result:`, result);
        if (!result || !result.playlist) {
          throw new Error('Could not load playlist');
        }
      }

      const collection = result.album || result.playlist;
      const collectionResolverId = result.resolverId;
      const tracks = collection.tracks || [];

      if (tracks.length === 0) {
        console.error(`âŒ ${urlType} has no tracks`);
        return;
      }

      console.log(`âœ… ${urlType} "${collection.name}" loaded with ${tracks.length} tracks`);

      // Create context for this collection (include source URL for external navigation)
      const context = urlType === 'album'
        ? { type: 'album', id: collection.id, name: collection.name, artist: collection.artist, url: url }
        : { type: 'playlist', id: collection.id, name: collection.name, url: url };

      // Convert all tracks to proper track objects with context
      const resolvedTracks = tracks.map(trackMeta => ({
        ...createTrackFromMeta(trackMeta, collectionResolverId, url),
        _playbackContext: context
      }));

      const hasCurrentTrack = currentTrackRef.current !== null;

      // If dropped on now-playing zone, play first track immediately
      // and add remaining tracks to the BEGINNING of the queue (play next)
      if (zone === 'now-playing') {
        const firstTrack = resolvedTracks[0];
        const remainingTracks = resolvedTracks.slice(1);

        // Show toast notification
        showToast(`Playing "${collection.name}" (${tracks.length} tracks)`);

        // Add remaining tracks to the BEGINNING of the queue (so they play next)
        if (remainingTracks.length > 0) {
          setCurrentQueue(prev => [...remainingTracks, ...prev]);
        }

        // Set context and play first track immediately
        setPlaybackContext(context);
        setCurrentTrack(firstTrack);
        handlePlay(firstTrack);

        // Trigger queue animation if we added tracks
        if (remainingTracks.length > 0) {
          triggerQueueAnimation();
        }
      } else {
        // Default behavior: insert tracks at position 1 (play next)
        showToast(`Playing "${collection.name}" next (${tracks.length} tracks)`);

        setCurrentQueue(prev => {
          // Insert at position 1 if queue has items, otherwise at position 0
          const insertPosition = prev.length > 0 ? 1 : 0;
          return [...prev.slice(0, insertPosition), ...resolvedTracks, ...prev.slice(insertPosition)];
        });
        triggerQueueAnimation();

        // If nothing is playing, start the first track
        if (!hasCurrentTrack && resolvedTracks.length > 0) {
          const firstTrack = resolvedTracks[0];
          // Remove from queue and set as current
          setCurrentQueue(prev => prev.slice(1));
          setPlaybackContext(context);
          setCurrentTrack(firstTrack);
          handlePlay(firstTrack);
        }
      }

      // Background resolution: resolve all tracks across all enabled resolvers
      // This happens asynchronously so tracks are playable immediately but will
      // have all sources available for priority-based playback
      resolveTracksInBackground(resolvedTracks);

    } catch (error) {
      console.error(`âŒ ${urlType} lookup failed:`, error);
      showToast(`Could not load ${urlType}: ${error.message}`, 'error');
    }
  };

  // Resolve tracks across all enabled resolvers in the background
  const resolveTracksInBackground = async (tracks) => {
    console.log(`ðŸ” Background resolution: resolving ${tracks.length} tracks across all sources...`);

    // Use ref to avoid stale closure issues
    const currentResolvers = loadedResolversRef.current;
    const enabledResolvers = resolverOrder
      .filter(id => activeResolvers.includes(id))
      .map(id => currentResolvers.find(r => r.id === id))
      .filter(r => r && r.capabilities.resolve);

    // Process tracks in batches to avoid overwhelming APIs
    const BATCH_SIZE = 5;
    for (let i = 0; i < tracks.length; i += BATCH_SIZE) {
      const batch = tracks.slice(i, i + BATCH_SIZE);

      await Promise.all(batch.map(async (track) => {
        // Skip if track already has multiple sources
        if (Object.keys(track.sources).length >= enabledResolvers.length) {
          return;
        }

        const resolvePromises = enabledResolvers.map(async (resolver) => {
          // Skip if we already have this source
          if (track.sources[resolver.id]) return;

          try {
            const config = await getResolverConfig(resolver.id);
            const result = await resolver.resolve(track.artist, track.title, track.album, config);
            if (result) {
              track.sources[resolver.id] = {
                ...result,
                confidence: 0.9
              };
              // Also update album/albumArt if not set
              if (!track.album && result.album) track.album = result.album;
              if (!track.albumArt && result.albumArt) track.albumArt = result.albumArt;
              console.log(`  âœ… ${resolver.name}: Found "${track.title}"`);
            }
          } catch (error) {
            // Silently fail - background resolution is best-effort
          }
        });

        await Promise.all(resolvePromises);
      }));

      // Small delay between batches to be nice to APIs
      if (i + BATCH_SIZE < tracks.length) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }

    // Update queue state with resolved sources and album info
    setCurrentQueue(prev => prev.map(queueTrack => {
      const resolvedTrack = tracks.find(t => t.id === queueTrack.id);
      if (resolvedTrack && Object.keys(resolvedTrack.sources).length > Object.keys(queueTrack.sources).length) {
        return {
          ...queueTrack,
          sources: resolvedTrack.sources,
          album: queueTrack.album || resolvedTrack.album,
          albumArt: queueTrack.albumArt || resolvedTrack.albumArt
        };
      }
      return queueTrack;
    }));

    console.log(`âœ… Background resolution complete for ${tracks.length} tracks`);
  };

  // Handle single track URL drop (original handleUrlDrop logic)
  const handleSingleTrackUrlDrop = async (url, zone, resolverId) => {
    // Create context for this URL drop
    const context = { type: 'url', url: url, name: getUrlDomain(url) };

    // Create placeholder track
    const placeholderId = `pending-${Date.now()}`;
    const placeholder = {
      id: placeholderId,
      status: 'loading',
      sourceUrl: url,
      sourceDomain: getUrlDomain(url),
      title: null,
      artist: null,
      album: null,
      duration: null,
      albumArt: null,
      sources: {},
      errorMessage: null,
      _playbackContext: context
    };

    // Determine where to insert - use refs to avoid stale closure issues
    // (especially when called from extension message handler in useEffect)
    const hasQueue = currentQueueRef.current.length > 0;
    const hasCurrentTrack = currentTrackRef.current !== null;
    // Play immediately only if explicitly requested OR if nothing is playing/queued
    const shouldPlayImmediately = zone === 'now-playing' || (!hasQueue && !hasCurrentTrack);
    console.log(`ðŸ“ handleUrlDrop: hasQueue=${hasQueue}, hasCurrentTrack=${hasCurrentTrack}, shouldPlayImmediately=${shouldPlayImmediately}`);

    if (shouldPlayImmediately) {
      // Set as current track (loading state)
      setCurrentTrack(placeholder);
    } else {
      // Add to queue - insert at position 1 if queue has items, otherwise at position 0
      setCurrentQueue(prev => {
        const newQueue = [...prev];
        const insertPosition = prev.length > 0 ? 1 : 0;
        newQueue.splice(insertPosition, 0, placeholder);
        return newQueue;
      });
      // Trigger queue icon animation
      triggerQueueAnimation();
    }

    // Look up track metadata
    try {
      // Pass resolver config so Spotify has access to token
      const config = await getResolverConfig(resolverId);
      const result = await resolverLoaderRef.current.lookupUrl(url, config);

      if (!result || !result.track) {
        throw new Error('Could not load track metadata');
      }

      const { track: trackMeta, resolverId: lookupResolverId } = result;
      console.log(`âœ… URL lookup success:`, trackMeta.title, '-', trackMeta.artist);

      // Create proper track object with playback context
      const resolvedTrack = {
        ...createTrackFromMeta(trackMeta, lookupResolverId, url),
        _playbackContext: context
      };

      // Now resolve across all enabled resolvers for playable sources
      console.log(`ðŸ” Resolving playable sources...`);
      // Use ref to avoid stale closure issues when called from extension message handler
      const currentResolvers = loadedResolversRef.current;
      const enabledResolvers = resolverOrder
        .filter(id => activeResolvers.includes(id))
        .map(id => currentResolvers.find(r => r.id === id))
        .filter(r => r && r.capabilities.resolve);

      const resolvePromises = enabledResolvers.map(async (resolver) => {
        try {
          const config = await getResolverConfig(resolver.id);
          const result = await resolver.resolve(trackMeta.artist, trackMeta.title, trackMeta.album, config);
          if (result) {
            resolvedTrack.sources[resolver.id] = {
              ...result,
              confidence: 0.9
            };
            console.log(`  âœ… ${resolver.name}: Found match`);
          }
        } catch (error) {
          console.error(`  âŒ ${resolver.name} resolve error:`, error);
        }
      });

      await Promise.all(resolvePromises);

      // Update the placeholder with resolved data
      if (shouldPlayImmediately) {
        setCurrentTrack(prev => {
          if (prev?.id === placeholderId) {
            return resolvedTrack;
          }
          return prev;
        });
        // Set playback context and actually play it
        setPlaybackContext(context);
        handlePlay(resolvedTrack);
      } else {
        setCurrentQueue(prev => prev.map(t =>
          t.id === placeholderId ? resolvedTrack : t
        ));
      }

    } catch (error) {
      console.error('âŒ URL lookup failed:', error);

      // Update placeholder to error state
      const errorTrack = {
        ...placeholder,
        status: 'error',
        errorMessage: error.message || 'Could not load track'
      };

      if (shouldPlayImmediately) {
        setCurrentTrack(prev => {
          if (prev?.id === placeholderId) {
            return errorTrack;
          }
          return prev;
        });
      } else {
        setCurrentQueue(prev => prev.map(t =>
          t.id === placeholderId ? errorTrack : t
        ));
      }
    }
  };

  // Queue animation trigger
  const triggerQueueAnimation = () => {
    setQueueAnimating(true);
    if (queueAnimationRef.current) {
      clearTimeout(queueAnimationRef.current);
    }
    queueAnimationRef.current = setTimeout(() => {
      setQueueAnimating(false);
    }, 300);
  };

  // Drag event handlers for URL drops
  const handleDragEnter = (e, zone) => {
    e.preventDefault();
    e.stopPropagation();

    const url = extractUrlFromDrop(e.dataTransfer);
    if (!url) return;

    // Check if any resolver can handle this URL
    const resolverId = resolverLoaderRef.current?.findResolverForUrl(url);
    if (resolverId) {
      setIsDraggingUrl(true);
      setDropZoneTarget(zone);
    }
  };

  const handleDragOver = (e, zone) => {
    e.preventDefault();
    e.stopPropagation();

    // Update target if moving between zones
    if (isDraggingUrl && dropZoneTarget !== zone) {
      setDropZoneTarget(zone);
    }
  };

  const handleDragLeave = (e) => {
    e.preventDefault();
    e.stopPropagation();

    // Only clear if leaving the app entirely
    const relatedTarget = e.relatedTarget;
    if (!relatedTarget || !e.currentTarget.contains(relatedTarget)) {
      setIsDraggingUrl(false);
      setDropZoneTarget(null);
    }
  };

  const handleDrop = (e, zone) => {
    e.preventDefault();
    e.stopPropagation();

    setIsDraggingUrl(false);
    setDropZoneTarget(null);

    // First, try to parse as internal JSON object (track, album, playlist)
    const plainText = e.dataTransfer.getData('text/plain');
    if (plainText) {
      try {
        const data = JSON.parse(plainText);
        if (data.type === 'track' && data.track) {
          console.log(`ðŸŽµ Internal track dropped on ${zone}:`, data.track.title);
          if (zone === 'now-playing') {
            // Play immediately
            setCurrentTrack(data.track);
            handlePlay(data.track);
          } else {
            // Add to queue
            setCurrentQueue(prev => [...prev, data.track]);
            triggerQueueAnimation();
          }
          return;
        }
        if (data.type === 'album' && data.album) {
          console.log(`ðŸ“€ Internal album dropped on ${zone}:`, data.album.title);
          // Fetch album tracks and handle like a collection drop
          handleInternalAlbumDrop(data.album, zone);
          return;
        }
        if (data.type === 'playlist' && data.playlist) {
          console.log(`ðŸ“‹ Internal playlist dropped on ${zone}:`, data.playlist.title);
          // Handle playlist tracks
          handleInternalPlaylistDrop(data.playlist, zone);
          return;
        }
      } catch (parseError) {
        // Not JSON, continue to URL handling
      }
    }

    // Fall back to URL drop handling
    const url = extractUrlFromDrop(e.dataTransfer);
    if (!url) {
      console.log('No valid URL or internal object in drop');
      return;
    }

    handleUrlDrop(url, zone);
  };

  // Handle internal album drop (from within the app)
  const handleInternalAlbumDrop = async (album, zone) => {
    // If album has tracks array, use it directly
    if (album.tracks && album.tracks.length > 0) {
      const tracks = album.tracks;
      const context = { type: 'album', id: album.id, name: album.title, artist: album.artist };
      const taggedTracks = tracks.map(t => ({ ...t, _playbackContext: context }));
      if (zone === 'now-playing') {
        showToast(`Playing "${album.title}" (${tracks.length} tracks)`);
        const firstTrack = taggedTracks[0];
        const remainingTracks = taggedTracks.slice(1);
        // Add remaining tracks to BEGINNING of queue (play next)
        if (remainingTracks.length > 0) {
          setCurrentQueue(prev => [...remainingTracks, ...prev]);
        }
        setPlaybackContext(context);
        setCurrentTrack(firstTrack);
        handlePlay(firstTrack);
        if (remainingTracks.length > 0) {
          triggerQueueAnimation();
        }
      } else {
        showToast(`Added ${tracks.length} tracks from "${album.title}" to queue`);
        setCurrentQueue(prev => [...prev, ...taggedTracks]);
        triggerQueueAnimation();
      }
      return;
    }

    // Otherwise, need to fetch the album tracks (e.g., from release page cache)
    const releaseId = album.id;
    const cachedRelease = prefetchedReleasesRef.current[releaseId];
    if (cachedRelease && cachedRelease.tracks) {
      const tracks = cachedRelease.tracks;
      const context = { type: 'album', id: album.id, name: album.title, artist: album.artist };
      const taggedTracks = tracks.map(t => ({ ...t, _playbackContext: context }));
      if (zone === 'now-playing') {
        showToast(`Playing "${album.title}" (${tracks.length} tracks)`);
        const firstTrack = taggedTracks[0];
        const remainingTracks = taggedTracks.slice(1);
        // Add remaining tracks to BEGINNING of queue (play next)
        if (remainingTracks.length > 0) {
          setCurrentQueue(prev => [...remainingTracks, ...prev]);
        }
        setPlaybackContext(context);
        setCurrentTrack(firstTrack);
        handlePlay(firstTrack);
        if (remainingTracks.length > 0) {
          triggerQueueAnimation();
        }
      } else {
        showToast(`Added ${tracks.length} tracks from "${album.title}" to queue`);
        setCurrentQueue(prev => [...prev, ...taggedTracks]);
        triggerQueueAnimation();
      }
    } else {
      showToast(`Could not load tracks for "${album.title}"`, 'error');
    }
  };

  // Handle internal playlist drop (from within the app)
  const handleInternalPlaylistDrop = async (playlist, zone) => {
    const tracks = playlist.tracks || [];
    if (tracks.length === 0) {
      showToast(`Playlist "${playlist.title}" has no tracks`, 'error');
      return;
    }

    const context = { type: 'playlist', id: playlist.id, name: playlist.title };
    const taggedTracks = tracks.map(t => ({ ...t, _playbackContext: context }));

    if (zone === 'now-playing') {
      showToast(`Playing "${playlist.title}" (${tracks.length} tracks)`);
      const firstTrack = taggedTracks[0];
      const remainingTracks = taggedTracks.slice(1);
      // Add remaining tracks to BEGINNING of queue (play next)
      if (remainingTracks.length > 0) {
        setCurrentQueue(prev => [...remainingTracks, ...prev]);
      }
      setPlaybackContext(context);
      setCurrentTrack(firstTrack);
      handlePlay(firstTrack);
      if (remainingTracks.length > 0) {
        triggerQueueAnimation();
      }
    } else {
      showToast(`Added ${tracks.length} tracks from "${playlist.title}" to queue`);
      setCurrentQueue(prev => [...prev, ...taggedTracks]);
      triggerQueueAnimation();
    }
  };

  // Drop zone overlay component
  const DropZoneOverlay = ({ zone, isActive }) => {
    if (!isActive) return null;

    const isNowPlaying = zone === 'now-playing';
    const icon = isNowPlaying ? 'â–¶' : 'ðŸ“‹';
    const text = isNowPlaying ? 'Drop to Play Now' : 'Drop to Play Next';

    return React.createElement('div', {
      style: {
        position: 'absolute',
        inset: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.8)',
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        zIndex: 100,
        borderRadius: '8px',
        border: '2px dashed rgba(147, 51, 234, 0.5)',
        pointerEvents: 'none'
      }
    },
      React.createElement('div', {
        style: {
          fontSize: '48px',
          marginBottom: '16px'
        }
      }, icon),
      React.createElement('div', {
        style: {
          fontSize: '18px',
          fontWeight: '600',
          color: '#a855f7'
        }
      }, text)
    );
  };

  // Resolver plugin system
  const resolverLoader = useRef(null);
  const [loadedResolvers, setLoadedResolvers] = useState([]);
  const loadedResolversRef = useRef([]);

  // Cleanup polling interval, external track timeout, and stop playback on unmount
  useEffect(() => {
    // Also handle beforeunload for when window closes
    const handleBeforeUnload = () => {
      if (spotifyTokenRef.current) {
        // Use sendBeacon for reliable delivery during page unload
        const url = 'https://api.spotify.com/v1/me/player/pause';
        // sendBeacon doesn't support PUT, so fall back to fetch with keepalive
        fetch(url, {
          method: 'PUT',
          headers: { 'Authorization': `Bearer ${spotifyTokenRef.current}` },
          keepalive: true
        }).catch(() => {});
      }
    };

    window.addEventListener('beforeunload', handleBeforeUnload);

    return () => {
      window.removeEventListener('beforeunload', handleBeforeUnload);
      if (playbackPollerRef.current) {
        clearInterval(playbackPollerRef.current);
        playbackPollerRef.current = null;
      }
      if (pollingRecoveryRef.current) {
        clearInterval(pollingRecoveryRef.current);
        pollingRecoveryRef.current = null;
      }
      if (externalTrackTimeoutRef.current) {
        clearTimeout(externalTrackTimeoutRef.current);
        externalTrackTimeoutRef.current = null;
      }
      // Stop Spotify playback on app shutdown
      if (spotifyTokenRef.current) {
        fetch('https://api.spotify.com/v1/me/player/pause', {
          method: 'PUT',
          headers: { 'Authorization': `Bearer ${spotifyTokenRef.current}` },
          keepalive: true
        }).catch(() => {}); // Ignore errors on shutdown
      }
    };
  }, []);

  // Helper to determine resolver ID from track properties
  const determineResolverIdFromTrack = (track) => {
    if (!track) return null;
    // First check if we have an explicitly set active resolver (set during playback)
    if (track._activeResolver) return track._activeResolver;
    // Fall back to checking resolver-specific properties at top level OR nested in sources
    if (track.spotifyUri || track.spotifyId || track.sources?.spotify) return 'spotify';
    if (track.bandcampUrl || track.sources?.bandcamp) return 'bandcamp';
    if (track.youtubeUrl || track.youtubeId || track.sources?.youtube) return 'youtube';
    if (track.qobuzId || track.sources?.qobuz) return 'qobuz';
    if (track.filePath || track.fileUrl || track.sources?.localfiles) return 'localfiles';
    return null;
  };

  // Calculate effective volume with resolver offset and per-track adjustment
  // Returns volume as 0-100 percentage
  const getEffectiveVolume = (baseVolume, resolverId, trackId) => {
    // Get resolver offset (dB)
    const resolverOffset = resolverVolumeOffsets[resolverId] || 0;
    // Get per-track adjustment (dB)
    const trackOffset = trackId ? (trackVolumeAdjustments.current[trackId] || 0) : 0;
    // Total dB adjustment
    const totalOffsetDb = resolverOffset + trackOffset;
    // Convert dB to linear multiplier: 10^(dB/20)
    const multiplier = Math.pow(10, totalOffsetDb / 20);
    // Apply to base volume and clamp to 0-100
    const effectiveVolume = Math.max(0, Math.min(100, baseVolume * multiplier));
    return effectiveVolume;
  };

  // Set Spotify playback volume via API (with normalization)
  const setSpotifyVolume = async (volumePercent, applyNormalization = true) => {
    if (!spotifyTokenRef.current) return;
    try {
      // Apply normalization if enabled
      let effectiveVolume = volumePercent;
      if (applyNormalization && currentTrackRef.current) {
        effectiveVolume = getEffectiveVolume(volumePercent, 'spotify', currentTrackRef.current.id);
      }
      const response = await fetch(`https://api.spotify.com/v1/me/player/volume?volume_percent=${Math.round(effectiveVolume)}`, {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${spotifyTokenRef.current}`
        }
      });
      if (!response.ok && response.status !== 204) {
        console.error('Failed to set Spotify volume:', response.status);
      }
    } catch (error) {
      console.error('Error setting Spotify volume:', error);
    }
  };

  // Debounced version for slider dragging (prevents rate limiting)
  const setSpotifyVolumeDebounced = (volumePercent, applyNormalization = true) => {
    if (spotifyVolumeTimeoutRef.current) {
      clearTimeout(spotifyVolumeTimeoutRef.current);
    }
    spotifyVolumeTimeoutRef.current = setTimeout(() => {
      setSpotifyVolume(volumePercent, applyNormalization);
    }, 150); // 150ms debounce
  };

  // Apply normalized volume for local file playback
  const applyLocalFileVolume = (baseVolume, trackId) => {
    if (!audioRef.current) return;
    const effectiveVolume = getEffectiveVolume(baseVolume, 'localfiles', trackId);
    audioRef.current.volume = effectiveVolume / 100;
  };

  // Cache for album art URLs (releaseId -> { url, timestamp })
  const albumArtCache = useRef({});
  const [cacheLoaded, setCacheLoaded] = useState(false); // Track when persistent cache is loaded

  // Viewport-prioritized album art loading
  const visibleAlbumIds = useRef(new Set());      // Currently in viewport
  const albumArtQueue = useRef([]);               // Ordered queue of release IDs to fetch
  const isAlbumArtFetching = useRef(false);       // Prevents multiple fetcher loops
  const albumArtObserver = useRef(null);          // IntersectionObserver instance
  const albumArtFetchId = useRef(0);              // Incremented on each new fetch session to detect stale loops

  // Cache for artist data (artistName -> { data, timestamp })
  const artistDataCache = useRef({});

  // Cache for track sources (trackKey -> { sources, timestamp })
  // trackKey format: "artist|title|album"
  const trackSourcesCache = useRef({});

  // Cache for artist images from Last.fm (artistName -> { url, timestamp })
  const artistImageCache = useRef({});

  // Cache for artist extended info from MusicBrainz (mbid -> { info, timestamp })
  const artistExtendedInfoCache = useRef({});

  // Cache for playlist cover art (playlistId -> { covers: [url1, url2, url3, url4], timestamp })
  const playlistCoverCache = useRef({});

  // API keys loaded from environment via IPC
  const lastfmApiKey = useRef(null);

  // Cache TTLs (in milliseconds)
  const CACHE_TTL = {
    albumArt: 90 * 24 * 60 * 60 * 1000,    // 90 days
    artistData: 30 * 24 * 60 * 60 * 1000,  // 30 days
    trackSources: 7 * 24 * 60 * 60 * 1000, // 7 days (track availability changes)
    artistImage: 90 * 24 * 60 * 60 * 1000, // 90 days
    artistExtendedInfo: 30 * 24 * 60 * 60 * 1000, // 30 days (band info rarely changes)
    playlistCover: 30 * 24 * 60 * 60 * 1000, // 30 days
    recommendations: 60 * 60 * 1000         // 1 hour (recommendations change based on listening)
  };

  // Cache for recommendations data (tracks from API)
  const recommendationsCache = useRef({ tracks: null, timestamp: 0 });

  // Cache for listening history data
  const listeningHistoryCache = useRef({ tracks: null, timestamp: 0 });

  // Cache for top tracks data (keyed by period)
  const topTracksCache = useRef({});

  // Get meta services with AI generation capability
  const getAiServices = () => {
    // AI services are meta-services loaded into the resolver loader
    if (!resolverLoaderRef.current) return [];
    return resolverLoaderRef.current.getAllResolvers().filter(r =>
      r.capabilities?.generate
    );
  };

  // Check if a scrobbler service (Last.fm or ListenBrainz) is connected
  const hasScrobblerConnected = () => {
    const lastfmConfig = metaServiceConfigs.lastfm;
    const listenbrainzConfig = metaServiceConfigs.listenbrainz;
    return !!(lastfmConfig?.username || listenbrainzConfig?.username);
  };

  // Get the name of the connected scrobbler service
  const getScrobblerName = () => {
    const lastfmConfig = metaServiceConfigs.lastfm;
    if (lastfmConfig?.username) return 'Last.fm';
    const listenbrainzConfig = metaServiceConfigs.listenbrainz;
    if (listenbrainzConfig?.username) return 'ListenBrainz';
    return null;
  };

  // Generate a hash of current resolver settings for cache invalidation
  const getResolverSettingsHash = () => {
    const sortedActive = [...activeResolvers].sort().join(',');
    const sortedOrder = [...resolverOrder].join(',');
    return `${sortedActive}|${sortedOrder}`;
  };

  const sampleTracks = [
    { id: 1, title: 'Midnight Dreams', artist: 'Luna Echo', album: 'Nocturnal', duration: 245, sources: ['youtube', 'soundcloud'] },
    { id: 2, title: 'Electric Pulse', artist: 'Neon Waves', album: 'Synthwave', duration: 198, sources: ['youtube'] },
    { id: 3, title: 'Ocean Breeze', artist: 'Coastal Drift', album: 'Tides', duration: 267, sources: ['soundcloud', 'youtube'] },
    { id: 4, title: 'Urban Nights', artist: 'City Lights', album: 'Metropolitan', duration: 223, sources: ['youtube'] },
    { id: 5, title: 'Forest Path', artist: 'Nature Sound', album: 'Wilderness', duration: 301, sources: ['youtube', 'soundcloud'] },
  ];

  // Initialize resolver plugin system and load config
  useEffect(() => {
    const initResolvers = async () => {
      console.log('ðŸ”Œ Initializing resolver plugin system...');

      // Load API keys from environment via IPC
      if (window.electron?.config?.get) {
        try {
          const lfmKey = await window.electron.config.get('LASTFM_API_KEY');
          if (lfmKey) {
            lastfmApiKey.current = lfmKey;
            console.log('ðŸ”‘ Last.fm API key loaded from environment');
          } else {
            console.warn('âš ï¸ LASTFM_API_KEY not found in .env file');
          }
        } catch (error) {
          console.error('âŒ Failed to load API keys from config:', error);
        }
      }

      // Check if ResolverLoader is available
      if (typeof ResolverLoader === 'undefined') {
        console.error('âŒ ResolverLoader not found! Make sure resolver-loader.js is loaded.');
        return;
      }
      
      // Create resolver loader
      resolverLoader.current = new ResolverLoader();
      
      try {
        // Try to load built-in resolvers from resolvers/builtin/ directory
        console.log('ðŸ“ Loading resolver .axe files from resolvers/builtin/...');
        const builtinAxeFiles = await loadBuiltinResolvers();
        
        let resolversToLoad = builtinAxeFiles;
        
        if (builtinAxeFiles.length === 0) {
          console.warn('âš ï¸  No .axe files found in resolvers/builtin/');
          console.log('ðŸ’¾ Using embedded fallback resolvers');
          resolversToLoad = FALLBACK_RESOLVERS;
        } else {
          console.log(`âœ… Loaded ${builtinAxeFiles.length} .axe files from disk`);
        }

        // Separate content resolvers from meta services by manifest type
        const contentResolverAxes = resolversToLoad.filter(axe =>
          !axe.manifest.type || axe.manifest.type === 'resolver'
        );
        const metaServiceAxes = resolversToLoad.filter(axe =>
          axe.manifest.type === 'meta-service'
        );
        // Meta services that have URL lookup capabilities need to be loaded for URL pattern matching
        const metaServicesWithUrlLookup = metaServiceAxes.filter(axe =>
          axe.capabilities?.urlLookup && axe.urlPatterns?.length > 0
        );
        // Meta services with generate capability need implementation functions loaded
        const metaServicesWithGenerate = metaServiceAxes.filter(axe =>
          axe.capabilities?.generate && axe.implementation?.generate
        );

        console.log(`ðŸ“¦ Found ${contentResolverAxes.length} content resolvers, ${metaServiceAxes.length} meta services (${metaServicesWithGenerate.length} with AI generate)`);

        // Load content resolvers through the resolver loader
        const resolvers = await resolverLoader.current.loadResolvers(contentResolverAxes);
        setLoadedResolvers(resolvers);
        resolverLoaderRef.current = resolverLoader.current;
        console.log(`âœ… Loaded ${resolvers.length} resolver plugins:`, resolvers.map(r => r.name).join(', '));

        // Also load meta services with URL lookup into the resolver loader (for URL pattern matching)
        if (metaServicesWithUrlLookup.length > 0) {
          await resolverLoader.current.loadResolvers(metaServicesWithUrlLookup);
          console.log(`ðŸ“Ž Loaded ${metaServicesWithUrlLookup.length} meta service(s) with URL lookup:`, metaServicesWithUrlLookup.map(s => s.manifest.name).join(', '));
        }

        // Load meta services with generate capability (AI playlist generation)
        if (metaServicesWithGenerate.length > 0) {
          const loadedAiServices = await resolverLoader.current.loadResolvers(metaServicesWithGenerate);
          console.log(`ðŸ¤– Loaded ${loadedAiServices.length} AI service(s):`, loadedAiServices.map(s => s.name).join(', '));
        }

        // Set meta services directly (they don't need the resolver pipeline for playback)
        if (metaServiceAxes.length > 0) {
          const metaServicesData = metaServiceAxes.map(axe => ({
            id: axe.manifest.id,
            name: axe.manifest.name,
            type: axe.manifest.type,
            version: axe.manifest.version,
            author: axe.manifest.author,
            description: axe.manifest.description,
            icon: axe.manifest.icon,
            color: axe.manifest.color,
            homepage: axe.manifest.homepage,
            capabilities: axe.capabilities,
            settings: axe.settings,
            _filename: axe._filename
          }));
          setMetaServices(metaServicesData);
          console.log(`âœ… Loaded ${metaServicesData.length} meta services:`, metaServicesData.map(s => s.name).join(', '));
        }
      } catch (error) {
        console.error('âŒ Failed to load resolvers:', error);
        console.log('ðŸ’¾ Attempting to use fallback resolvers...');
        
        try {
          const resolvers = await resolverLoader.current.loadResolvers(FALLBACK_RESOLVERS);
          setLoadedResolvers(resolvers);
          resolverLoaderRef.current = resolverLoader.current;
          console.log(`âœ… Loaded ${resolvers.length} fallback resolvers`);
        } catch (fallbackError) {
          console.error('âŒ Even fallback resolvers failed:', fallbackError);
        }
      }
    };
    
    initResolvers();
  }, []);

  // Initialize scrobblers (ListenBrainz, Last.fm, Libre.fm)
  useEffect(() => {
    const initScrobblers = async () => {
      if (typeof window.initializeScrobblers === 'function') {
        try {
          // Load Last.fm API credentials from main process environment
          let config = {};
          if (window.electron?.getScrobblerConfig) {
            config = await window.electron.getScrobblerConfig();
            if (config.lastfmApiKey) {
              console.log('[App] Last.fm API credentials loaded from environment');
            }
          }
          await window.initializeScrobblers(config);
          console.log('[App] Scrobblers initialized');
          setScrobblersInitialized(true);
        } catch (error) {
          console.error('[App] Failed to initialize scrobblers:', error);
        }
      } else {
        console.log('[App] Scrobbler loader not available');
      }
    };
    initScrobblers();
  }, []);

  // Load scrobbler configurations (runs after scrobblers are initialized)
  useEffect(() => {
    const loadScrobblerConfigs = async () => {
      if (!scrobblersInitialized || !window.scrobblers) return;

      const configs = {};
      for (const scrobbler of window.scrobblers) {
        configs[scrobbler.id] = await scrobbler.getConfig();
      }
      setScrobblerConfigs(configs);

      // Load global scrobbling enabled state
      if (window.electron?.store) {
        const enabled = await window.electron.store.get('scrobbling-enabled');
        setScrobblingEnabled(enabled !== false);
      }
    };
    loadScrobblerConfigs();
  }, [scrobblersInitialized]);

  // Register scrobble callback to update listening history cache when you scrobble
  useEffect(() => {
    if (!scrobblersInitialized || !window.scrobbleManager) return;

    window.scrobbleManager.setOnScrobbleCallback((track, timestamp) => {
      console.log(`ðŸ“œ Scrobble detected, updating listening history cache`);

      // Prepend the scrobbled track to the cached listening history
      if (listeningHistoryCache.current.tracks) {
        const newTrack = {
          id: `history-${timestamp}-${track.title}`.replace(/\s+/g, '-'),
          title: track.title,
          artist: track.artist,
          album: track.album || null,
          albumArt: track.albumArt || null,
          playedAt: timestamp * 1000, // Convert to milliseconds
          source: 'local'
        };

        // Add to front of cache and update state
        const updatedTracks = [newTrack, ...listeningHistoryCache.current.tracks];
        listeningHistoryCache.current = {
          tracks: updatedTracks,
          timestamp: Date.now()
        };

        // Also update the UI state if on the history page
        setListeningHistory(prev => ({
          ...prev,
          tracks: [newTrack, ...prev.tracks]
        }));
      }
    });

    return () => {
      if (window.scrobbleManager) {
        window.scrobbleManager.setOnScrobbleCallback(null);
      }
    };
  }, [scrobblersInitialized]);

  // Sync meta service configs with scrobblers when both are available
  // This ensures Last.fm API credentials and ListenBrainz tokens are applied to scrobblers
  useEffect(() => {
    const syncScrobblersWithMetaServices = async () => {
      if (!scrobblersInitialized || !window.scrobblers || Object.keys(metaServiceConfigs).length === 0) return;

      // Sync Last.fm API credentials
      const lastfmConfig = metaServiceConfigs.lastfm;
      if (lastfmConfig?.apiKey && lastfmConfig?.apiSecret && window.lastfmScrobbler) {
        window.lastfmScrobbler.setApiCredentials(lastfmConfig.apiKey, lastfmConfig.apiSecret);
        console.log('[App] Synced Last.fm API credentials with scrobbler');
      }

      // Sync ListenBrainz token if scrobbler isn't already enabled
      const listenbrainzConfig = metaServiceConfigs.listenbrainz;
      if (listenbrainzConfig?.userToken && window.listenbrainzScrobbler) {
        const scrobblerConfig = await window.listenbrainzScrobbler.getConfig();
        if (!scrobblerConfig?.enabled) {
          try {
            await window.listenbrainzScrobbler.connect(listenbrainzConfig.userToken);
            const newConfig = await window.listenbrainzScrobbler.getConfig();
            setScrobblerConfigs(prev => ({ ...prev, listenbrainz: newConfig }));
            console.log('[App] Auto-connected ListenBrainz scrobbler from meta service token');
          } catch (err) {
            console.warn('[App] Failed to auto-connect ListenBrainz scrobbler:', err.message);
          }
        }
      }
    };
    syncScrobblersWithMetaServices();
  }, [scrobblersInitialized, metaServiceConfigs]);

  // Keep ref updated with latest resolver list
  useEffect(() => {
    loadedResolversRef.current = loadedResolvers;
  }, [loadedResolvers]);

  // Auto-add newly loaded resolvers to activeResolvers and resolverOrder
  // This runs when both resolvers are loaded AND settings are loaded from storage
  useEffect(() => {
    if (loadedResolvers.length === 0) return;
    if (!cacheLoaded) return; // Wait for settings to load first

    // Find resolvers that are loaded but not in resolverOrder
    const newResolverIds = loadedResolvers
      .map(r => r.id)
      .filter(id => !resolverOrder.includes(id));

    if (newResolverIds.length > 0) {
      console.log(`ðŸ“‹ Adding new resolvers to order/active: ${newResolverIds.join(', ')}`);
      setResolverOrder(prev => [...prev, ...newResolverIds]);
      setActiveResolvers(prev => [...prev, ...newResolverIds]);
    }
  }, [loadedResolvers, cacheLoaded, resolverOrder]);

  // Load watch folders on initial app load (for needsConfiguration check)
  useEffect(() => {
    if (cacheLoaded && window.electron?.localFiles?.getWatchFolders) {
      window.electron.localFiles.getWatchFolders().then(setWatchFolders);
    }
  }, [cacheLoaded]);

  // Listen for sync progress
  useEffect(() => {
    const unsubscribe = window.electron.sync.onProgress((progress) => {
      // Update setup modal progress
      setSyncSetupModal(prev => ({
        ...prev,
        progress
      }));
      // Also track in global sync status for the status modal
      if (progress.providerId) {
        setSyncStatus(prev => ({
          ...prev,
          [progress.providerId]: {
            ...prev[progress.providerId],
            inProgress: progress.phase !== 'complete',
            progress: progress
          }
        }));
      }
    });
    return unsubscribe;
  }, []);

  // Handle "Send to Parachord" from browser extension
  const handleSendToParachord = async (url) => {
    console.log('ðŸŒ Processing URL from browser:', url);

    // Get friendly domain name for display
    const domain = getUrlDomain(url);
    const serviceName = domain.includes('spotify') ? 'Spotify' :
                       domain.includes('apple') ? 'Apple Music' :
                       domain.includes('youtube') ? 'YouTube' :
                       domain.includes('bandcamp') ? 'Bandcamp' : domain;

    // Show toast notification
    showToast(`Adding ${serviceName} to queue...`, 'info');

    // Always add to queue - handleUrlDrop will insert at position 1 (next up)
    // If queue is empty, it will play immediately
    await handleUrlDrop(url, 'queue');
  };

  // Handle scraped playlist from browser extension (fallback when API fails for Spotify editorial playlists)
  const handleScrapedPlaylist = async (playlist) => {
    if (!playlist || !playlist.tracks || playlist.tracks.length === 0) {
      console.error('âŒ No tracks in scraped playlist');
      showToast('Could not scrape tracks from page', 'error');
      return;
    }

    const playlistName = playlist.name || 'Scraped Playlist';
    console.log(`ðŸ“‹ Processing scraped playlist: "${playlistName}" with ${playlist.tracks.length} tracks`);

    showToast(`Adding ${playlist.tracks.length} tracks from "${playlistName}"...`, 'info');

    // Convert scraped tracks to our track format and add to queue
    const tracks = playlist.tracks.map((track, index) => ({
      id: `scraped-${Date.now()}-${index}`,
      title: track.title,
      artist: track.artist,
      album: track.album || '',
      duration: track.duration || 0,
      // These will be resolved by the resolution system
      source: null,
      resolvedBy: null,
      albumArt: null,
      // If track has a URL (e.g., Bandcamp track URL), use it as a hint for resolution
      sourceUrl: track.url || null,
      context: {
        type: 'playlist',
        name: playlistName,
        url: playlist.url
      }
    }));

    // Insert tracks at position 1 (play next) - same as URL drops
    setCurrentQueue(prev => {
      const insertPosition = prev.length > 0 ? 1 : 0;
      return [...prev.slice(0, insertPosition), ...tracks, ...prev.slice(insertPosition)];
    });

    // If nothing is currently loaded, load the first track
    if (!currentTrackRef.current && tracks.length > 0) {
      const firstTrack = tracks[0];
      setCurrentTrack(firstTrack);
      setPlaybackSource(null);
    }

    showToast(`Added ${tracks.length} tracks from "${playlistName}"`, 'success');
  };

  // Handle scraped album from browser extension (e.g., Pitchfork reviews)
  // Looks up the album on MusicBrainz and fetches the full tracklist
  const handleScrapedAlbum = async (albumData) => {
    if (!albumData || !albumData.artist || !albumData.album) {
      console.error('âŒ Invalid album data from scrape:', albumData);
      showToast('Could not identify album from page', 'error');
      return;
    }

    const { artist, album, score, url } = albumData;
    console.log(`ðŸŽµ Looking up album: "${artist}" - "${album}"${score ? ` (score: ${score})` : ''}`);
    showToast(`Looking up "${album}" by ${artist}...`, 'info');

    try {
      // Search MusicBrainz for the release-group
      const searchQuery = encodeURIComponent(`release:"${album}" AND artist:"${artist}"`);
      const searchResponse = await fetch(
        `https://musicbrainz.org/ws/2/release-group?query=${searchQuery}&fmt=json&limit=5`,
        { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }}
      );

      if (!searchResponse.ok) {
        throw new Error('MusicBrainz search failed');
      }

      const searchData = await searchResponse.json();
      const releaseGroups = searchData['release-groups'] || [];

      if (releaseGroups.length === 0) {
        console.log('âŒ No albums found on MusicBrainz for:', artist, album);
        showToast(`Could not find "${album}" on MusicBrainz`, 'error');
        return;
      }

      // Use the first match
      const releaseGroup = releaseGroups[0];
      const releaseGroupId = releaseGroup.id;
      const artistName = releaseGroup['artist-credit']?.[0]?.name || artist;
      const albumTitle = releaseGroup.title || album;

      console.log(`ðŸ“€ Found release-group: ${releaseGroupId} - "${artistName}" - "${albumTitle}"`);

      // Fetch the first release from this release-group
      const releaseResponse = await fetch(
        `https://musicbrainz.org/ws/2/release?release-group=${releaseGroupId}&status=official&fmt=json&limit=1`,
        { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }}
      );

      if (!releaseResponse.ok) {
        throw new Error('Failed to fetch release');
      }

      const releaseData = await releaseResponse.json();
      if (!releaseData.releases || releaseData.releases.length === 0) {
        showToast(`Could not find tracklist for "${albumTitle}"`, 'error');
        return;
      }

      const releaseId = releaseData.releases[0].id;

      // Fetch release details with tracks
      const detailsResponse = await fetch(
        `https://musicbrainz.org/ws/2/release/${releaseId}?inc=recordings+artist-credits&fmt=json`,
        { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }}
      );

      if (!detailsResponse.ok) {
        throw new Error('Failed to fetch release details');
      }

      const detailsData = await detailsResponse.json();

      // Extract tracks
      const tracks = [];
      if (detailsData.media && detailsData.media.length > 0) {
        detailsData.media.forEach((medium) => {
          if (medium.tracks) {
            medium.tracks.forEach((track, index) => {
              const trackId = `scraped-album-${Date.now()}-${tracks.length}`;
              tracks.push({
                id: trackId,
                position: track.position,
                title: track.title || track.recording?.title || 'Unknown Track',
                artist: artistName,
                album: albumTitle,
                duration: track.length ? Math.round(track.length / 1000) : 0,
                recordingId: track.recording?.id,
                source: null,
                resolvedBy: null,
                albumArt: null,
                context: {
                  type: 'album',
                  name: `${artistName} - ${albumTitle}`,
                  url: url,
                  score: score
                }
              });
            });
          }
        });
      }

      if (tracks.length === 0) {
        showToast(`No tracks found for "${albumTitle}"`, 'error');
        return;
      }

      console.log(`ðŸ“‹ Found ${tracks.length} tracks for "${albumTitle}"`);

      // Insert tracks at position 1 (play next)
      setCurrentQueue(prev => {
        const insertPosition = prev.length > 0 ? 1 : 0;
        return [...prev.slice(0, insertPosition), ...tracks, ...prev.slice(insertPosition)];
      });

      // If nothing is currently loaded, load the first track
      if (!currentTrackRef.current && tracks.length > 0) {
        const firstTrack = tracks[0];
        setCurrentTrack(firstTrack);
        setPlaybackSource(null);
      }

      showToast(`Added ${tracks.length} tracks from "${albumTitle}"`, 'success');
    } catch (error) {
      console.error('Error looking up album:', error);
      showToast(`Failed to look up album: ${error.message}`, 'error');
    }
  };

  // Open sync setup modal
  const openSyncSetupModal = async (providerId) => {
    // Check auth first
    const authStatus = await window.electron.sync.checkAuth(providerId);
    if (!authStatus.authenticated) {
      // Trigger auth flow
      if (providerId === 'spotify') {
        await window.electron.spotify.auth();
      }
      return;
    }

    // Load existing settings
    const existingSettings = await window.electron.syncSettings.getProvider(providerId);

    setSyncSetupModal({
      open: true,
      providerId,
      step: 'options',
      playlists: [],
      folders: [],
      selectedPlaylists: existingSettings?.selectedPlaylistIds || [],
      settings: {
        syncTracks: existingSettings?.syncTracks ?? true,
        syncAlbums: existingSettings?.syncAlbums ?? true,
        syncArtists: existingSettings?.syncArtists ?? true,
        syncPlaylists: existingSettings?.syncPlaylists ?? true
      },
      progress: null,
      results: null,
      error: null
    });
  };

  // Start sync from modal
  const startSync = async () => {
    const { providerId, settings, selectedPlaylists } = syncSetupModal;

    // Save settings first
    await window.electron.syncSettings.setProvider(providerId, {
      enabled: true,
      ...settings,
      selectedPlaylistIds: selectedPlaylists
    });

    setSyncSetupModal(prev => ({ ...prev, step: 'syncing' }));

    const result = await window.electron.sync.start(providerId, {
      settings: {
        ...settings,
        selectedPlaylistIds: selectedPlaylists
      }
    });

    if (result.success) {
      // Use the collection directly from the sync result (already saved to disk)
      // This ensures UI updates immediately with the exact data that was synced
      if (result.collection) {
        console.log(`[Sync] Updating UI with synced collection: ${result.collection.tracks?.length || 0} tracks, ${result.collection.albums?.length || 0} albums, ${result.collection.artists?.length || 0} artists`);
        // Create a new object reference to ensure React detects the change
        setCollectionData({
          tracks: result.collection.tracks || [],
          albums: result.collection.albums || [],
          artists: result.collection.artists || []
        });
      } else {
        // Fallback to loading from disk if collection not in result
        const newCollection = await window.electron.collection.load();
        setCollectionData(newCollection);
      }

      // Reload playlists if they were synced
      if (settings.syncPlaylists && selectedPlaylists.length > 0) {
        const loadedPlaylists = await window.electron.playlists.load();
        setPlaylists(loadedPlaylists);
      }

      setSyncSetupModal(prev => ({
        ...prev,
        step: 'complete',
        results: result.results
      }));
    } else {
      setSyncSetupModal(prev => ({
        ...prev,
        step: 'options',
        error: result.error
      }));
    }
  };

  // Stop syncing for a provider
  const stopSyncing = async (providerId, removeItems = false) => {
    if (removeItems) {
      // Remove items that only have this provider as source
      setCollectionData(prev => {
        const filterItems = (items) => items
          .map(item => {
            if (!item.syncSources?.[providerId]) return item;
            const newSyncSources = { ...item.syncSources };
            delete newSyncSources[providerId];
            if (Object.keys(newSyncSources).length === 0) return null;
            return { ...item, syncSources: newSyncSources };
          })
          .filter(Boolean);

        const newData = {
          ...prev,
          tracks: filterItems(prev.tracks || []),
          albums: filterItems(prev.albums || []),
          artists: filterItems(prev.artists || [])
        };
        // Save async (don't block state update)
        saveCollection(newData);
        return newData;
      });
    } else {
      // Just remove sync sources but keep items
      setCollectionData(prev => {
        const removeSource = (items) => items.map(item => {
          if (!item.syncSources?.[providerId]) return item;
          const newSyncSources = { ...item.syncSources };
          delete newSyncSources[providerId];
          return { ...item, syncSources: Object.keys(newSyncSources).length > 0 ? newSyncSources : undefined };
        });

        const newData = {
          ...prev,
          tracks: removeSource(prev.tracks || []),
          albums: removeSource(prev.albums || []),
          artists: removeSource(prev.artists || [])
        };
        // Save async (don't block state update)
        saveCollection(newData);
        return newData;
      });
    }

    // Disable sync in settings
    await window.electron.syncSettings.setProvider(providerId, {
      ...resolverSyncSettings[providerId],
      enabled: false
    });

    setResolverSyncSettings(prev => ({
      ...prev,
      [providerId]: { ...prev[providerId], enabled: false }
    }));

    setStopSyncDialog({ open: false, providerId: null });
  };

  // Browser extension event handlers
  useEffect(() => {
    console.log('ðŸ”Œ Setting up browser extension event handlers...');

    // Connection state handlers
    window.electron.extension.onConnected(() => {
      console.log('âœ… Browser extension connected');
      setExtensionConnected(true);
    });

    window.electron.extension.onDisconnected(() => {
      console.log('âŒ Browser extension disconnected');
      setExtensionConnected(false);
      setBrowserPlaybackActive(false);
      setActiveExtensionTabId(null);
    });

    // Message handler for extension events
    window.electron.extension.onMessage((message) => {
      console.log('ðŸ“¨ Extension message received:', message.type, message.event || message.url || '');
      if (message.type === 'event') {
        switch (message.event) {
          case 'connected':
            // Ignore when local file is playing
            if (audioRef.current && !audioRef.current.paused) {
              console.log('ðŸŽ¬ Browser connected (ignored - local file playing)');
              break;
            }
            // Browser tab with media content connected
            console.log(`ðŸŽ¬ Browser playback connected: ${message.site}`);
            setActiveExtensionTabId(message.tabId);
            setBrowserPlaybackActive(true);
            setIsExternalPlayback(true);

            // Clear the waiting flag - browser is now connected and handling playback
            if (waitingForBrowserPlaybackRef.current) {
              console.log('âœ… Browser playback connected, clearing wait flag');
              waitingForBrowserPlaybackRef.current = false;
              // Also ensure streaming flag is false so browser events aren't ignored
              streamingPlaybackActiveRef.current = false;
            }

            // Stop Spotify polling - browser is now handling playback
            if (playbackPollerRef.current) {
              console.log('â¹ï¸ Stopping Spotify polling - browser playback connected');
              clearInterval(playbackPollerRef.current);
              playbackPollerRef.current = null;
            }
            if (pollingRecoveryRef.current) {
              clearInterval(pollingRecoveryRef.current);
              pollingRecoveryRef.current = null;
            }

            // Close previous tab if one was pending
            if (pendingCloseTabIdRef.current && pendingCloseTabIdRef.current !== message.tabId) {
              window.electron.extension.sendCommand({
                type: 'command',
                action: 'closeTab',
                tabId: pendingCloseTabIdRef.current
              });
              pendingCloseTabIdRef.current = null;
            }
            break;

          case 'playing':
            // Ignore browser events when streaming playback (Spotify) is active
            if (streamingPlaybackActiveRef.current) {
              console.log('â–¶ï¸ Browser playback playing (ignored - streaming active)');
              break;
            }
            // Ignore when local file is playing
            if (audioRef.current && !audioRef.current.paused) {
              console.log('â–¶ï¸ Browser playback playing (ignored - local file playing)');
              break;
            }
            console.log('â–¶ï¸ Browser playback playing');
            setIsPlaying(true);
            // Also ensure browser playback state is set (handles race condition where playing arrives before connected)
            setBrowserPlaybackActive(true);
            setIsExternalPlayback(true);
            break;

          case 'paused':
            // Ignore browser events when streaming playback (Spotify) is active
            if (streamingPlaybackActiveRef.current) {
              console.log('â¸ï¸ Browser playback paused (ignored - streaming active)');
              break;
            }
            // Ignore when local file is playing
            if (audioRef.current && !audioRef.current.paused) {
              console.log('â¸ï¸ Browser playback paused (ignored - local file playing)');
              break;
            }
            console.log('â¸ï¸ Browser playback paused');
            setIsPlaying(false);
            break;

          case 'ended':
            // Ignore browser events when streaming playback (Spotify) is active
            if (streamingPlaybackActiveRef.current) {
              console.log('â¹ï¸ Browser playback ended (ignored - streaming active)');
              break;
            }
            // Ignore when local file is playing
            if (audioRef.current && !audioRef.current.paused) {
              console.log('â¹ï¸ Browser playback ended (ignored - local file playing)');
              break;
            }
            console.log('â¹ï¸ Browser playback ended');
            // Store tab ID to close when next track connects
            pendingCloseTabIdRef.current = message.tabId;
            setBrowserPlaybackActive(false);
            // Auto-advance to next track (use ref to avoid stale closure)
            if (handleNextRef.current) handleNextRef.current();
            break;

          case 'tabClosed':
            // Ignore browser events when streaming playback (Spotify) is active
            if (streamingPlaybackActiveRef.current) {
              console.log('ðŸšª Browser tab closed (ignored - streaming active)');
              setBrowserPlaybackActive(false);
              setActiveExtensionTabId(null);
              break;
            }
            // Ignore when local file is playing
            if (audioRef.current && !audioRef.current.paused) {
              console.log('ðŸšª Browser tab closed (ignored - local file playing)');
              break;
            }
            setBrowserPlaybackActive(false);
            setActiveExtensionTabId(null);
            // Check if this was a programmatic close (switching tracks)
            if (pendingCloseTabIdRef.current && message.tabId === pendingCloseTabIdRef.current) {
              console.log('ðŸ”„ Browser tab closed programmatically (switching tracks)');
              pendingCloseTabIdRef.current = null;
              // Don't call handleNext() - we're already loading the selected track
            } else {
              console.log('ðŸšª Browser tab closed by user');
              // Treat as skip to next (use ref to avoid stale closure)
              if (handleNextRef.current) handleNextRef.current();
            }
            break;

          case 'heartbeat':
            // Keep-alive from extension - only update tab ID, don't set playback state
            // The 'connected' and 'playing' events are responsible for setting browserPlaybackActive
            // Heartbeats just maintain the tab reference when browser playback is already active
            if (message.tabId && browserPlaybackActive) {
              setActiveExtensionTabId(message.tabId);
            }
            break;
        }
      } else if (message.type === 'sendToParachord') {
        // Handle URL sent from browser extension context menu
        console.log('ðŸŒ Received URL from browser extension:', message.url);
        handleSendToParachord(message.url);
      } else if (message.type === 'scrapedPlaylist') {
        // Handle scraped playlist from browser extension (fallback when API fails)
        console.log('ðŸŒ Received scraped playlist from browser extension:', message.playlist?.name, `(${message.playlist?.tracks?.length} tracks)`);
        handleScrapedPlaylist(message.playlist);
      } else if (message.type === 'addFriend') {
        // Handle add friend from browser extension (Last.fm/ListenBrainz user profiles)
        console.log('ðŸ‘¥ Received add friend request from browser extension:', message.url);
        addFriend(message.url);
      } else if (message.type === 'scrapedAlbum') {
        // Handle scraped album from browser extension (e.g., Pitchfork reviews)
        // This triggers a MusicBrainz lookup to get the full tracklist
        console.log('ðŸŽµ Received scraped album from browser extension:', message.album?.artist, '-', message.album?.album);
        handleScrapedAlbum(message.album);
      }
    });

    // Check initial connection status
    window.electron.extension.getStatus().then(status => {
      setExtensionConnected(status.connected);
    });

    // Playback window event handlers (for Bandcamp embedded player, etc.)
    if (window.electron?.playbackWindow?.onEvent) {
      window.electron.playbackWindow.onEvent((eventType) => {
        // Ignore playback window events when local file is playing
        if (audioRef.current && !audioRef.current.paused) {
          console.log(`ðŸŽµ Playback window event: ${eventType} (ignored - local file playing)`);
          return;
        }
        console.log(`ðŸŽµ Playback window event: ${eventType}`);
        switch (eventType) {
          case 'playing':
            setIsPlaying(true);
            setBrowserPlaybackActive(true);
            setIsExternalPlayback(true);
            // Clear the waiting flag - playback window is now connected and playing
            if (waitingForBrowserPlaybackRef.current) {
              console.log('âœ… Playback window playing, clearing wait flag');
              waitingForBrowserPlaybackRef.current = false;
            }
            break;
          case 'paused':
            setIsPlaying(false);
            break;
          case 'ended':
            console.log('ðŸŽµ Playback window track ended, advancing to next');
            setBrowserPlaybackActive(false);
            // Clear the waiting flag - browser track has ended, we're no longer waiting for it to connect
            waitingForBrowserPlaybackRef.current = false;
            // Use ref to avoid stale closure in useEffect
            if (handleNextRef.current) handleNextRef.current();
            break;
        }
      });
    }

    if (window.electron?.playbackWindow?.onClosed) {
      window.electron.playbackWindow.onClosed(() => {
        // Ignore when local file is playing
        if (audioRef.current && !audioRef.current.paused) {
          console.log('ðŸŽµ Playback window closed (ignored - local file playing)');
          return;
        }
        console.log('ðŸŽµ Playback window closed');
        setBrowserPlaybackActive(false);
        // Clear the waiting flag - browser window is closed, we're no longer waiting for it
        waitingForBrowserPlaybackRef.current = false;
        // Don't auto-advance, just stop playback
        setIsPlaying(false);
      });
    }
  }, []);

  // Listen for context menu actions (only set up once)
  useEffect(() => {
    if (window.electron?.resolvers?.onContextMenuAction) {
      window.electron.resolvers.onContextMenuAction(async (data) => {
        console.log('Context menu action received:', data);
        if (data.action === 'uninstall') {
          await handleUninstallResolver(data.resolverId);
        }
      });
    }
  }, []);

  // Use loaded resolvers or fallback to empty array
  const allResolvers = loadedResolvers.length > 0 ? loadedResolvers : [];

  // Sync loaded resolvers with resolverOrder - add any new resolvers not yet in the order
  // This runs after both resolvers are loaded AND cache/settings are loaded from storage
  useEffect(() => {
    if (loadedResolvers.length === 0) return;
    if (!cacheLoaded) return; // Wait until storage settings are loaded

    const loadedIds = loadedResolvers.map(r => r.id);
    const missingIds = loadedIds.filter(id => !resolverOrder.includes(id));

    if (missingIds.length > 0) {
      console.log('ðŸ“¦ Adding new resolvers to order:', missingIds);
      // Use functional update to ensure we don't add duplicates
      setResolverOrder(prev => {
        const newIds = missingIds.filter(id => !prev.includes(id));
        return newIds.length > 0 ? [...prev, ...newIds] : prev;
      });
      // Also enable new resolvers by default
      setActiveResolvers(prev => {
        const newIds = missingIds.filter(id => !prev.includes(id));
        return newIds.length > 0 ? [...prev, ...newIds] : prev;
      });
    }
  }, [loadedResolvers, cacheLoaded]);

  // Get resolvers in priority order
  const resolvers = resolverOrder
    .map(id => allResolvers.find(r => r.id === id))
    .filter(Boolean);

  // Helper function to get resolver config (async for Spotify to ensure fresh token)
  const getResolverConfig = async (resolverId) => {
    // For Spotify, always get a fresh token from the IPC handler
    // This ensures we use a valid token even if the React state is stale
    if (resolverId === 'spotify') {
      let token = spotifyToken;

      // Try to get a fresh/refreshed token from the IPC handler
      if (window.electron?.spotify) {
        const tokenData = await window.electron.spotify.checkToken();
        if (tokenData && tokenData.token) {
          token = tokenData.token;
          // Update React state if token changed
          if (token !== spotifyToken) {
            console.log('ðŸ”„ Token was refreshed, updating state');
            setSpotifyToken(token);
          }
        }
        // If checkToken() fails but we have a token in React state, keep using it
        // Don't discard a working token just because refresh failed
      }

      console.log('ðŸ”‘ Spotify token status:', {
        hasToken: !!token,
        tokenLength: token?.length,
        tokenPreview: token ? token.substring(0, 20) + '...' : 'null'
      });

      return { token };
    }

    const configs = {
      qobuz: { appId: '285473059', volume: volume / 100 },
      bandcamp: {}
    };
    return configs[resolverId] || {};
  };

  const SPOTIFY_CLIENT_ID = 'c040c0ee133344b282e6342198bcbeea';

  useEffect(() => {
    // Load local files into library instead of placeholder tracks
    const loadLocalFilesLibrary = async () => {
      setLibraryLoading(true);
      try {
        if (window.electron?.localFiles?.search) {
          const localTracks = await window.electron.localFiles.search('');
          if (localTracks && localTracks.length > 0) {
            console.log(`ðŸ“š Loaded ${localTracks.length} local tracks into library`);
            setLibrary(localTracks);
          } else {
            console.log('ðŸ“š No local files found - library is empty');
            setLibrary([]);
          }
        } else {
          console.log('ðŸ“š Local Files API not available');
          setLibrary([]);
        }
      } catch (error) {
        console.error('Failed to load local files library:', error);
        setLibrary([]);
      } finally {
        setLibraryLoading(false);
      }
    };

    loadLocalFilesLibrary();

    const context = new (window.AudioContext || window.webkitAudioContext)();
    setAudioContext(context);
    
    // Load playlists from electron-store
    const loadPlaylistsFromStore = async () => {
      try {
        const loadedPlaylists = await window.electron.playlists.load();
        console.log(`ðŸ“‹ Loaded ${loadedPlaylists.length} playlist(s) from local storage`);

        if (loadedPlaylists.length > 0) {
          // Playlists are already stored as full objects, just use them directly
          setPlaylists(loadedPlaylists);
        } else {
          console.log('ðŸ“‹ No playlists found in local storage');
        }

        // Check if there are hosted playlists to load
        const hostedPlaylistUrls = await window.electron?.store?.get('hosted_playlists') || [];
        if (hostedPlaylistUrls.length === 0) {
          setPlaylistsLoading(false);
        }
      } catch (error) {
        console.error('Failed to load playlists:', error);
        setPlaylistsLoading(false);
      }
    };

    loadPlaylistsFromStore();

    // Load search history
    loadSearchHistory();

    // Listen for local files library changes
    let libraryChangeCleanup = null;
    if (window.electron?.localFiles?.onLibraryChanged) {
      libraryChangeCleanup = window.electron.localFiles.onLibraryChanged((changes) => {
        console.log('ðŸ“š Library changed, reloading...', changes);
        loadLocalFilesLibrary();
      });
    }

    return () => {
      context.close();
      if (libraryChangeCleanup) libraryChangeCleanup();
    };
  }, []);

  // Load collection data on startup
  useEffect(() => {
    const loadCollection = async () => {
      if (window.electron?.collection?.load) {
        try {
          const data = await window.electron.collection.load();

          // Clean up corrupted sources data (e.g., numeric keys like "0" instead of resolver IDs)
          const validResolverIds = ['spotify', 'youtube', 'bandcamp', 'qobuz', 'soundcloud', 'localfiles'];
          let cleanedCount = 0;
          const cleanedTracks = data.tracks?.map(track => {
            if (track.sources && typeof track.sources === 'object') {
              const cleanedSources = {};
              for (const [key, value] of Object.entries(track.sources)) {
                if (validResolverIds.includes(key)) {
                  cleanedSources[key] = value;
                } else {
                  cleanedCount++;
                }
              }
              return { ...track, sources: cleanedSources };
            }
            return track;
          }) || [];

          // Migrate collection items to include syncSources field
          // Items without syncSources are assumed to be manually added
          let migratedCount = 0;
          const migrateItem = (item) => {
            if (!item.syncSources) {
              migratedCount++;
              return {
                ...item,
                syncSources: {
                  manual: { addedAt: item.addedAt || Date.now() }
                }
              };
            }
            return item;
          };

          const migratedTracks = (cleanedCount > 0 ? cleanedTracks : data.tracks || []).map(migrateItem);
          const migratedAlbums = (data.albums || []).map(migrateItem);
          const migratedArtists = (data.artists || []).map(migrateItem);

          const needsSave = cleanedCount > 0 || migratedCount > 0;
          const finalData = {
            ...data,  // Preserve any additional fields (e.g., version, lastModified, metadata)
            tracks: migratedTracks,
            albums: migratedAlbums,
            artists: migratedArtists
          };

          if (cleanedCount > 0) {
            console.log(`Cleaned ${cleanedCount} corrupted source entries from collection`);
          }
          if (migratedCount > 0) {
            console.log(`Migrated ${migratedCount} collection items to include syncSources`);
          }

          console.log(`[Collection] Loaded: ${finalData.tracks?.length || 0} tracks, ${finalData.albums?.length || 0} albums, ${finalData.artists?.length || 0} artists`);
          setCollectionData(finalData);

          // Save if any cleaning or migration occurred
          if (needsSave && window.electron?.collection?.save) {
            await window.electron.collection.save(finalData);
          }
        } catch (error) {
          console.error('Failed to load collection:', error);
        }
      }
      setCollectionLoading(false);
    };
    loadCollection();

    // Load sync settings
    const loadSyncSettings = async () => {
      if (window.electron?.syncSettings?.load) {
        try {
          const settings = await window.electron.syncSettings.load();
          setResolverSyncSettings(settings);
        } catch (error) {
          console.error('Failed to load sync settings:', error);
        }
      }
    };
    loadSyncSettings();
  }, []);

  useEffect(() => {
    // Skip progress tracking for streaming tracks (Spotify) - they have their own polling
    // Skip for local files - they use HTML5 Audio with timeupdate event
    // Skip for browser-based tracks (YouTube, Bandcamp) - they use extension events
    // Also skip if duration is 0 or missing to prevent infinite handleNext loop
    const isStreamingTrack = currentTrack?.sources?.spotify || currentTrack?.spotifyUri;
    const isLocalFile = currentTrack?.filePath || currentTrack?.sources?.localfiles;
    const isBrowserTrack = browserPlaybackActive || isExternalPlayback;
    const hasValidDuration = currentTrack?.duration && currentTrack.duration > 0;

    if (isPlaying && audioContext && currentTrack && !isStreamingTrack && !isLocalFile && !isBrowserTrack && hasValidDuration) {
      const interval = setInterval(() => {
        const elapsed = (audioContext.currentTime - startTime);
        if (elapsed >= currentTrack.duration) {
          // Use ref to avoid stale closure in interval callback
          if (handleNextRef.current) handleNextRef.current();
        } else {
          setProgress(elapsed);
          // Notify scrobble manager of progress for scrobble threshold checking
          if (window.scrobbleManager) {
            window.scrobbleManager.onProgressUpdate(elapsed);
          }
        }
      }, 100);
      return () => clearInterval(interval);
    }
  }, [isPlaying, audioContext, currentTrack, startTime, browserPlaybackActive, isExternalPlayback]);

  // Smooth progress interpolation for Spotify tracks
  // API polling happens every 5 seconds, but we want smooth 1-second visual updates
  // The baseline is ONLY set by API polls (in getCurrentPlaybackState), not by this effect
  const spotifyProgressBaselineRef = useRef({ progress: 0, timestamp: 0, isPlaying: false });

  useEffect(() => {
    const isStreamingTrack = currentTrack?.sources?.spotify || currentTrack?.spotifyUri;
    const hasValidDuration = currentTrack?.duration && currentTrack.duration > 0;

    if (isPlaying && isStreamingTrack && hasValidDuration && !browserPlaybackActive) {
      const interval = setInterval(() => {
        const baseline = spotifyProgressBaselineRef.current;

        // Only interpolate if:
        // 1. We have a valid baseline (timestamp > 0 means API has set it)
        // 2. Spotify reports that playback is actually happening (isPlaying from API)
        if (baseline.timestamp > 0 && baseline.isPlaying) {
          const elapsed = (Date.now() - baseline.timestamp) / 1000;
          const interpolatedProgress = baseline.progress + elapsed;

          // Don't exceed track duration and don't go backwards
          if (interpolatedProgress < currentTrack.duration && interpolatedProgress >= 0) {
            setProgress(interpolatedProgress);
            // Notify scrobble manager of progress for scrobble threshold checking
            if (window.scrobbleManager) {
              window.scrobbleManager.onProgressUpdate(interpolatedProgress);
            }
          }
        }
      }, 1000); // Update every second for smooth progress bar

      return () => clearInterval(interval);
    }
  }, [isPlaying, currentTrack, browserPlaybackActive]);

  // Auto-dismiss toast after 3 seconds (6 seconds if it has an action button)
  useEffect(() => {
    if (toast) {
      const timeout = toast.action ? 6000 : 3000;
      const timer = setTimeout(() => setToast(null), timeout);
      return () => clearTimeout(timer);
    }
  }, [toast]);

  const showToast = useCallback((message, type = 'success', action = null) => {
    setToast({ message, type, action });
  }, []);

  // Save collection to disk
  const saveCollection = useCallback(async (newData) => {
    if (window.electron?.collection?.save) {
      try {
        const result = await window.electron.collection.save(newData);
        if (!result?.success) {
          console.error('Collection save failed:', result?.error);
        }
      } catch (error) {
        console.error('Collection save error:', error);
      }
    }
  }, []);

  // Add track to collection
  const addTrackToCollection = useCallback((track) => {
    const trackId = generateTrackId(track.artist, track.title, track.album);

    setCollectionData(prev => {
      // Check for duplicate
      if (prev.tracks.some(t => t.id === trackId)) {
        showToast(`${track.title} is already in your collection`);
        return prev;
      }

      const newTrack = {
        id: trackId,
        title: track.title,
        artist: track.artist,
        album: track.album,
        duration: track.duration,
        albumArt: track.albumArt,
        sources: track.sources || {},
        addedAt: Date.now()
      };

      const newData = { ...prev, tracks: [...prev.tracks, newTrack] };
      // Save async (don't block state update)
      saveCollection(newData);
      showToast(`Added ${track.title} to Collection`);
      showSidebarBadge('collection');
      return newData;
    });
  }, [saveCollection, showToast, showSidebarBadge]);

  // Remove track from collection
  const removeTrackFromCollection = useCallback((track) => {
    const trackId = track.id || generateTrackId(track.artist, track.title, track.album);

    setCollectionData(prev => {
      const existingIndex = prev.tracks.findIndex(t => t.id === trackId);
      if (existingIndex === -1) {
        showToast(`${track.title} is not in your collection`);
        return prev;
      }

      const newTracks = prev.tracks.filter(t => t.id !== trackId);
      const newData = { ...prev, tracks: newTracks };
      // Save async (don't block state update)
      saveCollection(newData);
      showToast(`Removed ${track.title} from Collection`);
      return newData;
    });
  }, [saveCollection, showToast]);

  // Add album to collection
  const addAlbumToCollection = useCallback((album) => {
    const albumId = generateAlbumId(album.artist, album.title);

    setCollectionData(prev => {
      // Check for duplicate
      if (prev.albums.some(a => a.id === albumId)) {
        showToast(`${album.title} is already in your collection`);
        return prev;
      }

      const newAlbum = {
        id: albumId,
        title: album.title,
        artist: album.artist,
        year: album.year || null,
        art: album.art || album.albumArt || null,
        addedAt: Date.now()
      };

      const newData = { ...prev, albums: [...prev.albums, newAlbum] };
      // Save async (don't block state update)
      saveCollection(newData);
      showToast(`Added ${album.title} to Collection`);
      showSidebarBadge('collection');
      return newData;
    });
  }, [saveCollection, showToast, showSidebarBadge]);

  // Add artist to collection
  const addArtistToCollection = useCallback((artist) => {
    const artistId = generateArtistId(artist.name);

    setCollectionData(prev => {
      // Check for duplicate
      if (prev.artists.some(a => a.id === artistId)) {
        showToast(`${artist.name} is already in your collection`);
        return prev;
      }

      const newArtist = {
        id: artistId,
        name: artist.name,
        image: artist.image || null,
        addedAt: Date.now()
      };

      const newData = { ...prev, artists: [...prev.artists, newArtist] };
      // Save async (don't block state update)
      saveCollection(newData);
      showToast(`Added ${artist.name} to Collection`);
      showSidebarBadge('collection');
      return newData;
    });
  }, [saveCollection, showToast, showSidebarBadge]);

  // Listen for track/playlist context menu actions
  useEffect(() => {
    if (window.electron?.contextMenu?.onAction) {
      window.electron.contextMenu.onAction(async (data) => {
        console.log('Track context menu action received:', data);
        if (data.action === 'add-to-queue' && data.tracks) {
          // Build context from source info if available
          let context = null;
          if (data.sourceType === 'playlist' && data.sourceId) {
            context = { type: 'playlist', id: data.sourceId, name: data.sourceName };
          } else if ((data.sourceType === 'album' || data.sourceType === 'release') && data.sourceName) {
            context = { type: 'album', id: data.sourceId, name: data.sourceName, artist: data.artistName };
          } else if (data.sourceType === 'recommendations') {
            context = { type: 'recommendations', name: 'Recommendations' };
          }
          addToQueue(data.tracks, context);
        } else if (data.action === 'add-to-queue' && data.track) {
          // Single track - build context from source info if available
          let context = null;
          if (data.sourceType === 'recommendations') {
            context = { type: 'recommendations', name: 'Recommendations' };
          }
          addToQueue([data.track], context);
        } else if (data.action === 'add-to-playlist' && data.track) {
          // Single track from friend's now playing
          setAddToPlaylistPanel({
            open: true,
            tracks: [data.track],
            sourceName: `${data.track.artist} - ${data.track.title}`,
            sourceType: 'track'
          });
          setSelectedPlaylistsForAdd([]);
        } else if (data.action === 'add-track-to-collection' && data.track) {
          // Add single track to collection
          addTrackToCollection(data.track);
        } else if (data.action === 'go-to-artist' && data.artistName) {
          // Navigate to artist page
          fetchArtistData(data.artistName);
        } else if (data.action === 'add-to-playlist' && data.tracks) {
          // Open the Add to Playlist panel
          console.log(`ðŸ“‹ Add to Playlist: ${data.tracks.length} track(s) - "${data.sourceName}" (type: ${data.sourceType})`);
          if (data.tracks.length > 0) {
            console.log(`   First track: ${data.tracks[0]?.artist} - ${data.tracks[0]?.title}`);
          }
          setAddToPlaylistPanel({
            open: true,
            tracks: data.tracks,
            sourceName: data.sourceName || 'Selected tracks',
            sourceType: data.sourceType || 'track'
          });
          setSelectedPlaylistsForAdd([]); // Reset selection
        } else if (data.action === 'remove-from-playlist' && data.playlistId !== undefined) {
          // Remove track from playlist
          const trackIndex = data.trackIndex;
          console.log(`ðŸ—‘ï¸ Removing track at index ${trackIndex} from playlist ${data.playlistId}`);

          // Update playlistTracks state (the displayed tracks)
          setPlaylistTracks(prev => {
            const newTracks = [...prev];
            newTracks.splice(trackIndex, 1);
            return newTracks;
          });

          // Update the playlist in playlists state and save to disk
          setPlaylists(prev => {
            const updatedPlaylists = prev.map(p => {
              if (p.id === data.playlistId) {
                const newTracks = [...(p.tracks || [])];
                newTracks.splice(trackIndex, 1);
                const updatedPlaylist = {
                  ...p,
                  tracks: newTracks,
                  lastModified: Date.now()
                };
                // Save to disk (async, non-blocking)
                savePlaylistToStore(updatedPlaylist);
                return updatedPlaylist;
              }
              return p;
            });
            return updatedPlaylists;
          });

          // Mark synced playlist as locally modified
          markPlaylistAsLocallyModified(data.playlistId);

          // Update selectedPlaylist if viewing this playlist
          if (selectedPlaylist?.id === data.playlistId) {
            setSelectedPlaylist(prev => ({
              ...prev,
              lastModified: Date.now()
            }));
          }
        } else if (data.action === 'delete-playlist' && data.playlistId) {
          // Show confirmation alert
          const confirmed = window.confirm(`Are you sure you want to delete "${data.name}"?`);
          if (confirmed) {
            const result = await window.electron.playlists.delete(data.playlistId);
            if (result.success) {
              // Remove from state
              setPlaylists(prev => prev.filter(p => p.id !== data.playlistId));
              // Clear cover cache for deleted playlist
              delete playlistCoverCache.current[data.playlistId];
              setAllPlaylistCovers(prev => {
                const updated = { ...prev };
                delete updated[data.playlistId];
                return updated;
              });
            } else {
              alert(`Failed to delete playlist: ${result.error}`);
            }
          }
        } else if (data.action === 'edit-id3-tags' && data.track) {
          // Open ID3 tag editor modal
          console.log('ðŸ·ï¸ Opening ID3 tag editor for:', data.track.title);
          setId3EditorTrack(data.track);
          // Filter out "Unknown Album" placeholder - treat as empty
          const albumValue = data.track.album === 'Unknown Album' ? '' : (data.track.album || '');
          const newValues = {
            title: data.track.title || '',
            artist: data.track.artist || '',
            album: albumValue,
            trackNumber: data.track.trackNumber ? String(data.track.trackNumber) : '',
            year: data.track.year ? String(data.track.year) : ''
          };
          setId3EditorValues(newValues);
          setId3ArtSuggestions([]);
          setId3SelectedArt(null);
          setId3EditorOpen(true);

          // Auto-fetch album art if we have artist and album
          if (newValues.artist && newValues.album) {
            fetchAlbumArtSuggestions(newValues.artist, newValues.album);
          }
        } else if (data.action === 'add-to-collection') {
          // Add to collection based on type
          if (data.type === 'track' && data.track) {
            addTrackToCollection(data.track);
          } else if (data.type === 'album' && data.album) {
            addAlbumToCollection(data.album);
          } else if (data.type === 'artist' && data.artist) {
            addArtistToCollection(data.artist);
          }
        } else if (data.action === 'remove-from-collection') {
          // Remove from collection based on type
          if (data.type === 'track' && data.track) {
            removeTrackFromCollection(data.track);
          }
        } else if (data.action === 'view-friend-history' && data.friend) {
          if (navigateToFriendRef.current) navigateToFriendRef.current(data.friend);
        } else if (data.action === 'pin-friend' && data.friendId) {
          if (pinFriendRef.current) pinFriendRef.current(data.friendId);
        } else if (data.action === 'unpin-friend' && data.friendId) {
          if (unpinFriendRef.current) unpinFriendRef.current(data.friendId);
        } else if (data.action === 'remove-friend' && data.friendId) {
          if (removeFriendRef.current) removeFriendRef.current(data.friendId);
        } else if (data.action === 'save-friend-to-collection' && data.friendId) {
          if (saveFriendToCollectionRef.current) saveFriendToCollectionRef.current(data.friendId);
        } else if (data.action === 'remove-friend-from-collection' && data.friendId) {
          if (removeFriendFromCollectionRef.current) removeFriendFromCollectionRef.current(data.friendId);
        } else if (data.action === 'start-listen-along' && data.friend) {
          if (activateListenAlongRef.current) activateListenAlongRef.current(data.friend);
        } else if (data.action === 'stop-listen-along') {
          if (deactivateListenAlongRef.current) deactivateListenAlongRef.current();
        }
      });
    }
  }, [addTrackToCollection, addAlbumToCollection, addArtistToCollection, removeTrackFromCollection]);

  // Add multiple tracks to collection
  const addTracksToCollection = useCallback((tracks) => {
    let addedCount = 0;

    setCollectionData(prev => {
      const newTracks = [...prev.tracks];

      tracks.forEach(track => {
        const trackId = `${track.artist || 'unknown'}-${track.title || 'untitled'}-${track.album || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');

        if (!newTracks.some(t => t.id === trackId)) {
          newTracks.push({
            id: trackId,
            title: track.title,
            artist: track.artist,
            album: track.album,
            duration: track.duration,
            albumArt: track.albumArt,
            sources: track.sources || {},
            addedAt: Date.now()
          });
          addedCount++;
        }
      });

      if (addedCount === 0) {
        showToast('Tracks are already in your collection');
        return prev;
      }

      const newData = { ...prev, tracks: newTracks };
      // Save async (don't block state update)
      saveCollection(newData);
      showToast(`Added ${addedCount} track${addedCount !== 1 ? 's' : ''} to Collection`);
      return newData;
    });
  }, [saveCollection, showToast]);

  // Handle drop on collection sidebar
  const handleCollectionDrop = useCallback((e) => {
    e.preventDefault();
    setCollectionDropHighlight(false);

    try {
      const data = e.dataTransfer.getData('text/plain');
      if (!data) return;

      const parsed = JSON.parse(data);

      if (parsed.type === 'track') {
        addTrackToCollection(parsed.track);
      } else if (parsed.type === 'album') {
        addAlbumToCollection(parsed.album);
      } else if (parsed.type === 'artist') {
        addArtistToCollection(parsed.artist);
      } else if (parsed.type === 'tracks') {
        addTracksToCollection(parsed.tracks);
      }
    } catch (error) {
      console.error('Failed to parse drop data:', error);
    }
  }, [addTrackToCollection, addAlbumToCollection, addArtistToCollection, addTracksToCollection]);

  // Re-resolve tracks when resolver settings change (enabled/priority)
  useEffect(() => {
    // Skip on initial mount (when both are empty)
    if (activeResolvers.length === 0 && resolverOrder.length === 0) return;

    // Re-resolve release tracks if viewing an artist release
    if (currentRelease && currentRelease.tracks) {
      console.log('ðŸ”„ Resolver settings changed, re-resolving release tracks...');
      const artistName = currentArtist?.name || 'Unknown Artist';
      currentRelease.tracks.forEach(track => {
        // Force refresh to bypass cache
        resolveTrack(track, artistName, { forceRefresh: true });
      });
    }

    // Re-resolve playlist tracks if viewing a playlist
    if (selectedPlaylist && playlistTracks.length > 0) {
      console.log('ðŸ”„ Resolver settings changed, re-resolving playlist tracks...');

      // Re-resolve each playlist track with new resolver settings
      const reResolvePlaylistTracks = async () => {
        const updatedTracks = [];

        for (const track of playlistTracks) {
          const trackWithSources = { ...track, sources: {} };

          // Query enabled resolvers in priority order
          for (const resolverId of activeResolvers) {
            const resolver = allResolvers.find(r => r.id === resolverId);
            if (!resolver || !resolver.capabilities.resolve) continue;

            try {
              const config = await getResolverConfig(resolverId);
              const resolved = await resolver.resolve(track.artist, track.title, track.album, config);

              if (resolved) {
                trackWithSources.sources[resolverId] = resolved;
              }
            } catch (error) {
              console.error(`Error resolving with ${resolver.name}:`, error);
            }
          }

          updatedTracks.push(trackWithSources);
        }

        setPlaylistTracks(updatedTracks);
        console.log('âœ… Playlist tracks re-resolved');
      };

      reResolvePlaylistTracks();
    }
  }, [activeResolvers, resolverOrder]);

  // Save resolver settings when they change
  useEffect(() => {
    // Skip until we've loaded settings from storage to avoid overwriting saved settings
    if (!resolverSettingsLoaded.current) return;

    // Skip until resolvers are loaded and synced - this prevents saving before
    // new resolvers (like localfiles) are added to the settings
    if (loadedResolvers.length === 0) return;
    const loadedIds = loadedResolvers.map(r => r.id);
    const allResolversInOrder = loadedIds.every(id => resolverOrder.includes(id));
    if (!allResolversInOrder) {
      console.log('â³ Waiting for resolver sync before saving...');
      return;
    }

    // Debounce the save to avoid saving too frequently
    const timeoutId = setTimeout(() => {
      saveCacheToStore();
    }, 500);

    return () => clearTimeout(timeoutId);
  }, [activeResolvers, resolverOrder, loadedResolvers]);

  // Keep refs updated for unmount save
  useEffect(() => {
    activeResolversRef.current = activeResolvers;
    resolverOrderRef.current = resolverOrder;
  }, [activeResolvers, resolverOrder]);


  // Save queue when it changes (if remember queue is enabled)
  // Include currentTrack so it can be restored as the playing track
  useEffect(() => {
    // Skip until settings are loaded to avoid overwriting saved queue
    if (!resolverSettingsLoaded.current) return;
    if (!rememberQueue) return;

    // Debounce the save to avoid saving too frequently
    const timeoutId = setTimeout(async () => {
      if (window.electron?.store) {
        // Save currentTrack + queue together so we restore the correct playing track
        const fullQueue = currentTrack ? [currentTrack, ...currentQueue] : currentQueue;
        await window.electron.store.set('saved_queue', fullQueue);
        // Also save playback context
        await window.electron.store.set('saved_playback_context', playbackContext);
        // Save shuffle state and original queue for restore
        await window.electron.store.set('saved_shuffle_state', {
          shuffleMode: shuffleMode,
          originalQueue: originalQueueRef.current
        });
        console.log(`ðŸ’¾ Saved queue: ${currentTrack ? `"${currentTrack.title}" playing + ` : ''}${currentQueue.length} tracks in queue${playbackContext ? ` (from ${playbackContext.type})` : ''}${shuffleMode ? ' (shuffled)' : ''}`);
      }
    }, 500);

    return () => clearTimeout(timeoutId);
  }, [currentTrack, currentQueue, rememberQueue, playbackContext, shuffleMode]);

  // Persist friends to storage (only after cache is loaded to avoid overwriting)
  useEffect(() => {
    if (cacheLoaded && window.electron?.store) {
      window.electron.store.set('friends', friends);
    }
  }, [friends, cacheLoaded]);

  // Persist pinned friend IDs to storage (only after cache is loaded to avoid overwriting)
  useEffect(() => {
    if (cacheLoaded && window.electron?.store) {
      window.electron.store.set('pinnedFriendIds', pinnedFriendIds);
    }
  }, [pinnedFriendIds, cacheLoaded]);

  // Persist AI include history preference (only after cache is loaded to avoid overwriting)
  useEffect(() => {
    if (cacheLoaded && window.electron?.store) {
      window.electron.store.set('ai_include_history', aiIncludeHistory);
    }
  }, [aiIncludeHistory, cacheLoaded]);

  // Keep prefetchedReleasesRef in sync for context menu handlers
  useEffect(() => {
    prefetchedReleasesRef.current = prefetchedReleases;
  }, [prefetchedReleases]);

  // Local Files handlers
  const handleAddWatchFolder = async () => {
    if (!window.electron?.localFiles) return;

    setIsScanning(true);
    try {
      const result = await window.electron.localFiles.addWatchFolder();
      if (result?.success) {
        setWatchFolders(await window.electron.localFiles.getWatchFolders());
        setLocalFilesStats(await window.electron.localFiles.getStats());
      }
    } finally {
      setIsScanning(false);
    }
  };

  const handleRemoveWatchFolder = async (folderPath) => {
    if (!window.electron?.localFiles) return;

    await window.electron.localFiles.removeWatchFolder(folderPath);
    setWatchFolders(await window.electron.localFiles.getWatchFolders());
    setLocalFilesStats(await window.electron.localFiles.getStats());
  };

  const handleRescanFolder = async (folderPath) => {
    if (!window.electron?.localFiles) return;

    setIsScanning(true);
    try {
      await window.electron.localFiles.rescanFolder(folderPath);
      setWatchFolders(await window.electron.localFiles.getWatchFolders());
      setLocalFilesStats(await window.electron.localFiles.getStats());
    } finally {
      setIsScanning(false);
    }
  };

  const handleRescanAll = async () => {
    if (!window.electron?.localFiles) return;

    setIsScanning(true);
    try {
      await window.electron.localFiles.rescanAll();
      setWatchFolders(await window.electron.localFiles.getWatchFolders());
      setLocalFilesStats(await window.electron.localFiles.getStats());
    } finally {
      setIsScanning(false);
    }
  };

  // Fetch playlist covers when viewing playlists page
  useEffect(() => {
    if (activeView !== 'playlists' || playlists.length === 0) return;

    // Fetch covers for playlists that don't have cached covers yet
    const fetchMissingCovers = async () => {
      for (const playlist of playlists) {
        // Skip if we already have covers for this playlist
        if (allPlaylistCovers[playlist.id]) continue;

        // Get tracks from playlist
        let tracks = playlist.tracks || [];

        // If no tracks array but has XSPF, parse it
        if (tracks.length === 0 && playlist.xspf) {
          const parsed = parseXSPF(playlist.xspf);
          if (parsed) {
            tracks = parsed.tracks;
          }
        }

        if (tracks.length === 0) continue;

        // Fetch covers using the existing function (which handles caching)
        const covers = await getPlaylistCovers(playlist.id, tracks);
        if (covers.length > 0) {
          setAllPlaylistCovers(prev => ({
            ...prev,
            [playlist.id]: covers
          }));
        }
      }
    };

    fetchMissingCovers();
  }, [activeView, playlists]);

  // Keyboard shortcuts - Escape navigates back from search view
  useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.key === 'Escape' && activeView === 'search') {
        navigateBack();
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [activeView]);

  const playDemoAudio = (track) => {
    if (!audioContext) return;
    if (currentSource) {
      try { currentSource.stop(); } catch (e) {}
    }
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    oscillator.type = 'sine';
    oscillator.frequency.setValueAtTime(440 + (track.id * 100), audioContext.currentTime);
    gainNode.gain.setValueAtTime(volume / 100, audioContext.currentTime);
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    oscillator.start();
    setCurrentSource(oscillator);
    setStartTime(audioContext.currentTime);
  };

  const handlePlay = async (trackOrSource) => {
    console.log('ðŸŽµ Playing track:', trackOrSource.title, 'by', trackOrSource.artist);
    setTrackLoading(true); // Show loading state in playbar

    // Stop any active browser playback before starting new track
    if (browserPlaybackActive && activeExtensionTabId) {
      console.log('â¹ï¸ Stopping browser playback before playing new track');
      window.electron.extension.sendCommand({
        type: 'command',
        action: 'pause'
      });
      pendingCloseTabIdRef.current = activeExtensionTabId;
      setBrowserPlaybackActive(false);
      setActiveExtensionTabId(null);
    }

    // Close playback window if active (Bandcamp embedded player)
    if (window.electron?.playbackWindow?.close) {
      console.log('â¹ï¸ Closing playback window before playing new track');
      window.electron.playbackWindow.close();
    }

    // Exit spinoff mode if playing a track that isn't from the spinoff pool
    // (unless this is being called FROM spinoff mode's handleNext)
    if (spinoffMode && !trackOrSource._playbackContext?.type?.includes('spinoff')) {
      exitSpinoff();
    }

    // Use ref to avoid stale closure issues when called from extension message handler
    const currentResolvers = loadedResolversRef.current;

    // Determine if we were passed a track with multiple sources or a specific source
    let resolverId;
    let sourceToPlay = trackOrSource;

    if (trackOrSource.sources && typeof trackOrSource.sources === 'object' && !Array.isArray(trackOrSource.sources)) {
      // We have a track with multiple sources - select the best one
      let availableResolvers = Object.keys(trackOrSource.sources);

      if (availableResolvers.length === 0) {
        // No sources available - try resolving on-demand using shared resolution
        console.log('ðŸ”„ No sources found, attempting on-demand resolution...');

        const sources = await resolveTrack(trackOrSource, trackOrSource.artist, {});
        if (sources && Object.keys(sources).length > 0) {
          trackOrSource.sources = sources;
        }

        // Update availableResolvers after resolution
        availableResolvers = Object.keys(trackOrSource.sources);
        if (availableResolvers.length === 0) {
          console.error('âŒ No resolver found for track after on-demand resolution');
          setTrackLoading(false); // Clear loading state
          showConfirmDialog({
            type: 'error',
            title: 'No Source Found',
            message: 'Could not find a playable source for this track. Try enabling more resolvers in settings.'
          });
          return;
        }
      }

      // Sort sources by: 1) preferred resolver (if specified), 2) resolver priority, 3) confidence
      const preferredResolver = trackOrSource.preferredResolver;
      const sortedSources = availableResolvers.map(resId => ({
        resolverId: resId,
        source: trackOrSource.sources[resId],
        priority: resolverOrder.indexOf(resId),
        confidence: trackOrSource.sources[resId].confidence || 0
      }))
      .filter(s => activeResolvers.includes(s.resolverId)) // Only enabled resolvers
      .sort((a, b) => {
        // If a preferred resolver is specified, prioritize it
        if (preferredResolver) {
          if (a.resolverId === preferredResolver) return -1;
          if (b.resolverId === preferredResolver) return 1;
        }
        // Then sort by priority (lower index = higher priority)
        if (a.priority !== b.priority) {
          return a.priority - b.priority;
        }
        // If same priority, sort by confidence (higher = better)
        return b.confidence - a.confidence;
      });

      if (sortedSources.length === 0) {
        console.error('âŒ No enabled resolvers found for track');
        setTrackLoading(false); // Clear loading state
        return;
      }

      const best = sortedSources[0];
      resolverId = best.resolverId;
      sourceToPlay = best.source;

      console.log(`ðŸŽµ Selected ${resolverId} (priority #${best.priority + 1}, confidence: ${(best.confidence * 100).toFixed(0)}%)`);
    } else {
      // We were passed a specific source object - detect resolver from it
      // Check which resolver this source came from by examining resolver-specific fields
      if (trackOrSource.spotifyId) resolverId = 'spotify';
      else if (trackOrSource.youtubeId) resolverId = 'youtube';
      else if (trackOrSource.bandcampUrl) resolverId = 'bandcamp';
      else if (trackOrSource.qobuzId) resolverId = 'qobuz';
      else if (trackOrSource.filePath || trackOrSource.fileUrl) resolverId = 'localfiles';
      else {
        console.error('âŒ Could not determine resolver for source');
        setTrackLoading(false); // Clear loading state
        return;
      }
    }

    const resolver = currentResolvers.find(r => r.id === resolverId);
    if (!resolver) {
      console.error(`âŒ Resolver ${resolverId} not found`);
      console.error(`   Available resolvers:`, currentResolvers.map(r => r.id));
      setTrackLoading(false); // Clear loading state
      return;
    }

    // YouTube embedding is blocked in Electron, use resolver's play method instead
    // (which opens in external browser)

    // Handle local file playback directly with HTML5 Audio
    if (resolverId === 'localfiles') {
      console.log('ðŸŽµ Playing local file:', sourceToPlay.filePath || sourceToPlay.fileUrl);
      console.log('ðŸŽµ Source details:', JSON.stringify(sourceToPlay, null, 2));

      // Stop Spotify polling when switching to local file playback
      if (playbackPollerRef.current) {
        console.log('â¹ï¸ Stopping Spotify polling for local file playback');
        clearInterval(playbackPollerRef.current);
        playbackPollerRef.current = null;
      }
      if (pollingRecoveryRef.current) {
        clearInterval(pollingRecoveryRef.current);
        pollingRecoveryRef.current = null;
      }

      // Pause Spotify if it's playing
      if (spotifyPlayer && streamingPlaybackActiveRef.current) {
        console.log('â¹ï¸ Pausing Spotify for local file playback');
        try {
          spotifyPlayer.pause();
        } catch (e) {
          console.error('Failed to pause Spotify:', e);
        }
      }

      // Create audio element if needed
      if (!audioRef.current) {
        console.log('ðŸŽµ Creating new Audio element');
        audioRef.current = new Audio();
        audioRef.current.addEventListener('timeupdate', () => {
          if (audioRef.current) {
            const currentTime = audioRef.current.currentTime;
            setProgress(currentTime);
            // Notify scrobble manager of progress for scrobble threshold checking
            if (window.scrobbleManager) {
              window.scrobbleManager.onProgressUpdate(currentTime);
            }
          }
        });
        audioRef.current.addEventListener('loadedmetadata', () => {
          // Update current track duration from audio element once metadata loads
          const audioDuration = audioRef.current?.duration;
          if (audioDuration && !isNaN(audioDuration) && isFinite(audioDuration)) {
            console.log('ðŸŽµ Audio metadata loaded, duration:', audioDuration);
            setCurrentTrack(prev => prev ? { ...prev, duration: audioDuration } : prev);
          }
        });
        audioRef.current.addEventListener('durationchange', () => {
          // Also listen for duration changes (some formats report duration later)
          const audioDuration = audioRef.current?.duration;
          if (audioDuration && !isNaN(audioDuration) && isFinite(audioDuration)) {
            console.log('ðŸŽµ Audio duration changed:', audioDuration);
            setCurrentTrack(prev => prev ? { ...prev, duration: audioDuration } : prev);
          }
        });
        audioRef.current.addEventListener('ended', () => {
          console.log('ðŸŽµ Local file playback ended');
          handleNextRef.current?.();
        });
        audioRef.current.addEventListener('error', (e) => {
          console.error('ðŸŽµ Audio error:', e.target.error);
          // Don't show error dialog if fallback is in progress (it will be handled by the catch block)
          if (localFileFallbackInProgressRef.current) {
            console.log('ðŸ”„ Audio error during fallback attempt, skipping dialog');
            return;
          }
          showConfirmDialog({
            type: 'error',
            title: 'Playback Error',
            message: 'Could not play this file. It may have been moved or deleted.'
          });
        });
      }

      // Store the track for potential fallback handling
      localFilePlaybackTrackRef.current = trackOrSource;
      localFileFallbackInProgressRef.current = false;

      // Use custom local-audio:// protocol for secure local file playback
      const filePath = sourceToPlay.filePath || sourceToPlay.fileUrl?.replace('file://', '');
      const audioUrl = `local-audio://${filePath}`;
      console.log('ðŸŽµ Audio URL:', audioUrl);
      audioRef.current.src = audioUrl;
      // Apply normalized volume for local files (respect mute state)
      const volumeToApply = isMutedRef.current ? 0 : volume;
      const effectiveVolume = getEffectiveVolume(volumeToApply, 'localfiles', sourceToPlay.id || trackOrSource.id);
      audioRef.current.volume = effectiveVolume / 100;
      console.log(`ðŸ”Š Applied volume: ${volumeToApply}% -> ${effectiveVolume.toFixed(1)}% (offset: ${resolverVolumeOffsets.localfiles || 0}dB)${isMutedRef.current ? ' [MUTED]' : ''}`);

      // Explicitly load to trigger metadata events
      audioRef.current.load();

      try {
        await audioRef.current.play();

        // Set current track state
        // Duration from local files is already in seconds
        const duration = sourceToPlay.duration || trackOrSource.duration || 0;
        console.log('ðŸŽµ Track duration from source:', duration, 'sourceToPlay.duration:', sourceToPlay.duration, 'trackOrSource.duration:', trackOrSource.duration);
        const trackToSet = trackOrSource.sources ? {
          ...sourceToPlay,
          id: trackOrSource.id,
          artist: trackOrSource.artist,
          title: trackOrSource.title,
          album: trackOrSource.album,
          duration: duration,
          albumArt: getCachedAlbumArt(trackOrSource.artist, trackOrSource.album) || sourceToPlay.albumArt || trackOrSource.albumArt,
          sources: trackOrSource.sources,
          _playbackContext: trackOrSource._playbackContext, // Preserve playback context
          _activeResolver: resolverId // Track which resolver is actually playing
        } : { ...sourceToPlay, _playbackContext: trackOrSource._playbackContext, _activeResolver: resolverId };

        setCurrentTrack(trackToSet);
        setIsPlaying(true);
        setProgress(0);
        setTrackLoading(false); // Clear loading state
        streamingPlaybackActiveRef.current = false;
        setBrowserPlaybackActive(false);
        setIsExternalPlayback(false);
        // Clear explicit start flag since we're playing a new track
        trackNeedsExplicitStart.current = false;

        console.log('âœ… Local file playing');

        // Notify scrobble manager of track start
        if (window.scrobbleManager) {
          window.scrobbleManager.onTrackStart(trackToSet);
        }

        // If audio element has duration now, update the track
        const audioDuration = audioRef.current?.duration;
        if (audioDuration && !isNaN(audioDuration) && isFinite(audioDuration) && audioDuration > 0) {
          console.log('ðŸŽµ Setting duration from audio element:', audioDuration);
          setCurrentTrack(prev => prev ? { ...prev, duration: audioDuration } : prev);
        }
      } catch (error) {
        console.error('âŒ Local file playback failed:', error);

        // Try fallback to next available source if we have the original track with sources
        if (trackOrSource.sources && Object.keys(trackOrSource.sources).length > 1) {
          const otherSources = Object.keys(trackOrSource.sources).filter(id => id !== 'localfiles');
          if (otherSources.length > 0) {
            console.log('ðŸ”„ Falling back to next available source...');
            // Set flag to prevent error event listener from showing duplicate dialog
            localFileFallbackInProgressRef.current = true;
            // Create a modified track without localfiles source to trigger fallback
            const fallbackTrack = {
              ...trackOrSource,
              sources: Object.fromEntries(
                Object.entries(trackOrSource.sources).filter(([id]) => id !== 'localfiles')
              )
            };
            handlePlay(fallbackTrack);
            return;
          }
        }

        localFileFallbackInProgressRef.current = false;
        setTrackLoading(false); // Clear loading state on error
        showConfirmDialog({
          type: 'error',
          title: 'Playback Error',
          message: 'Could not play this file: ' + error.message
        });
      }
      return;
    }

    // Check if resolver can stream
    if (!resolver.capabilities.stream) {
      // For non-streaming resolvers (Bandcamp, YouTube), show prompt first
      console.log('ðŸŒ External browser track detected, showing prompt...');
      streamingPlaybackActiveRef.current = false; // Allow browser events for external playback

      // Stop any playing local audio before switching to browser playback
      if (audioRef.current && !audioRef.current.paused) {
        console.log('â¹ï¸ Stopping local audio before browser playback');
        audioRef.current.pause();
        audioRef.current.currentTime = 0;
      }

      // Stop Spotify polling when switching to external browser playback
      if (playbackPollerRef.current) {
        console.log('â¹ï¸ Stopping Spotify polling for external browser playback');
        clearInterval(playbackPollerRef.current);
        playbackPollerRef.current = null;
      }
      if (pollingRecoveryRef.current) {
        clearInterval(pollingRecoveryRef.current);
        pollingRecoveryRef.current = null;
      }
      // CRITICAL: Update currentTrack BEFORE showing prompt so handleNext() can find it in queue
      // Merge source with original track, explicitly preserving queue-essential properties
      const trackToSet = trackOrSource.sources ?
        {
          ...sourceToPlay,
          id: trackOrSource.id,  // MUST preserve queue ID
          artist: trackOrSource.artist,
          title: trackOrSource.title,
          album: trackOrSource.album,
          duration: sourceToPlay.duration || trackOrSource.duration,
          albumArt: getCachedAlbumArt(trackOrSource.artist, trackOrSource.album) || sourceToPlay.albumArt || trackOrSource.albumArt,
          sources: trackOrSource.sources,
          _playbackContext: trackOrSource._playbackContext, // Preserve playback context
          _activeResolver: resolverId // Track which resolver is actually playing
        } :
        { ...sourceToPlay, _playbackContext: trackOrSource._playbackContext, _activeResolver: resolverId };
      console.log(`ðŸ” trackToSet.id="${trackToSet.id}", trackOrSource.id="${trackOrSource.id}", sourceToPlay.id="${sourceToPlay.id}"`);
      setCurrentTrack(trackToSet);
      setTrackLoading(false); // Clear loading state when showing prompt
      // Clear explicit start flag since we're playing a new track
      trackNeedsExplicitStart.current = false;
      showExternalTrackPromptUI(trackToSet, resolverId);
      return; // Don't play yet, wait for user confirmation
    }

    // Use resolver's play method
    try {
      // Stop any playing local audio before switching to streaming resolver
      if (audioRef.current && !audioRef.current.paused) {
        console.log('â¹ï¸ Stopping local audio before streaming playback');
        audioRef.current.pause();
        audioRef.current.currentTime = 0;
      }

      const config = await getResolverConfig(resolverId);
      console.log(`â–¶ï¸ Using ${resolver.name} to play track...`);

      const success = await resolver.play(sourceToPlay, config);

      if (success) {
        console.log(`âœ… Playing on ${resolver.name}`);

        // Apply normalized volume for Spotify (respect mute state)
        if (resolverId === 'spotify') {
          const trackId = sourceToPlay.id || trackOrSource.id;
          const volumeToApply = isMutedRef.current ? 0 : volume;
          const effectiveVolume = getEffectiveVolume(volumeToApply, 'spotify', trackId);
          console.log(`ðŸ”Š Applied Spotify volume: ${volumeToApply}% -> ${effectiveVolume.toFixed(1)}% (offset: ${resolverVolumeOffsets.spotify || 0}dB)${isMutedRef.current ? ' [MUTED]' : ''}`);
          setSpotifyVolume(volumeToApply, !isMutedRef.current); // Apply with normalization only if not muted
        }

        // Reset browser playback state when playing via streaming resolver (Spotify, etc.)
        // This ensures we don't show "Playing in browser" for Spotify Connect playback
        if (resolver.capabilities.stream) {
          streamingPlaybackActiveRef.current = true; // Mark streaming active to ignore browser events
          setBrowserPlaybackActive(false);
          setIsExternalPlayback(false);
        }

        // Merge source with original track, explicitly preserving queue-essential properties
        const trackToSet = trackOrSource.sources ?
          {
            ...sourceToPlay,
            id: trackOrSource.id,  // MUST preserve queue ID
            artist: trackOrSource.artist,
            title: trackOrSource.title,
            album: trackOrSource.album,
            duration: sourceToPlay.duration || trackOrSource.duration,
            albumArt: getCachedAlbumArt(trackOrSource.artist, trackOrSource.album) || sourceToPlay.albumArt || trackOrSource.albumArt,
            sources: trackOrSource.sources,
            _playbackContext: trackOrSource._playbackContext, // Preserve playback context
            _activeResolver: resolverId // Track which resolver is actually playing
          } :
          { ...sourceToPlay, _playbackContext: trackOrSource._playbackContext, _activeResolver: resolverId };
        setCurrentTrack(trackToSet);
        setIsPlaying(true);
        setProgress(0);
        setTrackLoading(false); // Clear loading state on success
        // Clear explicit start flag since we're playing a new track
        trackNeedsExplicitStart.current = false;
        // Reset baseline for smooth progress interpolation
        spotifyProgressBaselineRef.current = { progress: 0, timestamp: Date.now(), isPlaying: true };

        // Notify scrobble manager of track start
        if (window.scrobbleManager) {
          window.scrobbleManager.onTrackStart(trackToSet);
        }

        if (audioContext) {
          setStartTime(audioContext.currentTime);
        }
      }

      // Start auto-advance polling for streaming tracks
      if (resolver.capabilities.stream && success) {
        startAutoAdvancePolling(resolverId, sourceToPlay, config);
      }

      if (!success) {
        setTrackLoading(false); // Clear loading state on failure
        console.error(`âŒ ${resolver.name} playback failed`);

        // For Spotify, retry once after a short delay (device may need to wake up)
        if (resolverId === 'spotify' && !sourceToPlay._spotifyRetried) {
          console.log('ðŸ”„ Spotify playback failed, retrying in 2 seconds...');
          await new Promise(resolve => setTimeout(resolve, 2000));

          // Mark as retried to prevent infinite loop
          const retrySource = { ...sourceToPlay, _spotifyRetried: true };
          const retryTrack = trackOrSource.sources ? {
            ...trackOrSource,
            sources: { ...trackOrSource.sources, spotify: retrySource }
          } : retrySource;

          console.log('ðŸ”„ Retrying Spotify playback...');
          const retrySuccess = await resolver.play(retrySource, config);

          if (retrySuccess) {
            console.log('âœ… Spotify retry successful');
            streamingPlaybackActiveRef.current = true;
            setBrowserPlaybackActive(false);
            setIsExternalPlayback(false);

            const trackToSet = trackOrSource.sources ? {
              ...sourceToPlay,
              id: trackOrSource.id,
              artist: trackOrSource.artist,
              title: trackOrSource.title,
              album: trackOrSource.album,
              duration: sourceToPlay.duration || trackOrSource.duration,
              sources: trackOrSource.sources,
              _playbackContext: trackOrSource._playbackContext, // Preserve playback context
              _activeResolver: resolverId // Track which resolver is actually playing
            } : { ...sourceToPlay, _playbackContext: trackOrSource._playbackContext, _activeResolver: resolverId };
            setCurrentTrack(trackToSet);
            setIsPlaying(true);
            setProgress(0);
            // Reset baseline for smooth progress interpolation
            spotifyProgressBaselineRef.current = { progress: 0, timestamp: Date.now(), isPlaying: true };

            // Notify scrobble manager of track start
            if (window.scrobbleManager) {
              window.scrobbleManager.onTrackStart(trackToSet);
            }

            if (audioContext) {
              setStartTime(audioContext.currentTime);
            }
            startAutoAdvancePolling(resolverId, sourceToPlay, config);
            return; // Success on retry, don't fall through to re-resolve
          }
          console.error('âŒ Spotify retry also failed');

          // Spotify failed after retry - try to fall back to next best source
          if (trackOrSource.sources && Object.keys(trackOrSource.sources).length > 1) {
            const otherSources = Object.keys(trackOrSource.sources).filter(id => id !== 'spotify' && activeResolvers.includes(id));

            if (otherSources.length > 0) {
              // Sort by resolver priority
              const sortedFallbacks = otherSources
                .map(resId => ({
                  resolverId: resId,
                  source: trackOrSource.sources[resId],
                  priority: resolverOrder.indexOf(resId)
                }))
                .sort((a, b) => a.priority - b.priority);

              const fallback = sortedFallbacks[0];
              const fallbackResolver = currentResolvers.find(r => r.id === fallback.resolverId);

              console.log(`ðŸ”„ Spotify unavailable, falling back to ${fallbackResolver?.name || fallback.resolverId}`);

              // Show toast with option to retry Spotify (e.g., after opening app)
              showToast(
                `Spotify device unavailable. Playing via ${fallbackResolver?.name || fallback.resolverId}.`,
                'info',
                {
                  label: 'Open Spotify',
                  onClick: wakeSpotifyApp
                }
              );

              // Create fallback track without spotify source to prevent loop
              const fallbackTrack = {
                ...trackOrSource,
                sources: Object.fromEntries(
                  Object.entries(trackOrSource.sources).filter(([id]) => id !== 'spotify')
                ),
                _spotifyFallback: true // Mark that we fell back from Spotify
              };

              // Play via the fallback source
              handlePlay(fallbackTrack);
              return;
            }
          }
        }

        // No fallback available or non-Spotify failure - show re-resolve dialog
        if (!trackOrSource._spotifyFallback && sourceToPlay.artist && sourceToPlay.title) {
          console.log('ðŸ”„ Attempting to re-resolve track with fresh sources...');
          const artistName = sourceToPlay.artist;
          const trackData = { position: sourceToPlay.position || 1, title: sourceToPlay.title, length: sourceToPlay.duration };

          // Force refresh to bypass cache
          await resolveTrack(trackData, artistName, { forceRefresh: true });

          showConfirmDialog({
            type: 'info',
            title: 'Track Re-resolved',
            message: 'Playback failed. Track has been re-resolved. Please try playing again.'
          });
        }
      }
    } catch (error) {
      console.error(`âŒ Error playing with ${resolver.name}:`, error);
      setTrackLoading(false); // Clear loading state on error

      // On error, also try to re-resolve
      if (sourceToPlay.artist && sourceToPlay.title) {
        console.log('ðŸ”„ Playback error - attempting to re-resolve...');
        const artistName = sourceToPlay.artist;
        const trackData = { position: sourceToPlay.position || 1, title: sourceToPlay.title, length: sourceToPlay.duration };
        await resolveTrack(trackData, artistName, { forceRefresh: true });
      }
    }
  };

  // Auto-advance: Start polling for track completion
  const startAutoAdvancePolling = (resolverId, track, config) => {
    // Clear any existing poller
    if (playbackPollerRef.current) {
      clearInterval(playbackPollerRef.current);
      playbackPollerRef.current = null;
    }
    // Clear recovery interval if we're starting fresh polling
    if (pollingRecoveryRef.current) {
      clearInterval(pollingRecoveryRef.current);
      pollingRecoveryRef.current = null;
    }
    // Increment generation to invalidate any stale polling callbacks
    pollingGenerationRef.current++;
    const thisGeneration = pollingGenerationRef.current;

    if (resolverId === 'spotify' && config.token) {
      const trackUri = track.spotifyUri || track.uri;
      console.log(`ðŸ”„ Starting Spotify playback polling for auto-advance (5s interval, gen ${thisGeneration})...`);
      console.log(`   Track: ${track.title} by ${track.artist}`);
      console.log(`   Expected URI: ${trackUri}`);
      console.log(`   spotifyUri: ${track.spotifyUri}, uri: ${track.uri}`);

      if (!trackUri) {
        console.warn('âš ï¸ No Spotify URI found on track, auto-advance may not work');
      }

      let errorCount = 0; // Track consecutive polling errors
      let lastTrackUri = trackUri; // Track what we started playing
      let stuckAtZeroCount = 0; // Track how many times we've been stuck at 0% with is_playing=false
      const MAX_STUCK_AT_ZERO = 3; // After 15 seconds (3 * 5s polls) of being stuck at 0%, give up
      let pollCount = 0; // Track poll number for first-poll grace period
      let pendingTrackChange = null; // Track URI from potential external change, needs confirmation
      let lastProgressMs = 0; // Track previous progress to detect track-end-then-reset scenario
      let lastKnownDurationMs = 0; // Track the duration when we last had valid progress

      const pollInterval = setInterval(async () => {
        // Check if this polling generation is still current (prevents stale callbacks)
        if (thisGeneration !== pollingGenerationRef.current) {
          console.log(`ðŸš« Stale poll callback (gen ${thisGeneration} vs current ${pollingGenerationRef.current}), ignoring`);
          return;
        }
        pollCount++; // Increment poll counter
        try {
          const response = await fetch('https://api.spotify.com/v1/me/player', {
            headers: {
              'Authorization': `Bearer ${config.token}`
            }
          });

          if (!response.ok) {
            if (response.status === 401) {
              // Token expired - attempt refresh and restart polling
              console.log('ðŸ”„ Spotify token expired during polling, attempting refresh...');
              clearInterval(pollInterval);
              playbackPollerRef.current = null;
              const newToken = await refreshSpotifyToken();
              if (newToken) {
                console.log('âœ… Token refreshed, restarting auto-advance polling');
                startAutoAdvancePolling(resolverId, track, { ...config, token: newToken });
              } else {
                console.error('âŒ Token refresh failed, auto-advance disabled');
              }
              return;
            }
            throw new Error(`Spotify API error: ${response.status}`);
          }

          const data = await response.json();
          errorCount = 0; // Reset on success

          if (!data.item) {
            // No track playing - playback stopped or track ended naturally
            // Check if we have more tracks in queue - if so, this likely means the track ended
            const queue = currentQueueRef.current;
            clearInterval(pollInterval);
            playbackPollerRef.current = null;

            if (queue && queue.length > 0) {
              // Track likely ended naturally, advance to next
              console.log('ðŸŽµ Spotify playback ended (no item), advancing to next track...');
              if (handleNextRef.current) handleNextRef.current();
            } else {
              // No queue, playback genuinely stopped
              console.log('â¹ï¸ Spotify playback stopped (no queue)');
            }
            return;
          }

          const currentUri = data.item.uri;
          const progressMs = data.progress_ms;
          const durationMs = data.item.duration_ms;
          const isPlaying = data.is_playing;

          // Check if we're still playing the same track we started with
          if (currentUri === lastTrackUri) {
            // Calculate if we're at or near the end of the track
            const isNearEnd = progressMs >= durationMs - 1000;
            const isAtEnd = progressMs >= durationMs - 100; // Within 100ms of end
            const percentComplete = (progressMs / durationMs) * 100;

            // If playing and near end, or if stopped and at end, trigger next
            if (isNearEnd && isPlaying) {
              console.log('ðŸŽµ Track ending, auto-advancing to next...');
              clearInterval(pollInterval);
              playbackPollerRef.current = null;
              if (handleNextRef.current) handleNextRef.current();
            } else if (!isPlaying && (isAtEnd || percentComplete >= 98)) {
              // Track finished playing (is_playing=false and at end of track)
              console.log(`ðŸŽµ Track finished (${percentComplete.toFixed(1)}% complete), auto-advancing to next...`);
              clearInterval(pollInterval);
              playbackPollerRef.current = null;
              if (handleNextRef.current) handleNextRef.current();
            } else if (!isPlaying) {
              // Track is paused - could be user pause or playback never started
              if (progressMs === 0) {
                // Check if we were previously near the end - this means track finished and reset
                // Use lastKnownDurationMs if available (more reliable than current durationMs which might be stale)
                const effectiveDuration = lastKnownDurationMs > 0 ? lastKnownDurationMs : durationMs;
                const lastPercentComplete = effectiveDuration > 0 ? (lastProgressMs / effectiveDuration) * 100 : 0;
                console.log(`ðŸ” Track at 0%: lastProgressMs=${lastProgressMs}, effectiveDuration=${effectiveDuration}, lastPercentComplete=${lastPercentComplete.toFixed(1)}%`);
                if (lastProgressMs > 0 && lastPercentComplete >= 90) {
                  // We were at 90%+ and now at 0% - track finished naturally
                  console.log(`ðŸŽµ Track finished (was at ${lastPercentComplete.toFixed(1)}%, now reset to 0%), auto-advancing to next...`);
                  clearInterval(pollInterval);
                  playbackPollerRef.current = null;
                  if (handleNextRef.current) handleNextRef.current();
                } else {
                  // Stuck at 0% - playback may have failed to start
                  stuckAtZeroCount++;
                  if (stuckAtZeroCount >= MAX_STUCK_AT_ZERO) {
                    // Been stuck at 0% for too long - playback failed to start
                    console.error(`âŒ Spotify playback stuck at 0% for ${stuckAtZeroCount * 5}s - device may not be active`);
                    clearInterval(pollInterval);
                    playbackPollerRef.current = null;

                    // Check if queue has more tracks and advance
                    const queue = currentQueueRef.current;
                    if (queue && queue.length > 0) {
                      console.log('â­ï¸ Auto-advancing to next track due to playback failure...');
                      if (handleNextRef.current) handleNextRef.current();
                    }
                  } else {
                    console.log(`â¸ï¸ Spotify playback paused at 0% (${stuckAtZeroCount}/${MAX_STUCK_AT_ZERO}), waiting for playback to start...`);
                  }
                }
              } else {
                // User paused mid-playback (progress > 0) - reset stuck counter
                stuckAtZeroCount = 0;
                lastProgressMs = progressMs; // Track progress even when paused
                lastKnownDurationMs = durationMs; // Track duration for accurate percentage calculation
                console.log(`â¸ï¸ Spotify playback paused at ${percentComplete.toFixed(1)}%, continuing to poll...`);
              }
            } else {
              // Playing normally - reset stuck counter and log progress periodically
              stuckAtZeroCount = 0;
              lastProgressMs = progressMs; // Track progress for end-of-track detection
              lastKnownDurationMs = durationMs; // Track duration for accurate percentage calculation
              pendingTrackChange = null; // Clear any pending track change since we're on the right track
              // Log every poll to confirm polling is working
              console.log(`â–¶ï¸ Spotify playing: ${percentComplete.toFixed(1)}% (${Math.floor(progressMs / 1000)}s / ${Math.floor(durationMs / 1000)}s)`);
            }
          } else {
            // Track changed - Spotify advanced on its own or user changed track
            // But wait! On the first few polls, Spotify might not have caught up yet
            // Give it a grace period before assuming the track truly changed
            console.log(`ðŸ”„ Detected potential track change (poll #${pollCount})...`);
            console.log(`   Expected URI: ${lastTrackUri}`);
            console.log(`   Current URI:  ${currentUri}`);
            console.log(`   Spotify says: ${data.item?.name} by ${data.item?.artists?.[0]?.name}`);

            // If this is one of the first 2 polls, check if Spotify is still catching up
            if (pollCount <= 2) {
              // Check if Spotify is playing the track we intended (by comparing track IDs)
              const expectedId = lastTrackUri?.split(':').pop();
              const currentId = currentUri?.split(':').pop();

              if (pendingTrackChange === null) {
                // First time seeing a mismatch - store it and wait for confirmation
                console.log(`   â³ First mismatch on poll #${pollCount}, waiting for confirmation...`);
                pendingTrackChange = currentUri;
              } else if (pendingTrackChange === currentUri) {
                // Confirmed - the track really changed
                console.log(`   âœ… Track change confirmed after grace period`);
                clearInterval(pollInterval);
                playbackPollerRef.current = null;
                if (handleNextRef.current) handleNextRef.current();
              } else {
                // Different URI than pending - reset and wait
                console.log(`   ðŸ”„ URI changed again, resetting confirmation...`);
                pendingTrackChange = currentUri;
              }
            } else {
              // After grace period, trust the mismatch and advance
              console.log(`   âœ… Track change detected after grace period, advancing queue...`);
              clearInterval(pollInterval);
              playbackPollerRef.current = null;
              if (handleNextRef.current) handleNextRef.current();
            }
          }
        } catch (error) {
          console.error('Spotify polling error:', error);

          // Track consecutive errors
          errorCount = (errorCount || 0) + 1;

          if (errorCount >= 3) {
            // After 3 consecutive errors, stop polling but start recovery
            console.error('âŒ Too many Spotify polling errors, stopping auto-advance');
            clearInterval(pollInterval);
            playbackPollerRef.current = null;
            // Start recovery interval to retry when API becomes available
            startPollingRecovery(config);
          }
        }
      }, 5000); // Poll every 5 seconds (consistent with existing playback polling)

      playbackPollerRef.current = pollInterval;
    }
    // For future HTML5 audio resolvers, add event listener logic here
  };

  // Start recovery polling when Spotify auto-advance fails
  // Periodically checks if we should restart polling (queue has tracks, nothing playing)
  const startPollingRecovery = (config) => {
    // Clear any existing recovery interval
    if (pollingRecoveryRef.current) {
      clearInterval(pollingRecoveryRef.current);
      pollingRecoveryRef.current = null;
    }

    console.log('ðŸ”„ Starting polling recovery interval (20s)...');

    const recoveryInterval = setInterval(async () => {
      const queue = currentQueueRef.current;
      const track = currentTrackRef.current;

      // Stop recovery if queue is empty
      if (!queue || queue.length === 0) {
        console.log('ðŸ”„ Recovery: Queue empty, stopping recovery');
        clearInterval(recoveryInterval);
        pollingRecoveryRef.current = null;
        return;
      }

      // Stop recovery if no current track (nothing to monitor)
      if (!track) {
        console.log('ðŸ”„ Recovery: No current track, stopping recovery');
        clearInterval(recoveryInterval);
        pollingRecoveryRef.current = null;
        return;
      }

      // Try to check Spotify playback state
      try {
        const response = await fetch('https://api.spotify.com/v1/me/player', {
          headers: {
            'Authorization': `Bearer ${config.token}`
          }
        });

        if (response.ok) {
          const data = await response.json();

          // If Spotify is playing, restart proper polling
          if (data.is_playing && data.item) {
            console.log('ðŸ”„ Recovery: Spotify responding, restarting auto-advance polling');
            clearInterval(recoveryInterval);
            pollingRecoveryRef.current = null;
            startAutoAdvancePolling('spotify', track, config);
          } else if (!data.is_playing && queue.length > 0) {
            // Spotify not playing but we have queue - advance to next track
            console.log('ðŸ”„ Recovery: Spotify not playing, queue has tracks - advancing');
            clearInterval(recoveryInterval);
            pollingRecoveryRef.current = null;
            if (handleNextRef.current) handleNextRef.current();
          }
        } else if (response.status === 401) {
          // Token expired - attempt refresh
          console.log('ðŸ”„ Recovery: Token expired, attempting refresh...');
          const newToken = await refreshSpotifyToken();
          if (newToken) {
            console.log('âœ… Recovery: Token refreshed, restarting polling');
            clearInterval(recoveryInterval);
            pollingRecoveryRef.current = null;
            startAutoAdvancePolling('spotify', track, { ...config, token: newToken });
          } else {
            console.log('âŒ Recovery: Token refresh failed, stopping recovery');
            clearInterval(recoveryInterval);
            pollingRecoveryRef.current = null;
          }
        }
        // Other errors: keep trying
      } catch (error) {
        console.log('ðŸ”„ Recovery: API still unavailable, will retry...', error.message);
        // Keep recovery interval running
      }
    }, 20000); // Check every 20 seconds

    pollingRecoveryRef.current = recoveryInterval;
  };

  // Wake Spotify by opening the app via protocol URL
  const wakeSpotifyApp = useCallback(() => {
    console.log('ðŸŽµ Attempting to wake Spotify app...');
    if (window.electron?.shell?.openExternal) {
      window.electron.shell.openExternal('spotify:');
    } else {
      // Fallback for web - open Spotify web player
      window.open('https://open.spotify.com', '_blank');
    }
  }, []);

  // Stop Spotify playback (used when switching to external browser track)
  const stopSpotifyPlayback = async () => {
    if (!spotifyToken) return;

    try {
      const response = await fetch('https://api.spotify.com/v1/me/player/pause', {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${spotifyToken}`
        }
      });

      if (response.ok || response.status === 204) {
        console.log('â¸ï¸ Stopped Spotify playback');
        setIsPlaying(false);
      }
    } catch (error) {
      console.error('Failed to stop Spotify playback:', error);
    }
  };

  // Show prompt for external browser track
  const showExternalTrackPromptUI = async (track, resolverId) => {
    console.log('ðŸŒ Showing external track prompt for:', track.title, 'via', resolverId);

    // Stop any currently playing Spotify track before prompting
    await stopSpotifyPlayback();

    // Store the selected resolver ID for when user confirms
    setPendingExternalResolverId(resolverId);

    // If user has opted to skip the prompt, auto-open directly
    if (skipExternalPrompt) {
      console.log('ðŸš€ Skip prompt enabled, auto-opening external track');
      setPendingExternalTrack(track);
      handleOpenExternalTrack(track, resolverId);
      return;
    }

    setPendingExternalTrack(track);
    setShowExternalPrompt(true);
    setExternalTrackCountdown(15);

    // Set countdown interval
    const interval = setInterval(() => {
      setExternalTrackCountdown(prev => {
        if (prev <= 1) {
          clearInterval(interval);
          return 0;
        }
        return prev - 1;
      });
    }, 1000);
    externalTrackIntervalRef.current = interval;

    // Set 15-second auto-skip timeout
    const timeout = setTimeout(() => {
      console.log('â±ï¸ External track prompt timeout, auto-skipping...');
      if (externalTrackIntervalRef.current) {
        clearInterval(externalTrackIntervalRef.current);
        externalTrackIntervalRef.current = null;
      }
      handleSkipExternalTrack();
    }, 15000);

    externalTrackTimeoutRef.current = timeout;
  };

  // User confirmed opening external browser
  // resolverIdOverride is used when called from showExternalTrackPromptUI with skip prompt enabled
  const handleOpenExternalTrack = async (track, resolverIdOverride = null) => {
    console.log('âœ… User confirmed, opening external track:', track.title);

    // Clear timeout and interval FIRST
    if (externalTrackTimeoutRef.current) {
      clearTimeout(externalTrackTimeoutRef.current);
      externalTrackTimeoutRef.current = null;
    }
    if (externalTrackIntervalRef.current) {
      clearInterval(externalTrackIntervalRef.current);
      externalTrackIntervalRef.current = null;
    }

    // Use the stored resolver ID from when the prompt was shown, or override if provided
    // This preserves the SELECTED resolver rather than re-determining from track properties
    const resolverId = resolverIdOverride || pendingExternalResolverId || determineResolverIdFromTrack(track);
    if (!resolverId) {
      console.error('âŒ Could not determine resolver for external track');
      setIsExternalPlayback(false);
      setPendingExternalTrack(null);
      setPendingExternalResolverId(null);
      setShowExternalPrompt(false);
      handleNext();
      return;
    }

    const resolver = allResolvers.find(r => r.id === resolverId);
    if (!resolver) {
      console.error(`âŒ Resolver ${resolverId} not found`);
      setIsExternalPlayback(false);
      setPendingExternalTrack(null);
      setPendingExternalResolverId(null);
      setShowExternalPrompt(false);
      handleNext();
      return;
    }

    // Close previous browser tab if one is active
    if (activeExtensionTabId && extensionConnected) {
      console.log('ðŸ”„ Closing previous browser tab:', activeExtensionTabId);
      // Mark this as a programmatic close so tabClosed handler doesn't call handleNext()
      pendingCloseTabIdRef.current = activeExtensionTabId;
      window.electron.extension.sendCommand({
        type: 'command',
        action: 'closeTab',
        tabId: activeExtensionTabId
      });
      setActiveExtensionTabId(null);
      setBrowserPlaybackActive(false);
    }

    // Close previous playback window if one is active (for Bandcamp, etc.)
    if (window.electron?.playbackWindow?.close) {
      console.log('ðŸ”„ Closing previous playback window');
      await window.electron.playbackWindow.close();
    }

    // Open in external browser FIRST
    try {
      // Mark that we're waiting for browser to connect - prevents premature handleNext() calls
      waitingForBrowserPlaybackRef.current = true;
      console.log('â³ Waiting for browser playback to connect...');

      // Safety timeout: Clear the waiting flag after 10 seconds if browser never connects
      // This prevents getting stuck if the browser extension isn't responding
      const safetyTimeout = setTimeout(() => {
        if (waitingForBrowserPlaybackRef.current) {
          console.log('âš ï¸ Browser playback timeout - clearing wait flag after 10s');
          waitingForBrowserPlaybackRef.current = false;
        }
      }, 10000);

      const config = await getResolverConfig(resolverId);
      await resolver.play(track, config);
      console.log(`ðŸŒ Opened ${track.title} in browser via ${resolver.name}`);

      // NOTE: Do NOT clear safety timeout here - it should only expire if the
      // playback window never fires a 'playing' event. The 'playing' event
      // handler clears waitingForBrowserPlaybackRef, and then the safety
      // timeout becomes a no-op (checks the flag before acting).

      // Only update state AFTER successful browser open
      setShowExternalPrompt(false);
      setPendingExternalTrack(null);
      setPendingExternalResolverId(null);
      setIsExternalPlayback(true);
      setIsPlaying(true);
      setCurrentTrack({ ...track, _activeResolver: resolverId });
    } catch (error) {
      console.error('âŒ Failed to open external track:', error);
      // Clear the waiting flag on error
      waitingForBrowserPlaybackRef.current = false;
      showConfirmDialog({
        type: 'error',
        title: 'Browser Error',
        message: `Failed to open browser: ${error.message}`
      });
      setIsExternalPlayback(false);
      setPendingExternalTrack(null);
      setPendingExternalResolverId(null);
      setShowExternalPrompt(false);
      handleNext();
    }
  };

  // Skip external track (manual or auto-timeout)
  const handleSkipExternalTrack = () => {
    console.log('â­ï¸ Skipping external track');

    // Clear waiting flag since we're skipping
    waitingForBrowserPlaybackRef.current = false;

    // Clear timeout and interval if exists
    if (externalTrackTimeoutRef.current) {
      clearTimeout(externalTrackTimeoutRef.current);
      externalTrackTimeoutRef.current = null;
    }
    if (externalTrackIntervalRef.current) {
      clearInterval(externalTrackIntervalRef.current);
      externalTrackIntervalRef.current = null;
    }

    setShowExternalPrompt(false);
    setPendingExternalTrack(null);
    setPendingExternalResolverId(null);

    // Show toast notification
    // (Simplified - full toast system out of scope)
    console.log('â„¹ï¸ Skipped external track');

    // Use refs to get current values (avoids stale closure when called from event handlers)
    const queue = currentQueueRef.current;
    const track = currentTrackRef.current;

    // Find next track BEFORE removing current from queue
    if (queue.length === 0) {
      console.log('Queue is empty, cannot skip');
      return;
    }

    const currentIndex = queue.findIndex(t => t.id === track?.id);
    console.log(`ðŸ” Skip: currentIndex=${currentIndex}, queueLength=${queue.length}`);
    console.log(`ðŸ” currentTrack.id="${track?.id}", title="${track?.title}"`);
    console.log(`ðŸ” Queue track IDs:`, queue.map(t => `"${t.id}"`));
    console.log(`ðŸ” Queue track titles:`, queue.map(t => t.title));

    let nextTrack;
    if (currentIndex === -1) {
      // Track not found, play first
      nextTrack = queue[0];
    } else if (currentIndex === queue.length - 1) {
      // Last track, loop to first
      nextTrack = queue[0];
    } else {
      // Play next track
      nextTrack = queue[currentIndex + 1];
    }

    // Remove current track from queue
    const newQueue = queue.filter(t => t.id !== track?.id);
    setCurrentQueue(newQueue);
    console.log(`ðŸ“‹ Removed track. New queue length: ${newQueue.length}`);

    // Play the next track directly
    if (nextTrack) {
      handlePlay(nextTrack);
    }
  };

  // User finished with external track, move to next
  const handleDoneWithExternalTrack = () => {
    console.log('âœ… User done with external track, moving to next');
    // Clear waiting flag
    waitingForBrowserPlaybackRef.current = false;
    setIsExternalPlayback(false);
    setShowExternalPrompt(false);
    setPendingExternalTrack(null);
    setPendingExternalResolverId(null);

    // Use refs to get current values (avoids stale closure when called from event handlers)
    const queue = currentQueueRef.current;
    const track = currentTrackRef.current;

    // Find next track BEFORE removing current from queue
    if (queue.length === 0) {
      console.log('Queue is empty, nothing to play');
      return;
    }

    const currentIndex = queue.findIndex(t => t.id === track?.id);
    console.log(`ðŸ” Done: currentIndex=${currentIndex}, queueLength=${queue.length}`);
    console.log(`ðŸ” currentTrack.id="${track?.id}", title="${track?.title}"`);
    console.log(`ðŸ” Queue track IDs:`, queue.map(t => `"${t.id}"`));
    console.log(`ðŸ” Queue track titles:`, queue.map(t => t.title));

    let nextTrack;
    if (currentIndex === -1) {
      // Track not found, play first
      nextTrack = queue[0];
    } else if (currentIndex === queue.length - 1) {
      // Last track, loop to first
      nextTrack = queue[0];
    } else {
      // Play next track
      nextTrack = queue[currentIndex + 1];
    }

    // Remove current track from queue
    const newQueue = queue.filter(t => t.id !== track?.id);
    setCurrentQueue(newQueue);
    console.log(`ðŸ“‹ Removed track. New queue length: ${newQueue.length}`);

    // Play the next track directly
    if (nextTrack) {
      handlePlay(nextTrack);
    }
  };

  const handlePlayPause = async () => {
    if (!currentTrack) return;

    // Check if browser extension is controlling playback
    if (browserPlaybackActive && extensionConnected) {
      console.log('ðŸŒ Sending play/pause to browser extension');
      window.electron.extension.sendCommand({
        type: 'command',
        action: isPlaying ? 'pause' : 'play'
      });
      // State will be updated when extension sends back playing/paused event
      return;
    }

    // Handle external playback window (Bandcamp embed)
    if (isExternalPlayback && window.electron?.playbackWindow?.toggle) {
      console.log('ðŸŽ¸ Toggling playback window play/pause');
      const result = await window.electron.playbackWindow.toggle();
      if (result.success) {
        if (result.state === 'playing') {
          setIsPlaying(true);
        } else if (result.state === 'paused') {
          setIsPlaying(false);
        } else {
          // For 'clicked' fallback, just toggle the state
          setIsPlaying(!isPlaying);
        }
      }
      return;
    }

    // Handle local file playback
    if (audioRef.current && currentTrack?.sources?.localfiles) {
      if (isPlaying) {
        audioRef.current.pause();
        setIsPlaying(false);
      } else {
        audioRef.current.play();
        setIsPlaying(true);
      }
      return;
    }

    const isSpotifyTrack = currentTrack.sources?.spotify || currentTrack.spotifyUri;

    if (isSpotifyTrack && spotifyToken) {
      // Control Spotify playback
      const attemptSpotifyControl = async (token, isRetry = false) => {
        try {
          if (isPlaying) {
            // Pausing - simple pause request
            const response = await fetch('https://api.spotify.com/v1/me/player/pause', {
              method: 'PUT',
              headers: {
                'Authorization': `Bearer ${token}`
              }
            });

            if (response.ok || response.status === 204) {
              setIsPlaying(false);
              console.log('Paused Spotify playback');
              return true;
            } else if (response.status === 401 && !isRetry) {
              // Token expired - try to refresh
              console.log('ðŸ”„ Spotify token expired on pause, attempting refresh...');
              const newToken = await refreshSpotifyToken();
              if (newToken) {
                return attemptSpotifyControl(newToken, true);
              }
            }
            // If we can't control Spotify, at least update UI to reflect user intent
            // This prevents the "can't pause" issue
            if (!isRetry) {
              console.log('âš ï¸ Could not pause Spotify, updating UI state anyway');
              setIsPlaying(false);
              // Stop polling since we're trying to pause
              if (playbackPollerRef.current) {
                clearInterval(playbackPollerRef.current);
                playbackPollerRef.current = null;
              }
            }
          } else {
            // Playing - check if we need to explicitly start this track
            // (e.g., restored from saved queue, Spotify may have different track loaded)
            if (trackNeedsExplicitStart.current) {
              // Use handlePlay to properly start the track with device handling
              // This ensures device discovery and wake-up logic is used
              console.log('ðŸ”„ Starting restored track via handlePlay:', currentTrack.title);
              trackNeedsExplicitStart.current = false;
              handlePlay(currentTrack);
              return true;
            } else {
              // Normal resume
              const response = await fetch('https://api.spotify.com/v1/me/player/play', {
                method: 'PUT',
                headers: {
                  'Authorization': `Bearer ${token}`
                }
              });

              if (response.ok || response.status === 204) {
                setIsPlaying(true);
                console.log('Resumed Spotify playback');
                return true;
              } else if (response.status === 401 && !isRetry) {
                // Token expired - try to refresh
                console.log('ðŸ”„ Spotify token expired on play, attempting refresh...');
                const newToken = await refreshSpotifyToken();
                if (newToken) {
                  return attemptSpotifyControl(newToken, true);
                }
              }
            }
          }
          return false;
        } catch (error) {
          console.error('Spotify play/pause error:', error);
          return false;
        }
      };

      await attemptSpotifyControl(spotifyToken);
    } else {
      // Toggle local playback
      if (!audioContext) return;
      if (isPlaying) {
        setIsPlaying(false);
        if (currentSource) {
          try { currentSource.stop(); setCurrentSource(null); } catch (e) {}
        }
      } else {
        if (audioContext.state === 'suspended') await audioContext.resume();
        setIsPlaying(true);
        playDemoAudio(currentTrack);
      }
    }
  };

  const handleNext = async (userInitiated = false) => {
    // BROWSER PLAYBACK GUARD: Block handleNext while waiting for browser to connect
    // This prevents race conditions when opening external tracks (YouTube, Bandcamp, etc.)
    if (waitingForBrowserPlaybackRef.current) {
      console.log('â³ handleNext() blocked - waiting for browser playback to connect');
      return;
    }

    // RE-ENTRANCY GUARD: Prevent multiple simultaneous handleNext() calls
    // This can happen when events fire in rapid succession (e.g., tab close + ended event)
    if (isAdvancingTrackRef.current) {
      console.log('âš ï¸ handleNext() already in progress, skipping duplicate call');
      return;
    }

    // If user manually clicked next while listening along, end the session
    let listenAlongEnded = false;
    const listenAlongFriendNow = listenAlongFriendRef.current;
    if (userInitiated && listenAlongFriendNow) {
      console.log(`ðŸŽ§ User skipped track - ending listen-along with ${listenAlongFriendNow.displayName}`);
      showToast(`Stopped listening along with ${listenAlongFriendNow.displayName}`);
      // Abort and cleanup pool context
      abortSchedulerContext('listen-along');
      setListenAlongFriend(null);
      listenAlongLastTrackRef.current = null;
      listenAlongPendingTrackRef.current = null;
      setPlaybackContext(null);
      listenAlongEnded = true;
      // Fall through to play from queue
    }
    isAdvancingTrackRef.current = true;

    try {
      // FIRST: Clean up any active polling to prevent race conditions
      // This must happen BEFORE any async operations to prevent duplicate handleNext calls
      if (playbackPollerRef.current) {
        clearInterval(playbackPollerRef.current);
        playbackPollerRef.current = null;
      }
      if (pollingRecoveryRef.current) {
        clearInterval(pollingRecoveryRef.current);
        pollingRecoveryRef.current = null;
      }

      // Notify scrobble manager that current track is ending
      if (window.scrobbleManager) {
        window.scrobbleManager.onTrackEnd();
      }

      // CRITICAL: Reset streaming playback flag when advancing tracks
      // This ensures browser extension events are not ignored when switching
      // from a streaming track (Spotify) to a browser track (YouTube/Bandcamp)
      streamingPlaybackActiveRef.current = false;

      // Stop browser extension playback if active (YouTube external browser)
      if (browserPlaybackActive && activeExtensionTabId) {
        console.log('â¹ï¸ Stopping browser playback before next track');
        window.electron.extension.sendCommand({
          type: 'command',
          action: 'pause'
        });
        // Store the tab ID to close when next track connects
        pendingCloseTabIdRef.current = activeExtensionTabId;
        setBrowserPlaybackActive(false);
        setActiveExtensionTabId(null);
      }

      // Close playback window if active (Bandcamp embedded player)
      if (window.electron?.playbackWindow?.close) {
        console.log('â¹ï¸ Closing playback window before next track');
        await window.electron.playbackWindow.close();
      }

      // Clean up external track timeouts
      if (externalTrackTimeoutRef.current) {
        clearTimeout(externalTrackTimeoutRef.current);
        externalTrackTimeoutRef.current = null;
      }
      if (externalTrackIntervalRef.current) {
        clearInterval(externalTrackIntervalRef.current);
        externalTrackIntervalRef.current = null;
      }
      setIsExternalPlayback(false);
      setShowExternalPrompt(false);
      setPendingExternalTrack(null);
      setPendingExternalResolverId(null);

      // LISTEN-ALONG MODE: Handle track progression when listening along with a friend
      // Skip this block if we already ended listen-along above (user clicked next)
      if (listenAlongFriendNow && !listenAlongEnded) {
        // Check if there's a pending track queued (friend moved ahead while we were still playing)
        const pendingTrack = listenAlongPendingTrackRef.current;
        if (pendingTrack) {
          console.log(`ðŸŽ§ Listen-along: Playing pending track "${pendingTrack.title}"`);
          listenAlongPendingTrackRef.current = null;
          listenAlongLastTrackRef.current = {
            name: pendingTrack.title,
            artist: pendingTrack.artist
          };
          handlePlay(pendingTrack);
          return;
        }

        // Check if friend's current track is the same as what we just finished
        // If so, they haven't moved on yet - end listen-along and go to queue
        const friendTrack = listenAlongFriendNow.cachedRecentTrack;
        const lastTrack = listenAlongLastTrackRef.current;
        const friendStillOnSameTrack = friendTrack && lastTrack &&
          friendTrack.name === lastTrack.name &&
          friendTrack.artist === lastTrack.artist;

        if (friendStillOnSameTrack) {
          console.log(`ðŸŽ§ Listen-along: Song ended but ${listenAlongFriendNow.displayName} hasn't moved on - ending listen-along`);
          showToast(`${listenAlongFriendNow.displayName} hasn't moved on - resuming your queue`);
          // Abort and cleanup pool context
          abortSchedulerContext('listen-along');
          setListenAlongFriend(null);
          listenAlongLastTrackRef.current = null;
          listenAlongPendingTrackRef.current = null;
          setPlaybackContext(null);
          // Fall through to play from queue below
        } else {
          // Friend has a different track, but we don't have it queued yet
          // Wait for polling to detect the change
          console.log(`ðŸŽ§ Listen-along active with ${listenAlongFriendNow.displayName} - waiting for their next track`);
          setIsPlaying(false);
          return;
        }
      }

      // Always use our local queue for navigation
      // (Spotify doesn't know about our queue - tracks may resolve to different services)
      // Use refs to get current values (avoids stale closure when called from event handlers)
      const queue = currentQueueRef.current;
      const track = currentTrackRef.current;

      // Check if we're in spinoff mode - play from spinoff pool instead of queue
      // Use refs to avoid stale closure issues
      if (spinoffModeRef.current && spinoffTracksRef.current.length > 0) {
        const nextSimilar = spinoffTracksRef.current.shift();
        console.log(`ðŸ”€ Spinoff: playing next similar track "${nextSimilar.title}"`);

        // Update pool visibility for resolution - next 5 tracks
        // Use track ID as key to avoid re-resolution when tracks shift
        const poolTracks = spinoffTracksRef.current.slice(0, 5).map((t) => ({
          key: t.id || `${t.artist}-${t.title}`,
          data: { track: t, artistName: t.artist || 'Unknown Artist' }
        }));
        updateSchedulerVisibility('spinoff', poolTracks);
        setSchedulerPlaybackIndex('spinoff', 0);

        handlePlay({
          ...nextSimilar,
          sources: nextSimilar.sources || {}, // Ensure sources object exists for on-demand resolution
          _playbackContext: {
            type: 'spinoff',
            sourceTrack: spinoffSourceTrackRef.current
          }
        });
        return;
      }

      // If spinoff mode but no tracks left, exit spinoff and continue with queue
      if (spinoffModeRef.current && spinoffTracksRef.current.length === 0) {
        console.log('ðŸ”€ Spinoff pool exhausted, returning to queue');
        exitSpinoff();
      }

      if (queue.length === 0) {
        console.log('No queue set, cannot go to next track');
        return;
      }

      console.log(`ðŸ” Queue navigation: currentTrack.id="${track?.id}", queueLength=${queue.length}`);

      // Queue represents upcoming tracks - current track is NOT in the queue
      // Find the first playable track in the queue
      const nextTrackIndex = queue.findIndex(t => t.status !== 'error');

      if (nextTrackIndex === -1) {
        console.log('âš ï¸ No playable tracks in queue');
        return;
      }

      const nextTrack = queue[nextTrackIndex];

      // Push current track to history before moving to next (for "previous" navigation)
      if (track) {
        playHistoryRef.current = [...playHistoryRef.current, track];
        console.log(`ðŸ“š Added "${track.title}" to play history (${playHistoryRef.current.length} tracks)`);
      }

      // Remove the track we're about to play from the queue
      const newQueue = queue.filter((_, index) => index !== nextTrackIndex);
      setCurrentQueue(newQueue);

      // Update playback context if the next track has a different context
      console.log(`ðŸŽ¯ Next track context:`, nextTrack._playbackContext);
      if (nextTrack._playbackContext) {
        setPlaybackContext(nextTrack._playbackContext);
        console.log(`ðŸŽ¯ Updated playback context to:`, nextTrack._playbackContext.type);
      }

      console.log(`âž¡ï¸ Playing next track: "${nextTrack.title}", remaining queue: ${newQueue.length}`);
      handlePlay(nextTrack);
    } finally {
      // Reset re-entrancy guard after a delay to allow state updates and async operations to complete
      // This prevents re-entry from race conditions (e.g., in-flight Spotify polls, browser events)
      setTimeout(() => {
        isAdvancingTrackRef.current = false;
      }, 500);
    }
  };

  // Keep handleNextRef in sync so event handlers always call the latest version
  useEffect(() => { handleNextRef.current = handleNext; });

  const handlePrevious = async () => {
    // Use refs to get current values (avoids stale closure when called from event handlers)
    const track = currentTrackRef.current;

    if (!track) return;

    // If user clicked previous while listening along, end the session
    const listenAlongFriendNow = listenAlongFriendRef.current;
    if (listenAlongFriendNow) {
      console.log(`ðŸŽ§ User went back - ending listen-along with ${listenAlongFriendNow.displayName}`);
      showToast(`Stopped listening along with ${listenAlongFriendNow.displayName}`);
      // Abort and cleanup pool context
      abortSchedulerContext('listen-along');
      setListenAlongFriend(null);
      listenAlongLastTrackRef.current = null;
      listenAlongPendingTrackRef.current = null;
      setPlaybackContext(null);
    }

    // Notify scrobble manager that current track is ending
    if (window.scrobbleManager) {
      window.scrobbleManager.onTrackEnd();
    }

    // CRITICAL: Reset streaming playback flag when changing tracks
    streamingPlaybackActiveRef.current = false;

    // Stop browser playback if active
    if (browserPlaybackActive && activeExtensionTabId) {
      console.log('â¹ï¸ Stopping browser playback before restarting track');
      window.electron.extension.sendCommand({
        type: 'command',
        action: 'pause'
      });
      pendingCloseTabIdRef.current = activeExtensionTabId;
      setBrowserPlaybackActive(false);
      setActiveExtensionTabId(null);
    }

    // Close playback window if active (for Bandcamp, etc.)
    if (window.electron?.playbackWindow?.close) {
      console.log('â¹ï¸ Closing playback window before restarting track');
      await window.electron.playbackWindow.close();
    }

    // Clean up any active polling or timeouts
    if (playbackPollerRef.current) {
      clearInterval(playbackPollerRef.current);
      playbackPollerRef.current = null;
    }
    if (pollingRecoveryRef.current) {
      clearInterval(pollingRecoveryRef.current);
      pollingRecoveryRef.current = null;
    }
    if (externalTrackTimeoutRef.current) {
      clearTimeout(externalTrackTimeoutRef.current);
      externalTrackTimeoutRef.current = null;
    }
    if (externalTrackIntervalRef.current) {
      clearInterval(externalTrackIntervalRef.current);
      externalTrackIntervalRef.current = null;
    }
    setIsExternalPlayback(false);
    setShowExternalPrompt(false);
    setPendingExternalTrack(null);
    setPendingExternalResolverId(null);

    // Check if we have history to go back to
    const history = playHistoryRef.current;
    if (history.length > 0) {
      // Pop the previous track from history
      const previousTrack = history[history.length - 1];
      playHistoryRef.current = history.slice(0, -1);

      // Put current track at the front of the queue so it plays next after the previous track
      // This maintains proper playback order: previous -> current -> rest of queue
      if (track) {
        // Check if track is already in queue before inserting
        const queue = currentQueueRef.current;
        const isDuplicate = queue.some(t =>
          t.title === track.title && t.artist === track.artist
        );

        if (isDuplicate) {
          console.log(`â­ï¸ Track "${track.title}" already in queue, skipping duplicate`);
        } else {
          setCurrentQueue(prev => [track, ...prev]);
          console.log(`ðŸ“¥ Returned "${track.title}" to front of queue`);
          // Trigger insert animation
          setInsertedTrackId(track.id);
          setTimeout(() => setInsertedTrackId(null), 1000); // Clear after animation
        }
      }

      console.log(`â¬…ï¸ Going back to previous track: "${previousTrack.title}" (${playHistoryRef.current.length} tracks remaining in history)`);
      handlePlay(previousTrack);
    } else {
      // No history - restart current track
      console.log(`â¬…ï¸ No history, restarting current track: "${track.title}"`);
      handlePlay(track);
    }
  };

  // Queue management functions
  const removeFromQueue = (trackId) => {
    setCurrentQueue(prev => prev.filter(t => t.id !== trackId));
    // Also remove from original queue if shuffle is active
    if (shuffleMode && originalQueueRef.current) {
      originalQueueRef.current = originalQueueRef.current.filter(t => t.id !== trackId);
    }
    console.log(`ðŸ—‘ï¸ Removed track ${trackId} from queue`);
  };

  const moveInQueue = (fromIndex, toIndex) => {
    if (fromIndex === toIndex) return;
    setCurrentQueue(prev => {
      const newQueue = [...prev];
      const [removed] = newQueue.splice(fromIndex, 1);
      newQueue.splice(toIndex, 0, removed);
      console.log(`ðŸ”€ Moved track from index ${fromIndex} to ${toIndex}`);
      return newQueue;
    });
  };

  const moveInPlaylist = (fromIndex, toIndex) => {
    if (fromIndex === toIndex) return;

    // Update displayed tracks
    setPlaylistTracks(prev => {
      const newTracks = [...prev];
      const [removed] = newTracks.splice(fromIndex, 1);
      newTracks.splice(toIndex, 0, removed);
      console.log(`ðŸ”€ Moved playlist track from index ${fromIndex} to ${toIndex}`);
      return newTracks;
    });

    // Update lastModified on the selected playlist and save to disk
    if (selectedPlaylist) {
      setSelectedPlaylist(prev => ({ ...prev, lastModified: Date.now() }));
      setPlaylists(prev => prev.map(p => {
        if (p.id === selectedPlaylist.id) {
          // Reorder tracks in the playlist data
          const newTracks = [...(p.tracks || [])];
          const [removed] = newTracks.splice(fromIndex, 1);
          newTracks.splice(toIndex, 0, removed);
          const updatedPlaylist = {
            ...p,
            tracks: newTracks,
            lastModified: Date.now()
          };
          // Save to disk
          savePlaylistToStore(updatedPlaylist);
          return updatedPlaylist;
        }
        return p;
      }));
      // Mark synced playlist as locally modified
      markPlaylistAsLocallyModified(selectedPlaylist.id);
    }
  };

  // Move track in buffered edit data (for edit mode)
  const moveInEditedPlaylist = (fromIndex, toIndex) => {
    if (fromIndex === toIndex) return;
    setEditedPlaylistData(prev => {
      if (!prev) return prev;
      const newTracks = [...prev.tracks];
      const [removed] = newTracks.splice(fromIndex, 1);
      newTracks.splice(toIndex, 0, removed);
      console.log(`ðŸ”€ Moved track in edit buffer from index ${fromIndex} to ${toIndex}`);
      return { ...prev, tracks: newTracks };
    });
  };

  // Mark a synced playlist as locally modified (for sync disconnect handling)
  // Only affects playlists with syncedFrom - local playlists are unaffected
  const markPlaylistAsLocallyModified = (playlistId) => {
    setPlaylists(prev => prev.map(p =>
      p.id === playlistId && p.syncedFrom
        ? { ...p, locallyModified: true, lastModified: Date.now() }
        : p
    ));
  };

  const clearQueue = () => {
    setCurrentQueue([]);
    // Reset shuffle state when queue is cleared
    setShuffleMode(false);
    originalQueueRef.current = null;
    // Preserve playback context if in spinoff or listen-along mode
    // Only clear context for regular queue scenarios
    if (playbackContext?.type !== 'spinoff' && playbackContext?.type !== 'listenAlong') {
      setPlaybackContext(null);
    }
    console.log('ðŸ—‘ï¸ Cleared queue');
  };

  // Toggle shuffle mode - shuffles queue in place, stores original for restore
  const toggleShuffle = () => {
    if (shuffleMode) {
      // Turn off shuffle - restore original order if available
      if (originalQueueRef.current) {
        // Filter to only include tracks that still exist in current queue
        const currentIds = new Set(currentQueue.map(t => t.id));
        const restoredQueue = originalQueueRef.current.filter(t => currentIds.has(t.id));
        setCurrentQueue(restoredQueue);
        console.log('ðŸ”€ Shuffle OFF - restored original order');
      }
      originalQueueRef.current = null;
      setShuffleMode(false);
    } else {
      // Turn on shuffle - store original and shuffle
      if (currentQueue.length > 1) {
        originalQueueRef.current = [...currentQueue];
        // Fisher-Yates shuffle
        const shuffled = [...currentQueue];
        for (let i = shuffled.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        setCurrentQueue(shuffled);
        console.log('ðŸ”€ Shuffle ON - queue randomized');
      }
      setShuffleMode(true);
    }
  };

  // Restore original queue order (used from queue header button)
  const restoreOriginalOrder = () => {
    if (originalQueueRef.current && shuffleMode) {
      const currentIds = new Set(currentQueue.map(t => t.id));
      const restoredQueue = originalQueueRef.current.filter(t => currentIds.has(t.id));
      setCurrentQueue(restoredQueue);
      setShuffleMode(false);
      originalQueueRef.current = null;
      console.log('ðŸ”€ Restored original queue order');
    }
  };

  // Start Collection Station - shuffle and play all collection tracks
  const handleStartCollectionStation = () => {
    // Merge local files with collection tracks
    const allTracks = [...library, ...collectionData.tracks];

    if (allTracks.length === 0) {
      showToast('No tracks in your collection yet');
      return;
    }

    // Deduplicate by id
    const trackMap = new Map();
    allTracks.forEach(track => {
      const trackId = track.id || `${track.artist || 'unknown'}-${track.title || 'untitled'}-${track.album || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
      if (!trackMap.has(trackId)) {
        trackMap.set(trackId, { ...track, id: trackId });
      }
    });
    const uniqueTracks = Array.from(trackMap.values());

    // Fisher-Yates shuffle
    const shuffled = [...uniqueTracks];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }

    // Set up playback context
    const context = { type: 'library', name: 'Collection Station' };

    // Play first track, queue the rest
    const firstTrack = shuffled[0];
    const remainingTracks = shuffled.slice(1);

    // Store original order for unshuffle and enable shuffle mode
    originalQueueRef.current = remainingTracks;
    setShuffleMode(true);

    // Set queue and play
    setQueueWithContext(remainingTracks, context);
    setPlaybackContext(context);
    handlePlay(firstTrack);

    showToast(`Playing ${uniqueTracks.length} tracks on shuffle`);
    console.log(`ðŸ“» Started Collection Station with ${uniqueTracks.length} tracks`);
  };

  // Helper to set queue with playback context tagged on each track
  // This allows the context to update when tracks from different sources come up
  const setQueueWithContext = (tracks, context) => {
    const taggedTracks = tracks.map(track => ({
      ...track,
      _playbackContext: context
    }));
    console.log(`ðŸ·ï¸ Tagged ${taggedTracks.length} tracks with context:`, context.type);
    setCurrentQueue(taggedTracks);
    setPlaybackContext(context);
  };

  // Helper to add tracks to existing queue with context
  const addToQueueWithContext = (tracks, context) => {
    const taggedTracks = tracks.map(track => ({
      ...track,
      _playbackContext: context
    }));
    setCurrentQueue(prev => [...prev, ...taggedTracks]);
  };

  // Open save dialog for queue as playlist
  const handleSaveQueueAsPlaylist = () => {
    // Build track list: currently playing + queue
    const tracksToSave = currentTrack ? [currentTrack, ...currentQueue] : currentQueue;
    if (tracksToSave.length === 0) return;

    // Generate default name based on first track artist
    const firstTrack = tracksToSave[0];
    const defaultName = firstTrack?.artist
      ? `${firstTrack.artist} Mix`
      : 'My Queue';

    setQueueSavePlaylistName(defaultName);
    setQueueSaveDialogOpen(true);
  };

  // Actually save the queue as a playlist
  const handleSaveQueueConfirm = async () => {
    const tracksToSave = currentTrack ? [currentTrack, ...currentQueue] : currentQueue;
    if (tracksToSave.length === 0 || !queueSavePlaylistName.trim()) return;

    const playlistId = `queue-${Date.now()}`;

    const newPlaylist = {
      id: playlistId,
      title: queueSavePlaylistName.trim(),
      creator: 'Queue',
      tracks: tracksToSave,
      createdAt: Date.now(),
      addedAt: Date.now(),
      lastModified: Date.now()
    };

    // Add to playlists state (prepend so it appears at top immediately)
    setPlaylists(prev => [newPlaylist, ...prev]);

    // Save to unified local storage (electron-store)
    await savePlaylistToStore(newPlaylist);

    // Close dialog
    setQueueSaveDialogOpen(false);
    showToast(`Saved playlist: ${queueSavePlaylistName.trim()}`);
  };

  // Fetch listening context from Last.fm or ListenBrainz for AI prompt enrichment
  const fetchListeningContext = async () => {
    const lastfmConfig = metaServiceConfigs.lastfm;
    const listenbrainzConfig = metaServiceConfigs.listenbrainz;

    // Try Last.fm first
    if (lastfmConfig?.username) {
      const apiKey = lastfmApiKey.current;
      if (apiKey) {
        try {
          console.log('ðŸŽµ Fetching listening context from Last.fm...');

          // Fetch top artists (10) and top tracks (25) in parallel
          const [artistsRes, tracksRes] = await Promise.all([
            fetch(`https://ws.audioscrobbler.com/2.0/?method=user.gettopartists&user=${encodeURIComponent(lastfmConfig.username)}&api_key=${apiKey}&format=json&period=3month&limit=10`),
            fetch(`https://ws.audioscrobbler.com/2.0/?method=user.gettoptracks&user=${encodeURIComponent(lastfmConfig.username)}&api_key=${apiKey}&format=json&period=3month&limit=25`)
          ]);

          if (artistsRes.ok && tracksRes.ok) {
            const [artistsData, tracksData] = await Promise.all([artistsRes.json(), tracksRes.json()]);

            const topArtists = (artistsData.topartists?.artist || []).map(a => a.name);
            const topTracks = (tracksData.toptracks?.track || []).map(t => ({
              artist: t.artist?.name || 'Unknown',
              title: t.name
            }));

            console.log(`ðŸŽµ Got ${topArtists.length} artists and ${topTracks.length} tracks from Last.fm`);

            return {
              source: 'Last.fm',
              window: 'last_3_months',
              top_artists: topArtists,
              top_tracks: topTracks
            };
          }
        } catch (err) {
          console.error('Failed to fetch Last.fm context:', err);
        }
      }
    }

    // Fall back to ListenBrainz
    if (listenbrainzConfig?.username) {
      try {
        console.log('ðŸŽµ Fetching listening context from ListenBrainz...');

        // Fetch top artists (10) and top tracks (25) in parallel
        const [artistsRes, tracksRes] = await Promise.all([
          fetch(`https://api.listenbrainz.org/1/stats/user/${encodeURIComponent(listenbrainzConfig.username)}/artists?range=quarter&count=10`),
          fetch(`https://api.listenbrainz.org/1/stats/user/${encodeURIComponent(listenbrainzConfig.username)}/recordings?range=quarter&count=25`)
        ]);

        // Handle 204 No Content
        if (artistsRes.status === 204 || tracksRes.status === 204) {
          console.log('ðŸŽµ No ListenBrainz stats available for this period');
          return null;
        }

        if (artistsRes.ok && tracksRes.ok) {
          const [artistsData, tracksData] = await Promise.all([artistsRes.json(), tracksRes.json()]);

          const topArtists = (artistsData.payload?.artists || []).map(a => a.artist_name);
          const topTracks = (tracksData.payload?.recordings || []).map(t => ({
            artist: t.artist_name || 'Unknown',
            title: t.track_name
          }));

          console.log(`ðŸŽµ Got ${topArtists.length} artists and ${topTracks.length} tracks from ListenBrainz`);

          return {
            source: 'ListenBrainz',
            window: 'last_3_months',
            top_artists: topArtists,
            top_tracks: topTracks
          };
        }
      } catch (err) {
        console.error('Failed to fetch ListenBrainz context:', err);
      }
    }

    return null;
  };

  // AI Playlist Generation
  const handleAiGenerate = async (prompt) => {
    const aiServices = getAiServices();
    // Filter to only enabled services with API keys
    const enabledServices = aiServices.filter(s => {
      const config = metaServiceConfigs[s.id] || {};
      return config.enabled && config.apiKey;
    });

    if (enabledServices.length === 0) {
      setAiError('No AI plugins configured. Enable OpenAI or Gemini and add your API key in Settings â†’ General.');
      return;
    }

    // Use selected service or first available
    const service = selectedAiResolver
      ? enabledServices.find(s => s.id === selectedAiResolver) || enabledServices[0]
      : enabledServices[0];

    setAiLoading(true);
    setAiError(null);

    // Open sidebar immediately with loading state
    setResultsSidebar({
      title: 'âœ¨ AI Playlist',
      subtitle: `"${prompt.length > 50 ? prompt.substring(0, 50) + '...' : prompt}"`,
      tracks: [],
      source: 'ai',
      prompt: prompt,
      provider: { id: service.id, name: service.name },
      loading: true
    });

    // Close prompt input immediately
    setAiPromptOpen(false);
    setAiPrompt('');

    try {
      // Get service config from metaServiceConfigs
      const config = metaServiceConfigs[service.id] || {};

      // Fetch listening context if toggle is enabled
      let listeningContext = null;
      if (aiIncludeHistory) {
        listeningContext = await fetchListeningContext();
        if (!listeningContext) {
          console.log('ðŸŽµ No listening context available, proceeding without');
        }
      }

      // Call the service's generate function
      const tracks = await service.generate(prompt, config, listeningContext);

      if (!tracks || tracks.length === 0) {
        throw new Error('No tracks returned. Try a different prompt.');
      }

      // Update sidebar with the generated tracks
      setResultsSidebar({
        title: 'âœ¨ AI Playlist',
        subtitle: `"${prompt.length > 50 ? prompt.substring(0, 50) + '...' : prompt}"`,
        tracks: tracks.map((t, i) => ({
          id: `ai-${Date.now()}-${i}`,
          title: t.title,
          artist: t.artist,
          album: t.album || '',
          sources: {} // Will be resolved when added to queue
        })),
        source: 'ai',
        prompt: prompt,
        provider: { id: service.id, name: service.name },
        loading: false
      });
    } catch (error) {
      console.error('AI generation error:', error);
      setAiError(error.message || 'Failed to generate playlist');
      // Close sidebar on error, reopen prompt
      setResultsSidebar(null);
      setAiPromptOpen(true);
    } finally {
      setAiLoading(false);
    }
  };

  // Handle adding AI results to queue
  const handleAiAddToQueue = () => {
    if (!resultsSidebar?.tracks) return;
    // Use aiPlaylist context type (not navigable, unlike recommendations page)
    const context = { type: 'aiPlaylist', name: 'AI Playlist' };
    addToQueue(resultsSidebar.tracks, context);
    setResultsSidebar(null);
    showToast(`Added ${resultsSidebar.tracks.length} tracks to queue`);
  };
  const addToQueue = (tracks, context = null) => {
    const tracksArray = Array.isArray(tracks) ? tracks : [tracks];

    // Tag tracks with context if provided
    const taggedTracks = context
      ? tracksArray.map(track => ({ ...track, _playbackContext: context }))
      : tracksArray;

    // Check if nothing is currently playing BEFORE updating queue
    const nothingPlaying = !currentTrackRef.current;

    // If shuffle mode is active, update the original queue ref (or initialize it)
    if (shuffleMode) {
      if (originalQueueRef.current) {
        originalQueueRef.current = [...originalQueueRef.current, ...taggedTracks];
      } else {
        // Initialize original queue if shuffle was enabled before any tracks were added
        originalQueueRef.current = [...currentQueue, ...taggedTracks];
      }
    }

    // Append to queue (shuffle mode inserts at random positions)
    if (shuffleMode) {
      if (currentQueue.length > 0) {
        // Insert new tracks at random positions in existing queue
        setCurrentQueue(prev => {
          const newQueue = [...prev];
          taggedTracks.forEach(track => {
            const randomIndex = Math.floor(Math.random() * (newQueue.length + 1));
            newQueue.splice(randomIndex, 0, track);
          });
          return newQueue;
        });
      } else if (taggedTracks.length > 1) {
        // Shuffle the new tracks before adding to empty queue
        const shuffled = [...taggedTracks];
        for (let i = shuffled.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        setCurrentQueue(prev => [...prev, ...shuffled]);
      } else {
        // Single track, just append
        setCurrentQueue(prev => [...prev, ...taggedTracks]);
      }
    } else {
      // Normal append to end
      setCurrentQueue(prev => [...prev, ...taggedTracks]);
    }
    // Trigger queue animation
    setQueueAnimating(true);
    setTimeout(() => setQueueAnimating(false), 600);
    console.log(`âž• Added ${tracksArray.length} track(s) to queue${shuffleMode ? ' (shuffled)' : ''}`);

    // Queue track resolution is now handled by ResolutionScheduler via queue context visibility

    // If nothing is playing, auto-start the first track
    if (nothingPlaying && taggedTracks.length > 0) {
      const firstTrack = taggedTracks[0];
      console.log(`â–¶ï¸ Auto-starting playback: "${firstTrack.title}" by ${firstTrack.artist}`);
      // Remove from queue and play
      setCurrentQueue(prev => prev.slice(1));
      handlePlay(firstTrack);
    }
  };

  const handleSearchInput = (value) => {
    setSearchQuery(value);
    searchQueryRef.current = value;

    // Clear existing timeout
    if (searchTimeoutRef.current) {
      clearTimeout(searchTimeoutRef.current);
    }

    // Clear results if search cleared
    if (!value) {
      setSearchResults({ artists: [], albums: [], tracks: [], playlists: [] });
      setIsSearching(false);
      setDisplayLimits({ artists: 5, albums: 5, tracks: 8, playlists: 5 });
      return;
    }

    // Show loading state for responsive feel
    if (value.length >= 2) {
      setIsSearching(true);
    }

    // Reset pagination on new search
    setDisplayLimits({ artists: 5, albums: 5, tracks: 8, playlists: 5 });

    // Debounce search by 400ms
    searchTimeoutRef.current = setTimeout(() => {
      if (value.length >= 2) {
        performSearch(value);
      }
    }, 400);
  };

  // Load search history from electron-store
  const loadSearchHistory = async () => {
    try {
      const history = await window.electron.invoke('search-history-load');
      setSearchHistory(history || []);
    } catch (error) {
      console.error('Failed to load search history:', error);
    }
  };

  // Save a search history entry when user clicks a result
  const saveSearchHistory = async (query, selectedResult) => {
    if (!query || query.trim().length < 2) return;

    const entry = {
      query: query.trim(),
      selectedResult: selectedResult ? {
        type: selectedResult.type,
        id: selectedResult.id,
        name: selectedResult.name || selectedResult.title,
        artist: selectedResult.artist,
        imageUrl: selectedResult.imageUrl || selectedResult.albumArt
      } : null
    };

    try {
      await window.electron.invoke('search-history-save', entry);
      // Reload history to reflect update
      loadSearchHistory();
    } catch (error) {
      console.error('Failed to save search history:', error);
    }
  };

  // Clear search history (single entry or all)
  const clearSearchHistory = async (entryQuery = null) => {
    try {
      await window.electron.invoke('search-history-clear', entryQuery);
      loadSearchHistory();
    } catch (error) {
      console.error('Failed to clear search history:', error);
    }
  };

  // Load more results for a specific category
  const handleLoadMore = (category) => {
    setDisplayLimits(prev => ({
      ...prev,
      [category]: prev[category] + (category === 'tracks' ? 8 : 5)
    }));
  };

  // Re-rank search results using fuzzy matching + MusicBrainz popularity score
  const reRankResults = (items, query, nameKey = 'name') => {
    if (!items || items.length === 0 || !query) return items;

    // Configure Fuse.js for fuzzy matching
    const fuse = new Fuse(items, {
      keys: [nameKey],
      includeScore: true,
      threshold: 0.6,
      ignoreLocation: true,
      useExtendedSearch: false
    });

    const fuzzyResults = fuse.search(query);

    // Create a map of fuzzy scores (Fuse score is 0-1 where 0 is perfect match)
    const fuzzyScoreMap = new Map();
    fuzzyResults.forEach(result => {
      // Convert Fuse score (0=best, 1=worst) to 0-100 (100=best)
      fuzzyScoreMap.set(result.item, (1 - result.score) * 100);
    });

    // Score and sort all items
    return items
      .map(item => {
        const fuzzyScore = fuzzyScoreMap.get(item) || 0;
        const mbScore = item.score || 50; // MusicBrainz popularity score (0-100)
        // Blend: 60% fuzzy relevance, 40% popularity
        const finalScore = (fuzzyScore * 0.6) + (mbScore * 0.4);
        return { ...item, _finalScore: finalScore };
      })
      .sort((a, b) => b._finalScore - a._finalScore);
  };

  const resolveRecording = async (recording) => {
    const track = {
      id: recording.id,
      title: recording.title,
      artist: recording['artist-credit']?.[0]?.name || 'Unknown',
      duration: Math.floor((recording.length || 180000) / 1000), // Convert ms to seconds
      album: recording.releases?.[0]?.title || '',
      releaseId: recording.releases?.[0]?.id || null, // Store release ID for album art
      length: recording.length, // Keep original length in ms for confidence calculation
      sources: {}
    };

    console.log(`ðŸ” Resolving recording: ${track.artist} - ${track.title}`);

    // Query all enabled resolvers in priority order
    const enabledResolvers = resolverOrder
      .filter(id => activeResolvers.includes(id))
      .map(id => allResolvers.find(r => r.id === id))
      .filter(Boolean);

    // Parallel resolution with confidence scoring
    const resolverPromises = enabledResolvers.map(async (resolver) => {
      // Skip resolvers that can't resolve or can't play (no point resolving if we can't play)
      if (!resolver.capabilities.resolve || !resolver.play) return;

      try {
        const config = await getResolverConfig(resolver.id);
        const result = await resolver.resolve(track.artist, track.title, track.album, config);

        if (result) {
          track.sources[resolver.id] = {
            ...result,
            confidence: calculateConfidence(track, result)
          };
          console.log(`  âœ… ${resolver.name}: Found match (confidence: ${(track.sources[resolver.id].confidence * 100).toFixed(0)}%)`);
        }
      } catch (error) {
        console.error(`  âŒ ${resolver.name} resolve error:`, error);
      }
    });

    // Wait for all resolvers to complete
    await Promise.all(resolverPromises);

    if (Object.keys(track.sources).length > 0) {
      console.log(`âœ… Found ${Object.keys(track.sources).length} source(s) for: ${track.title}`);
    }

    return track;
  };

  // ResizeObserver to track search results container width for responsive item count
  useEffect(() => {
    const container = searchResultsContainerRef.current;
    if (!container) return;

    const resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        setSearchContainerWidth(entry.contentRect.width);
      }
    });

    resizeObserver.observe(container);
    // Set initial width
    setSearchContainerWidth(container.offsetWidth);

    return () => resizeObserver.disconnect();
  }, [activeView]); // Re-attach when view changes

  // Calculate how many items fit in a row based on container width and item size
  const getItemsPerRow = (minItemWidth, gap = 16) => {
    const availableWidth = searchContainerWidth;
    // Calculate how many items fit: (width + gap) * n - gap <= availableWidth
    // n <= (availableWidth + gap) / (minItemWidth + gap)
    return Math.max(1, Math.floor((availableWidth + gap) / (minItemWidth + gap)));
  };

  // Preprocess search query for MusicBrainz Lucene syntax
  // Maps user-friendly filters to MusicBrainz field names
  const preprocessQuery = (query, endpoint) => {
    let processed = query;

    // Map album: to appropriate field based on endpoint
    if (endpoint === 'release-group') {
      processed = processed.replace(/\balbum:/gi, 'releasegroup:');
    } else if (endpoint === 'recording') {
      processed = processed.replace(/\balbum:/gi, 'release:');
    } else if (endpoint === 'artist') {
      // For artist endpoint, album: doesn't make sense - strip it
      // Pattern handles both quoted values (album:"dark side") and unquoted (album:thriller)
      processed = processed.replace(/\balbum:(?:"[^"]*"|[^\s]*)/gi, '').trim();
    }

    // Map track:/song: to recording: (only for recording endpoint)
    if (endpoint === 'recording') {
      processed = processed.replace(/\b(track|song):/gi, 'recording:');
    } else {
      // Strip track:/song: from non-recording endpoints
      // Pattern handles both quoted values (track:"let it be") and unquoted (track:yesterday)
      processed = processed.replace(/\b(track|song):(?:"[^"]*"|[^\s]*)/gi, '').trim();
    }

    // Clean up any double spaces from removals
    processed = processed.replace(/\s+/g, ' ').trim();

    return processed;
  };

  const performSearch = async (query) => {
    // Cancel any in-flight request
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    abortControllerRef.current = new AbortController();
    const signal = abortControllerRef.current.signal;

    setIsSearching(true);
    const results = {
      artists: [],
      albums: [],
      tracks: [],
      playlists: []
    };

    try {
      const fetchOptions = {
        headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' },
        signal
      };

      // Search MusicBrainz for artists (fetch more than we initially display)
      const artistQuery = preprocessQuery(query, 'artist');
      const artistResponse = await fetch(
        `https://musicbrainz.org/ws/2/artist?query=${encodeURIComponent(artistQuery)}&fmt=json&limit=25`,
        fetchOptions
      );
      if (artistResponse.ok) {
        const data = await artistResponse.json();
        const rawArtists = data.artists || [];

        // Deduplicate artists by name (case-insensitive)
        const seenArtists = new Set();
        results.artists = rawArtists.filter(artist => {
          const name = artist.name?.toLowerCase() || '';
          if (seenArtists.has(name)) return false;
          seenArtists.add(name);
          return true;
        });

        // Re-rank artists with fuzzy matching + popularity
        results.artists = reRankResults(results.artists, query, 'name');
      }

      // Check if query is still current before continuing
      if (query !== searchQueryRef.current) return;

      // Search MusicBrainz for albums (release-groups)
      const albumQuery = preprocessQuery(query, 'release-group');
      const albumResponse = await fetch(
        `https://musicbrainz.org/ws/2/release-group?query=${encodeURIComponent(albumQuery)}&fmt=json&limit=30`,
        fetchOptions
      );
      if (albumResponse.ok) {
        const data = await albumResponse.json();
        const rawAlbums = data['release-groups'] || [];

        // Deduplicate albums by artist + title (case-insensitive)
        const seen = new Set();
        results.albums = rawAlbums.filter(album => {
          const artist = album['artist-credit']?.[0]?.name?.toLowerCase() || '';
          const title = album.title?.toLowerCase() || '';
          const key = `${artist}|${title}`;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        });

        // Re-rank albums with fuzzy matching + popularity
        results.albums = reRankResults(results.albums, query, 'title');
      }

      // Check if query is still current before continuing
      if (query !== searchQueryRef.current) return;

      // Search MusicBrainz for tracks (recordings)
      const trackQuery = preprocessQuery(query, 'recording');
      const trackResponse = await fetch(
        `https://musicbrainz.org/ws/2/recording?query=${encodeURIComponent(trackQuery)}&fmt=json&limit=50`,
        fetchOptions
      );
      if (trackResponse.ok) {
        const data = await trackResponse.json();
        const recordings = data.recordings || [];

        // Only resolve the first batch of tracks for performance
        // Rest will be resolved on-demand when "Load more" is clicked or when played
        const initialBatchSize = 8;
        const trackPromises = recordings.slice(0, initialBatchSize).map(recording => resolveRecording(recording));
        const resolvedTracks = await Promise.all(trackPromises);

        // Check if query is still current after track resolution
        if (query !== searchQueryRef.current) return;

        // Store unresolved tracks without sources (will resolve on-demand)
        const unresolvedTracks = recordings.slice(initialBatchSize).map(recording => ({
          id: recording.id,
          title: recording.title,
          artist: recording['artist-credit']?.[0]?.name || 'Unknown',
          duration: Math.floor((recording.length || 180000) / 1000),
          album: recording.releases?.[0]?.title || '',
          releaseId: recording.releases?.[0]?.id || null,
          length: recording.length,
          sources: {}
        }));

        results.tracks = [...resolvedTracks, ...unresolvedTracks];

        // Re-rank tracks with fuzzy matching + popularity
        results.tracks = reRankResults(results.tracks, query, 'title');
      }

      // Search local playlists
      results.playlists = playlists.filter(p =>
        p.title.toLowerCase().includes(query.toLowerCase())
      );

      // Final check: only update results if query is still current
      if (query !== searchQueryRef.current) return;

      setSearchResults(results);
      console.log('ðŸ” Search results:', results);

      // Fetch album art lazily in background (don't block search results)
      fetchSearchAlbumArt(results.albums, results.tracks);
    } catch (error) {
      // Ignore abort errors - these are expected when cancelling stale requests
      if (error.name === 'AbortError') {
        console.log('ðŸ” Search request cancelled (newer query in progress)');
        return;
      }
      console.error('Search error:', error);
    } finally {
      // Only clear loading state if this query is still current
      if (query === searchQueryRef.current) {
        setIsSearching(false);
      }
    }
  };

  // Fetch album art for search results (albums and tracks) - leverages albumArtCache
  const fetchSearchAlbumArt = async (albums, tracks) => {
    // Fetch album art for albums (release-groups need to be converted to releases first)
    for (const album of albums.slice(0, 10)) { // Limit to first 10 for performance
      if (album.albumArt) continue; // Skip if already has art

      const albumId = album.id;

      // Check albumArtCache first (keyed by release-group ID)
      const cachedArt = albumArtCache.current[albumId];
      if (cachedArt?.url) {
        setSearchResults(prev => ({
          ...prev,
          albums: prev.albums.map(a => a.id === albumId ? { ...a, albumArt: cachedArt.url } : a)
        }));
        continue;
      }

      try {
        // Get first release for this release-group
        const releaseResponse = await fetch(
          `https://musicbrainz.org/ws/2/release?release-group=${albumId}&status=official&fmt=json&limit=1`,
          { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }}
        );

        if (releaseResponse.ok) {
          const releaseData = await releaseResponse.json();
          if (releaseData.releases && releaseData.releases.length > 0) {
            const releaseId = releaseData.releases[0].id;

            // Check cache for release ID as well
            const cachedReleaseArt = albumArtCache.current[releaseId];
            if (cachedReleaseArt?.url) {
              // Also cache under release-group ID for future lookups
              albumArtCache.current[albumId] = cachedReleaseArt;
              setSearchResults(prev => ({
                ...prev,
                albums: prev.albums.map(a => a.id === albumId ? { ...a, albumArt: cachedReleaseArt.url } : a)
              }));
              continue;
            }

            // Fetch album art for this release
            const artResponse = await fetch(
              `https://coverartarchive.org/release/${releaseId}`,
              { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }}
            );

            if (artResponse.ok) {
              const artData = await artResponse.json();
              const frontCover = artData.images.find(img => img.front);
              if (frontCover) {
                const artUrl = frontCover.thumbnails?.['250'] || frontCover.thumbnails?.['500'] || frontCover.image;

                // Cache under both release-group ID and release ID
                const cacheEntry = { url: artUrl, timestamp: Date.now() };
                albumArtCache.current[albumId] = cacheEntry;
                albumArtCache.current[releaseId] = cacheEntry;

                // Update search results with new album art - create new object reference
                setSearchResults(prev => ({
                  ...prev,
                  albums: prev.albums.map(a => a.id === albumId ? { ...a, albumArt: artUrl } : a)
                }));
              }
            }
          }
        }
      } catch (error) {
        // Silently fail - album art is optional
      }
    }

    // Fetch album art for tracks (from their releases) - check cache first
    for (const track of tracks.slice(0, 10)) { // Limit to first 10 for performance
      if (track.albumArt || !track.releaseId) continue; // Skip if already has art or no release ID

      const trackId = track.id;
      const releaseId = track.releaseId;

      // Check albumArtCache first
      const cachedArt = albumArtCache.current[releaseId];
      if (cachedArt?.url) {
        setSearchResults(prev => ({
          ...prev,
          tracks: prev.tracks.map(t => t.id === trackId ? { ...t, albumArt: cachedArt.url } : t)
        }));
        continue;
      }

      try {
        const artResponse = await fetch(
          `https://coverartarchive.org/release/${releaseId}`,
          { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }}
        );

        if (artResponse.ok) {
          const artData = await artResponse.json();
          const frontCover = artData.images.find(img => img.front);
          if (frontCover) {
            const artUrl = frontCover.thumbnails?.['250'] || frontCover.thumbnails?.['500'] || frontCover.image;

            // Also cache it for future use
            albumArtCache.current[releaseId] = { url: artUrl, timestamp: Date.now() };

            // Update search results with new album art - create new object reference
            setSearchResults(prev => ({
              ...prev,
              tracks: prev.tracks.map(t => t.id === trackId ? { ...t, albumArt: artUrl } : t)
            }));
          }
        }
      } catch (error) {
        // Silently fail - album art is optional
      }
    }
  };

  // Cache utility functions
  const loadCacheFromStore = async () => {
    if (!window.electron?.store) return;

    try {
      // Load album art cache (keep full { url, timestamp } structure)
      const albumArtData = await window.electron.store.get('cache_album_art');
      if (albumArtData) {
        // Filter out expired entries
        const now = Date.now();
        const validEntries = Object.entries(albumArtData).filter(
          ([_, entry]) => entry && entry.timestamp && (now - entry.timestamp) < CACHE_TTL.albumArt
        );
        albumArtCache.current = Object.fromEntries(validEntries);
        console.log(`ðŸ“¦ Loaded ${validEntries.length} album art entries from cache`);
      }

      // Load artist data cache
      // Cache version 2: Added release-group categorization (live, compilation)
      const ARTIST_CACHE_VERSION = 2;
      const artistData = await window.electron.store.get('cache_artist_data');
      if (artistData) {
        // Filter out expired entries and entries from old cache versions
        const now = Date.now();
        const validEntries = Object.entries(artistData).filter(
          ([_, entry]) => entry.cacheVersion === ARTIST_CACHE_VERSION &&
                         now - entry.timestamp < CACHE_TTL.artistData
        );
        artistDataCache.current = Object.fromEntries(validEntries);
        const invalidated = Object.keys(artistData).length - validEntries.length;
        console.log(`ðŸ“¦ Loaded ${validEntries.length} artist data entries from cache${invalidated > 0 ? ` (${invalidated} invalidated due to version change)` : ''}`);
      }

      // Load track sources cache
      const trackSourcesData = await window.electron.store.get('cache_track_sources');
      if (trackSourcesData) {
        // Filter out expired entries
        const now = Date.now();
        const validEntries = Object.entries(trackSourcesData).filter(
          ([_, entry]) => now - entry.timestamp < CACHE_TTL.trackSources
        );
        trackSourcesCache.current = Object.fromEntries(validEntries);
        console.log(`ðŸ“¦ Loaded ${validEntries.length} track source entries from cache`);
      }

      // Load artist image cache
      const artistImageData = await window.electron.store.get('cache_artist_images');
      if (artistImageData) {
        // Filter out expired entries
        const now = Date.now();
        const validEntries = Object.entries(artistImageData).filter(
          ([_, entry]) => now - entry.timestamp < CACHE_TTL.artistImage
        );
        artistImageCache.current = Object.fromEntries(validEntries);
        console.log(`ðŸ“¦ Loaded ${validEntries.length} artist image entries from cache`);
      }

      // Load album-to-release-ID mapping cache (for Critic's Picks and track art lookups)
      const albumReleaseIdData = await window.electron.store.get('cache_album_release_ids');
      if (albumReleaseIdData) {
        albumToReleaseIdCache.current = albumReleaseIdData;
        console.log(`ðŸ“¦ Loaded ${Object.keys(albumReleaseIdData).length} album-to-release-ID mappings from cache`);
      }

      // Load playlist cover cache
      const playlistCoverData = await window.electron.store.get('cache_playlist_covers');
      if (playlistCoverData) {
        // Filter out expired entries
        const now = Date.now();
        const validEntries = Object.entries(playlistCoverData).filter(
          ([_, entry]) => now - entry.timestamp < CACHE_TTL.playlistCover
        );
        playlistCoverCache.current = Object.fromEntries(validEntries);
        console.log(`ðŸ“¦ Loaded ${validEntries.length} playlist cover entries from cache`);
      }

      // Load resolver settings
      const savedActiveResolvers = await window.electron.store.get('active_resolvers');
      const savedResolverOrder = await window.electron.store.get('resolver_order');

      if (savedActiveResolvers) {
        // Deduplicate in case of corrupted data
        const dedupedActive = [...new Set(savedActiveResolvers)];
        setActiveResolvers(dedupedActive);
        console.log(`ðŸ“¦ Loaded ${dedupedActive.length} active resolvers from storage`);
      }

      if (savedResolverOrder) {
        // Deduplicate in case of corrupted data (preserving order of first occurrence)
        const dedupedOrder = [...new Set(savedResolverOrder)];
        setResolverOrder(dedupedOrder);
        console.log(`ðŸ“¦ Loaded resolver order from storage (${dedupedOrder.length} resolvers)`);
      }

      // Load meta service configs (Last.fm, AI services, etc.)
      const savedMetaServiceConfigs = await window.electron.store.get('meta_service_configs');
      if (savedMetaServiceConfigs) {
        setMetaServiceConfigs(savedMetaServiceConfigs);
        console.log('ðŸ“¦ Loaded meta service configs:', Object.keys(savedMetaServiceConfigs).join(', '));
      }

      // Load friends from storage
      const savedFriends = await window.electron.store.get('friends');
      if (savedFriends && Array.isArray(savedFriends)) {
        // Migrate friends to have savedToCollection: true (covers both false and undefined from older versions)
        const migratedFriends = savedFriends.map(f =>
          f.savedToCollection !== true ? { ...f, savedToCollection: true } : f
        );
        // Save migrated friends back if any were changed
        if (migratedFriends.some((f, i) => f !== savedFriends[i])) {
          await window.electron.store.set('friends', migratedFriends);
          console.log('ðŸ‘¥ Migrated friends to savedToCollection: true');
        }
        setFriends(migratedFriends);
        console.log(`ðŸ‘¥ Loaded ${migratedFriends.length} friends from storage`);
      }

      const savedPinnedFriendIds = await window.electron.store.get('pinnedFriendIds');
      if (savedPinnedFriendIds && Array.isArray(savedPinnedFriendIds)) {
        // Dedupe in case duplicates were saved
        const dedupedIds = [...new Set(savedPinnedFriendIds)];
        setPinnedFriendIds(dedupedIds);
        console.log(`ðŸ“Œ Loaded ${dedupedIds.length} pinned friends from storage`);
      }

      // Load volume normalization offsets
      const savedVolumeOffsets = await window.electron.store.get('resolver_volume_offsets');
      if (savedVolumeOffsets) {
        setResolverVolumeOffsets(prev => ({ ...prev, ...savedVolumeOffsets }));
        console.log('ðŸ“¦ Loaded volume normalization offsets');
      }

      // Load skip external prompt preference
      const savedSkipExternalPrompt = await window.electron.store.get('skip_external_prompt');
      if (savedSkipExternalPrompt !== undefined) {
        setSkipExternalPrompt(savedSkipExternalPrompt);
        console.log('ðŸ“¦ Loaded skip external prompt preference:', savedSkipExternalPrompt);
      }

      // Load auto-launch Spotify preference and trigger launch if enabled
      const savedAutoLaunchSpotify = await window.electron.store.get('auto_launch_spotify');
      if (savedAutoLaunchSpotify !== undefined) {
        setAutoLaunchSpotify(savedAutoLaunchSpotify);
        console.log('ðŸ“¦ Loaded auto-launch Spotify preference:', savedAutoLaunchSpotify);

        // If enabled, launch Spotify in background on startup
        if (savedAutoLaunchSpotify && window.electron?.spotify?.launchInBackground) {
          console.log('ðŸŽµ Auto-launching Spotify in background...');
          window.electron.spotify.launchInBackground();
        }
      }

      // Load skip unsaved friend warning preference
      const savedSkipUnsavedFriendWarning = await window.electron.store.get('skip_unsaved_friend_warning');
      if (savedSkipUnsavedFriendWarning !== undefined) {
        setSkipUnsavedFriendWarning(savedSkipUnsavedFriendWarning);
        console.log('ðŸ“¦ Loaded skip unsaved friend warning preference:', savedSkipUnsavedFriendWarning);
      }

      // Load remember queue preference
      const savedRememberQueue = await window.electron.store.get('remember_queue');
      if (savedRememberQueue !== undefined) {
        setRememberQueue(savedRememberQueue);
        console.log('ðŸ“¦ Loaded remember queue preference:', savedRememberQueue);
      }

      // Load playlists view mode preference
      const savedPlaylistsViewMode = await window.electron.store.get('playlists_view_mode');
      if (savedPlaylistsViewMode) {
        setPlaylistsViewMode(savedPlaylistsViewMode);
        console.log('ðŸ“¦ Loaded playlists view mode:', savedPlaylistsViewMode);
      }

      // Load AI include history preference
      const savedAiIncludeHistory = await window.electron.store.get('ai_include_history');
      if (savedAiIncludeHistory !== undefined) {
        setAiIncludeHistory(savedAiIncludeHistory);
        console.log('ðŸ“¦ Loaded AI include history preference:', savedAiIncludeHistory);
      }

      // Load saved queue if remember queue is enabled
      if (savedRememberQueue) {
        const savedQueue = await window.electron.store.get('saved_queue');
        if (savedQueue && Array.isArray(savedQueue) && savedQueue.length > 0) {
          // Move first track to playbar (paused), rest stays in queue
          const [firstTrack, ...remainingQueue] = savedQueue;
          setCurrentTrack(firstTrack);
          setCurrentQueue(remainingQueue);
          setIsPlaying(false); // Ensure it starts paused
          // Mark that this track needs explicit start (not just resume) when played
          trackNeedsExplicitStart.current = true;
          console.log(`ðŸ“¦ Restored queue: "${firstTrack.title}" ready in playbar, ${remainingQueue.length} tracks in queue`);
        }
        // Restore playback context
        const savedPlaybackContext = await window.electron.store.get('saved_playback_context');
        if (savedPlaybackContext) {
          setPlaybackContext(savedPlaybackContext);
          console.log(`ðŸ“¦ Restored playback context: ${savedPlaybackContext.type}`);
        }
        // Restore shuffle state
        const savedShuffleState = await window.electron.store.get('saved_shuffle_state');
        if (savedShuffleState) {
          setShuffleMode(savedShuffleState.shuffleMode || false);
          originalQueueRef.current = savedShuffleState.originalQueue || null;
          console.log(`ðŸ“¦ Restored shuffle state: ${savedShuffleState.shuffleMode ? 'ON' : 'OFF'}${savedShuffleState.originalQueue ? ' (with original order saved)' : ''}`);
        }
      }

      // Load last active view
      const savedLastView = await window.electron.store.get('last_active_view');
      if (savedLastView) {
        const validViews = ['library', 'search', 'artist', 'playlists', 'playlist-view', 'discover', 'critics-picks', 'recommendations', 'history', 'settings', 'friends', 'friendHistory', 'new-releases'];
        if (validViews.includes(savedLastView.view)) {
          // For artist view, we need to restore the artist data
          if (savedLastView.view === 'artist' && savedLastView.artistName) {
            // Set the view first, then fetch artist data
            setActiveView('artist');
            setViewHistory(['library', 'artist']);
            // Restore artist page tab if saved
            if (savedLastView.artistPageTab) {
              setArtistPageTab(savedLastView.artistPageTab);
              // Mark that we're restoring state so useEffect doesn't reset the tab
              restoringStateRef.current = true;
            }
            // If a release/album was open, save it to load after artist data is fetched
            if (savedLastView.releaseId) {
              pendingReleaseLoad.current = {
                id: savedLastView.releaseId,
                title: savedLastView.releaseTitle,
                releaseType: savedLastView.releaseType,
                date: savedLastView.releaseDate
              };
            }
            // Fetch the artist data (this will populate currentArtist)
            setTimeout(() => fetchArtistData(savedLastView.artistName), 100);
            console.log(`ðŸ“¦ Restoring last view: artist (${savedLastView.artistName})${savedLastView.artistPageTab ? ` [${savedLastView.artistPageTab}]` : ''}${savedLastView.releaseTitle ? ` -> ${savedLastView.releaseTitle}` : ''}`);
          } else if (savedLastView.view === 'history') {
            // Restore history view with tab
            setActiveView('history');
            setViewHistory(['library', 'history']);
            const tab = savedLastView.historyTab || 'topTracks';
            setHistoryTab(tab);
            // Mark that we need to load data once metaServiceConfigs is ready
            pendingHistoryLoad.current = tab;
            console.log(`ðŸ“¦ Restoring last view: history [${tab}]`);
          } else if (savedLastView.view === 'settings') {
            // Restore settings view with tab
            setActiveView('settings');
            setViewHistory(['library', 'settings']);
            if (savedLastView.settingsTab) {
              setSettingsTab(savedLastView.settingsTab);
            }
            console.log(`ðŸ“¦ Restoring last view: settings [${savedLastView.settingsTab || 'installed'}]`);
          } else if (savedLastView.view === 'library') {
            // Restore library view with tab
            setActiveView('library');
            if (savedLastView.collectionTab) {
              setCollectionTab(savedLastView.collectionTab);
            }
            console.log(`ðŸ“¦ Restoring last view: library [${savedLastView.collectionTab || 'tracks'}]`);
          } else if (savedLastView.view === 'recommendations') {
            // Restore recommendations view with tab
            setActiveView('recommendations');
            setViewHistory(['library', 'recommendations']);
            if (savedLastView.recommendationsTab) {
              setRecommendationsTab(savedLastView.recommendationsTab);
            }
            console.log(`ðŸ“¦ Restoring last view: recommendations [${savedLastView.recommendationsTab || 'artists'}]`);
          } else if (savedLastView.view === 'playlist-view' && savedLastView.playlistId) {
            // Restore playlist detail view - need to find the playlist by ID
            setActiveView('playlist-view');
            setViewHistory(['library', 'playlists', 'playlist-view']);
            // Store pending playlist load - will be processed once playlists are loaded
            setPendingPlaylistLoad({
              id: savedLastView.playlistId,
              title: savedLastView.playlistTitle
            });
            console.log(`ðŸ“¦ Restoring last view: playlist-view (${savedLastView.playlistTitle})`);
          } else if (savedLastView.view === 'discover') {
            // Restore discover view - charts will be loaded by useEffect when cacheLoaded is true
            setActiveView('discover');
            setViewHistory(['library', 'discover']);
            console.log(`ðŸ“¦ Restoring last view: discover (Pop of the Tops)`);
          } else if (savedLastView.view === 'critics-picks') {
            // Restore critics-picks view - data will be loaded by useEffect when cacheLoaded is true
            setActiveView('critics-picks');
            setViewHistory(['library', 'critics-picks']);
            console.log(`ðŸ“¦ Restoring last view: critics-picks (Critical Darlings)`);
          } else if (savedLastView.view === 'friendHistory' && savedLastView.friendId) {
            // Restore friend history view - need to find the friend and load their data
            setActiveView('friendHistory');
            setViewHistory(['library', 'friendHistory']);
            // Store pending friend load - will be processed once friends are loaded
            setPendingFriendLoad({
              id: savedLastView.friendId,
              tab: savedLastView.friendHistoryTab || 'recent'
            });
            console.log(`ðŸ“¦ Restoring last view: friendHistory (${savedLastView.friendId})`);
          } else if (savedLastView.view !== 'artist') {
            // For other views, just set the view directly
            setActiveView(savedLastView.view);
            setViewHistory(['library', savedLastView.view]);
            console.log(`ðŸ“¦ Restoring last view: ${savedLastView.view}`);
          }
        } else {
          // No saved view or invalid - default to library
          setActiveView('library');
          setViewHistory(['library']);
        }
      } else {
        // No saved view data - default to library
        setActiveView('library');
        setViewHistory(['library']);
      }

      // Check if this is the first run (tutorial not completed)
      const tutorialCompleted = await window.electron.store.get('tutorial_completed');
      if (!tutorialCompleted) {
        console.log('ðŸŽ“ First run detected - showing tutorial');
        setFirstRunTutorial(prev => ({ ...prev, open: true }));
      }

      // Mark settings as loaded so save useEffect knows it's safe to save
      resolverSettingsLoaded.current = true;
      setCacheLoaded(true);
      console.log('ðŸ“¦ All caches loaded from persistent storage');
    } catch (error) {
      console.error('Failed to load cache from store:', error);
      // Even on error, mark as loaded so app can function
      resolverSettingsLoaded.current = true;
      setCacheLoaded(true);
      // Default to library view on error
      if (activeView === null) {
        setActiveView('library');
        setViewHistory(['library']);
      }
    }
  };

  const saveCacheToStore = async () => {
    if (!window.electron?.store) return;

    try {
      // Save album art cache (already has timestamps from when items were added)
      await window.electron.store.set('cache_album_art', albumArtCache.current);

      // Save artist data cache (already has timestamps)
      await window.electron.store.set('cache_artist_data', artistDataCache.current);

      // Save track sources cache (already has timestamps)
      await window.electron.store.set('cache_track_sources', trackSourcesCache.current);

      // Save artist image cache (already has timestamps)
      await window.electron.store.set('cache_artist_images', artistImageCache.current);

      // Save album-to-release-ID mapping cache
      await window.electron.store.set('cache_album_release_ids', albumToReleaseIdCache.current);

      // Save playlist cover cache
      await window.electron.store.set('cache_playlist_covers', playlistCoverCache.current);

      // Save resolver settings (use refs to ensure we have current values, not stale closure)
      await window.electron.store.set('active_resolvers', activeResolversRef.current);
      await window.electron.store.set('resolver_order', resolverOrderRef.current);

      // Save volume normalization offsets
      await window.electron.store.set('resolver_volume_offsets', resolverVolumeOffsets);

      // Save playlists view mode
      await window.electron.store.set('playlists_view_mode', playlistsViewMode);

      // Note: Meta service configs are saved immediately when changed, not in periodic save

      console.log('ðŸ’¾ Cache and resolver settings saved to persistent storage');
      console.log('   Saved resolver order:', resolverOrderRef.current);
    } catch (error) {
      console.error('Failed to save cache to store:', error);
    }
  };

  // Load cache on mount
  useEffect(() => {
    loadCacheFromStore();

    // Save cache periodically (every 5 minutes)
    const cacheInterval = setInterval(saveCacheToStore, 5 * 60 * 1000);

    // Save cache on unmount
    return () => {
      clearInterval(cacheInterval);
      saveCacheToStore();
    };
  }, []);

  // Save last active view when it changes
  useEffect(() => {
    if (!resolverSettingsLoaded.current || !window.electron?.store) return;

    const viewData = { view: activeView };
    // For artist view, also save the artist name so we can restore it
    if (activeView === 'artist' && currentArtist?.name) {
      viewData.artistName = currentArtist.name;
      viewData.artistPageTab = artistPageTab;
      // Also save current release/album if viewing one
      if (currentRelease) {
        viewData.releaseId = currentRelease.id;
        viewData.releaseTitle = currentRelease.title;
        viewData.releaseType = currentRelease.releaseType;
        viewData.releaseDate = currentRelease.date;
      }
    }
    // Save tab state for views with tabs
    if (activeView === 'history') {
      viewData.historyTab = historyTab;
    }
    if (activeView === 'settings') {
      viewData.settingsTab = settingsTab;
    }
    if (activeView === 'library') {
      viewData.collectionTab = collectionTab;
    }
    if (activeView === 'recommendations') {
      viewData.recommendationsTab = recommendationsTab;
    }
    if (activeView === 'playlist-view' && selectedPlaylist) {
      viewData.playlistId = selectedPlaylist.id;
      viewData.playlistTitle = selectedPlaylist.title;
    }
    if (activeView === 'friendHistory' && currentFriend) {
      viewData.friendId = currentFriend.id;
      viewData.friendHistoryTab = friendHistoryTab;
    }

    window.electron.store.set('last_active_view', viewData);
    console.log(`ðŸ“¦ Saved last view: ${activeView}${viewData.artistName ? ` (${viewData.artistName})` : ''}${viewData.releaseTitle ? ` -> ${viewData.releaseTitle}` : ''}${viewData.historyTab ? ` [${viewData.historyTab}]` : ''}${viewData.settingsTab ? ` [${viewData.settingsTab}]` : ''}${viewData.collectionTab ? ` [${viewData.collectionTab}]` : ''}${viewData.recommendationsTab ? ` [${viewData.recommendationsTab}]` : ''}${viewData.playlistTitle ? ` (${viewData.playlistTitle})` : ''}${viewData.friendId ? ` (friend: ${viewData.friendId})` : ''}`);
  }, [activeView, currentArtist?.name, artistPageTab, currentRelease?.id, historyTab, settingsTab, collectionTab, recommendationsTab, selectedPlaylist?.id, currentFriend?.id, friendHistoryTab]);

  // Load pending history data once cache is fully loaded
  useEffect(() => {
    const hasMetaService = metaServiceConfigs.lastfm?.username || metaServiceConfigs.listenbrainz?.username;
    if (cacheLoaded && pendingHistoryLoad.current && hasMetaService) {
      const tab = pendingHistoryLoad.current;
      pendingHistoryLoad.current = null; // Clear pending load
      console.log(`ðŸ“¦ Loading history data for restored tab: ${tab}`);
      if (tab === 'topTracks') loadTopTracks();
      else if (tab === 'topAlbums') loadTopAlbums();
      else if (tab === 'topArtists') loadTopArtists();
      else if (tab === 'recent') loadListeningHistory();
    }
  }, [cacheLoaded, metaServiceConfigs.lastfm?.username, metaServiceConfigs.listenbrainz?.username]);

  // Load pending release/album once artist data is available
  useEffect(() => {
    if (currentArtist && pendingReleaseLoad.current) {
      const release = pendingReleaseLoad.current;
      pendingReleaseLoad.current = null; // Clear pending load
      console.log(`ðŸ“¦ Loading release for restored view: ${release.title}`);
      // fetchReleaseData expects a release object and artist object
      fetchReleaseData(release, currentArtist);
    }
  }, [currentArtist]);

  // Load pending playlist once playlists are loaded
  useEffect(() => {
    if (pendingPlaylistLoad) {
      const playlist = playlists.find(p => p.id === pendingPlaylistLoad.id);
      if (playlist) {
        console.log(`ðŸ“¦ Loading playlist for restored view: ${playlist.title}`);
        setPendingPlaylistLoad(null); // Clear only when found
        // Use loadPlaylist to properly parse XSPF and populate playlistTracks
        // Skip navigation since we already set activeView to 'playlist-view'
        loadPlaylist(playlist, { skipNavigation: true });
      }
      // Don't clear pending or fall back yet - hosted playlists may still be loading
    }
  }, [playlists, pendingPlaylistLoad]);

  // Give up on pending playlist load after timeout (hosted playlists should be loaded by then)
  useEffect(() => {
    if (pendingPlaylistLoad) {
      const timer = setTimeout(() => {
        if (pendingPlaylistLoad) {
          console.log(`ðŸ“¦ Playlist not found after timeout: ${pendingPlaylistLoad.title}, falling back to playlists view`);
          setPendingPlaylistLoad(null);
          setActiveView('playlists');
          setViewHistory(['library', 'playlists']);
        }
      }, 5000); // 5 second timeout to allow hosted playlists to load
      return () => clearTimeout(timer);
    }
  }, [pendingPlaylistLoad]);

  // Load pending friend once friends are loaded
  useEffect(() => {
    if (pendingFriendLoad && friends.length > 0) {
      const friend = friends.find(f => f.id === pendingFriendLoad.id);
      if (friend) {
        console.log(`ðŸ“¦ Loading friend for restored view: ${friend.displayName}`);
        setCurrentFriend(friend);
        setFriendHistoryTab(pendingFriendLoad.tab || 'recent');
        setPendingFriendLoad(null);
        // Load the appropriate data
        if (pendingFriendLoad.tab === 'topTracks') loadFriendTopTracks(friend);
        else if (pendingFriendLoad.tab === 'topAlbums') loadFriendTopAlbums(friend);
        else if (pendingFriendLoad.tab === 'topArtists') loadFriendTopArtists(friend);
        else loadFriendRecentTracks(friend);
      } else {
        // Friend not found, fall back to library
        console.log(`ðŸ“¦ Friend not found: ${pendingFriendLoad.id}, falling back to library`);
        setPendingFriendLoad(null);
        setActiveView('library');
        setViewHistory(['library']);
      }
    }
  }, [friends, pendingFriendLoad]);

  // Fetch artist data and discography from MusicBrainz
  const fetchArtistData = async (artistName) => {
    console.log('Fetching artist data for:', artistName);

    // Clear any current release view when navigating to a new artist
    setCurrentRelease(null);

    // Only add to artist history if we're already on the artist view
    // This prevents search results from building up history
    if (activeView === 'artist' && currentArtist && currentArtist.name !== artistName) {
      setArtistHistory(prev => [...prev, currentArtist.name]);
    } else if (activeView !== 'artist') {
      // Clear artist history when coming from a different view (like search)
      setArtistHistory([]);
    }

    // Check cache first BEFORE clearing state
    const cacheKey = artistName.toLowerCase();
    const cachedData = artistDataCache.current[cacheKey];
    const now = Date.now();

    // Cache is valid if data exists and not expired
    // Note: Resolver settings don't affect artist/release metadata - tracks are re-resolved when loading a release
    const cacheValid = cachedData &&
                      (now - cachedData.timestamp) < CACHE_TTL.artistData;

    // Also check if artist image is in cache
    const normalizedName = artistName.trim().toLowerCase();
    const cachedImage = artistImageCache.current[normalizedName];
    const imageCacheValid = cachedImage && (now - cachedImage.timestamp) < CACHE_TTL.artistImage;

    if (cacheValid) {
      console.log('ðŸ“¦ Using cached artist data for:', artistName);

      // Set artist image immediately from cache if available
      if (imageCacheValid) {
        console.log('ðŸ“¦ Using cached artist image for:', artistName);
        setArtistImage(cachedImage.url);
        setArtistImagePosition(cachedImage.facePosition || 'center 25%');
      } else {
        // Clear image and fetch fresh
        setArtistImage(null);
        setArtistImagePosition('center 25%');
        getArtistImage(artistName).then(result => {
          if (result) {
            setArtistImage(result.url);
            setArtistImagePosition(result.facePosition || 'center 25%');
          }
        });
      }

      setCurrentArtist(cachedData.artist);

      // Pre-populate releases with cached album art
      const releasesWithCache = cachedData.releases.map(release => ({
        ...release,
        // Use cached URL if available, undefined if needs fetch (shows shimmer), null handled by fetchAlbumArtLazy
        albumArt: albumArtCache.current[release.id]?.url !== undefined
          ? albumArtCache.current[release.id]?.url
          : undefined
      }));

      setArtistReleases(releasesWithCache);
      setSmartReleaseTypeFilter(releasesWithCache);
      setLoadingArtist(false);
      navigateTo('artist');

      // Queue album art fetches for releases without cached art (viewport-prioritized)
      const releasesNeedingArt = cachedData.releases.filter(r => !albumArtCache.current[r.id]);
      albumArtFetchId.current++; // Cancel any previous fetch session
      isAlbumArtFetching.current = false;
      albumArtQueue.current = releasesNeedingArt;
      visibleAlbumIds.current.clear();
      processAlbumArtQueue();
      return;
    }

    // No valid cache - set minimal artist data immediately so header/tabs show
    // while releases are loading
    setCurrentArtist({ name: artistName });
    setArtistReleases([]);
    setLoadingArtist(true);
    setArtistImage(null);
    setArtistImagePosition('center 25%');
    navigateTo('artist');

    if (cachedData && cachedData.resolverHash !== currentResolverHash) {
      console.log('ðŸ”„ Resolver settings changed, invalidating cache for:', artistName);
    }

    console.log('ðŸŒ Fetching fresh artist data from MusicBrainz...');

    try {
      // Step 1: Search for artist by name to get MBID
      // Helper function to fetch with retry on rate limit and network errors
      const fetchWithRetry = async (url, maxRetries = 3) => {
        for (let attempt = 0; attempt < maxRetries; attempt++) {
          try {
            const response = await fetch(url, {
              headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }
            });

            if (response.ok) {
              return response;
            }

            if (response.status === 503 || response.status === 429) {
              const delay = Math.pow(2, attempt) * 1000; // Exponential backoff: 1s, 2s, 4s
              console.log(`Rate limited (${response.status}), retrying in ${delay}ms... (attempt ${attempt + 1}/${maxRetries})`);
              await new Promise(resolve => setTimeout(resolve, delay));
            } else {
              // Non-retryable HTTP error
              return response;
            }
          } catch (networkError) {
            // Network error (no connection, DNS failure, etc.)
            if (attempt < maxRetries - 1) {
              const delay = Math.pow(2, attempt) * 1000;
              console.log(`Network error, retrying in ${delay}ms... (attempt ${attempt + 1}/${maxRetries}):`, networkError.message);
              await new Promise(resolve => setTimeout(resolve, delay));
            } else {
              throw networkError; // Re-throw on final attempt
            }
          }
        }
        // Return last response after all retries exhausted
        return fetch(url, {
          headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }
        });
      };

      const searchResponse = await fetchWithRetry(
        `https://musicbrainz.org/ws/2/artist?query=${encodeURIComponent(artistName)}&fmt=json&limit=1`
      );

      if (!searchResponse.ok) {
        console.error('Artist search failed:', searchResponse.status);
        if (searchResponse.status === 503 || searchResponse.status === 429) {
          showConfirmDialog({
            type: 'error',
            title: 'Service Busy',
            message: 'MusicBrainz is temporarily unavailable. Please try again in a few seconds.'
          });
        }
        setLoadingArtist(false);
        return;
      }
      
      const searchData = await searchResponse.json();
      
      if (!searchData.artists || searchData.artists.length === 0) {
        console.log('Artist not found');
        showConfirmDialog({
          type: 'info',
          title: 'Artist Not Found',
          message: `"${artistName}" was not found in MusicBrainz`
        });
        setLoadingArtist(false);
        return;
      }
      
      const artist = searchData.artists[0];
      console.log('Found artist:', artist.name, 'MBID:', artist.id);

      // Set artist name immediately so header shows while releases load
      setCurrentArtist({
        name: artist.name,
        mbid: artist.id,
        country: artist.country,
        disambiguation: artist.disambiguation,
        type: artist.type
      });

      // Start fetching artist image early (non-blocking) with fallbacks
      (async () => {
        // Try Spotify first
        const spotifyResult = await getArtistImage(artistName);
        if (spotifyResult) {
          setArtistImage(spotifyResult.url);
          setArtistImagePosition(spotifyResult.facePosition || 'center 25%');
          return;
        }

        // Try Wikipedia fallback
        const wikiImage = await getWikipediaArtistImage(artist.id);
        if (wikiImage) {
          setArtistImage(wikiImage);
          setArtistImagePosition('center 25%');
          return;
        }

        // Try Discogs fallback
        const discogsImage = await getDiscogsArtistImage(artist.id, artistName);
        if (discogsImage) {
          setArtistImage(discogsImage);
          setArtistImagePosition('center 25%');
        }
      })();

      // Step 2: Fetch artist's release-groups (albums, EPs, singles) with staggered requests
      // Using release-groups instead of releases to avoid duplicates (each album appears once)
      // MusicBrainz rate limits to ~1 req/sec, so we stagger by 500ms to stay under limit
      const releaseTypes = ['album', 'ep', 'single'];

      const releasePromises = releaseTypes.map(async (type, index) => {
        // Stagger requests by 500ms each to avoid rate limiting
        if (index > 0) {
          await new Promise(resolve => setTimeout(resolve, index * 500));
        }
        try {
          const releasesResponse = await fetchWithRetry(
            `https://musicbrainz.org/ws/2/release-group?artist=${artist.id}&type=${type}&fmt=json&limit=100`
          );

          if (releasesResponse.ok) {
            const releasesData = await releasesResponse.json();
            if (releasesData['release-groups']) {
              return releasesData['release-groups'].map(rg => {
                // Determine release type based on primary-type and secondary-types
                const primaryType = (rg['primary-type'] || '').toLowerCase();
                const secondaryTypes = (rg['secondary-types'] || []).map(t => t.toLowerCase());

                // Categorize: studio album, live, compilation, or the primary type (ep/single)
                let releaseType = primaryType || type;
                if (secondaryTypes.includes('live')) {
                  releaseType = 'live';
                } else if (secondaryTypes.includes('compilation')) {
                  releaseType = 'compilation';
                } else if (primaryType === 'album' && secondaryTypes.length === 0) {
                  releaseType = 'album'; // Studio album (no secondary types)
                }

                return {
                  id: rg.id,
                  title: rg.title,
                  date: rg['first-release-date'] || null,
                  releaseType: releaseType,
                  secondaryTypes: secondaryTypes,
                  disambiguation: rg.disambiguation
                };
              });
            }
          }
          return [];
        } catch (error) {
          console.error(`Error fetching ${type} release-groups:`, error);
          return [];
        }
      });

      const releaseResults = await Promise.all(releasePromises);
      const allReleases = releaseResults.flat();

      console.log(`Found ${allReleases.length} release-groups for ${artist.name}`);

      // Sort by date (newest first)
      const uniqueReleases = [...allReleases].sort((a, b) => {
        const dateA = a.date || '0000';
        const dateB = b.date || '0000';
        return dateB.localeCompare(dateA);
      });
      
      const artistData = {
        name: artist.name,
        mbid: artist.id,
        country: artist.country,
        disambiguation: artist.disambiguation,
        type: artist.type
      };

      // Cache the artist data (version 2: release-group categorization)
      artistDataCache.current[cacheKey] = {
        artist: artistData,
        releases: uniqueReleases,
        timestamp: Date.now(),
        cacheVersion: 2
      };
      console.log('ðŸ’¾ Cached artist data for:', artistName);

      // Pre-populate releases with cached album art
      const releasesWithCache = uniqueReleases.map(release => ({
        ...release,
        // Use cached URL if available, undefined if needs fetch (shows shimmer)
        albumArt: albumArtCache.current[release.id]?.url !== undefined
          ? albumArtCache.current[release.id]?.url
          : undefined
      }));

      // Show page immediately (with cached album art if available)
      setArtistReleases(releasesWithCache);
      setSmartReleaseTypeFilter(releasesWithCache);
      setLoadingArtist(false);

      // Queue album art fetches (viewport-prioritized) - only for releases without cache
      const releasesNeedingArt = uniqueReleases.filter(r => !albumArtCache.current[r.id]);
      albumArtFetchId.current++; // Cancel any previous fetch session
      isAlbumArtFetching.current = false;
      albumArtQueue.current = releasesNeedingArt;
      visibleAlbumIds.current.clear();
      processAlbumArtQueue();
      
    } catch (error) {
      console.error('Error fetching artist data:', error);
      // Provide specific error message based on error type
      let message = 'Failed to load artist data. Please try again.';
      if (error.name === 'TypeError' && error.message.includes('fetch')) {
        message = 'Network error - please check your internet connection.';
      } else if (error.message) {
        message = `Error: ${error.message}`;
      }
      showConfirmDialog({
        type: 'error',
        title: 'Load Failed',
        message
      });
      setLoadingArtist(false);
    }
  };

  // Fetch release data (album/EP/single) with full track listing
  const fetchReleaseData = async (release, artist) => {
    setLoadingRelease(true);
    setCurrentRelease(null);
    // Collapse header smoothly when opening a release
    setIsHeaderCollapsed(true);

    // Helper to fetch with retry on rate limiting
    const fetchWithRetry = async (url, options, maxRetries = 3) => {
      for (let attempt = 0; attempt < maxRetries; attempt++) {
        const response = await fetch(url, options);
        if (response.status === 503 || response.status === 429) {
          // Rate limited - wait and retry
          const delay = Math.pow(2, attempt) * 1000; // 1s, 2s, 4s
          console.log(`Rate limited, retrying in ${delay}ms...`);
          await new Promise(resolve => setTimeout(resolve, delay));
          continue;
        }
        return response;
      }
      // Final attempt
      return fetch(url, options);
    };

    try {
      console.log('Fetching release data for:', release.title);

      // Try fetching as a direct release ID first (for artist discography)
      let releaseId = release.id;
      let releaseDetailsResponse = await fetchWithRetry(
        `https://musicbrainz.org/ws/2/release/${releaseId}?inc=recordings+artist-credits&fmt=json`,
        { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }}
      );

      // If that fails (404), it might be a release-group ID (from search)
      // Try converting release-group to release ID
      if (!releaseDetailsResponse.ok && releaseDetailsResponse.status === 404) {
        console.log('Not a release ID, trying as release-group...');

        const releaseGroupResponse = await fetchWithRetry(
          `https://musicbrainz.org/ws/2/release?release-group=${release.id}&status=official&fmt=json&limit=1`,
          { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }}
        );

        if (!releaseGroupResponse.ok) {
          throw new Error(`Failed to fetch release or release-group (HTTP ${releaseGroupResponse.status})`);
        }

        const releaseGroupData = await releaseGroupResponse.json();

        if (!releaseGroupData.releases || releaseGroupData.releases.length === 0) {
          throw new Error('No official releases found for this release-group');
        }

        // Use the first official release ID
        releaseId = releaseGroupData.releases[0].id;
        console.log('Converted release-group to release ID:', releaseId);

        // Fetch again with the converted ID
        releaseDetailsResponse = await fetchWithRetry(
          `https://musicbrainz.org/ws/2/release/${releaseId}?inc=recordings+artist-credits&fmt=json`,
          { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }}
        );
      }

      if (!releaseDetailsResponse.ok) {
        throw new Error('Release not found');
      }

      const releaseData = await releaseDetailsResponse.json();
      
      // Extract track listing from media
      const tracks = [];
      if (releaseData.media && releaseData.media.length > 0) {
        releaseData.media.forEach((medium, mediumIndex) => {
          if (medium.tracks) {
            medium.tracks.forEach(track => {
              tracks.push({
                position: track.position,
                title: track.title || track.recording?.title || 'Unknown Track',
                length: track.length,
                recording: track.recording,
                mediumIndex: mediumIndex + 1,
                mediumTitle: medium.title
              });
            });
          }
        });
      }

      // Keep track of the original ID (release-group ID from artist page) for caching
      const originalReleaseGroupId = release.id;

      // Create release info and show tracks immediately (don't wait for album art)
      // Use existing album art from release object if available (from artist page cache)
      const releaseInfo = {
        id: releaseData.id,
        title: releaseData.title,
        artist: artist,
        date: releaseData.date || release.date,
        releaseType: release.releaseType,
        tracks: tracks,
        albumArt: release.albumArt || albumArtCache.current[release.id]?.url || null,
        barcode: releaseData.barcode,
        country: releaseData.country,
        label: releaseData['label-info']?.[0]?.label?.name
      };

      console.log('Release data loaded:', tracks.length, 'tracks');
      setCurrentRelease(releaseInfo);
      setLoadingRelease(false);

      // Resolve release tracks directly (release pages are typically small, 10-20 tracks)
      // Use the artist parameter passed to fetchReleaseData, not release.artist
      const artistName = artist?.name || artist || 'Unknown Artist';
      tracks.forEach(track => {
        // Generate track ID matching what ReleasePage uses for source lookup
        const trackId = `${artistName || 'unknown'}-${track.title || 'untitled'}-${releaseData.title || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
        resolveTrack({ ...track, id: trackId }, artistName, {});
      });

      // Fetch album art in background (don't block track display)
      (async () => {
        try {
          const artResponse = await fetch(
            `https://coverartarchive.org/release/${releaseId}`,
            { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }}
          );

          if (artResponse.ok) {
            const artData = await artResponse.json();
            const frontCover = artData.images.find(img => img.front);
            if (frontCover) {
              const albumArt = frontCover.thumbnails?.['500'] || frontCover.image;

              // Update the current release with album art
              setCurrentRelease(prev => prev && prev.id === releaseData.id ? { ...prev, albumArt } : prev);

              // Cache the album art using the release-group ID so artist page can use it
              // Use a smaller thumbnail (250) for the cache like fetchAlbumArtLazy does
              const cacheUrl = frontCover.thumbnails?.['250'] || albumArt;
              albumArtCache.current[originalReleaseGroupId] = { url: cacheUrl, timestamp: Date.now() };

              // Update artistReleases so the art shows immediately when returning to artist page
              setArtistReleases(prev =>
                prev.map(r =>
                  r.id === originalReleaseGroupId
                    ? { ...r, albumArt: cacheUrl }
                    : r
                )
              );

              // Update criticsPicks so the art shows when returning to Critics Picks page
              setCriticsPicks(prev =>
                prev.map(a => {
                  // Match by release title (case-insensitive) and check artist contains match
                  const titleMatch = a.title.toLowerCase() === release.title.toLowerCase();
                  const artistMatch = artist?.name && a.artist.toLowerCase().includes(artist.name.toLowerCase());
                  if (titleMatch && artistMatch) {
                    return { ...a, albumArt: cacheUrl };
                  }
                  return a;
                })
              );

              // Update charts (Pop of the Tops) so the art shows when returning
              setCharts(prev =>
                prev.map(a => {
                  const titleMatch = a.title.toLowerCase() === release.title.toLowerCase();
                  const artistMatch = artist?.name && a.artist.toLowerCase().includes(artist.name.toLowerCase());
                  if (titleMatch && artistMatch) {
                    return { ...a, albumArt: cacheUrl };
                  }
                  return a;
                })
              );

              // Update topAlbums (History page) so the art shows when returning
              setTopAlbums(prev => ({
                ...prev,
                albums: prev.albums.map(a => {
                  const titleMatch = a.name.toLowerCase() === release.title.toLowerCase();
                  const artistMatch = artist?.name && a.artist.toLowerCase().includes(artist.name.toLowerCase());
                  if (titleMatch && artistMatch) {
                    return { ...a, image: cacheUrl };
                  }
                  return a;
                })
              }));

              // Save cache to persist
              saveCacheToStore();
            }
          }
        } catch (error) {
          console.log('No album art found');
        }
      })();
      
    } catch (error) {
      console.error('Error fetching release data:', error);
      showConfirmDialog({
        type: 'error',
        title: 'Load Failed',
        message: 'Failed to load release data. Please try again.'
      });
      setLoadingRelease(false);
    }
  };

  // Prefetch release tracks on hover (for context menu "Add All to Queue")
  const prefetchReleaseTracks = async (release, artist) => {
    // Skip if already prefetched or currently loaded
    if (prefetchedReleases[release.id] || currentRelease?.id === release.id) {
      return;
    }

    try {
      console.log('ðŸ” Prefetching tracks for:', release.title);

      // Try fetching as a direct release ID first
      let releaseId = release.id;
      let releaseDetailsResponse = await fetch(
        `https://musicbrainz.org/ws/2/release/${releaseId}?inc=recordings+artist-credits&fmt=json`,
        { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }}
      );

      // If that fails (404), it might be a release-group ID
      if (!releaseDetailsResponse.ok && releaseDetailsResponse.status === 404) {
        const releaseGroupResponse = await fetch(
          `https://musicbrainz.org/ws/2/release?release-group=${release.id}&status=official&fmt=json&limit=1`,
          { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }}
        );

        if (!releaseGroupResponse.ok) return;

        const releaseGroupData = await releaseGroupResponse.json();
        if (!releaseGroupData.releases || releaseGroupData.releases.length === 0) return;

        releaseId = releaseGroupData.releases[0].id;
        releaseDetailsResponse = await fetch(
          `https://musicbrainz.org/ws/2/release/${releaseId}?inc=recordings+artist-credits&fmt=json`,
          { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }}
        );
      }

      if (!releaseDetailsResponse.ok) return;

      const releaseData = await releaseDetailsResponse.json();

      // Extract tracks
      const tracks = [];
      if (releaseData.media && releaseData.media.length > 0) {
        releaseData.media.forEach((medium) => {
          if (medium.tracks) {
            medium.tracks.forEach(track => {
              const trackId = `${artist?.name || 'unknown'}-${track.title || 'untitled'}-${release.title || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
              tracks.push({
                id: trackId,
                position: track.position,
                title: track.title || track.recording?.title || 'Unknown Track',
                length: track.length,
                recordingId: track.recording?.id,
                artist: artist?.name,
                album: release.title,
                albumArt: release.albumArt,
                sources: {}
              });
            });
          }
        });
      }

      // Cache the prefetched tracks
      setPrefetchedReleases(prev => ({
        ...prev,
        [release.id]: {
          tracks,
          title: release.title,
          albumArt: release.albumArt,
          artist: artist?.name
        }
      }));

      console.log(`âœ… Prefetched ${tracks.length} tracks for ${release.title}`);
    } catch (error) {
      console.error('Error prefetching release tracks:', error);
    }
  };

  // Prefetch search album tracks on hover (for context menu "Add All to Queue")
  const prefetchSearchAlbumTracks = (album) => {
    // Skip if already prefetched or in progress (use module-level Set to avoid stale closure)
    if (prefetchedReleasesRef.current[album.id] || prefetchInProgress.has(album.id)) {
      return;
    }

    // Mark as in progress SYNCHRONOUSLY before any async work
    prefetchInProgress.add(album.id);

    // Run the actual fetch asynchronously
    (async () => {
    try {
      const artistName = album['artist-credit']?.[0]?.name || 'Unknown Artist';

      // Search albums use release-group IDs, so fetch the first release from the group
      const releaseGroupResponse = await fetch(
        `https://musicbrainz.org/ws/2/release?release-group=${album.id}&status=official&fmt=json&limit=1`,
        { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }}
      );

      if (!releaseGroupResponse.ok) return;

      const releaseGroupData = await releaseGroupResponse.json();
      if (!releaseGroupData.releases || releaseGroupData.releases.length === 0) return;

      const releaseId = releaseGroupData.releases[0].id;

      // Fetch the release details with tracks
      const releaseDetailsResponse = await fetch(
        `https://musicbrainz.org/ws/2/release/${releaseId}?inc=recordings+artist-credits&fmt=json`,
        { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }}
      );

      if (!releaseDetailsResponse.ok) return;

      const releaseData = await releaseDetailsResponse.json();

      // Extract tracks
      const tracks = [];
      if (releaseData.media && releaseData.media.length > 0) {
        releaseData.media.forEach((medium) => {
          if (medium.tracks) {
            medium.tracks.forEach(track => {
              const trackId = `${artistName}-${track.title || 'untitled'}-${album.title || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
              // Get album art - could be on album.albumArt (quick search) or in searchAlbumArt state (detail view)
              const albumArt = album.albumArt || (typeof searchAlbumArt !== 'undefined' ? searchAlbumArt[album.id] : null) || null;
              tracks.push({
                id: trackId,
                position: track.position,
                title: track.title || track.recording?.title || 'Unknown Track',
                length: track.length,
                recordingId: track.recording?.id,
                artist: artistName,
                album: album.title,
                albumArt: albumArt,
                sources: {}
              });
            });
          }
        });
      }

      // Get album art - could be on album.albumArt (quick search) or in searchAlbumArt state (detail view)
      const cachedAlbumArt = album.albumArt || (typeof searchAlbumArt !== 'undefined' ? searchAlbumArt[album.id] : null) || null;

      // Cache the prefetched tracks using the release-group ID
      setPrefetchedReleases(prev => ({
        ...prev,
        [album.id]: {
          tracks,
          title: album.title,
          albumArt: cachedAlbumArt,
          artist: artistName
        }
      }));

    } catch (error) {
      // Silently fail - prefetch is optional optimization
    } finally {
      // Remove from in-progress set
      prefetchInProgress.delete(album.id);
    }
    })();
  };

  // Async version of prefetch that can be awaited
  const fetchSearchAlbumTracksAsync = async (album) => {
    // If already prefetched, return immediately
    if (prefetchedReleasesRef.current[album.id]) {
      return prefetchedReleasesRef.current[album.id];
    }

    try {
      const artistName = album['artist-credit']?.[0]?.name || 'Unknown Artist';

      // Search albums use release-group IDs, so fetch the first release from the group
      const releaseGroupResponse = await fetch(
        `https://musicbrainz.org/ws/2/release?release-group=${album.id}&status=official&fmt=json&limit=1`,
        { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }}
      );

      if (!releaseGroupResponse.ok) return null;

      const releaseGroupData = await releaseGroupResponse.json();
      if (!releaseGroupData.releases || releaseGroupData.releases.length === 0) return null;

      const releaseId = releaseGroupData.releases[0].id;

      // Fetch the release details with tracks
      const releaseDetailsResponse = await fetch(
        `https://musicbrainz.org/ws/2/release/${releaseId}?inc=recordings+artist-credits&fmt=json`,
        { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }}
      );

      if (!releaseDetailsResponse.ok) return null;

      const releaseData = await releaseDetailsResponse.json();

      // Extract tracks
      const tracks = [];
      if (releaseData.media && releaseData.media.length > 0) {
        releaseData.media.forEach((medium) => {
          if (medium.tracks) {
            medium.tracks.forEach(track => {
              const trackId = `${artistName}-${track.title || 'untitled'}-${album.title || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
              const albumArt = album.albumArt || null;
              tracks.push({
                id: trackId,
                position: track.position,
                title: track.title || track.recording?.title || 'Unknown Track',
                length: track.length,
                duration: track.length ? Math.round(track.length / 1000) : 0,
                recordingId: track.recording?.id,
                artist: artistName,
                album: album.title,
                albumArt: albumArt,
                sources: {}
              });
            });
          }
        });
      }

      const cachedAlbumArt = album.albumArt || null;

      // Cache the prefetched tracks using the release-group ID
      const result = {
        tracks,
        title: album.title,
        albumArt: cachedAlbumArt,
        artist: artistName
      };

      setPrefetchedReleases(prev => ({
        ...prev,
        [album.id]: result
      }));

      // Also update the ref immediately so it's available
      prefetchedReleasesRef.current[album.id] = result;

      return result;
    } catch (error) {
      console.error('Error fetching album tracks:', error);
      return null;
    }
  };

  // Handle album click from search - fetch release data by release-group ID
  const handleAlbumClick = async (album) => {
    try {
      console.log('Fetching album from search:', album.title);

      // Get artist name from album
      const artistName = album['artist-credit']?.[0]?.name || 'Unknown Artist';

      // Create artist object
      const artist = {
        name: artistName,
        id: album['artist-credit']?.[0]?.artist?.id || null
      };

      // Mark that we're opening a release so header stays collapsed when artist changes
      openingReleaseRef.current = true;

      // Set artist context
      setCurrentArtist(artist);

      // Check for cached artist image first for instant display
      const normalizedName = artistName.trim().toLowerCase();
      const cachedImage = artistImageCache.current[normalizedName];
      const now = Date.now();
      const imageCacheValid = cachedImage && (now - cachedImage.timestamp) < CACHE_TTL.artistImage;

      if (imageCacheValid) {
        setArtistImage(cachedImage.url);
        setArtistImagePosition(cachedImage.facePosition || 'center 25%');
      } else {
        // Fetch artist image (don't clear current image to avoid gray flash)
        getArtistImage(artistName).then(result => {
          if (result) {
            setArtistImage(result.url);
            setArtistImagePosition(result.facePosition || 'center 25%');
          }
        });
      }

      // Start loading release FIRST (sets loadingRelease=true), then navigate
      // This prevents the header from flashing because loadingRelease=true hides it
      fetchReleaseData({
        id: album.id,
        title: album.title,
        releaseType: album['primary-type']?.toLowerCase() || 'album'
      }, artist);
      navigateTo('artist');
    } catch (error) {
      console.error('Error fetching album from search:', error);
      showConfirmDialog({
        type: 'error',
        title: 'Load Failed',
        message: 'Failed to load album. Please try again.'
      });
    }
  };

  // Handle playlist click from search
  const handlePlaylistClick = (playlist) => {
    loadPlaylist(playlist);
  };

  // Handle collection album click - search and navigate to album page
  const handleCollectionAlbumClick = async (album) => {
    try {
      console.log('Loading collection album:', album.title, 'by', album.artist);

      // Skip if already viewing this album (avoid unnecessary reloads)
      if (activeView === 'artist' && currentRelease?.title === album.title && currentArtist?.name === album.artist) {
        console.log('ðŸ“€ Already viewing album:', album.title);
        return;
      }

      // Show loading state immediately - set artist and navigate before search
      const artist = {
        name: album.artist,
        id: null
      };

      openingReleaseRef.current = true;
      setCurrentArtist(artist);
      setLoadingRelease(true);

      // Load artist image from cache if available
      const normalizedName = album.artist.trim().toLowerCase();
      const cachedImage = artistImageCache.current[normalizedName];
      const now = Date.now();
      const imageCacheValid = cachedImage && (now - cachedImage.timestamp) < CACHE_TTL.artistImage;

      if (imageCacheValid) {
        setArtistImage(cachedImage.url);
        setArtistImagePosition(cachedImage.facePosition || 'center 25%');
      } else {
        getArtistImage(album.artist).then(result => {
          if (result) {
            setArtistImage(result.url);
            setArtistImagePosition(result.facePosition || 'center 25%');
          }
        });
      }

      navigateTo('artist');

      // Search MusicBrainz for the album
      const searchQuery = encodeURIComponent(`${album.artist} ${album.title}`);
      const response = await fetch(
        `https://musicbrainz.org/ws/2/release-group?query=${searchQuery}&limit=5&fmt=json`,
        { headers: { 'User-Agent': 'Parachord/0.1 (https://parachord.com)' } }
      );

      if (!response.ok) throw new Error('Search failed');

      const data = await response.json();
      const results = data['release-groups'] || [];

      if (results.length === 0) {
        showToast('Album not found');
        setLoadingRelease(false);
        return;
      }

      // Find best match (prefer exact artist match)
      const match = results.find(r =>
        r['artist-credit']?.[0]?.name?.toLowerCase() === album.artist?.toLowerCase()
      ) || results[0];

      // Fetch release data (don't call handleAlbumClick to avoid duplicate state setting)
      fetchReleaseData({
        id: match.id,
        title: match.title,
        releaseType: match['primary-type']?.toLowerCase() || 'album'
      }, artist);
    } catch (error) {
      console.error('Error loading collection album:', error);
      showToast('Failed to load album');
      setLoadingRelease(false);
    }
  };

  // Validate cached sources in background and update if changed
  const validateCachedSources = async (track, artistName, cachedSources, cacheKey, trackKey) => {
    console.log(`ðŸ” Validating cached sources for: ${track.title}`);

    const freshSources = {};

    // Query enabled resolvers in priority order
    const enabledResolvers = resolverOrder
      .filter(id => activeResolvers.includes(id))
      .map(id => allResolvers.find(r => r.id === id))
      .filter(Boolean);

    const resolverPromises = enabledResolvers.map(async (resolver) => {
      // Skip resolvers that can't resolve or can't play (no point resolving if we can't play)
      if (!resolver.capabilities.resolve || !resolver.play) return;

      try {
        const config = await getResolverConfig(resolver.id);
        const result = await resolver.resolve(artistName, track.title, null, config);

        if (result) {
          freshSources[resolver.id] = {
            ...result,
            confidence: calculateConfidence(track, result)
          };
        }
      } catch (error) {
        console.error(`  âŒ ${resolver.name} validation error:`, error);
      }
    });

    await Promise.all(resolverPromises);

    // Compare with cached sources
    const cachedResolverIds = Object.keys(cachedSources).sort();
    const freshResolverIds = Object.keys(freshSources).sort();
    const sourcesChanged = JSON.stringify(cachedResolverIds) !== JSON.stringify(freshResolverIds);

    if (sourcesChanged) {
      console.log(`âš ï¸ Sources changed for: ${track.title}`);
      console.log(`  Old: ${cachedResolverIds.join(', ') || 'none'}`);
      console.log(`  New: ${freshResolverIds.join(', ') || 'none'}`);

      // Update cache with fresh data
      if (Object.keys(freshSources).length > 0) {
        trackSourcesCache.current[cacheKey] = {
          sources: freshSources,
          timestamp: Date.now(),
          resolverHash: getResolverSettingsHash()
        };

        // Update UI with fresh sources
        setTrackSources(prev => ({
          ...prev,
          [trackKey]: freshSources
        }));

        console.log(`âœ… Cache updated with ${Object.keys(freshSources).length} fresh source(s)`);
      } else {
        // No sources found - invalidate cache
        delete trackSourcesCache.current[cacheKey];
        console.log(`âŒ No sources found - cache invalidated`);
      }
    } else {
      console.log(`âœ… Sources still valid, refreshing timestamp`);
      // Sources unchanged, just refresh timestamp and resolver hash
      trackSourcesCache.current[cacheKey].timestamp = Date.now();
      trackSourcesCache.current[cacheKey].resolverHash = getResolverSettingsHash();
    }
  };

  // Resolve a single track across all active resolvers
  // isQueueResolution: when true, this is a priority queue resolution that won't yield
  const resolveTrack = async (track, artistName, options = {}) => {
    const { forceRefresh = false, isQueueResolution = false, signal } = options;

    // Validate required parameters
    if (!track || !track.title) {
      console.warn('âš ï¸ resolveTrack called with invalid track:', track);
      return;
    }
    if (!artistName) {
      // Try to get artist from track object
      artistName = track.artist || track.artistName || 'Unknown Artist';
    }

    // Early abort check
    if (signal?.aborted) {
      console.log(`â¹ï¸ Resolution aborted for "${track.title}" before start`);
      return;
    }

    // Use track.id as the key for trackSources state - this matches what views use to look up resolved sources
    const trackKey = track.id;
    const cacheKey = `${artistName.toLowerCase()}|${track.title.toLowerCase()}|${track.position || 0}`;
    const currentResolverHash = getResolverSettingsHash();

    // Check cache first (unless force refresh)
    const cachedData = trackSourcesCache.current[cacheKey];
    const now = Date.now();

    // Cache is valid if:
    // 1. Not forcing refresh
    // 2. Data exists and not expired
    // 3. Resolver settings haven't changed
    const cacheValid = !forceRefresh &&
                      cachedData &&
                      (now - cachedData.timestamp) < CACHE_TTL.trackSources &&
                      cachedData.resolverHash === currentResolverHash;

    // Check if there are active resolvers that weren't queried in the cached data
    const cachedResolverIds = cachedData ? Object.keys(cachedData.sources) : [];
    const missingResolvers = activeResolvers.filter(id =>
      !cachedResolverIds.includes(id) &&
      allResolvers.find(r => r.id === id)?.capabilities?.resolve
    );

    if (cachedData) {
      console.log(`  ðŸ” Cache check for "${track.title}": hash match=${cachedData.resolverHash === currentResolverHash}, missing resolvers: ${missingResolvers.join(', ') || 'none'}`);
    }

    if (cacheValid && missingResolvers.length === 0) {
      const cacheAge = Math.floor((now - cachedData.timestamp) / (1000 * 60 * 60)); // hours
      console.log(`ðŸ“¦ Using cached sources for: ${track.title} (age: ${cacheAge}h, sources: ${Object.keys(cachedData.sources).join(', ')})`);

      // Use cached sources immediately for fast UI
      setTrackSources(prev => ({
        ...prev,
        [trackKey]: cachedData.sources
      }));

      // Background validation: if cache is > 24 hours old, validate in background
      if (cacheAge >= 24) {
        console.log(`ðŸ”„ Cache > 24h old, validating in background...`);
        setTimeout(() => validateCachedSources(track, artistName, cachedData.sources, cacheKey, trackKey), 1000);
      }

      return cachedData.sources;
    }

    // Check abort after cache check
    if (signal?.aborted) return;

    // If cache is valid but missing resolvers, query only the missing ones
    if (cacheValid && missingResolvers.length > 0) {
      console.log(`ðŸ” Cache valid but missing ${missingResolvers.length} resolver(s), querying: ${missingResolvers.join(', ')}`);

      // Start with cached sources
      const sources = { ...cachedData.sources };

      // Query only missing resolvers
      const missingResolverInstances = missingResolvers
        .map(id => allResolvers.find(r => r.id === id))
        .filter(Boolean);

      const resolverPromises = missingResolverInstances.map(async (resolver) => {
        // Check abort before each resolver
        if (signal?.aborted) return;

        if (!resolver.capabilities.resolve || !resolver.play) return;

        try {
          const config = await getResolverConfig(resolver.id);

          // Check abort after config fetch
          if (signal?.aborted) return;

          console.log(`  ðŸ”Ž Trying ${resolver.id}...`);

          let result;

          // If track has a sourceUrl hint matching this resolver, use it directly
          if (track.sourceUrl && resolver.id === 'bandcamp' && track.sourceUrl.includes('bandcamp.com/track/')) {
            console.log(`  ðŸ“Ž Using sourceUrl hint for Bandcamp: ${track.sourceUrl}`);
            result = {
              id: `bandcamp-${Date.now()}`,
              title: track.title,
              artist: artistName,
              album: track.album || '',
              duration: track.duration || 210,
              sources: ['bandcamp'],
              bandcampUrl: track.sourceUrl
            };
          } else {
            result = await resolver.resolve(artistName, track.title, null, config);
          }

          // Check abort before processing result
          if (signal?.aborted) return;

          if (result) {
            sources[resolver.id] = {
              ...result,
              confidence: calculateConfidence(track, result)
            };
            console.log(`  âœ… ${resolver.name}: Found match (confidence: ${(sources[resolver.id].confidence * 100).toFixed(0)}%)`);
            if (resolver.id === 'localfiles') {
              console.log(`  ðŸ“ LocalFiles source structure:`, JSON.stringify(sources[resolver.id], null, 2));
            }
          } else {
            console.log(`  âšª ${resolver.name}: No match found`);
          }
        } catch (error) {
          // Silently ignore abort errors
          if (error.name === 'AbortError') return;
          console.error(`  âŒ ${resolver.name} resolve error:`, error);
        }
      });

      await Promise.all(resolverPromises);

      // Final abort check before state update
      if (signal?.aborted) {
        console.log(`â¹ï¸ Resolution aborted for "${track.title}" before state update`);
        return;
      }

      // Update state with combined sources
      setTrackSources(prev => ({
        ...prev,
        [trackKey]: sources
      }));

      // Update cache with new sources
      trackSourcesCache.current[cacheKey] = {
        sources: sources,
        timestamp: Date.now(),
        resolverHash: getResolverSettingsHash()
      };

      return sources;
    }

    if (cachedData && cachedData.resolverHash !== currentResolverHash) {
      console.log(`ðŸ”„ Resolver settings changed, re-resolving: ${track.title}`);
    }

    console.log(`ðŸ” Resolving: ${artistName} - ${track.title}${forceRefresh ? ' (forced refresh)' : ''}`);

    const sources = {};

    // Query enabled resolvers in priority order
    const enabledResolvers = resolverOrder
      .filter(id => activeResolvers.includes(id))
      .map(id => allResolvers.find(r => r.id === id))
      .filter(Boolean);

    console.log(`  ðŸ“‹ Active resolvers: ${activeResolvers.join(', ')}`);
    console.log(`  ðŸ“‹ Resolver order: ${resolverOrder.join(', ')}`);
    console.log(`  ðŸ“‹ Enabled resolvers: ${enabledResolvers.map(r => r.id).join(', ')}`);

    const resolverPromises = enabledResolvers.map(async (resolver) => {
      // Check abort before each resolver
      if (signal?.aborted) return;

      // Skip resolvers that can't resolve or can't play (no point resolving if we can't play)
      if (!resolver.capabilities.resolve || !resolver.play) {
        console.log(`  â­ï¸ Skipping ${resolver.id}: resolve=${resolver.capabilities.resolve}, play=${!!resolver.play}`);
        return;
      }

      try {
        const config = await getResolverConfig(resolver.id);

        // Check abort after config fetch
        if (signal?.aborted) return;

        console.log(`  ðŸ”Ž Trying ${resolver.id}...`);

        let result;

        // If track has a sourceUrl hint matching this resolver, use it directly
        // (e.g., Bandcamp tracks scraped from playlists have their original URL)
        if (track.sourceUrl && resolver.id === 'bandcamp' && track.sourceUrl.includes('bandcamp.com/track/')) {
          console.log(`  ðŸ“Ž Using sourceUrl hint for Bandcamp: ${track.sourceUrl}`);
          // Create a source directly from the URL
          result = {
            id: `bandcamp-${Date.now()}`,
            title: track.title,
            artist: artistName,
            album: track.album || '',
            duration: track.duration || 210,
            sources: ['bandcamp'],
            bandcampUrl: track.sourceUrl
          };
        } else {
          result = await resolver.resolve(artistName, track.title, null, config);
        }

        // Check abort before processing result
        if (signal?.aborted) return;

        if (result) {
          sources[resolver.id] = {
            ...result,
            confidence: calculateConfidence(track, result)
          };
          console.log(`  âœ… ${resolver.name}: Found match (confidence: ${(sources[resolver.id].confidence * 100).toFixed(0)}%)`);
        } else {
          console.log(`  âšª ${resolver.name}: No match found`);
        }
      } catch (error) {
        // Silently ignore abort errors
        if (error.name === 'AbortError') return;
        console.error(`  âŒ ${resolver.name} resolve error:`, error);
      }
    });

    // Wait for all resolvers to complete
    await Promise.all(resolverPromises);

    // Final abort check before state update
    if (signal?.aborted) {
      console.log(`â¹ï¸ Resolution aborted for "${track.title}" before state update`);
      return;
    }

    // Update state with found sources
    if (Object.keys(sources).length > 0) {
      setTrackSources(prev => ({
        ...prev,
        [trackKey]: sources
      }));

      // Also update queue track objects directly so VirtualizedQueueList can see changes
      if (isQueueResolution && track.id) {
        setCurrentQueue(prev => prev.map(t =>
          t.id === track.id ? { ...t, sources: { ...t.sources, ...sources } } : t
        ));
      }

      // Cache the resolved sources with resolver settings hash
      trackSourcesCache.current[cacheKey] = {
        sources: sources,
        timestamp: Date.now(),
        resolverHash: getResolverSettingsHash()
      };

      console.log(`âœ… Found ${Object.keys(sources).length} source(s) for: ${track.title} (cached)`);
    }

    return sources;
  };

  // Resolution scheduler hook - manages viewport-based resolution
  const resolutionSchedulerRef = useRef(null);

  // Initialize scheduler (use window.ResolutionScheduler since it's loaded via IIFE)
  if (!resolutionSchedulerRef.current) {
    resolutionSchedulerRef.current = new window.ResolutionScheduler();
  }

  const resolutionScheduler = resolutionSchedulerRef.current;

  // Set resolve callback (needs to be updated when resolveTrack changes)
  useEffect(() => {
    resolutionScheduler.setResolveCallback(async (trackData, signal) => {
      await resolveTrack(trackData.track, trackData.artistName, {
        signal,
        isQueueResolution: trackData.isQueueResolution
      });
    });
  }, [resolveTrack]);

  // Context management functions
  const registerPageContext = useCallback((pageId) => {
    resolutionScheduler.registerContext(pageId, 'page');
    return () => resolutionScheduler.unregisterContext(pageId);
  }, []);

  const registerQueueContext = useCallback((queueId, playbackLookahead = 5) => {
    resolutionScheduler.registerContext(queueId, 'queue', { playbackLookahead });
    return () => resolutionScheduler.unregisterContext(queueId);
  }, []);

  const registerPoolContext = useCallback((poolId, playbackLookahead = 5) => {
    resolutionScheduler.registerContext(poolId, 'pool', { playbackLookahead });
    return () => resolutionScheduler.unregisterContext(poolId);
  }, []);

  const registerSidebarContext = useCallback((sidebarId) => {
    resolutionScheduler.registerContext(sidebarId, 'sidebar');
    return () => resolutionScheduler.unregisterContext(sidebarId);
  }, []);

  // Visibility updates
  const updateSchedulerVisibility = useCallback((contextId, visibleTracks) => {
    resolutionScheduler.updateVisibility(contextId, visibleTracks);
  }, []);

  // Hover
  const setSchedulerHoverTrack = useCallback((trackKey, contextId) => {
    resolutionScheduler.setHoverTrack(trackKey, contextId);
  }, []);

  const clearSchedulerHoverTrack = useCallback(() => {
    resolutionScheduler.clearHoverTrack();
  }, []);

  // Playback position
  const setSchedulerPlaybackIndex = useCallback((contextId, index) => {
    resolutionScheduler.setPlaybackIndex(contextId, index);
  }, []);

  // Abort
  const abortSchedulerContext = useCallback((contextId, options) => {
    resolutionScheduler.abortContext(contextId, options);
  }, []);

  // Expose scheduler API for use in components
  const resolutionSchedulerAPI = useMemo(() => ({
    registerPageContext,
    registerQueueContext,
    registerPoolContext,
    registerSidebarContext,
    updateVisibility: updateSchedulerVisibility,
    setHoverTrack: setSchedulerHoverTrack,
    clearHoverTrack: clearSchedulerHoverTrack,
    setPlaybackIndex: setSchedulerPlaybackIndex,
    abortContext: abortSchedulerContext,
    getPendingCount: () => resolutionScheduler.getPendingCount()
  }), [
    registerPageContext,
    registerQueueContext,
    registerPoolContext,
    registerSidebarContext,
    updateSchedulerVisibility,
    setSchedulerHoverTrack,
    clearSchedulerHoverTrack,
    setSchedulerPlaybackIndex,
    abortSchedulerContext
  ]);

  // Register queue context for resolution scheduler
  useEffect(() => {
    const cleanup = registerQueueContext('queue', 5);
    return cleanup;
  }, [registerQueueContext]);

  // Register page context for collection tracks resolution
  useEffect(() => {
    if (activeView === 'library' && collectionTab === 'tracks') {
      const cleanup = registerPageContext('collection-tracks');
      return () => {
        // Abort context with afterCurrentBatch when leaving
        abortSchedulerContext('collection-tracks', { afterCurrentBatch: true });
        cleanup();
      };
    }
  }, [activeView, collectionTab, registerPageContext, abortSchedulerContext]);

  // Keep ref in sync with collection tracks for observer callback
  useEffect(() => {
    collectionTracksRef.current = [...library, ...collectionData.tracks];
  }, [library, collectionData.tracks]);

  // IntersectionObserver for collection tracks visibility
  useEffect(() => {
    if (activeView !== 'library' || collectionTab !== 'tracks') {
      collectionObserverRef.current?.disconnect();
      visibleCollectionTrackIds.current.clear();
      setCollectionScrollContainerReady(false);
      return;
    }

    // Get all tracks (local + collection merged)
    const allTracks = [...library, ...collectionData.tracks];
    if (allTracks.length === 0) return;

    // Wait for scroll container to be available
    const scrollContainer = collectionScrollContainerRef.current;
    if (!scrollContainer) return;

    collectionObserverRef.current = new IntersectionObserver(
      (entries) => {
        let changed = false;
        entries.forEach(entry => {
          const trackId = entry.target.dataset.trackId;
          if (entry.isIntersecting) {
            if (!visibleCollectionTrackIds.current.has(trackId)) {
              visibleCollectionTrackIds.current.add(trackId);
              changed = true;
            }
          } else {
            if (visibleCollectionTrackIds.current.has(trackId)) {
              visibleCollectionTrackIds.current.delete(trackId);
              changed = true;
            }
          }
        });

        if (changed) {
          const currentTracks = collectionTracksRef.current;
          const visibleTracks = [];
          visibleCollectionTrackIds.current.forEach(trackId => {
            const track = currentTracks.find(t => t.id === trackId);
            if (track) {
              visibleTracks.push({
                key: trackId,
                data: { track, artistName: track.artist || 'Unknown Artist' }
              });
            }
          });
          updateSchedulerVisibility('collection-tracks', visibleTracks);
        }
      },
      { root: scrollContainer, rootMargin: '200px' }
    );

    // Observe all existing track rows
    collectionTrackRowRefs.current.forEach((element) => {
      if (element) collectionObserverRef.current.observe(element);
    });

    return () => collectionObserverRef.current?.disconnect();
  }, [activeView, collectionTab, library, collectionData.tracks, updateSchedulerVisibility, collectionScrollContainerReady]);

  // Register page context for release page tracks resolution
  useEffect(() => {
    if (activeView === 'artist' && currentRelease && currentRelease.tracks) {
      const cleanup = registerPageContext('release-tracks');
      return () => {
        abortSchedulerContext('release-tracks', { afterCurrentBatch: true });
        cleanup();
      };
    }
  }, [activeView, currentRelease?.id, registerPageContext, abortSchedulerContext]);

  // IntersectionObserver for release page tracks visibility
  useEffect(() => {
    if (activeView !== 'artist' || !currentRelease || !currentRelease.tracks) {
      releaseObserverRef.current?.disconnect();
      visibleReleaseTrackIds.current.clear();
      return;
    }

    const releaseTracks = currentRelease.tracks;
    const artistName = currentRelease.artist?.name || currentArtist?.name || 'Unknown Artist';

    releaseObserverRef.current = new IntersectionObserver(
      (entries) => {
        let changed = false;
        entries.forEach(entry => {
          const trackId = entry.target.dataset.trackId;
          if (entry.isIntersecting) {
            if (!visibleReleaseTrackIds.current.has(trackId)) {
              visibleReleaseTrackIds.current.add(trackId);
              changed = true;
            }
          } else {
            if (visibleReleaseTrackIds.current.has(trackId)) {
              visibleReleaseTrackIds.current.delete(trackId);
              changed = true;
            }
          }
        });

        if (changed) {
          const visibleTracks = [];
          visibleReleaseTrackIds.current.forEach(trackId => {
            // Release tracks from API don't have id - we need to find by matching the computed ID
            // The trackId is computed as: artist-title-album (lowercase, alphanumeric only)
            const track = releaseTracks.find(t => {
              const computedId = `${artistName || 'unknown'}-${t.title || 'untitled'}-${currentRelease.title || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
              return computedId === trackId;
            });
            if (track) {
              visibleTracks.push({
                key: trackId,
                data: {
                  track: { ...track, id: trackId, artist: artistName, album: currentRelease.title, albumArt: currentRelease.albumArt },
                  artistName
                }
              });
            }
          });
          updateSchedulerVisibility('release-tracks', visibleTracks);
        }
      },
      { rootMargin: '200px' }
    );

    // Observe all existing track rows
    releaseTrackRowRefs.current.forEach((element) => {
      if (element) releaseObserverRef.current.observe(element);
    });

    return () => releaseObserverRef.current?.disconnect();
  }, [activeView, currentRelease, currentArtist?.name, updateSchedulerVisibility]);

  // Register sidebar context for friends sidebar visibility tracking
  useEffect(() => {
    if (pinnedFriendIds.length > 0) {
      const cleanup = registerSidebarContext('friends-sidebar');
      return () => {
        // Abort context when no pinned friends
        abortSchedulerContext('friends-sidebar', { afterCurrentBatch: true });
        cleanup();
      };
    }
  }, [pinnedFriendIds.length, registerSidebarContext, abortSchedulerContext]);

  // IntersectionObserver for friends sidebar visibility
  useEffect(() => {
    if (pinnedFriendIds.length === 0) {
      friendsObserverRef.current?.disconnect();
      visibleFriendIds.current.clear();
      return;
    }

    friendsObserverRef.current = new IntersectionObserver(
      (entries) => {
        let changed = false;
        entries.forEach(entry => {
          const friendId = entry.target.dataset.friendId;
          if (entry.isIntersecting) {
            if (!visibleFriendIds.current.has(friendId)) {
              visibleFriendIds.current.add(friendId);
              changed = true;
            }
          } else {
            if (visibleFriendIds.current.has(friendId)) {
              visibleFriendIds.current.delete(friendId);
              changed = true;
            }
          }
        });

        if (changed) {
          const visibleFriends = [];
          visibleFriendIds.current.forEach(friendId => {
            const friend = friends.find(f => f.id === friendId);
            if (friend?.cachedRecentTrack) {
              visibleFriends.push({
                key: `friend-${friendId}`,
                data: {
                  track: friend.cachedRecentTrack,
                  artistName: friend.cachedRecentTrack.artist
                }
              });
            }
          });
          updateSchedulerVisibility('friends-sidebar', visibleFriends);
        }
      },
      { rootMargin: '50px' }
    );

    // Observe all existing friend entries
    friendEntryRefs.current.forEach((element) => {
      if (element) friendsObserverRef.current.observe(element);
    });

    return () => friendsObserverRef.current?.disconnect();
  }, [pinnedFriendIds, friends, updateSchedulerVisibility]);

  // Register page context for recommendations tracks resolution
  useEffect(() => {
    if (activeView === 'recommendations' && recommendationsTab === 'songs' && recommendations.tracks.length > 0) {
      const cleanup = registerPageContext('recommendations-tracks');
      return () => {
        abortSchedulerContext('recommendations-tracks', { afterCurrentBatch: true });
        cleanup();
      };
    }
  }, [activeView, recommendationsTab, recommendations.tracks.length, registerPageContext, abortSchedulerContext]);

  // Keep ref in sync with recommendations tracks for observer callback
  useEffect(() => {
    recommendationsTracksRef.current = recommendations.tracks;
  }, [recommendations.tracks]);

  // IntersectionObserver for recommendations tracks visibility
  useEffect(() => {
    if (activeView !== 'recommendations' || recommendationsTab !== 'songs') {
      recommendationsObserverRef.current?.disconnect();
      visibleRecommendationsTrackIds.current.clear();
      setRecommendationsScrollContainerReady(false);
      return;
    }

    const tracks = recommendations.tracks;
    if (tracks.length === 0) return;

    // Wait for scroll container to be available
    const scrollContainer = recommendationsScrollContainerRef.current;
    if (!scrollContainer) {
      // Schedule a retry once the container is mounted
      return;
    }

    recommendationsObserverRef.current = new IntersectionObserver(
      (entries) => {
        let changed = false;
        entries.forEach(entry => {
          const trackId = entry.target.dataset.trackId;
          if (entry.isIntersecting) {
            if (!visibleRecommendationsTrackIds.current.has(trackId)) {
              visibleRecommendationsTrackIds.current.add(trackId);
              changed = true;
            }
          } else {
            if (visibleRecommendationsTrackIds.current.has(trackId)) {
              visibleRecommendationsTrackIds.current.delete(trackId);
              changed = true;
            }
          }
        });

        if (changed) {
          // Use ref to get current tracks (avoids stale closure)
          const currentTracks = recommendationsTracksRef.current;
          const visibleTracks = [];
          visibleRecommendationsTrackIds.current.forEach(trackId => {
            const track = currentTracks.find(t => t.id === trackId);
            if (track) {
              visibleTracks.push({
                key: trackId,
                data: { track, artistName: track.artist || 'Unknown Artist' }
              });
            }
          });
          updateSchedulerVisibility('recommendations-tracks', visibleTracks);
        }
      },
      { root: scrollContainer, rootMargin: '200px' }
    );

    recommendationsTrackRowRefs.current.forEach((element) => {
      if (element) recommendationsObserverRef.current.observe(element);
    });

    return () => recommendationsObserverRef.current?.disconnect();
  }, [activeView, recommendationsTab, recommendations.tracks, updateSchedulerVisibility, recommendationsScrollContainerReady]);

  // Register page context for history tracks resolution
  useEffect(() => {
    if (activeView === 'history' && historyTab === 'recent' && listeningHistory.tracks.length > 0) {
      const cleanup = registerPageContext('history-tracks');
      return () => {
        abortSchedulerContext('history-tracks', { afterCurrentBatch: true });
        cleanup();
      };
    }
  }, [activeView, historyTab, listeningHistory.tracks.length, registerPageContext, abortSchedulerContext]);

  // Keep ref in sync with history tracks for observer callback
  useEffect(() => {
    historyTracksRef.current = listeningHistory.tracks;
  }, [listeningHistory.tracks]);

  // IntersectionObserver for history tracks visibility
  useEffect(() => {
    if (activeView !== 'history' || historyTab !== 'recent') {
      historyObserverRef.current?.disconnect();
      visibleHistoryTrackIds.current.clear();
      setHistoryScrollContainerReady(false);
      return;
    }

    const tracks = listeningHistory.tracks;
    if (tracks.length === 0) return;

    // Wait for scroll container to be available
    const scrollContainer = historyScrollContainerRef.current;
    if (!scrollContainer) return;

    historyObserverRef.current = new IntersectionObserver(
      (entries) => {
        let changed = false;
        entries.forEach(entry => {
          const trackId = entry.target.dataset.trackId;
          if (entry.isIntersecting) {
            if (!visibleHistoryTrackIds.current.has(trackId)) {
              visibleHistoryTrackIds.current.add(trackId);
              changed = true;
            }
          } else {
            if (visibleHistoryTrackIds.current.has(trackId)) {
              visibleHistoryTrackIds.current.delete(trackId);
              changed = true;
            }
          }
        });

        if (changed) {
          const currentTracks = historyTracksRef.current;
          const visibleTracks = [];
          visibleHistoryTrackIds.current.forEach(trackId => {
            const track = currentTracks.find(t => t.id === trackId);
            if (track) {
              visibleTracks.push({
                key: trackId,
                data: { track, artistName: track.artist || 'Unknown Artist' }
              });
            }
          });
          updateSchedulerVisibility('history-tracks', visibleTracks);
        }
      },
      { root: scrollContainer, rootMargin: '200px' }
    );

    historyTrackRowRefs.current.forEach((element) => {
      if (element) historyObserverRef.current.observe(element);
    });

    return () => historyObserverRef.current?.disconnect();
  }, [activeView, historyTab, listeningHistory.tracks, updateSchedulerVisibility, historyScrollContainerReady]);

  // Register page context for top tracks resolution
  useEffect(() => {
    if (activeView === 'history' && historyTab === 'topTracks' && topTracks.tracks.length > 0) {
      const cleanup = registerPageContext('top-tracks');
      return () => {
        abortSchedulerContext('top-tracks', { afterCurrentBatch: true });
        cleanup();
      };
    }
  }, [activeView, historyTab, topTracks.tracks.length, registerPageContext, abortSchedulerContext]);

  // Keep ref in sync with top tracks for observer callback
  useEffect(() => {
    topTracksRef.current = topTracks.tracks;
  }, [topTracks.tracks]);

  // IntersectionObserver for top tracks visibility
  useEffect(() => {
    if (activeView !== 'history' || historyTab !== 'topTracks') {
      topTracksObserverRef.current?.disconnect();
      visibleTopTrackIds.current.clear();
      setTopTracksScrollContainerReady(false);
      return;
    }

    const tracks = topTracks.tracks;
    if (tracks.length === 0) return;

    // Wait for scroll container to be available (uses same container as history)
    const scrollContainer = topTracksScrollContainerRef.current;
    if (!scrollContainer) return;

    topTracksObserverRef.current = new IntersectionObserver(
      (entries) => {
        let changed = false;
        entries.forEach(entry => {
          const trackId = entry.target.dataset.trackId;
          if (entry.isIntersecting) {
            if (!visibleTopTrackIds.current.has(trackId)) {
              visibleTopTrackIds.current.add(trackId);
              changed = true;
            }
          } else {
            if (visibleTopTrackIds.current.has(trackId)) {
              visibleTopTrackIds.current.delete(trackId);
              changed = true;
            }
          }
        });

        if (changed) {
          const currentTracks = topTracksRef.current;
          const visibleTracks = [];
          visibleTopTrackIds.current.forEach(trackId => {
            const track = currentTracks.find(t => t.id === trackId);
            if (track) {
              visibleTracks.push({
                key: trackId,
                data: { track, artistName: track.artist || 'Unknown Artist' }
              });
            }
          });
          updateSchedulerVisibility('top-tracks', visibleTracks);
        }
      },
      { root: scrollContainer, rootMargin: '200px' }
    );

    topTracksRowRefs.current.forEach((element) => {
      if (element) topTracksObserverRef.current.observe(element);
    });

    return () => topTracksObserverRef.current?.disconnect();
  }, [activeView, historyTab, topTracks.tracks, updateSchedulerVisibility, topTracksScrollContainerReady]);

  // Register page context for friend history tracks resolution
  useEffect(() => {
    if (activeView === 'friendHistory' && currentFriend) {
      const dataKey = friendHistoryTab === 'recent' ? 'recent' : 'topTracks';
      const tracks = friendHistoryData[dataKey] || [];
      if (tracks.length > 0) {
        const cleanup = registerPageContext('friend-history-tracks');
        return () => {
          abortSchedulerContext('friend-history-tracks', { afterCurrentBatch: true });
          cleanup();
        };
      }
    }
  }, [activeView, currentFriend?.id, friendHistoryTab, friendHistoryData.recent?.length, friendHistoryData.topTracks?.length, registerPageContext, abortSchedulerContext]);

  // Keep ref in sync with friend history tracks for observer callback
  useEffect(() => {
    const dataKey = friendHistoryTab === 'recent' ? 'recent' : 'topTracks';
    friendHistoryTracksRef.current = friendHistoryData[dataKey] || [];
  }, [friendHistoryTab, friendHistoryData]);

  // IntersectionObserver for friend history tracks visibility
  useEffect(() => {
    if (activeView !== 'friendHistory' || !currentFriend) {
      friendHistoryObserverRef.current?.disconnect();
      visibleFriendHistoryTrackIds.current.clear();
      setFriendHistoryScrollContainerReady(false);
      return;
    }

    const dataKey = friendHistoryTab === 'recent' ? 'recent' : 'topTracks';
    const tracks = friendHistoryData[dataKey] || [];
    if (tracks.length === 0) return;

    // Wait for scroll container to be available
    const scrollContainer = friendHistoryScrollContainerRef.current;
    if (!scrollContainer) return;

    friendHistoryObserverRef.current = new IntersectionObserver(
      (entries) => {
        let changed = false;
        entries.forEach(entry => {
          const trackId = entry.target.dataset.trackId;
          if (entry.isIntersecting) {
            if (!visibleFriendHistoryTrackIds.current.has(trackId)) {
              visibleFriendHistoryTrackIds.current.add(trackId);
              changed = true;
            }
          } else {
            if (visibleFriendHistoryTrackIds.current.has(trackId)) {
              visibleFriendHistoryTrackIds.current.delete(trackId);
              changed = true;
            }
          }
        });

        if (changed) {
          const currentTracks = friendHistoryTracksRef.current;
          const visibleTracks = [];
          visibleFriendHistoryTrackIds.current.forEach(trackId => {
            const track = currentTracks.find(t => t.id === trackId);
            if (track) {
              visibleTracks.push({
                key: trackId,
                data: { track, artistName: track.artist || 'Unknown Artist' }
              });
            }
          });
          updateSchedulerVisibility('friend-history-tracks', visibleTracks);
        }
      },
      { root: scrollContainer, rootMargin: '200px' }
    );

    friendHistoryTrackRowRefs.current.forEach((element) => {
      if (element) friendHistoryObserverRef.current.observe(element);
    });

    return () => friendHistoryObserverRef.current?.disconnect();
  }, [activeView, currentFriend?.id, friendHistoryTab, friendHistoryData, updateSchedulerVisibility, friendHistoryScrollContainerReady]);

  // Register page context for search results tracks resolution
  useEffect(() => {
    if (activeView === 'search' && searchDetailCategory === 'tracks' && searchResults.tracks.length > 0) {
      const cleanup = registerPageContext('search-tracks');
      return () => {
        abortSchedulerContext('search-tracks', { afterCurrentBatch: true });
        cleanup();
      };
    }
  }, [activeView, searchDetailCategory, searchResults.tracks.length, registerPageContext, abortSchedulerContext]);

  // Keep ref in sync with search tracks for observer callback
  useEffect(() => {
    searchTracksRef.current = searchResults.tracks;
  }, [searchResults.tracks]);

  // IntersectionObserver for search results tracks visibility
  useEffect(() => {
    if (activeView !== 'search' || searchDetailCategory !== 'tracks') {
      searchTracksObserverRef.current?.disconnect();
      visibleSearchTrackIds.current.clear();
      setSearchScrollContainerReady(false);
      return;
    }

    const tracks = searchResults.tracks;
    if (tracks.length === 0) return;

    // Wait for scroll container to be available
    const scrollContainer = searchScrollContainerRef.current;
    if (!scrollContainer) return;

    searchTracksObserverRef.current = new IntersectionObserver(
      (entries) => {
        let changed = false;
        entries.forEach(entry => {
          const trackId = entry.target.dataset.trackId;
          if (entry.isIntersecting) {
            if (!visibleSearchTrackIds.current.has(trackId)) {
              visibleSearchTrackIds.current.add(trackId);
              changed = true;
            }
          } else {
            if (visibleSearchTrackIds.current.has(trackId)) {
              visibleSearchTrackIds.current.delete(trackId);
              changed = true;
            }
          }
        });

        if (changed) {
          const currentTracks = searchTracksRef.current;
          const visibleTracks = [];
          visibleSearchTrackIds.current.forEach(trackId => {
            const track = currentTracks.find(t => t.id === trackId);
            if (track) {
              visibleTracks.push({
                key: trackId,
                data: { track, artistName: track.artist || 'Unknown Artist' }
              });
            }
          });
          updateSchedulerVisibility('search-tracks', visibleTracks);
        }
      },
      { root: scrollContainer, rootMargin: '200px' }
    );

    searchTracksRowRefs.current.forEach((element) => {
      if (element) searchTracksObserverRef.current.observe(element);
    });

    return () => searchTracksObserverRef.current?.disconnect();
  }, [activeView, searchDetailCategory, searchResults.tracks, updateSchedulerVisibility, searchScrollContainerReady]);

  // Register page context for playlist tracks resolution
  useEffect(() => {
    if (selectedPlaylist && playlistTracks.length > 0) {
      const cleanup = registerPageContext('playlist-tracks');
      return () => {
        abortSchedulerContext('playlist-tracks', { afterCurrentBatch: true });
        cleanup();
      };
    }
  }, [selectedPlaylist?.id, playlistTracks.length, registerPageContext, abortSchedulerContext]);

  // Keep ref in sync with playlist tracks for observer callback
  useEffect(() => {
    playlistTracksRef.current = playlistTracks;
  }, [playlistTracks]);

  // IntersectionObserver for playlist tracks visibility
  useEffect(() => {
    if (!selectedPlaylist) {
      playlistObserverRef.current?.disconnect();
      visiblePlaylistTrackIds.current.clear();
      setPlaylistScrollContainerReady(false);
      return;
    }

    const tracks = playlistTracks;
    if (tracks.length === 0) return;

    // Wait for scroll container to be available
    const scrollContainer = playlistScrollContainerRef.current;
    if (!scrollContainer) return;

    playlistObserverRef.current = new IntersectionObserver(
      (entries) => {
        let changed = false;
        entries.forEach(entry => {
          const trackId = entry.target.dataset.trackId;
          if (entry.isIntersecting) {
            if (!visiblePlaylistTrackIds.current.has(trackId)) {
              visiblePlaylistTrackIds.current.add(trackId);
              changed = true;
            }
          } else {
            if (visiblePlaylistTrackIds.current.has(trackId)) {
              visiblePlaylistTrackIds.current.delete(trackId);
              changed = true;
            }
          }
        });

        if (changed) {
          const currentTracks = playlistTracksRef.current;
          const visibleTracks = [];
          // Sort by track index to ensure consistent ordering
          const sortedVisibleIds = Array.from(visiblePlaylistTrackIds.current).sort((a, b) => {
            const indexA = currentTracks.findIndex(t => t.id === a);
            const indexB = currentTracks.findIndex(t => t.id === b);
            return indexA - indexB;
          });

          // Sync cached sources to state for visible tracks
          // This ensures tracks that were resolved earlier show their sources
          const sourcesToSync = {};
          sortedVisibleIds.forEach(trackId => {
            const track = currentTracks.find(t => t.id === trackId);
            if (track) {
              visibleTracks.push({
                key: trackId,
                data: { track, artistName: track.artist || 'Unknown Artist' }
              });
              // Check if this track has cached sources but isn't in trackSources state
              const cacheKey = `${(track.artist || 'Unknown Artist').toLowerCase()}|${track.title.toLowerCase()}|${track.position || 0}`;
              const cached = trackSourcesCache.current[cacheKey];
              if (cached?.sources && Object.keys(cached.sources).length > 0) {
                sourcesToSync[trackId] = cached.sources;
              }
            }
          });

          // Batch update trackSources state with any cached sources
          if (Object.keys(sourcesToSync).length > 0) {
            setTrackSources(prev => {
              const updated = { ...prev };
              let hasChanges = false;
              for (const [trackId, sources] of Object.entries(sourcesToSync)) {
                if (!prev[trackId] || Object.keys(prev[trackId]).length < Object.keys(sources).length) {
                  updated[trackId] = sources;
                  hasChanges = true;
                }
              }
              return hasChanges ? updated : prev;
            });
          }

          updateSchedulerVisibility('playlist-tracks', visibleTracks);
        }
      },
      { root: scrollContainer, rootMargin: '200px' }
    );

    playlistTrackRowRefs.current.forEach((element) => {
      if (element) playlistObserverRef.current.observe(element);
    });

    return () => playlistObserverRef.current?.disconnect();
  }, [selectedPlaylist?.id, playlistTracks, updateSchedulerVisibility, playlistScrollContainerReady]);

  // Calculate confidence score for a match (0-1)
  const calculateConfidence = (originalTrack, foundTrack) => {
    // If the resolver already provided a confidence score, use it
    if (foundTrack.confidence && typeof foundTrack.confidence === 'number') {
      return foundTrack.confidence;
    }

    // Otherwise calculate based on title and duration match
    const originalTitle = originalTrack.title?.toLowerCase() || '';
    const foundTitle = foundTrack.title?.toLowerCase() || '';
    const titleMatch = originalTitle && foundTitle && originalTitle === foundTitle;
    const durationMatch = originalTrack.length && foundTrack.duration
      ? Math.abs(originalTrack.length / 1000 - foundTrack.duration) < 10 // Within 10 seconds
      : false;

    if (titleMatch && durationMatch) return 0.95;
    if (titleMatch) return 0.85;
    if (durationMatch) return 0.70;
    return 0.50;
  };

  // Fetch album art suggestions from MusicBrainz/Cover Art Archive
  const fetchAlbumArtSuggestions = async (artist, album) => {
    if (!artist || !album) {
      setId3ArtSuggestions([]);
      return;
    }

    setId3ArtLoading(true);
    setId3ArtSuggestions([]);

    try {
      // Search MusicBrainz for releases matching artist and album
      const query = encodeURIComponent(`artist:"${artist}" AND release:"${album}"`);
      const searchUrl = `https://musicbrainz.org/ws/2/release?query=${query}&fmt=json&limit=5`;

      console.log('ðŸŽ¨ Searching MusicBrainz for album art:', artist, '-', album);

      const response = await fetch(searchUrl, {
        headers: {
          'User-Agent': 'Parachord/1.0.0 (https://github.com/parachord)'
        }
      });

      if (!response.ok) {
        throw new Error(`MusicBrainz search failed: ${response.status}`);
      }

      const data = await response.json();
      const releases = data.releases || [];

      console.log(`ðŸŽ¨ Found ${releases.length} releases`);

      // For each release, check if Cover Art Archive has artwork
      const artPromises = releases.slice(0, 5).map(async (release) => {
        try {
          const artUrl = `https://coverartarchive.org/release/${release.id}`;
          const artResponse = await fetch(artUrl, {
            headers: {
              'User-Agent': 'Parachord/1.0.0 (https://github.com/parachord)'
            }
          });

          if (artResponse.ok) {
            const artData = await artResponse.json();
            const frontArt = artData.images?.find(img => img.front) || artData.images?.[0];

            if (frontArt) {
              return {
                releaseId: release.id,
                releaseName: release.title,
                artistName: release['artist-credit']?.[0]?.name || artist,
                year: release.date?.split('-')[0] || '',
                thumbnailUrl: frontArt.thumbnails?.small || frontArt.thumbnails?.['250'] || frontArt.image,
                fullUrl: frontArt.image
              };
            }
          }
          return null;
        } catch (err) {
          // Silently fail for individual releases
          return null;
        }
      });

      const artResults = (await Promise.all(artPromises)).filter(Boolean);
      console.log(`ðŸŽ¨ Found ${artResults.length} releases with artwork`);

      setId3ArtSuggestions(artResults);
    } catch (error) {
      console.error('Error fetching album art suggestions:', error);
      setId3ArtSuggestions([]);
    } finally {
      setId3ArtLoading(false);
    }
  };

  // Auto-fetch album art suggestions when artist or album changes in ID3 editor
  useEffect(() => {
    // Only run when editor is open
    if (!id3EditorOpen) return;

    const artist = id3EditorValues.artist?.trim();
    const album = id3EditorValues.album?.trim();

    // Need both artist and album
    if (!artist || !album) {
      return;
    }

    // Create a key to track what we've already fetched
    const fetchKey = `${artist}|${album}`;
    if (fetchKey === id3ArtFetchKey) {
      return; // Already fetched for this combination
    }

    // Clear selection when search criteria change
    setId3SelectedArt(null);

    // Debounce the fetch
    const timer = setTimeout(() => {
      setId3ArtFetchKey(fetchKey);
      fetchAlbumArtSuggestions(artist, album);
    }, 500);

    return () => clearTimeout(timer);
  }, [id3EditorOpen, id3EditorValues.artist, id3EditorValues.album]);

  // Reset fetch key when editor closes
  useEffect(() => {
    if (!id3EditorOpen) {
      setId3ArtFetchKey('');
    }
  }, [id3EditorOpen]);

  // Reorder album art queue to prioritize visible albums
  const reprioritizeAlbumArtQueue = () => {
    const queue = albumArtQueue.current;
    if (queue.length === 0) return;

    const visible = [];
    const nonVisible = [];

    for (const item of queue) {
      if (visibleAlbumIds.current.has(item.id)) {
        visible.push(item);
      } else {
        nonVisible.push(item);
      }
    }

    albumArtQueue.current = [...visible, ...nonVisible];
  };

  // Fetch album art for a single release (extracted for reuse)
  const fetchSingleAlbumArt = async (release) => {
    let albumArtUrl = null;

    // First try release-group endpoint
    const artResponse = await fetch(
      `https://coverartarchive.org/release-group/${release.id}`,
      {
        headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }
      }
    );

    if (artResponse.ok) {
      const artData = await artResponse.json();
      const frontCover = artData.images.find(img => img.front);
      if (frontCover && frontCover.thumbnails && frontCover.thumbnails['250']) {
        albumArtUrl = frontCover.thumbnails['250'];
      }
    }

    // If release-group has no art, try getting a specific release and its art
    if (!albumArtUrl) {
      // Get the first release in this release-group
      const releaseResponse = await fetch(
        `https://musicbrainz.org/ws/2/release?release-group=${release.id}&status=official&fmt=json&limit=1`,
        { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' } }
      );

      if (releaseResponse.ok) {
        const releaseData = await releaseResponse.json();
        if (releaseData.releases && releaseData.releases.length > 0) {
          const specificReleaseId = releaseData.releases[0].id;

          // Try fetching art from the specific release
          const releaseArtResponse = await fetch(
            `https://coverartarchive.org/release/${specificReleaseId}`,
            { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' } }
          );

          if (releaseArtResponse.ok) {
            const releaseArtData = await releaseArtResponse.json();
            const frontCover = releaseArtData.images.find(img => img.front);
            if (frontCover && frontCover.thumbnails && frontCover.thumbnails['250']) {
              albumArtUrl = frontCover.thumbnails['250'];
            }
          }
        }
      }
    }

    return albumArtUrl;
  };

  // Process album art queue with viewport prioritization
  const processAlbumArtQueue = async () => {
    if (isAlbumArtFetching.current) return;
    isAlbumArtFetching.current = true;

    // Increment fetch ID to detect stale loops (navigation away)
    albumArtFetchId.current++;
    const currentFetchId = albumArtFetchId.current;

    console.log('ðŸŽ¨ Starting viewport-prioritized album art loading...');
    let loadedCount = 0;
    let consecutiveFailures = 0;
    let batchSize = 4;

    while (albumArtQueue.current.length > 0 && albumArtFetchId.current === currentFetchId) {
      // Reprioritize queue based on current viewport
      reprioritizeAlbumArtQueue();

      // Check how many visible items are at the front
      const visibleBatch = [];
      for (let i = 0; i < Math.min(batchSize, albumArtQueue.current.length); i++) {
        const item = albumArtQueue.current[i];
        if (visibleAlbumIds.current.has(item.id)) {
          visibleBatch.push(item);
        } else {
          break; // Stop at first non-visible item
        }
      }

      if (visibleBatch.length > 0) {
        // Parallel fetch for visible items
        albumArtQueue.current = albumArtQueue.current.slice(visibleBatch.length);

        const results = await Promise.all(
          visibleBatch.map(async (release) => {
            try {
              // Skip if already cached (race condition check)
              if (albumArtCache.current[release.id]) {
                return { release, url: albumArtCache.current[release.id].url, cached: true };
              }

              const url = await fetchSingleAlbumArt(release);
              return { release, url, cached: false };
            } catch (error) {
              console.warn(`Failed to fetch art for ${release.title}:`, error);
              return { release, url: null, error: true };
            }
          })
        );

        // Process results
        for (const { release, url, cached, error } of results) {
          if (cached) continue;

          if (error) {
            consecutiveFailures++;
            if (consecutiveFailures >= 3) {
              batchSize = Math.max(2, batchSize - 1);
              consecutiveFailures = 0;
            }
          } else {
            consecutiveFailures = 0;
            if (loadedCount > 10 && batchSize < 4) {
              batchSize = 4; // Restore batch size after successes
            }
          }

          if (url) {
            albumArtCache.current[release.id] = { url, timestamp: Date.now() };
            loadedCount++;
          }

          // Update state for this release
          setArtistReleases(prev =>
            prev.map(r =>
              r.id === release.id
                ? { ...r, albumArt: url }
                : r
            )
          );
        }
      } else {
        // Sequential fetch for non-visible items (background loading)
        const release = albumArtQueue.current.shift();

        // Skip if already cached
        if (albumArtCache.current[release.id]) {
          continue;
        }

        try {
          const url = await fetchSingleAlbumArt(release);

          if (url) {
            albumArtCache.current[release.id] = { url, timestamp: Date.now() };
            loadedCount++;
          }

          setArtistReleases(prev =>
            prev.map(r =>
              r.id === release.id
                ? { ...r, albumArt: url }
                : r
            )
          );

          consecutiveFailures = 0;
        } catch (error) {
          setArtistReleases(prev =>
            prev.map(r =>
              r.id === release.id
                ? { ...r, albumArt: null }
                : r
            )
          );
          consecutiveFailures++;
        }

        // Delay for non-visible items to avoid hammering API
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }

    console.log(`ðŸŽ¨ Album art loading complete: ${loadedCount} loaded`);
    isAlbumArtFetching.current = false;

    // Save cache after loading
    if (loadedCount > 0) {
      saveCacheToStore();
    }
  };

  // DEPRECATED: Sequential album art loading - replaced by viewport-prioritized processAlbumArtQueue()
  // Kept for reference only
  const fetchAlbumArtLazy = async (releases) => {
    console.log('Starting lazy album art loading...');
    let loadedCount = 0;
    let skippedCount = 0;
    
    // Fetch album art one at a time to update UI progressively
    for (const release of releases) {
      // Skip if already in cache
      if (albumArtCache.current[release.id]) {
        skippedCount++;
        continue;
      }
      
      try {
        let albumArtUrl = null;

        // First try release-group endpoint
        const artResponse = await fetch(
          `https://coverartarchive.org/release-group/${release.id}`,
          {
            headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }
          }
        );

        if (artResponse.ok) {
          const artData = await artResponse.json();
          const frontCover = artData.images.find(img => img.front);
          if (frontCover && frontCover.thumbnails && frontCover.thumbnails['250']) {
            albumArtUrl = frontCover.thumbnails['250'];
          }
        }

        // If release-group has no art, try getting a specific release and its art
        if (!albumArtUrl) {
          // Get the first release in this release-group
          const releaseResponse = await fetch(
            `https://musicbrainz.org/ws/2/release?release-group=${release.id}&status=official&fmt=json&limit=1`,
            { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' } }
          );

          if (releaseResponse.ok) {
            const releaseData = await releaseResponse.json();
            if (releaseData.releases && releaseData.releases.length > 0) {
              const specificReleaseId = releaseData.releases[0].id;

              // Try fetching art from the specific release
              const releaseArtResponse = await fetch(
                `https://coverartarchive.org/release/${specificReleaseId}`,
                { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' } }
              );

              if (releaseArtResponse.ok) {
                const releaseArtData = await releaseArtResponse.json();
                const frontCover = releaseArtData.images.find(img => img.front);
                if (frontCover && frontCover.thumbnails && frontCover.thumbnails['250']) {
                  albumArtUrl = frontCover.thumbnails['250'];
                }
              }
            }
          }
        }

        if (albumArtUrl) {
          // Store in cache with timestamp
          albumArtCache.current[release.id] = { url: albumArtUrl, timestamp: Date.now() };

          // Update just this release with album art
          setArtistReleases(prev =>
            prev.map(r =>
              r.id === release.id
                ? { ...r, albumArt: albumArtUrl }
                : r
            )
          );
          loadedCount++;
        } else {
          // No art found - set to null to show placeholder instead of shimmer
          setArtistReleases(prev =>
            prev.map(r =>
              r.id === release.id
                ? { ...r, albumArt: null }
                : r
            )
          );
        }
      } catch (error) {
        // On error, set to null to show placeholder
        setArtistReleases(prev =>
          prev.map(r =>
            r.id === release.id
              ? { ...r, albumArt: null }
              : r
          )
        );
      }
      
      // Small delay to avoid rate limiting
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    console.log(`Album art: ${loadedCount} loaded, ${skippedCount} from cache, ${releases.length - loadedCount - skippedCount} not found`);

    // Save cache immediately after loading album art so it persists on navigation
    if (loadedCount > 0) {
      saveCacheToStore();
    }
  };

  // Remove a resolver's sources from all track data (trackSources, playlistTracks, queue, library)
  const removeResolverSources = (resolverId) => {
    console.log(`ðŸ§¹ Removing sources for disabled/uninstalled resolver: ${resolverId}`);

    // Remove from trackSources (release/album view)
    setTrackSources(prev => {
      const updated = {};
      for (const [trackKey, sources] of Object.entries(prev)) {
        const { [resolverId]: removed, ...remainingSources } = sources;
        if (Object.keys(remainingSources).length > 0) {
          updated[trackKey] = remainingSources;
        }
      }
      return updated;
    });

    // Remove from playlistTracks
    setPlaylistTracks(prev =>
      prev.map(track => {
        if (track.sources && track.sources[resolverId]) {
          const { [resolverId]: removed, ...remainingSources } = track.sources;
          return { ...track, sources: remainingSources };
        }
        return track;
      })
    );

    // Remove from currentQueue
    setCurrentQueue(prev =>
      prev.map(track => {
        if (track.sources && track.sources[resolverId]) {
          const { [resolverId]: removed, ...remainingSources } = track.sources;
          return { ...track, sources: remainingSources };
        }
        return track;
      })
    );

    // Remove from library
    setLibrary(prev =>
      prev.map(track => {
        if (track.sources && track.sources[resolverId]) {
          const { [resolverId]: removed, ...remainingSources } = track.sources;
          return { ...track, sources: remainingSources };
        }
        return track;
      })
    );

    // Also clean up the cache
    if (trackSourcesCache.current) {
      for (const [cacheKey, cacheEntry] of Object.entries(trackSourcesCache.current)) {
        if (cacheEntry.sources && cacheEntry.sources[resolverId]) {
          const { [resolverId]: removed, ...remainingSources } = cacheEntry.sources;
          trackSourcesCache.current[cacheKey] = {
            ...cacheEntry,
            sources: remainingSources
          };
        }
      }
    }
  };

  const toggleResolver = (resolverId) => {
    const isCurrentlyActive = activeResolvers.includes(resolverId);

    // If disabling, remove the resolver's sources from all tracks
    if (isCurrentlyActive) {
      removeResolverSources(resolverId);
    }

    setActiveResolvers(prev =>
      prev.includes(resolverId)
        ? prev.filter(id => id !== resolverId)
        : [...prev, resolverId]
    );
  };

  // Drag and drop handlers for resolver reordering
  const handleResolverDragStart = (e, resolverId) => {
    setDraggedResolver(resolverId);
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/html', e.target);
  };

  const handleResolverDragOver = (e) => {
    if (e.preventDefault) {
      e.preventDefault();
    }
    e.dataTransfer.dropEffect = 'move';
    return false;
  };

  const handleResolverDragEnter = (e, resolverId) => {
    e.preventDefault();
    if (draggedResolver && draggedResolver !== resolverId) {
      setDragOverResolver(resolverId);
    }
  };

  const handleResolverDragLeave = (e) => {
    e.preventDefault();
    // Only clear if we're leaving the card entirely (not entering a child)
    const relatedTarget = e.relatedTarget;
    if (!relatedTarget || !e.currentTarget.contains(relatedTarget)) {
      setDragOverResolver(null);
    }
  };

  const handleResolverDrop = (e, targetResolverId) => {
    if (e.stopPropagation) {
      e.stopPropagation();
    }

    if (draggedResolver !== targetResolverId) {
      const newOrder = [...resolverOrder];
      const draggedIndex = newOrder.indexOf(draggedResolver);
      const targetIndex = newOrder.indexOf(targetResolverId);

      // Remove dragged item and insert at target position
      newOrder.splice(draggedIndex, 1);
      newOrder.splice(targetIndex, 0, draggedResolver);

      setResolverOrder(newOrder);
      console.log('Resolver order updated:', newOrder);
    }

    setDraggedResolver(null);
    setDragOverResolver(null);
    return false;
  };

  const handleResolverDragEnd = () => {
    setDraggedResolver(null);
    setDragOverResolver(null);
  };

  // Install new resolver from .axe file (hot-reload, no restart)
  const handleInstallResolver = async () => {
    if (!window.electron?.resolvers?.pickFile) {
      showConfirmDialog({
        type: 'error',
        title: 'Not Available',
        message: 'File picker not available. Make sure you are running in Electron.'
      });
      return;
    }

    console.log('ðŸ“¦ Opening file picker for resolver...');

    try {
      const result = await window.electron.resolvers.pickFile();

      if (!result) {
        console.log('User cancelled file picker');
        return;
      }

      if (result.error) {
        showConfirmDialog({
          type: 'error',
          title: 'File Error',
          message: result.error
        });
        return;
      }
      
      const { content, filename } = result;
      
      // Parse to validate and get info
      const axe = JSON.parse(content);
      const resolverName = axe.manifest.name;
      const resolverId = axe.manifest.id;
      
      // Check if already installed
      const existing = allResolvers.find(r => r.id === resolverId);
      if (existing) {
        const shouldOverwrite = confirm(
          `Resolver "${resolverName}" (${resolverId}) is already installed.\n\n` +
          `Do you want to overwrite it with the new version?`
        );
        if (!shouldOverwrite) {
          return;
        }
      }
      
      console.log(`Installing resolver: ${resolverName}`);
      
      // Install via IPC
      const installResult = await window.electron.resolvers.install(content, filename);
      
      if (!installResult.success) {
        showConfirmDialog({
          type: 'error',
          title: 'Installation Failed',
          message: installResult.error
        });
        return;
      }
      
      console.log(`âœ… Installed ${resolverName}`);
      
      // Hot-reload: Load the new resolver without restarting
      try {
                axe._filename = filename;
        const newResolverInstance = await resolverLoader.current.loadResolver(axe);
        
        if (existing) {
          // Replace existing resolver
          setLoadedResolvers(prev => prev.map(r => 
            r.id === resolverId ? newResolverInstance : r
          ));
          console.log(`ðŸ”„ Updated resolver: ${resolverName}`);
          showConfirmDialog({
            type: 'success',
            title: 'Resolver Updated',
            message: resolverName
          });
        } else {
          // Add new resolver
          setLoadedResolvers(prev => [...prev, newResolverInstance]);

          // Add to resolver order
          setResolverOrder(prev => [...prev, resolverId]);

          // Enable by default
          setActiveResolvers(prev => [...prev, resolverId]);

          console.log(`âž• Added resolver: ${resolverName}`);
          showConfirmDialog({
            type: 'success',
            title: 'Resolver Installed',
            message: resolverName
          });
        }
      } catch (error) {
        console.error('Failed to hot-load resolver:', error);
        showConfirmDialog({
          type: 'error',
          title: 'Load Failed',
          message: `Resolver installed but failed to load. Please restart the app.\n\n${error.message}`
        });
      }
    } catch (error) {
      console.error('Error installing resolver:', error);
      showConfirmDialog({
        type: 'error',
        title: 'Installation Error',
        message: error.message
      });
    }
  };

  // Uninstall resolver (permanently delete from disk)
  const handleUninstallResolver = async (resolverId) => {
    console.log('=== handleUninstallResolver called ===');
    console.log('  Resolver ID:', resolverId);
    console.log('  Loaded resolvers count (ref):', loadedResolversRef.current.length);
    console.log('  Loaded resolver IDs (ref):', loadedResolversRef.current.map(r => r.id));

    const resolver = loadedResolversRef.current.find(r => r.id === resolverId);

    if (!resolver) {
      console.error('âŒ Resolver not found:', resolverId);
      showConfirmDialog({
        type: 'error',
        title: 'Resolver Not Found',
        message: `Resolver "${resolverId}" not found. This might be a bug.`
      });
      return;
    }

    console.log('  Found resolver:', resolver.name);

    const confirmMessage = `Are you sure you want to uninstall "${resolver.name}"?\n\nThis will permanently remove the resolver from your system.`;

    const shouldUninstall = confirm(confirmMessage);

    if (!shouldUninstall) {
      return;
    }

    console.log(`ðŸ—‘ï¸ Uninstalling resolver: ${resolver.name}`);

    try {
      // Delete the resolver file from disk
      const result = await window.electron.resolvers.uninstall(resolverId);

      if (!result.success) {
        showConfirmDialog({
          type: 'error',
          title: 'Uninstall Failed',
          message: result.error
        });
        return;
      }

      console.log(`âœ… Uninstalled ${resolver.name}`);

      // Remove the resolver's sources from all displayed tracks
      removeResolverSources(resolverId);

      // Hot-reload: Remove from state without restarting
      setLoadedResolvers(prev => prev.filter(r => r.id !== resolverId));
      setResolverOrder(prev => prev.filter(id => id !== resolverId));
      setActiveResolvers(prev => prev.filter(id => id !== resolverId));

      showConfirmDialog({
        type: 'success',
        title: 'Resolver Uninstalled',
        message: resolver.name
      });
    } catch (error) {
      console.error('Error uninstalling resolver:', error);
      showConfirmDialog({
        type: 'error',
        title: 'Uninstall Error',
        message: error.message
      });
    }
  };

  // Marketplace functions
  const loadMarketplaceManifest = async () => {
    if (!window.electron?.resolvers?.getMarketplaceManifest) {
      console.error('Marketplace not available');
      return;
    }

    setMarketplaceLoading(true);

    try {
      const result = await window.electron.resolvers.getMarketplaceManifest();

      if (result.success) {
        setMarketplaceManifest(result.manifest);
        console.log(`âœ… Loaded marketplace with ${result.manifest.resolvers.length} resolvers`);
      } else {
        console.error('Failed to load marketplace:', result.error);
        setMarketplaceManifest({ version: '1.0.0', resolvers: [] });
      }
    } catch (error) {
      console.error('Marketplace load error:', error);
      setMarketplaceManifest({ version: '1.0.0', resolvers: [] });
    } finally {
      setMarketplaceLoading(false);
    }
  };

  // Install resolver from marketplace
  const handleInstallFromMarketplace = async (marketplaceResolver) => {
    const { id, name, downloadUrl } = marketplaceResolver;

    // Check if already installing
    if (installingResolvers.has(id)) {
      return;
    }

    setInstallingResolvers(prev => new Set(prev).add(id));

    console.log(`ðŸ“¦ Installing ${name} from marketplace...`);

    try {
      // Download resolver from URL
      const downloadResult = await window.electron.resolvers.downloadResolver(downloadUrl);

      if (!downloadResult.success) {
        showConfirmDialog({
          type: 'error',
          title: 'Download Failed',
          message: `Failed to download ${name}: ${downloadResult.error}`
        });
        return;
      }

      const { content, filename, resolver: axe } = downloadResult;
      const resolverName = axe.manifest.name;
      const resolverId = axe.manifest.id;

      // Check if already installed
      const existing = allResolvers.find(r => r.id === resolverId);
      if (existing) {
        const shouldOverwrite = confirm(
          `Resolver "${resolverName}" is already installed.\n\n` +
          `Installed version: ${existing.version}\n` +
          `Marketplace version: ${axe.manifest.version}\n\n` +
          `Do you want to update it?`
        );
        if (!shouldOverwrite) {
          return;
        }
      }

      // Install via IPC (reuse existing install handler)
      const installResult = await window.electron.resolvers.install(content, filename);

      if (!installResult.success) {
        showConfirmDialog({
          type: 'error',
          title: 'Installation Failed',
          message: `Failed to install ${resolverName}: ${installResult.error}`
        });
        return;
      }

      // Hot-reload
            axe._filename = filename;
      const newResolverInstance = await resolverLoader.current.loadResolver(axe);

      if (existing) {
        setLoadedResolvers(prev => prev.map(r =>
          r.id === resolverId ? newResolverInstance : r
        ));
        showConfirmDialog({
          type: 'success',
          title: 'Resolver Updated',
          message: resolverName
        });
      } else {
        setLoadedResolvers(prev => [...prev, newResolverInstance]);
        setResolverOrder(prev => [...prev, resolverId]);
        setActiveResolvers(prev => [...prev, resolverId]);
        showConfirmDialog({
          type: 'success',
          title: 'Resolver Installed',
          message: resolverName
        });
      }
    } catch (error) {
      console.error('Marketplace install error:', error);
      showConfirmDialog({
        type: 'error',
        title: 'Installation Failed',
        message: error.message
      });
    } finally {
      setInstallingResolvers(prev => {
        const next = new Set(prev);
        next.delete(id);
        return next;
      });
    }
  };

  // Load marketplace when settings page opens to marketplace tab
  useEffect(() => {
    if (activeView === 'settings' && settingsTab === 'marketplace' && !marketplaceManifest) {
      loadMarketplaceManifest();
    }
  }, [activeView, settingsTab, marketplaceManifest]);

  // Playlist functions
  const parseXSPF = (xspfString) => {
    try {
      const parser = new DOMParser();
      const xml = parser.parseFromString(xspfString, 'text/xml');

      // Parse date from XSPF (ISO 8601 format)
      const dateStr = xml.querySelector('playlist > date')?.textContent;
      const parsedDate = dateStr ? new Date(dateStr).getTime() : null;

      const playlist = {
        title: xml.querySelector('playlist > title')?.textContent || 'Untitled Playlist',
        creator: xml.querySelector('playlist > creator')?.textContent || 'Unknown',
        date: parsedDate, // Original creation date from XSPF
        tracks: []
      };
      
      const trackElements = xml.querySelectorAll('track');
      trackElements.forEach(trackEl => {
        const track = {
          title: trackEl.querySelector('title')?.textContent || 'Unknown Track',
          artist: trackEl.querySelector('creator')?.textContent || 'Unknown Artist',
          album: trackEl.querySelector('album')?.textContent || '',
          duration: parseInt(trackEl.querySelector('duration')?.textContent || '0') / 1000, // Convert ms to seconds
          location: trackEl.querySelector('location')?.textContent || ''
        };
        playlist.tracks.push(track);
      });
      
      return playlist;
    } catch (error) {
      console.error('Error parsing XSPF:', error);
      return null;
    }
  };

  // Generate XSPF content from playlist object
  const generateXSPF = (playlist) => {
    const escapeXml = (str) => {
      if (!str) return '';
      return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&apos;');
    };

    const tracks = (playlist.tracks || []).map(track => `    <track>
      <title>${escapeXml(track.title)}</title>
      <creator>${escapeXml(track.artist)}</creator>
      <album>${escapeXml(track.album || '')}</album>
      <duration>${Math.round((track.duration || 0) * 1000)}</duration>
    </track>`).join('\n');

    const date = playlist.createdAt ? new Date(playlist.createdAt).toISOString() : new Date().toISOString();

    return `<?xml version="1.0" encoding="UTF-8"?>
<playlist version="1" xmlns="http://xspf.org/ns/0/">
  <title>${escapeXml(playlist.title)}</title>
  <creator>${escapeXml(playlist.creator || 'Parachord')}</creator>
  <date>${date}</date>
  <trackList>
${tracks}
  </trackList>
</playlist>`;
  };

  // Open save dialog for AI playlist
  const handleAiSavePlaylist = () => {
    if (!resultsSidebar?.tracks) return;

    // Set default name based on prompt
    const defaultName = resultsSidebar.prompt
      ? resultsSidebar.prompt.substring(0, 50)
      : 'AI Generated Playlist';

    setAiSavePlaylistName(defaultName);
    setAiSaveDialogOpen(true);
  };

  // Actually save the AI playlist with the chosen name
  const handleAiSavePlaylistConfirm = async () => {
    if (!resultsSidebar?.tracks || !aiSavePlaylistName.trim()) return;

    const playlistId = `ai-${Date.now()}`;
    const providerName = resultsSidebar.provider?.name || 'AI';

    const newPlaylist = {
      id: playlistId,
      title: aiSavePlaylistName.trim(),
      creator: providerName,
      tracks: resultsSidebar.tracks,
      createdAt: Date.now(),
      addedAt: Date.now(),
      lastModified: Date.now()
    };

    // Add to playlists state (prepend so it appears at top immediately)
    setPlaylists(prev => [newPlaylist, ...prev]);

    // Save to unified local storage (electron-store)
    await savePlaylistToStore(newPlaylist);

    // Close dialogs
    setAiSaveDialogOpen(false);
    setResultsSidebar(null);
    showToast(`Saved playlist: ${aiSavePlaylistName.trim()}`);
  };

  // Save playlist to local storage (electron-store)
  const savePlaylistToStore = async (playlist) => {
    if (!playlist || !playlist.id) return;

    // Don't save hosted playlists (they come from URLs)
    if (playlist.sourceUrl) {
      console.log(`â­ï¸ Skipping save for hosted playlist: ${playlist.title}`);
      return;
    }

    // Invalidate playlist cover cache when tracks change
    // This ensures the 2x2 cover grid regenerates with new tracks
    if (playlistCoverCache.current[playlist.id]) {
      delete playlistCoverCache.current[playlist.id];
      // Also clear from UI state so it re-fetches
      setAllPlaylistCovers(prev => {
        const updated = { ...prev };
        delete updated[playlist.id];
        return updated;
      });
    }

    try {
      // Generate XSPF content for the playlist
      const xspfContent = generateXSPF(playlist);

      // Create playlist data object for storage
      const playlistData = {
        id: playlist.id,
        title: playlist.title,
        creator: playlist.creator,
        tracks: playlist.tracks,
        xspf: xspfContent,
        createdAt: playlist.createdAt || Date.now(),
        addedAt: playlist.addedAt || Date.now(),
        lastModified: Date.now(),
        isAiPlaylist: playlist.isAiPlaylist || false
      };

      const result = await window.electron.playlists.save(playlistData);

      if (result.success) {
        console.log(`ðŸ’¾ Saved playlist: ${playlist.title}`);
      } else {
        console.error(`âŒ Failed to save playlist: ${result.error}`);
      }
    } catch (error) {
      console.error(`âŒ Error saving playlist:`, error);
    }
  };

  // Parse Critic's Picks RSS feed
  const parseCriticsPicksRSS = (rssString) => {
    try {
      const parser = new DOMParser();
      const xml = parser.parseFromString(rssString, 'text/xml');

      const items = xml.querySelectorAll('item');
      const albums = [];

      items.forEach(item => {
        const titleText = item.querySelector('title')?.textContent || '';
        const link = item.querySelector('link')?.textContent || '';
        const descriptionRaw = item.querySelector('description')?.textContent || '';
        const pubDate = item.querySelector('pubDate')?.textContent || '';

        // Extract Spotify URL from description before stripping HTML
        const spotifyMatch = descriptionRaw.match(/href="(https:\/\/open\.spotify\.com\/album\/[^"]+)"/);
        const spotifyUrl = spotifyMatch ? spotifyMatch[1] : null;

        // Strip HTML tags and remove any remaining Spotify URLs from the synopsis
        let description = descriptionRaw.replace(/<[^>]*>/g, '').trim();
        // Remove plain text Spotify URLs that might remain after HTML stripping
        description = description.replace(/https:\/\/open\.spotify\.com\/album\/\S+/g, '').trim();

        // Parse "Album by Artist" format
        // Examples: "Valentine by Courtney Marie Andrews", "Tragic Magic by Julianna Barwick & Mary Lattimore"
        let artist = '';
        let album = '';

        const byMatch = titleText.match(/^(.+?)\s+by\s+(.+)$/i);
        if (byMatch) {
          album = byMatch[1].trim();
          artist = byMatch[2].trim();
        } else {
          // Fallback: use full title as album name
          artist = 'Unknown Artist';
          album = titleText;
        }

        if (album) {
          albums.push({
            id: `critics-${artist}-${album}`.toLowerCase().replace(/[^a-z0-9-]/g, '-'),
            artist: artist,
            title: album,
            link: link,
            description: description,
            spotifyUrl: spotifyUrl,
            pubDate: pubDate ? new Date(pubDate) : null,
            albumArt: undefined // undefined = loading, null = no art found, string = art URL
          });
        }
      });

      return albums;
    } catch (error) {
      console.error('Error parsing Critic\'s Picks RSS:', error);
      return [];
    }
  };

  // Parse Apple Music Charts JSON feed
  const parseChartsJSON = (data) => {
    try {
      const results = data?.feed?.results || [];
      const albums = [];

      results.forEach((item, index) => {
        const album = item.name || '';
        const artist = item.artistName || '';
        const artworkUrl = item.artworkUrl100 || '';
        const link = item.url || '';
        const genres = (item.genres || [])
          .map(g => g.name)
          .filter(g => g !== 'Music');

        if (album && artist) {
          albums.push({
            id: `charts-${index}-${artist}-${album}`.toLowerCase().replace(/[^a-z0-9-]/g, '-'),
            artist: artist,
            title: album,
            rank: index + 1,
            link: link,
            genres: genres,
            pubDate: item.releaseDate ? new Date(item.releaseDate) : null,
            // Use artwork URL directly from JSON (higher quality available)
            albumArt: artworkUrl ? artworkUrl.replace('100x100bb', '300x300bb') : null
          });
        }
      });

      return albums;
    } catch (error) {
      console.error('Error parsing Charts JSON:', error);
      return [];
    }
  };

  // Parse Apple Music Charts RSS feed (legacy fallback)
  const parseChartsRSS = (rssString) => {
    try {
      const parser = new DOMParser();
      const xml = parser.parseFromString(rssString, 'text/xml');

      const items = xml.querySelectorAll('item');
      const albums = [];

      items.forEach((item, index) => {
        const titleText = item.querySelector('title')?.textContent || '';
        const link = item.querySelector('link')?.textContent || '';
        const description = item.querySelector('description')?.textContent || '';
        const pubDate = item.querySelector('pubDate')?.textContent || '';

        // Get artist from category with domain attribute
        const categories = item.querySelectorAll('category');
        let artist = '';
        let genres = [];

        categories.forEach(cat => {
          if (cat.getAttribute('domain')) {
            // Category with domain is the artist link
            artist = cat.textContent || '';
          } else {
            // Categories without domain are genres
            genres.push(cat.textContent);
          }
        });

        // Title format is "Album Name - Artist Name"
        // But we already have artist from category, so extract album from title
        let album = titleText;
        if (titleText.includes(' - ') && artist) {
          album = titleText.replace(` - ${artist}`, '').trim();
        }

        // Fallback: if no artist from category, try parsing from title
        if (!artist && titleText.includes(' - ')) {
          const parts = titleText.split(' - ');
          album = parts[0].trim();
          artist = parts.slice(1).join(' - ').trim();
        }

        if (album && artist) {
          albums.push({
            id: `charts-${index}-${artist}-${album}`.toLowerCase().replace(/[^a-z0-9-]/g, '-'),
            artist: artist,
            title: album,
            rank: index + 1,
            link: link,
            genres: genres.filter(g => g !== 'Music'),
            pubDate: pubDate ? new Date(pubDate) : null,
            albumArt: null
          });
        }
      });

      return albums;
    } catch (error) {
      console.error('Error parsing Charts RSS:', error);
      return [];
    }
  };

  // Load Critic's Picks from RSS feed
  const loadCriticsPicks = async () => {
    if (criticsPicksLoading || criticsPicksLoaded) return;

    setCriticsPicksLoading(true);
    console.log('ðŸ“° Loading Critic\'s Picks...');

    try {
      const response = await fetch('https://www.rssground.com/p/uncoveries');
      if (!response.ok) {
        throw new Error(`Failed to fetch RSS: ${response.status}`);
      }

      const rssText = await response.text();
      const albums = parseCriticsPicksRSS(rssText);

      console.log(`ðŸ“° Parsed ${albums.length} albums from Critic's Picks`);

      // Set albums immediately (without album art)
      setCriticsPicks(albums);
      setCriticsPicksLoaded(true);

      // Fetch album art in background
      fetchCriticsPicksAlbumArt(albums);

    } catch (error) {
      console.error('Failed to load Critic\'s Picks:', error);
      showConfirmDialog({
        type: 'error',
        title: 'Load Failed',
        message: 'Failed to load Critic\'s Picks. Please try again.'
      });
    } finally {
      setCriticsPicksLoading(false);
    }
  };

  // Load Charts from Apple Music JSON feed
  const loadCharts = async () => {
    if (chartsLoading || chartsLoaded) return;

    setChartsLoading(true);
    console.log('ðŸ“Š Loading Charts...');

    try {
      // Use JSON endpoint instead of RSS (RSS returns 500 intermittently)
      const response = await fetch('https://rss.applemarketingtools.com/api/v2/us/music/most-played/50/albums.json');
      if (!response.ok) {
        throw new Error(`Failed to fetch charts: ${response.status}`);
      }

      const data = await response.json();
      const albums = parseChartsJSON(data);

      console.log(`ðŸ“Š Parsed ${albums.length} albums from Charts`);

      setCharts(albums);
      setChartsLoaded(true);

      // Wait for cache to be loaded before fetching album art
      if (cacheLoaded) {
        fetchChartsAlbumArt(albums);
      } else {
        // If cache not ready, wait a bit and try again
        const waitForCache = setInterval(() => {
          if (cacheLoaded) {
            clearInterval(waitForCache);
            fetchChartsAlbumArt(albums);
          }
        }, 100);
      }

    } catch (error) {
      console.error('Failed to load Charts:', error);
      showConfirmDialog({
        type: 'error',
        title: 'Load Failed',
        message: 'Failed to load Charts. Please try again.'
      });
    } finally {
      setChartsLoading(false);
    }
  };

  // Fetch album art for Charts in background
  const fetchChartsAlbumArt = async (albums) => {
    const albumsNeedingFetch = [];
    const cachedUpdates = [];

    for (const album of albums) {
      // Skip albums that already have artwork from the JSON feed
      if (album.albumArt) continue;

      const lookupKey = `${album.artist}-${album.title}`.toLowerCase();
      const cachedReleaseId = albumToReleaseIdCache.current[lookupKey];

      if (cachedReleaseId && albumArtCache.current[cachedReleaseId]?.url) {
        cachedUpdates.push({ id: album.id, albumArt: albumArtCache.current[cachedReleaseId].url });
      } else if (cachedReleaseId !== null) {
        albumsNeedingFetch.push(album);
      }
    }

    if (cachedUpdates.length > 0) {
      console.log(`ðŸ“Š Using cached art for ${cachedUpdates.length} Charts albums`);
      setCharts(prev => prev.map(a => {
        const cached = cachedUpdates.find(u => u.id === a.id);
        return cached ? { ...a, albumArt: cached.albumArt } : a;
      }));
    }

    for (const album of albumsNeedingFetch) {
      try {
        const artUrl = await getAlbumArt(album.artist, album.title);
        if (artUrl) {
          setCharts(prev => prev.map(a =>
            a.id === album.id ? { ...a, albumArt: artUrl } : a
          ));
        }
      } catch (error) {
        console.log(`Could not fetch art for: ${album.artist} - ${album.title}`);
      }
      // MusicBrainz rate limit: 1 request per second
      await new Promise(resolve => setTimeout(resolve, 1100));
    }
  };

  // Navigate to a Charts album release page
  const openChartsAlbum = async (album) => {
    console.log(`ðŸŽµ Opening Chart Album: ${album.artist} - ${album.title}`);

    try {
      // Search MusicBrainz for the release
      const searchQuery = encodeURIComponent(`release:"${album.title}" AND artist:"${album.artist}"`);
      const mbResponse = await fetch(
        `https://musicbrainz.org/ws/2/release/?query=${searchQuery}&fmt=json&limit=1`,
        { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' } }
      );

      if (!mbResponse.ok) {
        throw new Error('MusicBrainz search failed');
      }

      const mbData = await mbResponse.json();

      if (!mbData.releases || mbData.releases.length === 0) {
        // Fallback: just navigate to artist page
        console.log('Release not found in MusicBrainz, navigating to artist page');
        fetchArtistData(album.artist);
        return;
      }

      const release = mbData.releases[0];
      const artistCredit = release['artist-credit']?.[0];

      // Create artist object for the release page
      const artist = {
        id: artistCredit?.artist?.id,
        name: artistCredit?.artist?.name || album.artist
      };

      // Create release object matching the expected format
      const releaseObj = {
        id: release.id,
        title: release.title,
        date: release.date,
        releaseType: release['release-group']?.['primary-type']?.toLowerCase() || 'album',
        albumArt: album.albumArt
      };

      // Set artist context and fetch release data
      // Mark that we're opening a release so header stays collapsed
      openingReleaseRef.current = true;
      setCurrentArtist(artist);
      navigateTo('artist');
      fetchReleaseData(releaseObj, artist);

    } catch (error) {
      console.error('Error opening chart album:', error);
      // Fallback: navigate to artist page
      fetchArtistData(album.artist);
    }
  };

  // Prefetch tracks for a Charts album on hover
  const prefetchChartsTracks = async (album) => {
    // Skip if already prefetched
    if (prefetchedReleases[album.id]) {
      return;
    }

    try {
      const searchQuery = encodeURIComponent(`release:"${album.title}" AND artist:"${album.artist}"`);
      const mbResponse = await fetch(
        `https://musicbrainz.org/ws/2/release/?query=${searchQuery}&fmt=json&limit=1`,
        { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' } }
      );

      if (!mbResponse.ok) return;

      const mbData = await mbResponse.json();
      if (!mbData.releases || mbData.releases.length === 0) return;

      const releaseId = mbData.releases[0].id;

      // Fetch release details with tracks
      const releaseDetailsResponse = await fetch(
        `https://musicbrainz.org/ws/2/release/${releaseId}?inc=recordings&fmt=json`,
        { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' } }
      );

      if (!releaseDetailsResponse.ok) return;

      const releaseData = await releaseDetailsResponse.json();
      const tracks = [];

      releaseData.media?.forEach(medium => {
        medium.tracks?.forEach(track => {
          tracks.push({
            id: track.recording?.id || track.id,
            title: track.title,
            artist: album.artist,
            duration: track.length ? Math.round(track.length / 1000) : null,
            albumArt: album.albumArt
          });
        });
      });

      if (tracks.length > 0) {
        setPrefetchedReleases(prev => ({
          ...prev,
          [album.id]: {
            tracks,
            title: album.title,
            albumArt: album.albumArt
          }
        }));
      }
    } catch (error) {
      // Silent fail for prefetch
    }
  };

  // Add all tracks from a Charts album to the queue
  const addChartsToQueue = async (album) => {
    console.log(`âž• Adding chart album to queue: ${album.artist} - ${album.title}`);

    try {
      const searchQuery = encodeURIComponent(`release:"${album.title}" AND artist:"${album.artist}"`);
      const mbResponse = await fetch(
        `https://musicbrainz.org/ws/2/release/?query=${searchQuery}&fmt=json&limit=1`,
        { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' } }
      );

      if (!mbResponse.ok) throw new Error('MusicBrainz search failed');

      const mbData = await mbResponse.json();
      if (!mbData.releases?.[0]) {
        showConfirmDialog({
          type: 'error',
          title: 'Album Not Found',
          message: `Could not find tracks for "${album.title}"`
        });
        return;
      }

      const releaseId = mbData.releases[0].id;
      const tracksResponse = await fetch(
        `https://musicbrainz.org/ws/2/release/${releaseId}?inc=recordings&fmt=json`,
        { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' } }
      );

      if (!tracksResponse.ok) throw new Error('Failed to fetch tracks');

      const releaseData = await tracksResponse.json();
      const tracks = [];

      releaseData.media?.forEach(medium => {
        medium.tracks?.forEach(track => {
          tracks.push({
            id: track.recording?.id || track.id,
            title: track.title,
            artist: album.artist,
            duration: track.length ? Math.round(track.length / 1000) : null,
            albumArt: album.albumArt
          });
        });
      });

      if (tracks.length > 0) {
        const context = { type: 'album', id: album.id, name: album.title, artist: album.artist };
        addToQueue(tracks, context);
        showConfirmDialog({
          type: 'success',
          title: 'Added to Queue',
          message: `Added ${tracks.length} tracks from "${album.title}"`
        });
      }
    } catch (error) {
      console.error('Error adding chart album to queue:', error);
      showConfirmDialog({
        type: 'error',
        title: 'Error',
        message: 'Failed to add album to queue. Please try again.'
      });
    }
  };

  // Load Recommendations from Last.fm and/or ListenBrainz (merged and de-duped)
  const loadRecommendations = async (forceRefresh = false) => {
    // Check if Last.fm or ListenBrainz is configured
    const lastfmConfig = metaServiceConfigs.lastfm;
    const listenbrainzConfig = metaServiceConfigs.listenbrainz;

    if (!lastfmConfig?.username && !listenbrainzConfig?.username) {
      console.log('â­ No recommendation service configured, skipping recommendations load');
      setRecommendations({
        artists: [],
        tracks: [],
        loading: false,
        error: 'not_configured'
      });
      return;
    }

    // Check if we have valid cached data
    const now = Date.now();
    const cacheValid = !forceRefresh &&
                       recommendationsCache.current.tracks &&
                       (now - recommendationsCache.current.timestamp) < CACHE_TTL.recommendations;

    if (cacheValid) {
      console.log(`â­ Using cached recommendations (${Math.round((now - recommendationsCache.current.timestamp) / 60000)}m old)`);
      const tracks = recommendationsCache.current.tracks;

      // Extract unique artists, pre-populating images from cache for instant display
      const artistMap = new Map();
      tracks.forEach(track => {
        if (track.artist && !artistMap.has(track.artist)) {
          const normalizedName = track.artist.trim().toLowerCase();
          const cachedImage = artistImageCache.current[normalizedName];
          const imageCacheValid = cachedImage && (now - cachedImage.timestamp) < CACHE_TTL.artistImage;

          artistMap.set(track.artist, {
            id: track.artist.toLowerCase().replace(/[^a-z0-9]/g, '-'),
            name: track.artist,
            image: imageCacheValid ? cachedImage.url : null,
            imageLoaded: imageCacheValid
          });
        }
      });
      const artists = Array.from(artistMap.values());

      setRecommendations({
        artists,
        tracks,
        loading: false,
        error: null
      });

      // Fetch images for artists not in cache
      const artistsNeedingImages = artists.filter(a => !a.imageLoaded);
      if (artistsNeedingImages.length > 0) {
        resolveRecommendationArtistImages(artistsNeedingImages);
      }
      return;
    }

    setRecommendations(prev => ({ ...prev, loading: true, error: null }));

    try {
      // Fetch from both services in parallel if both are configured
      const fetchPromises = [];

      if (listenbrainzConfig?.username) {
        console.log(`â­ Loading Recommendations from ListenBrainz for ${listenbrainzConfig.username}...`);
        fetchPromises.push(
          loadListenbrainzRecommendations(listenbrainzConfig.username)
            .catch(err => { console.error('ListenBrainz recommendations error:', err); return []; })
        );
      } else {
        fetchPromises.push(Promise.resolve([]));
      }

      if (lastfmConfig?.username) {
        console.log(`â­ Loading Recommendations from Last.fm for ${lastfmConfig.username}...`);
        fetchPromises.push(
          loadLastfmRecommendations(lastfmConfig.username)
            .catch(err => { console.error('Last.fm recommendations error:', err); return []; })
        );
      } else {
        fetchPromises.push(Promise.resolve([]));
      }

      const [listenbrainzTracks, lastfmTracks] = await Promise.all(fetchPromises);

      // Merge and de-dupe tracks (ListenBrainz first since it has MBID metadata)
      const seenTracks = new Set();
      const tracks = [];

      for (const track of listenbrainzTracks) {
        const key = `${track.artist.toLowerCase().trim()}|${track.title.toLowerCase().trim()}`;
        if (!seenTracks.has(key)) {
          seenTracks.add(key);
          tracks.push({ ...track, source: 'listenbrainz' });
        }
      }

      for (const track of lastfmTracks) {
        const key = `${track.artist.toLowerCase().trim()}|${track.title.toLowerCase().trim()}`;
        if (!seenTracks.has(key)) {
          seenTracks.add(key);
          tracks.push({ ...track, source: 'lastfm' });
        }
      }

      console.log(`â­ Merged ${listenbrainzTracks.length} ListenBrainz + ${lastfmTracks.length} Last.fm tracks â†’ ${tracks.length} unique tracks`);

      // Cache the merged tracks for quick reload
      recommendationsCache.current = {
        tracks,
        timestamp: Date.now()
      };

      // Extract unique artists, pre-populating images from cache for instant display
      const artistMap = new Map();
      const now = Date.now();
      tracks.forEach(track => {
        if (track.artist && !artistMap.has(track.artist)) {
          const normalizedName = track.artist.trim().toLowerCase();
          const cachedImage = artistImageCache.current[normalizedName];
          const cacheValid = cachedImage && (now - cachedImage.timestamp) < CACHE_TTL.artistImage;

          artistMap.set(track.artist, {
            id: track.artist.toLowerCase().replace(/[^a-z0-9]/g, '-'),
            name: track.artist,
            image: cacheValid ? cachedImage.url : null,
            imageLoaded: cacheValid // Already loaded if we have valid cache
          });
        }
      });
      const artists = Array.from(artistMap.values());
      const cachedCount = artists.filter(a => a.imageLoaded).length;

      console.log(`â­ Extracted ${artists.length} unique artists (${cachedCount} with cached images)`);

      // Set initial state with tracks (sources empty, will resolve via scheduler)
      setRecommendations({
        artists,
        tracks,
        loading: false,
        error: null
      });

      // Only fetch images for artists not already in cache
      const artistsNeedingImages = artists.filter(a => !a.imageLoaded);
      if (artistsNeedingImages.length > 0) {
        resolveRecommendationArtistImages(artistsNeedingImages);
      } else {
        console.log(`â­ All artist images loaded from cache`);
      }

    } catch (error) {
      console.error('Failed to load Recommendations:', error);
      setRecommendations(prev => ({
        ...prev,
        loading: false,
        error: 'Failed to load recommendations. Please try again.'
      }));
    }
  };

  // Load recommendations from Last.fm
  const loadLastfmRecommendations = async (username) => {
    const response = await fetch(`https://www.last.fm/player/station/user/${encodeURIComponent(username)}/recommended`);
    if (!response.ok) {
      throw new Error(`Failed to fetch Last.fm recommendations: ${response.status}`);
    }

    const data = await response.json();
    const playlist = data.playlist || [];

    // Transform tracks to app format with empty sources (will be resolved)
    return playlist.map((track, index) => ({
      id: track.spelling_id || `rec-${index}-${track.name}-${track.artists?.[0]?.name}`.replace(/\s+/g, '-'),
      title: track.name || track._name,
      artist: track.artists?.[0]?.name || track.artists?.[0]?._name || 'Unknown Artist',
      duration: track.duration || null,
      sources: {} // Will be populated by resolver pipeline
    }));
  };

  // Load recommendations from ListenBrainz
  const loadListenbrainzRecommendations = async (username) => {
    // ListenBrainz has a recommendations endpoint that returns personalized playlists
    // First try to get recommendation playlists
    const playlistsResponse = await fetch(`https://api.listenbrainz.org/1/user/${encodeURIComponent(username)}/playlists/recommendations`);

    if (playlistsResponse.ok) {
      const playlistsData = await playlistsResponse.json();
      const playlists = playlistsData.playlists || [];

      // Get the most recent recommendation playlist
      if (playlists.length > 0) {
        const latestPlaylist = playlists[0];
        const playlistId = latestPlaylist.playlist?.identifier?.split('/').pop();

        if (playlistId) {
          // Fetch the full playlist with tracks
          const playlistResponse = await fetch(`https://api.listenbrainz.org/1/playlist/${playlistId}`);
          if (playlistResponse.ok) {
            const playlistData = await playlistResponse.json();
            const tracks = playlistData.playlist?.track || [];

            return tracks.map((track, index) => ({
              id: track.identifier?.[0]?.split('/').pop() || `lb-rec-${index}-${track.title}`.replace(/\s+/g, '-'),
              title: track.title || 'Unknown Track',
              artist: track.creator || 'Unknown Artist',
              duration: track.duration ? Math.floor(track.duration / 1000) : null,
              sources: {},
              mbid: track.identifier?.[0]?.split('/').pop() || null
            }));
          }
        }
      }
    }

    // Fallback: use top recordings as pseudo-recommendations
    console.log('â­ No ListenBrainz recommendation playlists found, falling back to top recordings');
    const statsResponse = await fetch(`https://api.listenbrainz.org/1/stats/user/${encodeURIComponent(username)}/recordings?range=month&count=50`);

    if (statsResponse.ok) {
      const statsData = await statsResponse.json();
      const recordings = statsData.payload?.recordings || [];

      return recordings.map((rec, index) => ({
        id: rec.recording_mbid || `lb-top-${index}-${rec.track_name}`.replace(/\s+/g, '-'),
        title: rec.track_name || 'Unknown Track',
        artist: rec.artist_name || 'Unknown Artist',
        duration: null,
        sources: {},
        mbid: rec.recording_mbid || null,
        listenCount: rec.listen_count
      }));
    }

    return [];
  };

  // Load charts when navigating to discover page (Pop of the Tops)
  useEffect(() => {
    // Only load if we're on the discover page AND cache is loaded AND charts haven't been loaded yet
    if (activeView === 'discover' && cacheLoaded && !chartsLoaded) {
      loadCharts();
    }
  }, [activeView, cacheLoaded, chartsLoaded]);

  // Load critics picks when navigating to critics-picks page
  useEffect(() => {
    // Only load if we're on the critics-picks page AND cache is loaded AND not already loaded
    if (activeView === 'critics-picks' && cacheLoaded && !criticsPicksLoaded) {
      loadCriticsPicks();
    }
  }, [activeView, cacheLoaded, criticsPicksLoaded]);

  // Load recommendations when navigating to the page or when config changes
  useEffect(() => {
    // Only load if we're on the recommendations page AND cache is loaded
    if (activeView === 'recommendations' && cacheLoaded) {
      loadRecommendations();
    }
  }, [activeView, cacheLoaded, metaServiceConfigs.lastfm?.username, metaServiceConfigs.listenbrainz?.username]);

  // Resolve recommendation tracks using the resolver pipeline
  // Fetch images for recommended artists
  const resolveRecommendationArtistImages = async (artists) => {
    console.log(`â­ Fetching images for ${artists.length} recommended artists...`);

    for (const artist of artists) {
      try {
        const result = await getArtistImage(artist.name);
        setRecommendations(prev => ({
          ...prev,
          artists: prev.artists.map(a =>
            a.id === artist.id ? { ...a, image: result?.url || null, imageLoaded: true } : a
          )
        }));
      } catch (err) {
        console.error(`Error fetching image for ${artist.name}:`, err);
        // Mark as loaded even on error so we show fallback icon instead of spinner
        setRecommendations(prev => ({
          ...prev,
          artists: prev.artists.map(a =>
            a.id === artist.id ? { ...a, imageLoaded: true } : a
          )
        }));
      }
    }
    console.log(`â­ Finished fetching recommended artist images`);
  };

  // Fetch images for search result artists
  const resolveSearchArtistImages = async (artists) => {
    console.log(`ðŸ” Fetching images for ${artists.length} search result artists...`);

    for (const artist of artists) {
      // Skip if already has image or is loading
      if (artist.image || artist.imageLoaded) continue;

      try {
        const result = await getArtistImage(artist.name);
        setSearchResults(prev => ({
          ...prev,
          artists: prev.artists.map(a =>
            a.id === artist.id ? { ...a, image: result?.url || null, imageLoaded: true } : a
          )
        }));
      } catch (err) {
        console.error(`Error fetching image for ${artist.name}:`, err);
        // Mark as loaded even on error so we show fallback icon instead of spinner
        setSearchResults(prev => ({
          ...prev,
          artists: prev.artists.map(a =>
            a.id === artist.id ? { ...a, imageLoaded: true } : a
          )
        }));
      }
    }
    console.log(`ðŸ” Finished fetching search result artist images`);
  };

  // Load Listening History from Last.fm and/or ListenBrainz (merged and de-duped)
  const loadListeningHistory = async (forceRefresh = false) => {
    // Get configs from metaServiceConfigs
    const lastfmConfig = metaServiceConfigs.lastfm;
    const listenbrainzConfig = metaServiceConfigs.listenbrainz;

    // If no service is configured
    if (!lastfmConfig?.username && !listenbrainzConfig?.username) {
      setListeningHistory({
        tracks: [],
        loading: false,
        error: 'No listening history service connected. Configure Last.fm or ListenBrainz in Settings > Resolvers.'
      });
      return;
    }

    // Check if we have valid cached data (cache for 5 minutes - recent history changes frequently)
    const now = Date.now();
    const cacheValid = !forceRefresh &&
                       listeningHistoryCache.current.tracks &&
                       (now - listeningHistoryCache.current.timestamp) < (5 * 60 * 1000);

    if (cacheValid) {
      console.log(`ðŸ“œ Using cached listening history (${Math.round((now - listeningHistoryCache.current.timestamp) / 60000)}m old)`);
      setListeningHistory({
        tracks: listeningHistoryCache.current.tracks,
        loading: false,
        error: null
      });
      return;
    }

    setListeningHistory(prev => ({ ...prev, loading: true, error: null }));
    console.log('ðŸ“œ Loading Listening History...');

    try {
      // Fetch from both services in parallel if both are configured
      const fetchPromises = [];

      if (listenbrainzConfig?.username) {
        console.log(`ðŸ“œ Loading history from ListenBrainz for ${listenbrainzConfig.username}...`);
        fetchPromises.push(
          loadListenbrainzHistory(listenbrainzConfig.username)
            .catch(err => { console.error('ListenBrainz history error:', err); return []; })
        );
      } else {
        fetchPromises.push(Promise.resolve([]));
      }

      if (lastfmConfig?.username) {
        const apiKey = lastfmApiKey.current;
        if (apiKey) {
          console.log(`ðŸ“œ Loading history from Last.fm for ${lastfmConfig.username}...`);
          fetchPromises.push(
            loadLastfmHistory(lastfmConfig.username, apiKey)
              .catch(err => { console.error('Last.fm history error:', err); return []; })
          );
        } else {
          console.log('ðŸ“œ Last.fm API key not configured, skipping Last.fm history');
          fetchPromises.push(Promise.resolve([]));
        }
      } else {
        fetchPromises.push(Promise.resolve([]));
      }

      const [listenbrainzTracks, lastfmTracks] = await Promise.all(fetchPromises);

      // Merge and de-dupe tracks by artist+title+timestamp (within 5 min window)
      // Sort by playedAt descending, keeping most recent plays
      const allTracks = [
        ...listenbrainzTracks.map(t => ({ ...t, source: 'listenbrainz' })),
        ...lastfmTracks.map(t => ({ ...t, source: 'lastfm' }))
      ].sort((a, b) => (b.playedAt || 0) - (a.playedAt || 0));

      const seenTracks = new Set();
      const tracks = [];

      for (const track of allTracks) {
        // Create a key that considers artist+title and groups listens within 5 minutes
        const timeWindow = track.playedAt ? Math.floor(track.playedAt / (5 * 60 * 1000)) : 'now';
        const key = `${track.artist.toLowerCase().trim()}|${track.title.toLowerCase().trim()}|${timeWindow}`;
        if (!seenTracks.has(key)) {
          seenTracks.add(key);
          tracks.push(track);
        }
      }

      console.log(`ðŸ“œ Merged ${listenbrainzTracks.length} ListenBrainz + ${lastfmTracks.length} Last.fm listens â†’ ${tracks.length} unique listens`);

      // Cache the tracks
      listeningHistoryCache.current = { tracks, timestamp: Date.now() };

      // Set initial state with tracks (resolution handled by scheduler via IntersectionObserver)
      setListeningHistory({
        tracks,
        loading: false,
        error: null
      });

    } catch (error) {
      console.error('Failed to load Listening History:', error);
      setListeningHistory({
        tracks: [],
        loading: false,
        error: error.message || 'Failed to load listening history. Please try again.'
      });
    }
  };

  // Period options for top charts
  const historyPeriodOptions = [
    { value: '7day', label: 'Last 7 Days' },
    { value: '1month', label: 'Last Month' },
    { value: '3month', label: 'Last 3 Months' },
    { value: '6month', label: 'Last 6 Months' },
    { value: '12month', label: 'Last Year' },
    { value: 'overall', label: 'All Time' }
  ];

  // Load Top Tracks from Last.fm
  const loadTopTracks = async (period = historyPeriod, forceRefresh = false) => {
    const lastfmConfig = metaServiceConfigs.lastfm;
    if (!lastfmConfig?.username) {
      setTopTracks({ tracks: [], loading: false, error: 'No Last.fm account connected.' });
      return;
    }

    const apiKey = lastfmApiKey.current;
    if (!apiKey) {
      setTopTracks({ tracks: [], loading: false, error: 'Last.fm API key not configured.' });
      return;
    }

    // Check if we have valid cached data for this period (cache for 30 minutes)
    const now = Date.now();
    const cachedEntry = topTracksCache.current[period];
    const cacheValid = !forceRefresh &&
                       cachedEntry?.tracks &&
                       (now - cachedEntry.timestamp) < (30 * 60 * 1000);

    if (cacheValid) {
      console.log(`ðŸ“Š Using cached top tracks for ${period} (${Math.round((now - cachedEntry.timestamp) / 60000)}m old)`);
      setTopTracks({
        tracks: cachedEntry.tracks,
        loading: false,
        error: null
      });
      return;
    }

    setTopTracks(prev => ({ ...prev, loading: true, error: null }));
    console.log(`ðŸ“Š Loading Top Tracks (${period})...`);

    try {
      const url = `https://ws.audioscrobbler.com/2.0/?method=user.gettoptracks&user=${encodeURIComponent(lastfmConfig.username)}&api_key=${apiKey}&format=json&period=${period}&limit=50`;
      const response = await fetch(url);

      if (!response.ok) throw new Error(`Failed to fetch top tracks: ${response.status}`);

      const data = await response.json();
      const topTracksList = data.toptracks?.track || [];

      console.log(`ðŸ“Š Received ${topTracksList.length} top tracks`);

      const tracks = topTracksList.map((track, index) => ({
        id: `top-track-${index}-${track.name}`.replace(/\s+/g, '-'),
        title: track.name,
        artist: track.artist?.name || 'Unknown Artist',
        album: null,
        albumArt: track.image?.[2]?.['#text'] || null,
        playCount: parseInt(track.playcount) || 0,
        rank: index + 1,
        sources: {}
      }));

      // Cache the tracks for this period
      topTracksCache.current[period] = { tracks, timestamp: Date.now() };

      // Resolution handled by scheduler via IntersectionObserver
      setTopTracks({ tracks, loading: false, error: null });
    } catch (error) {
      console.error('Failed to load Top Tracks:', error);
      setTopTracks({ tracks: [], loading: false, error: error.message });
    }
  };

  // Load Top Artists from Last.fm
  const loadTopArtists = async (period = historyPeriod) => {
    setTopArtists(prev => ({ ...prev, loading: true, error: null }));
    console.log(`ðŸ“Š Loading Top Artists (${period})...`);

    try {
      const lastfmConfig = metaServiceConfigs.lastfm;
      if (!lastfmConfig?.username) {
        setTopArtists({ artists: [], loading: false, error: 'No Last.fm account connected.' });
        return;
      }

      const apiKey = lastfmApiKey.current;
      if (!apiKey) {
        setTopArtists({ artists: [], loading: false, error: 'Last.fm API key not configured.' });
        return;
      }

      const url = `https://ws.audioscrobbler.com/2.0/?method=user.gettopartists&user=${encodeURIComponent(lastfmConfig.username)}&api_key=${apiKey}&format=json&period=${period}&limit=50`;
      const response = await fetch(url);

      if (!response.ok) throw new Error(`Failed to fetch top artists: ${response.status}`);

      const data = await response.json();
      const topArtistsList = data.topartists?.artist || [];

      console.log(`ðŸ“Š Received ${topArtistsList.length} top artists`);

      const artists = topArtistsList.map((artist, index) => ({
        id: `top-artist-${index}-${artist.name}`.replace(/\s+/g, '-'),
        name: artist.name,
        image: null, // Will be fetched from Spotify
        playCount: parseInt(artist.playcount) || 0,
        rank: index + 1
      }));

      setTopArtists({ artists, loading: false, error: null });

      // Fetch artist images from Spotify in background
      resolveTopArtistImages(artists);
    } catch (error) {
      console.error('Failed to load Top Artists:', error);
      setTopArtists({ artists: [], loading: false, error: error.message });
    }
  };

  // Resolve artist images from Spotify
  const resolveTopArtistImages = async (artists) => {
    console.log(`ðŸ“Š Fetching images for ${artists.length} top artists...`);

    for (const artist of artists) {
      try {
        const result = await getArtistImage(artist.name);
        setTopArtists(prev => ({
          ...prev,
          artists: prev.artists.map(a =>
            a.id === artist.id ? { ...a, image: result?.url || null, imageLoaded: true } : a
          )
        }));
      } catch (err) {
        console.error(`Error fetching image for ${artist.name}:`, err);
        // Mark as loaded even on error so we show the pattern fallback
        setTopArtists(prev => ({
          ...prev,
          artists: prev.artists.map(a =>
            a.id === artist.id ? { ...a, imageLoaded: true } : a
          )
        }));
      }
    }
    console.log(`ðŸ“Š Finished fetching top artist images`);
  };

  // Load Top Albums from Last.fm
  const loadTopAlbums = async (period = historyPeriod) => {
    setTopAlbums(prev => ({ ...prev, loading: true, error: null }));
    console.log(`ðŸ“Š Loading Top Albums (${period})...`);

    try {
      const lastfmConfig = metaServiceConfigs.lastfm;
      if (!lastfmConfig?.username) {
        setTopAlbums({ albums: [], loading: false, error: 'No Last.fm account connected.' });
        return;
      }

      const apiKey = lastfmApiKey.current;
      if (!apiKey) {
        setTopAlbums({ albums: [], loading: false, error: 'Last.fm API key not configured.' });
        return;
      }

      const url = `https://ws.audioscrobbler.com/2.0/?method=user.gettopalbums&user=${encodeURIComponent(lastfmConfig.username)}&api_key=${apiKey}&format=json&period=${period}&limit=50`;
      const response = await fetch(url);

      if (!response.ok) throw new Error(`Failed to fetch top albums: ${response.status}`);

      const data = await response.json();
      const topAlbumsList = data.topalbums?.album || [];

      console.log(`ðŸ“Š Received ${topAlbumsList.length} top albums`);

      const albums = topAlbumsList.map((album, index) => ({
        id: `top-album-${index}-${album.name}`.replace(/\s+/g, '-'),
        name: album.name,
        artist: album.artist?.name || 'Unknown Artist',
        image: album.image?.[3]?.['#text'] || album.image?.[2]?.['#text'] || null,
        playCount: parseInt(album.playcount) || 0,
        rank: index + 1
      }));

      setTopAlbums({ albums, loading: false, error: null });
    } catch (error) {
      console.error('Failed to load Top Albums:', error);
      setTopAlbums({ albums: [], loading: false, error: error.message });
    }
  };

  // Parse friend input to extract service and username
  const parseFriendInput = (input) => {
    const trimmed = input.trim();

    // Check for Last.fm URL
    const lastfmMatch = trimmed.match(/last\.fm\/user\/([^\/\?]+)/i);
    if (lastfmMatch) {
      return { service: 'lastfm', username: lastfmMatch[1] };
    }

    // Check for ListenBrainz URL
    const listenbrainzMatch = trimmed.match(/listenbrainz\.org\/user\/([^\/\?]+)/i);
    if (listenbrainzMatch) {
      return { service: 'listenbrainz', username: listenbrainzMatch[1] };
    }

    // Plain username - will try Last.fm first, then ListenBrainz
    return { service: null, username: trimmed };
  };

  // Fetch Last.fm user info (avatar, display name)
  const fetchLastfmUserInfo = async (username) => {
    const apiKey = lastfmApiKey.current;
    if (!apiKey) throw new Error('Last.fm API key not configured');

    const url = `https://ws.audioscrobbler.com/2.0/?method=user.getinfo&user=${encodeURIComponent(username)}&api_key=${apiKey}&format=json`;
    const response = await fetch(url);

    if (!response.ok) {
      if (response.status === 404) throw new Error('User not found on Last.fm');
      throw new Error(`Last.fm API error: ${response.status}`);
    }

    const data = await response.json();
    if (data.error) throw new Error(data.message || 'User not found on Last.fm');

    const user = data.user;
    return {
      username: user.name,
      displayName: user.realname || user.name,
      avatarUrl: user.image?.[2]?.['#text'] || user.image?.[1]?.['#text'] || null
    };
  };

  // Fetch ListenBrainz user info
  const fetchListenbrainzUserInfo = async (username) => {
    // Use listen-count endpoint to validate user exists (the /1/user/{username} endpoint doesn't work)
    const url = `https://api.listenbrainz.org/1/user/${encodeURIComponent(username)}/listen-count`;
    const response = await fetch(url);

    if (!response.ok) {
      if (response.status === 404) throw new Error('User not found on ListenBrainz');
      throw new Error(`ListenBrainz API error: ${response.status}`);
    }

    // Verify response has valid data
    const data = await response.json();
    if (data.payload?.count === undefined) {
      throw new Error('User not found on ListenBrainz');
    }

    // ListenBrainz doesn't have avatars, return username only
    return {
      username: username,
      displayName: username,
      avatarUrl: null // Will use generated avatar fallback
    };
  };

  // Fetch friend's most recent track (for on-air status)
  const fetchFriendRecentTrack = async (friend) => {
    try {
      if (friend.service === 'lastfm') {
        const apiKey = lastfmApiKey.current;
        if (!apiKey) return null;

        const url = `https://ws.audioscrobbler.com/2.0/?method=user.getrecenttracks&user=${encodeURIComponent(friend.username)}&api_key=${apiKey}&format=json&limit=1`;
        const response = await fetch(url);
        if (!response.ok) return null;

        const data = await response.json();
        const track = data.recenttracks?.track?.[0];
        if (!track) return null;

        // Check if currently playing (no date means currently playing)
        const isNowPlaying = track['@attr']?.nowplaying === 'true';
        const timestamp = isNowPlaying ? Date.now() : (track.date?.uts ? parseInt(track.date.uts) * 1000 : null);

        return {
          name: track.name,
          artist: track.artist?.['#text'] || track.artist?.name || 'Unknown Artist',
          album: track.album?.['#text'] || null,
          timestamp: timestamp,
          albumArt: track.image?.[2]?.['#text'] || track.image?.[1]?.['#text'] || null
        };
      } else if (friend.service === 'listenbrainz') {
        const url = `https://api.listenbrainz.org/1/user/${encodeURIComponent(friend.username)}/listens?count=1`;
        const response = await fetch(url);
        if (!response.ok) return null;

        const data = await response.json();
        const listen = data.payload?.listens?.[0];
        if (!listen) return null;

        return {
          name: listen.track_metadata?.track_name || 'Unknown Track',
          artist: listen.track_metadata?.artist_name || 'Unknown Artist',
          album: listen.track_metadata?.release_name || null,
          timestamp: listen.listened_at ? listen.listened_at * 1000 : null,
          albumArt: null // ListenBrainz doesn't provide album art in listens - will be fetched via getAlbumArt
        };
      }
      return null;
    } catch (error) {
      console.error(`Error fetching recent track for ${friend.username}:`, error);
      return null;
    }
  };

  // Check if friend is "on air" (listened within last 10 minutes)
  const isOnAir = (friend) => {
    if (!friend.cachedRecentTrack?.timestamp) return false;
    const tenMinutesAgo = Date.now() - (10 * 60 * 1000);
    return friend.cachedRecentTrack.timestamp > tenMinutesAgo;
  };

  // Add a friend from username or URL
  const addFriend = async (input) => {
    setAddFriendLoading(true);

    try {
      const { service, username } = parseFriendInput(input);

      if (!username) {
        showToast('Please enter a username or profile URL', 'error');
        return;
      }

      let userInfo = null;
      let finalService = service;

      if (service === 'lastfm') {
        userInfo = await fetchLastfmUserInfo(username);
        finalService = 'lastfm';
      } else if (service === 'listenbrainz') {
        userInfo = await fetchListenbrainzUserInfo(username);
        finalService = 'listenbrainz';
      } else {
        // Try Last.fm first, then ListenBrainz
        try {
          userInfo = await fetchLastfmUserInfo(username);
          finalService = 'lastfm';
        } catch (lfmError) {
          console.log(`User not found on Last.fm, trying ListenBrainz...`);
          try {
            userInfo = await fetchListenbrainzUserInfo(username);
            finalService = 'listenbrainz';
          } catch (lbError) {
            throw new Error('User not found on Last.fm or ListenBrainz');
          }
        }
      }

      // Check if already added
      const existingFriend = friends.find(f =>
        f.username.toLowerCase() === userInfo.username.toLowerCase() &&
        f.service === finalService
      );
      if (existingFriend) {
        showToast(`${userInfo.displayName} is already in your friends list`, 'error');
        return;
      }

      // Create friend object
      const newFriend = {
        id: `friend-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        username: userInfo.username,
        service: finalService,
        displayName: userInfo.displayName,
        avatarUrl: userInfo.avatarUrl,
        addedAt: Date.now(),
        lastFetched: Date.now(),
        cachedRecentTrack: null,
        savedToCollection: false  // Friends added from sidebar are NOT saved to collection by default
      };

      // Fetch recent track for initial on-air status
      const recentTrack = await fetchFriendRecentTrack(newFriend);
      if (recentTrack) {
        newFriend.cachedRecentTrack = recentTrack;
        // Resolve the track in background for instant playback
        resolveFriendTrack(recentTrack);
      }

      setFriends(prev => [...prev, newFriend]);
      // Auto-pin the friend to sidebar (they're not saved to collection yet)
      setPinnedFriendIds(prev => prev.includes(newFriend.id) ? prev : [...prev, newFriend.id]);
      setAddFriendModalOpen(false);
      setAddFriendInput('');
      showToast(`${newFriend.displayName} pinned to sidebar`);

      console.log(`ðŸ‘¥ Added friend: ${newFriend.displayName} (${finalService})`);
    } catch (error) {
      console.error('Failed to add friend:', error);
      showToast(error.message || 'Failed to add friend', 'error');
    } finally {
      setAddFriendLoading(false);
    }
  };

  // Remove a friend completely (deletes from friends list and unpins)
  const removeFriend = (friendId) => {
    const friend = friends.find(f => f.id === friendId);
    setFriends(prev => prev.filter(f => f.id !== friendId));
    setPinnedFriendIds(prev => prev.filter(id => id !== friendId));
    if (friend) {
      showToast(`${friend.displayName} removed`);
    }
  };
  removeFriendRef.current = removeFriend;

  // Remove friend from collection (keeps them as temporary, stays pinned if pinned)
  const removeFriendFromCollection = (friendId) => {
    setFriends(prev => prev.map(f =>
      f.id === friendId ? { ...f, savedToCollection: false } : f
    ));
    const friend = friends.find(f => f.id === friendId);
    if (friend) {
      showToast(`${friend.displayName} removed from collection`);
    }
  };
  removeFriendFromCollectionRef.current = removeFriendFromCollection;

  // Pin a friend to the sidebar
  const pinFriend = (friendId) => {
    if (!pinnedFriendIds.includes(friendId)) {
      setPinnedFriendIds(prev => prev.includes(friendId) ? prev : [...prev, friendId]);
      // Track as newly pinned for entry animation
      setNewlyPinnedFriendIds(prev => new Set([...prev, friendId]));
      // Clear animation tracking after animation completes
      setTimeout(() => {
        setNewlyPinnedFriendIds(prev => {
          const next = new Set(prev);
          next.delete(friendId);
          return next;
        });
      }, 300); // Match animation duration
      const friend = friends.find(f => f.id === friendId);
      if (friend) {
        showToast(`${friend.displayName} pinned to sidebar`);
      }
    }
    // If friend was auto-pinned, remove from auto-pinned list (now manually pinned)
    if (autoPinnedFriendIds.includes(friendId)) {
      setAutoPinnedFriendIds(prev => prev.filter(id => id !== friendId));
    }
  };
  pinFriendRef.current = pinFriend;

  // Unpin a friend from the sidebar (with warning for unsaved friends)
  const unpinFriend = (friendId) => {
    const friend = friends.find(f => f.id === friendId);

    // If friend is not saved to collection and warning not dismissed, show warning
    if (friend && !friend.savedToCollection && !skipUnsavedFriendWarning) {
      setPendingUnpinFriend(friend);
      setUnsavedFriendWarningOpen(true);
      return;
    }

    // Otherwise proceed with unpin
    setPinnedFriendIds(prev => prev.filter(id => id !== friendId));
    // Also clear from auto-pinned list if they were auto-pinned
    setAutoPinnedFriendIds(prev => prev.filter(id => id !== friendId));
    if (friend) {
      showToast(`${friend.displayName} unpinned from sidebar`);
    }
  };
  unpinFriendRef.current = unpinFriend;

  // Confirm unpin after warning dialog
  const confirmUnpinFriend = () => {
    if (pendingUnpinFriend) {
      setPinnedFriendIds(prev => prev.filter(id => id !== pendingUnpinFriend.id));
      setAutoPinnedFriendIds(prev => prev.filter(id => id !== pendingUnpinFriend.id));
      showToast(`${pendingUnpinFriend.displayName} unpinned from sidebar`);
      setUnsavedFriendWarningOpen(false);
      setPendingUnpinFriend(null);
    }
  };

  // Save friend to collection
  const saveFriendToCollection = (friendId) => {
    setFriends(prev => prev.map(f =>
      f.id === friendId ? { ...f, savedToCollection: true } : f
    ));
    const friend = friends.find(f => f.id === friendId);
    if (friend) {
      showToast(`${friend.displayName} saved to collection`);
    }
  };
  saveFriendToCollectionRef.current = saveFriendToCollection;

  // Reorder pinned friends in sidebar (for drag-drop)
  const reorderPinnedFriends = (fromIndex, toIndex) => {
    setPinnedFriendIds(prev => {
      const newOrder = [...prev];
      const [removed] = newOrder.splice(fromIndex, 1);
      newOrder.splice(toIndex, 0, removed);
      // Track moved friend for animation
      setMovedFriendIds(new Set([removed]));
      setTimeout(() => {
        setMovedFriendIds(new Set());
      }, 400); // Match animation duration
      return newOrder;
    });
  };

  // Resolve a friend's current track in background (for instant playback)
  const resolveFriendTrack = async (track) => {
    if (!track || !track.name || !track.artist) return;

    const cacheKey = `${track.artist.toLowerCase()}|${track.name.toLowerCase()}|0`;
    const currentResolverHash = getResolverSettingsHash();

    // Check if already cached and valid
    const cachedData = trackSourcesCache.current[cacheKey];
    if (cachedData &&
        (Date.now() - cachedData.timestamp) < CACHE_TTL.trackSources &&
        cachedData.resolverHash === currentResolverHash) {
      console.log(`ðŸ‘¥ Friend track already resolved: ${track.artist} - ${track.name}`);
      return;
    }

    console.log(`ðŸ‘¥ Resolving friend track: ${track.artist} - ${track.name}`);

    const sources = {};

    for (const resolverId of activeResolvers) {
      const resolver = allResolvers.find(r => r.id === resolverId);
      if (!resolver || !resolver.capabilities.resolve) continue;

      try {
        const config = await getResolverConfig(resolverId);
        const resolved = await resolver.resolve(track.artist, track.name, null, config);

        if (resolved) {
          console.log(`  âœ… ${resolver.name}: Found match for friend track`);
          sources[resolverId] = resolved;
        }
      } catch (error) {
        console.error(`  âŒ ${resolver.name} resolve error:`, error);
      }
    }

    // Cache the results
    if (Object.keys(sources).length > 0) {
      trackSourcesCache.current[cacheKey] = {
        sources,
        timestamp: Date.now(),
        resolverHash: currentResolverHash
      };
      console.log(`ðŸ‘¥ Friend track resolved with ${Object.keys(sources).length} sources`);
    }
  };

  // Refresh recent tracks for friends (for polling)
  // Polls: all pinned friends + all saved friends (to check if they become active)
  const refreshPinnedFriends = async () => {
    const listenAlongFriendNow = listenAlongFriendRef.current;

    // Get all friends we need to poll:
    // 1. All pinned friends (manual or auto-pinned)
    // 2. All saved friends (even if not pinned, to detect when they become active)
    const friendsToCheck = friends.filter(f =>
      pinnedFriendIds.includes(f.id) || f.savedToCollection
    );

    for (const friend of friendsToCheck) {
      const recentTrack = await fetchFriendRecentTrack(friend);
      if (recentTrack) {
        // Check if track changed before updating
        const previousTrack = friend.cachedRecentTrack;
        const trackChanged = !previousTrack ||
          previousTrack.name !== recentTrack.name ||
          previousTrack.artist !== recentTrack.artist;

        // Check if friend is on-air (track less than 10 minutes old)
        const isOnAirNow = recentTrack.timestamp && (Date.now() - recentTrack.timestamp) < 10 * 60 * 1000;
        const wasOnAir = previousTrack?.timestamp && (Date.now() - previousTrack.timestamp) < 10 * 60 * 1000;

        // Track on-air status change for animation (friend will move in sorted list)
        if (isOnAirNow !== wasOnAir && pinnedFriendIds.includes(friend.id)) {
          setMovedFriendIds(prev => new Set([...prev, friend.id]));
          setTimeout(() => {
            setMovedFriendIds(prev => {
              const next = new Set(prev);
              next.delete(friend.id);
              return next;
            });
          }, 400);
        }

        setFriends(prev => prev.map(f =>
          f.id === friend.id
            ? { ...f, cachedRecentTrack: recentTrack, lastFetched: Date.now() }
            : f
        ));

        // Auto-pin/unpin saved friends based on on-air status
        const isPinned = pinnedFriendIds.includes(friend.id);
        const isAutoPinned = autoPinnedFriendIds.includes(friend.id);

        if (friend.savedToCollection && isOnAirNow && !isPinned) {
          // Saved friend became active - auto-pin them to sidebar
          console.log(`ðŸ‘¥ Auto-pinning ${friend.displayName} (now active)`);
          setPinnedFriendIds(prev => prev.includes(friend.id) ? prev : [...prev, friend.id]);
          setAutoPinnedFriendIds(prev => prev.includes(friend.id) ? prev : [...prev, friend.id]);
          // Track as newly pinned for entry animation
          setNewlyPinnedFriendIds(prev => new Set([...prev, friend.id]));
          setTimeout(() => {
            setNewlyPinnedFriendIds(prev => {
              const next = new Set(prev);
              next.delete(friend.id);
              return next;
            });
          }, 300);
        } else if (isAutoPinned && !isOnAirNow) {
          // Auto-pinned friend is no longer active - auto-unpin them
          console.log(`ðŸ‘¥ Auto-unpinning ${friend.displayName} (no longer active)`);
          setPinnedFriendIds(prev => prev.filter(id => id !== friend.id));
          setAutoPinnedFriendIds(prev => prev.filter(id => id !== friend.id));
        }

        // Check if the friend we're listening along to went inactive
        if (listenAlongFriendNow?.id === friend.id && !isOnAirNow) {
          console.log(`ðŸŽ§ Listen-along: ${friend.displayName} is no longer active`);
          showToast(`${friend.displayName} stopped listening`);
          // Abort and cleanup pool context
          abortSchedulerContext('listen-along');
          setListenAlongFriend(null);
          listenAlongLastTrackRef.current = null;
          listenAlongPendingTrackRef.current = null;
          setPlaybackContext(null);
          // Resume playback from queue if there are tracks
          if (currentQueueRef.current.length > 0) {
            handleNextRef.current?.();
          }
          continue; // Skip further processing for this friend
        }

        // Resolve the track in background if it's new/changed and friend is on-air
        if (trackChanged && isOnAirNow) {
          resolveFriendTrack(recentTrack);

          // If we're listening along to this friend and they changed tracks, queue or play the new one
          if (listenAlongFriendNow?.id === friend.id) {
            const lastTrack = listenAlongLastTrackRef.current;
            const isNewTrack = !lastTrack ||
              lastTrack.name !== recentTrack.name ||
              lastTrack.artist !== recentTrack.artist;

            if (isNewTrack) {
              console.log(`ðŸŽ§ Listen-along: ${friend.displayName} started playing "${recentTrack.name}"`);

              // Wait a moment for track to resolve, then queue or play
              setTimeout(async () => {
                const cacheKey = `${recentTrack.artist.toLowerCase()}|${recentTrack.name.toLowerCase()}|0`;
                const cachedSources = trackSourcesCache.current[cacheKey]?.sources || {};
                const track = {
                  title: recentTrack.name,
                  artist: recentTrack.artist,
                  album: recentTrack.album,
                  albumArt: recentTrack.albumArt,
                  sources: cachedSources,
                  _playbackContext: {
                    type: 'listenAlong',
                    name: friend.displayName,
                    friendId: friend.id
                  }
                };

                // Check if we're currently playing - if so, queue as pending
                // Otherwise play immediately (our song already ended)
                if (isPlayingRef.current) {
                  console.log(`ðŸŽ§ Listen-along: Queuing "${track.title}" to play when current track ends`);
                  listenAlongPendingTrackRef.current = track;

                  // Update pool visibility for resolution - the pending track
                  // Use track ID as key to avoid re-resolution
                  const poolTracks = [{
                    key: track.id || `${track.artist}-${track.title}`,
                    data: { track, artistName: track.artist || 'Unknown Artist' }
                  }];
                  updateSchedulerVisibility('listen-along', poolTracks);
                } else {
                  // Not playing, so our track ended - play friend's track now
                  console.log(`ðŸŽ§ Listen-along: Playing "${track.title}" immediately`);
                  listenAlongLastTrackRef.current = {
                    name: recentTrack.name,
                    artist: recentTrack.artist
                  };
                  handlePlay(track);
                }
              }, 1000); // Wait 1 second for sources to resolve
            }
          }
        }
      }
    }
  };

  // Activate listen-along mode for a friend
  const activateListenAlong = (friend) => {
    if (!friend || !friend.cachedRecentTrack) return;

    console.log(`ðŸŽ§ Starting listen-along with ${friend.displayName}`);

    // Register pool context for listen-along resolution
    registerPoolContext('listen-along', 1);

    setListenAlongFriend(friend);
    listenAlongLastTrackRef.current = {
      name: friend.cachedRecentTrack.name,
      artist: friend.cachedRecentTrack.artist
    };

    // Set playback context to listen-along
    setPlaybackContext({
      type: 'listenAlong',
      name: friend.displayName,
      friendId: friend.id
    });

    // Play the friend's current track
    const cacheKey = `${friend.cachedRecentTrack.artist.toLowerCase()}|${friend.cachedRecentTrack.name.toLowerCase()}|0`;
    const cachedSources = trackSourcesCache.current[cacheKey]?.sources || {};
    const track = {
      title: friend.cachedRecentTrack.name,
      artist: friend.cachedRecentTrack.artist,
      album: friend.cachedRecentTrack.album,
      albumArt: friend.cachedRecentTrack.albumArt,
      sources: cachedSources,
      _playbackContext: {
        type: 'listenAlong',
        name: friend.displayName,
        friendId: friend.id
      }
    };
    handlePlay(track);

    showToast(`Listening along with ${friend.displayName}`);
  };

  // Deactivate listen-along mode
  const deactivateListenAlong = () => {
    if (!listenAlongFriend) return;

    // Abort and cleanup pool context
    abortSchedulerContext('listen-along');

    const friendName = listenAlongFriend.displayName;
    console.log(`ðŸŽ§ Stopped listening along with ${friendName}`);
    setListenAlongFriend(null);
    listenAlongLastTrackRef.current = null;

    // Clear the listen-along context - will use queue's context when next track plays
    setPlaybackContext(null);

    showToast(`Stopped listening along with ${friendName}`);
  };

  // Assign listen-along functions to refs for context menu access
  activateListenAlongRef.current = activateListenAlong;
  deactivateListenAlongRef.current = deactivateListenAlong;

  // Poll friends for on-air status (pinned friends + saved friends for auto-pinning)
  const hasSavedFriends = friends.some(f => f.savedToCollection);
  useEffect(() => {
    if (pinnedFriendIds.length > 0 || hasSavedFriends) {
      // Initial refresh
      refreshPinnedFriends();

      // Set up polling interval - faster when listen-along is active
      const pollInterval = listenAlongFriend ? 15 * 1000 : 2 * 60 * 1000; // 15 seconds vs 2 minutes
      friendPollIntervalRef.current = setInterval(refreshPinnedFriends, pollInterval);

      return () => {
        if (friendPollIntervalRef.current) {
          clearInterval(friendPollIntervalRef.current);
        }
      };
    }
  }, [pinnedFriendIds.length, hasSavedFriends, listenAlongFriend]);

  // Load friend's recent listening history
  const loadFriendRecentTracks = async (friend) => {
    setFriendHistoryLoading(true);

    try {
      let tracks = [];

      if (friend.service === 'lastfm') {
        const apiKey = lastfmApiKey.current;
        if (!apiKey) throw new Error('Last.fm API key not configured');

        const url = `https://ws.audioscrobbler.com/2.0/?method=user.getrecenttracks&user=${encodeURIComponent(friend.username)}&api_key=${apiKey}&format=json&limit=50`;
        const response = await fetch(url);
        if (!response.ok) throw new Error(`Failed to fetch recent tracks: ${response.status}`);

        const data = await response.json();
        const recentTracks = data.recenttracks?.track || [];

        tracks = recentTracks.map((track, index) => ({
          id: `friend-recent-${index}-${track.name}`.replace(/\s+/g, '-'),
          title: track.name,
          artist: track.artist?.['#text'] || track.artist?.name || 'Unknown Artist',
          album: track.album?.['#text'] || null,
          albumArt: track.image?.[2]?.['#text'] || track.image?.[1]?.['#text'] || null,
          timestamp: track.date?.uts ? parseInt(track.date.uts) * 1000 : Date.now(),
          nowPlaying: track['@attr']?.nowplaying === 'true',
          sources: {}
        }));
      } else if (friend.service === 'listenbrainz') {
        const url = `https://api.listenbrainz.org/1/user/${encodeURIComponent(friend.username)}/listens?count=50`;
        const response = await fetch(url);
        if (!response.ok) throw new Error(`Failed to fetch listens: ${response.status}`);

        const data = await response.json();
        const listens = data.payload?.listens || [];

        tracks = listens.map((listen, index) => ({
          id: `friend-recent-${index}-${listen.track_metadata?.track_name}`.replace(/\s+/g, '-'),
          title: listen.track_metadata?.track_name || 'Unknown Track',
          artist: listen.track_metadata?.artist_name || 'Unknown Artist',
          album: listen.track_metadata?.release_name || null,
          albumArt: null,
          timestamp: listen.listened_at ? listen.listened_at * 1000 : Date.now(),
          nowPlaying: false,
          sources: {}
        }));
      }

      // Resolution handled by scheduler via IntersectionObserver
      setFriendHistoryData(prev => ({ ...prev, recent: tracks }));
    } catch (error) {
      console.error('Failed to load friend recent tracks:', error);
      showToast('Failed to load listening history', 'error');
    } finally {
      setFriendHistoryLoading(false);
    }
  };

  // Load friend's top tracks
  const loadFriendTopTracks = async (friend, period = friendHistoryPeriod) => {
    if (friend.service !== 'lastfm') {
      return loadFriendTopTracksListenBrainz(friend, period);
    }

    setFriendHistoryLoading(true);

    try {
      const apiKey = lastfmApiKey.current;
      if (!apiKey) throw new Error('Last.fm API key not configured');

      const url = `https://ws.audioscrobbler.com/2.0/?method=user.gettoptracks&user=${encodeURIComponent(friend.username)}&api_key=${apiKey}&format=json&period=${period}&limit=50`;
      const response = await fetch(url);
      if (!response.ok) throw new Error(`Failed to fetch top tracks: ${response.status}`);

      const data = await response.json();
      const topTracksList = data.toptracks?.track || [];

      const tracks = topTracksList.map((track, index) => ({
        id: `friend-top-track-${index}-${track.name}`.replace(/\s+/g, '-'),
        title: track.name,
        artist: track.artist?.name || 'Unknown Artist',
        albumArt: track.image?.[2]?.['#text'] || null,
        playCount: parseInt(track.playcount) || 0,
        rank: index + 1,
        sources: {}
      }));

      // Resolution handled by scheduler via IntersectionObserver
      setFriendHistoryData(prev => ({ ...prev, topTracks: tracks }));
    } catch (error) {
      console.error('Failed to load friend top tracks:', error);
      showToast('Failed to load top tracks', 'error');
    } finally {
      setFriendHistoryLoading(false);
    }
  };

  // ListenBrainz version
  const loadFriendTopTracksListenBrainz = async (friend, period) => {
    setFriendHistoryLoading(true);

    try {
      const range = period === 'overall' ? 'all_time' : period === '7day' ? 'week' : period === '1month' ? 'month' : period === '3month' ? 'quarter' : period === '6month' ? 'half_yearly' : 'year';
      const url = `https://api.listenbrainz.org/1/stats/user/${encodeURIComponent(friend.username)}/recordings?range=${range}&count=50`;
      const response = await fetch(url);
      if (!response.ok) throw new Error(`Failed to fetch top recordings: ${response.status}`);

      // Handle 204 No Content (no stats available for this period)
      if (response.status === 204) {
        setFriendHistoryData(prev => ({ ...prev, topTracks: [] }));
        setFriendHistoryLoading(false);
        return;
      }

      const data = await response.json();
      const recordings = data.payload?.recordings || [];

      const tracks = recordings.map((rec, index) => ({
        id: `friend-top-track-${index}-${rec.track_name}`.replace(/\s+/g, '-'),
        title: rec.track_name || 'Unknown Track',
        artist: rec.artist_name || 'Unknown Artist',
        albumArt: null,
        playCount: rec.listen_count || 0,
        rank: index + 1,
        sources: {}
      }));

      // Resolution handled by scheduler via IntersectionObserver
      setFriendHistoryData(prev => ({ ...prev, topTracks: tracks }));
    } catch (error) {
      console.error('Failed to load friend top tracks:', error);
      showToast('Failed to load top tracks', 'error');
    } finally {
      setFriendHistoryLoading(false);
    }
  };

  // Load friend's top artists
  const loadFriendTopArtists = async (friend, period = friendHistoryPeriod) => {
    setFriendHistoryLoading(true);

    try {
      let artists = [];

      if (friend.service === 'lastfm') {
        const apiKey = lastfmApiKey.current;
        if (!apiKey) throw new Error('Last.fm API key not configured');

        const url = `https://ws.audioscrobbler.com/2.0/?method=user.gettopartists&user=${encodeURIComponent(friend.username)}&api_key=${apiKey}&format=json&period=${period}&limit=50`;
        const response = await fetch(url);
        if (!response.ok) throw new Error(`Failed to fetch top artists: ${response.status}`);

        const data = await response.json();
        const topArtistsList = data.topartists?.artist || [];

        artists = topArtistsList.map((artist, index) => ({
          id: `friend-top-artist-${index}-${artist.name}`.replace(/\s+/g, '-'),
          name: artist.name,
          image: null,
          playCount: parseInt(artist.playcount) || 0,
          rank: index + 1
        }));
      } else {
        const range = period === 'overall' ? 'all_time' : period === '7day' ? 'week' : period === '1month' ? 'month' : period === '3month' ? 'quarter' : period === '6month' ? 'half_yearly' : 'year';
        const url = `https://api.listenbrainz.org/1/stats/user/${encodeURIComponent(friend.username)}/artists?range=${range}&count=50`;
        const response = await fetch(url);
        if (!response.ok) throw new Error(`Failed to fetch top artists: ${response.status}`);

        // Handle 204 No Content (no stats available for this period)
        if (response.status === 204) {
          setFriendHistoryData(prev => ({ ...prev, topArtists: [] }));
          setFriendHistoryLoading(false);
          return;
        }

        const data = await response.json();
        const artistList = data.payload?.artists || [];

        artists = artistList.map((artist, index) => ({
          id: `friend-top-artist-${index}-${artist.artist_name}`.replace(/\s+/g, '-'),
          name: artist.artist_name || 'Unknown Artist',
          image: null,
          playCount: artist.listen_count || 0,
          rank: index + 1
        }));
      }

      setFriendHistoryData(prev => ({ ...prev, topArtists: artists }));

      // Fetch artist images in background
      if (artists.length > 0) {
        resolveFriendTopArtistImages(artists);
      }
    } catch (error) {
      console.error('Failed to load friend top artists:', error);
      showToast('Failed to load top artists', 'error');
    } finally {
      setFriendHistoryLoading(false);
    }
  };

  // Resolve friend top artist images
  const resolveFriendTopArtistImages = async (artists) => {
    for (const artist of artists) {
      try {
        const result = await getArtistImage(artist.name);
        setFriendHistoryData(prev => ({
          ...prev,
          topArtists: prev.topArtists.map(a =>
            a.id === artist.id ? { ...a, image: result?.url || null, imageLoaded: true } : a
          )
        }));
      } catch (err) {
        console.error(`Error fetching image for ${artist.name}:`, err);
        // Mark as loaded even on error so we show the pattern fallback
        setFriendHistoryData(prev => ({
          ...prev,
          topArtists: prev.topArtists.map(a =>
            a.id === artist.id ? { ...a, imageLoaded: true } : a
          )
        }));
      }
    }
  };

  // Load friend's top albums
  const loadFriendTopAlbums = async (friend, period = friendHistoryPeriod) => {
    setFriendHistoryLoading(true);

    try {
      let albums = [];

      if (friend.service === 'lastfm') {
        const apiKey = lastfmApiKey.current;
        if (!apiKey) throw new Error('Last.fm API key not configured');

        const url = `https://ws.audioscrobbler.com/2.0/?method=user.gettopalbums&user=${encodeURIComponent(friend.username)}&api_key=${apiKey}&format=json&period=${period}&limit=50`;
        const response = await fetch(url);
        if (!response.ok) throw new Error(`Failed to fetch top albums: ${response.status}`);

        const data = await response.json();
        const topAlbumsList = data.topalbums?.album || [];

        albums = topAlbumsList.map((album, index) => ({
          id: `friend-top-album-${index}-${album.name}`.replace(/\s+/g, '-'),
          name: album.name,
          artist: album.artist?.name || 'Unknown Artist',
          image: album.image?.[3]?.['#text'] || album.image?.[2]?.['#text'] || null,
          playCount: parseInt(album.playcount) || 0,
          rank: index + 1
        }));
      } else {
        const range = period === 'overall' ? 'all_time' : period === '7day' ? 'week' : period === '1month' ? 'month' : period === '3month' ? 'quarter' : period === '6month' ? 'half_yearly' : 'year';
        const url = `https://api.listenbrainz.org/1/stats/user/${encodeURIComponent(friend.username)}/releases?range=${range}&count=50`;
        const response = await fetch(url);
        if (!response.ok) throw new Error(`Failed to fetch top releases: ${response.status}`);

        // Handle 204 No Content (no stats available for this period)
        if (response.status === 204) {
          setFriendHistoryData(prev => ({ ...prev, topAlbums: [] }));
          setFriendHistoryLoading(false);
          return;
        }

        const data = await response.json();
        const releaseList = data.payload?.releases || [];

        albums = releaseList.map((release, index) => ({
          id: `friend-top-album-${index}-${release.release_name}`.replace(/\s+/g, '-'),
          name: release.release_name || 'Unknown Album',
          artist: release.artist_name || 'Unknown Artist',
          image: null,
          playCount: release.listen_count || 0,
          rank: index + 1
        }));
      }

      setFriendHistoryData(prev => ({ ...prev, topAlbums: albums }));

      // Fetch album images in background
      if (albums.length > 0) {
        resolveFriendTopAlbumImages(albums);
      }
    } catch (error) {
      console.error('Failed to load friend top albums:', error);
      showToast('Failed to load top albums', 'error');
    } finally {
      setFriendHistoryLoading(false);
    }
  };

  // Resolve friend top album images from Cover Art Archive
  const resolveFriendTopAlbumImages = async (albums) => {
    for (const album of albums) {
      // Skip if already has an image from Last.fm
      if (album.image) {
        setFriendHistoryData(prev => ({
          ...prev,
          topAlbums: prev.topAlbums.map(a =>
            a.id === album.id ? { ...a, imageLoaded: true } : a
          )
        }));
        continue;
      }

      try {
        // Try to get album art from Cover Art Archive via MusicBrainz
        const searchUrl = `https://musicbrainz.org/ws/2/release-group?query=release:${encodeURIComponent(album.name)}%20AND%20artist:${encodeURIComponent(album.artist)}&fmt=json&limit=1`;
        const searchResponse = await fetch(searchUrl, {
          headers: { 'User-Agent': 'Parachord/1.0 (support@parachord.com)' }
        });

        if (searchResponse.ok) {
          const searchData = await searchResponse.json();
          const releaseGroup = searchData['release-groups']?.[0];

          if (releaseGroup?.id) {
            const coverUrl = `https://coverartarchive.org/release-group/${releaseGroup.id}/front-250`;
            // Check if cover exists
            const coverResponse = await fetch(coverUrl, { method: 'HEAD' });
            if (coverResponse.ok) {
              setFriendHistoryData(prev => ({
                ...prev,
                topAlbums: prev.topAlbums.map(a =>
                  a.id === album.id ? { ...a, image: coverUrl, imageLoaded: true } : a
                )
              }));
              continue;
            }
          }
        }

        // No image found
        setFriendHistoryData(prev => ({
          ...prev,
          topAlbums: prev.topAlbums.map(a =>
            a.id === album.id ? { ...a, imageLoaded: true } : a
          )
        }));
      } catch (err) {
        console.error(`Error fetching image for album ${album.name}:`, err);
        // Mark as loaded even on error so we show the pattern fallback
        setFriendHistoryData(prev => ({
          ...prev,
          topAlbums: prev.topAlbums.map(a =>
            a.id === album.id ? { ...a, imageLoaded: true } : a
          )
        }));
      }
    }
  };

  // Navigate to friend's history view
  const navigateToFriend = (friend) => {
    setCurrentFriend(friend);
    setFriendHistoryTab('recent');
    setFriendHistoryData({ recent: [], topTracks: [], topAlbums: [], topArtists: [] });
    navigateTo('friendHistory');
    loadFriendRecentTracks(friend);
  };
  navigateToFriendRef.current = navigateToFriend;

  // Load listening history from Last.fm
  const loadLastfmHistory = async (username, apiKey) => {
    const url = `https://ws.audioscrobbler.com/2.0/?method=user.getrecenttracks&user=${encodeURIComponent(username)}&api_key=${apiKey}&format=json&limit=50`;
    const response = await fetch(url);

    if (!response.ok) {
      throw new Error(`Failed to fetch Last.fm listening history: ${response.status}`);
    }

    const data = await response.json();
    const recentTracks = data.recenttracks?.track || [];

    // Transform tracks to app format
    return recentTracks.map((track, index) => ({
      id: `history-${index}-${track.date?.uts || 'now'}-${track.name}`.replace(/\s+/g, '-'),
      title: track.name,
      artist: track.artist?.['#text'] || track.artist?.name || 'Unknown Artist',
      album: track.album?.['#text'] || null,
      albumArt: track.image?.[2]?.['#text'] || null, // Medium size image
      playedAt: track.date?.uts ? parseInt(track.date.uts) * 1000 : null, // Convert to ms
      nowPlaying: track['@attr']?.nowplaying === 'true',
      sources: {} // Will be populated by resolver pipeline
    }));
  };

  // Load listening history from ListenBrainz
  const loadListenbrainzHistory = async (username) => {
    const url = `https://api.listenbrainz.org/1/user/${encodeURIComponent(username)}/listens?count=50`;
    const response = await fetch(url);

    if (!response.ok) {
      throw new Error(`Failed to fetch ListenBrainz listening history: ${response.status}`);
    }

    const data = await response.json();
    const listens = data.payload?.listens || [];

    // Transform listens to app format
    return listens.map((listen, index) => ({
      id: listen.recording_msid || `lb-history-${index}-${listen.listened_at}-${listen.track_metadata?.track_name}`.replace(/\s+/g, '-'),
      title: listen.track_metadata?.track_name || 'Unknown Track',
      artist: listen.track_metadata?.artist_name || 'Unknown Artist',
      album: listen.track_metadata?.release_name || null,
      albumArt: null, // ListenBrainz doesn't provide album art directly
      playedAt: listen.listened_at ? listen.listened_at * 1000 : null, // Convert to ms
      nowPlaying: listen.playing_now || false,
      sources: {},
      mbid: listen.track_metadata?.additional_info?.recording_mbid || null
    }));
  };

  // Helper function to search MusicBrainz with fallback for multi-artist names
  // If artist contains "&" or " and " and search fails, tries with just the first artist name
  const searchMusicBrainzRelease = async (album, artist) => {
    const doSearch = async (artistQuery) => {
      const searchQuery = encodeURIComponent(`release:"${album}" AND artist:"${artistQuery}"`);
      const mbResponse = await fetch(
        `https://musicbrainz.org/ws/2/release/?query=${searchQuery}&fmt=json&limit=1`,
        { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' } }
      );

      if (!mbResponse.ok) {
        throw new Error('MusicBrainz search failed');
      }

      const mbData = await mbResponse.json();
      return mbData.releases || [];
    };

    // Try with full artist name first
    let releases = await doSearch(artist);

    // If no results and artist contains "&" or " and ", try with just the first artist
    if (releases.length === 0) {
      let firstArtist = null;

      if (artist.includes(' & ')) {
        firstArtist = artist.split(' & ')[0].trim();
      } else if (artist.toLowerCase().includes(' and ')) {
        firstArtist = artist.split(/ and /i)[0].trim();
      }

      if (firstArtist) {
        console.log(`MusicBrainz: No results for "${artist}", trying with "${firstArtist}"`);
        releases = await doSearch(firstArtist);
      }
    }

    return releases;
  };

  // Fetch album art for Critic's Picks in background
  const fetchCriticsPicksAlbumArt = async (albums) => {
    // First pass: check cache for all albums (instant, no network)
    const albumsNeedingFetch = [];
    const cachedUpdates = [];
    const failedAlbumIds = [];

    for (const album of albums) {
      const lookupKey = `${album.artist}-${album.title}`.toLowerCase();
      const cachedReleaseId = albumToReleaseIdCache.current[lookupKey];
      const hasArtUrl = cachedReleaseId && albumArtCache.current[cachedReleaseId]?.url;

      if (hasArtUrl) {
        // We have cached art - collect for batch update
        cachedUpdates.push({ id: album.id, albumArt: albumArtCache.current[cachedReleaseId].url });
      } else if (cachedReleaseId === null) {
        // Previously failed to find this album - mark as null to show placeholder
        failedAlbumIds.push(album.id);
      } else {
        // No cached art or release ID not yet looked up - need to fetch
        albumsNeedingFetch.push(album);
      }
    }

    // Apply cached updates immediately (both successes and known failures)
    if (cachedUpdates.length > 0 || failedAlbumIds.length > 0) {
      console.log(`ðŸ“° Using cached art for ${cachedUpdates.length} Critic's Picks albums, ${failedAlbumIds.length} known failures`);
      setCriticsPicks(prev => prev.map(a => {
        const cached = cachedUpdates.find(u => u.id === a.id);
        if (cached) return { ...a, albumArt: cached.albumArt };
        if (failedAlbumIds.includes(a.id)) return { ...a, albumArt: null };
        return a;
      }));
    }

    // Second pass: fetch art for albums not in cache
    for (const album of albumsNeedingFetch) {
      try {
        const artUrl = await getAlbumArt(album.artist, album.title);
        // Set to artUrl if found, or null if not (to show placeholder instead of shimmer)
        setCriticsPicks(prev => prev.map(a =>
          a.id === album.id ? { ...a, albumArt: artUrl || null } : a
        ));
      } catch (error) {
        console.log(`Could not fetch art for: ${album.artist} - ${album.title}`);
        // Set to null on error to show placeholder
        setCriticsPicks(prev => prev.map(a =>
          a.id === album.id ? { ...a, albumArt: null } : a
        ));
      }
      // Small delay to avoid rate limiting
      await new Promise(resolve => setTimeout(resolve, 200));
    }
  };

  // Navigate to a Critic's Picks album release page
  const openCriticsPicksAlbum = async (album) => {
    console.log(`ðŸŽµ Opening Critic's Pick: ${album.artist} - ${album.title}`);

    try {
      // Search MusicBrainz for the release (with fallback for multi-artist names)
      const releases = await searchMusicBrainzRelease(album.title, album.artist);

      if (releases.length === 0) {
        // Fallback: just navigate to artist page
        console.log('Release not found in MusicBrainz, navigating to artist page');
        fetchArtistData(album.artist);
        return;
      }

      const release = releases[0];
      const artistCredit = release['artist-credit']?.[0];

      // Cache the release ID mapping so art loaded on album page can be reused
      const lookupKey = `${album.artist}-${album.title}`.toLowerCase();
      albumToReleaseIdCache.current[lookupKey] = release.id;

      // Create artist object for the release page
      const artist = {
        id: artistCredit?.artist?.id,
        name: artistCredit?.artist?.name || album.artist
      };

      // Create release object matching the expected format
      const releaseObj = {
        id: release.id,
        title: release.title,
        date: release.date,
        releaseType: release['release-group']?.['primary-type']?.toLowerCase() || 'album',
        albumArt: album.albumArt
      };

      // Set artist context and fetch release data
      // Mark that we're opening a release so header stays collapsed
      openingReleaseRef.current = true;
      setCurrentArtist(artist);
      navigateTo('artist');
      fetchReleaseData(releaseObj, artist);

    } catch (error) {
      console.error('Error opening Critic\'s Pick album:', error);
      // Fallback: navigate to artist page
      fetchArtistData(album.artist);
    }
  };

  // Navigate to a Top Album from History page
  const openTopAlbum = async (album) => {
    console.log(`ðŸŽµ Opening Top Album: ${album.artist} - ${album.name}`);

    try {
      // Search MusicBrainz for the release (with fallback for multi-artist names)
      const releases = await searchMusicBrainzRelease(album.name, album.artist);

      if (releases.length === 0) {
        // Fallback: just navigate to artist page
        console.log('Release not found in MusicBrainz, navigating to artist page');
        fetchArtistData(album.artist);
        return;
      }

      const release = releases[0];
      const artistCredit = release['artist-credit']?.[0];

      // Cache the release ID mapping so art loaded on album page can be reused
      const lookupKey = `${album.artist}-${album.name}`.toLowerCase();
      albumToReleaseIdCache.current[lookupKey] = release.id;

      // Create artist object for the release page
      const artist = {
        id: artistCredit?.artist?.id,
        name: artistCredit?.artist?.name || album.artist
      };

      // Create release object matching the expected format
      const releaseObj = {
        id: release.id,
        title: release.title,
        date: release.date,
        releaseType: release['release-group']?.['primary-type']?.toLowerCase() || 'album',
        albumArt: album.image
      };

      // Set artist context and fetch release data
      // Mark that we're opening a release so header stays collapsed
      openingReleaseRef.current = true;
      setCurrentArtist(artist);
      navigateTo('artist');
      fetchReleaseData(releaseObj, artist);

    } catch (error) {
      console.error('Error opening Top Album:', error);
      // Fallback: navigate to artist page
      fetchArtistData(album.artist);
    }
  };

  // Prefetch Critic's Picks album tracks on hover (for Add to Queue)
  const prefetchCriticsPicksTracks = async (album) => {
    // Skip if already prefetched
    if (prefetchedReleases[album.id]) {
      return;
    }

    try {
      console.log('ðŸ” Prefetching Critic\'s Pick tracks for:', album.title);

      // Search MusicBrainz for the release
      const searchQuery = encodeURIComponent(`release:"${album.title}" AND artist:"${album.artist}"`);
      const mbResponse = await fetch(
        `https://musicbrainz.org/ws/2/release/?query=${searchQuery}&fmt=json&limit=1`,
        { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' } }
      );

      if (!mbResponse.ok) return;

      const mbData = await mbResponse.json();
      if (!mbData.releases || mbData.releases.length === 0) return;

      const releaseId = mbData.releases[0].id;

      // Fetch release details with tracks
      const releaseDetailsResponse = await fetch(
        `https://musicbrainz.org/ws/2/release/${releaseId}?inc=recordings+artist-credits&fmt=json`,
        { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' } }
      );

      if (!releaseDetailsResponse.ok) return;

      const releaseData = await releaseDetailsResponse.json();

      // Extract tracks
      const tracks = [];
      if (releaseData.media && releaseData.media.length > 0) {
        releaseData.media.forEach((medium) => {
          if (medium.tracks) {
            medium.tracks.forEach(track => {
              const trackId = `${album.artist}-${track.title || 'untitled'}-${album.title}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
              tracks.push({
                id: trackId,
                position: track.position,
                title: track.title || track.recording?.title || 'Unknown Track',
                length: track.length,
                recordingId: track.recording?.id,
                artist: album.artist,
                album: album.title,
                albumArt: album.albumArt,
                sources: {}
              });
            });
          }
        });
      }

      // Cache the prefetched tracks
      setPrefetchedReleases(prev => ({
        ...prev,
        [album.id]: {
          tracks,
          title: album.title,
          albumArt: album.albumArt,
          artist: album.artist
        }
      }));

      console.log(`âœ… Prefetched ${tracks.length} tracks for ${album.title}`);
    } catch (error) {
      console.error('Error prefetching Critic\'s Pick tracks:', error);
    }
  };

  // Add Critic's Picks album to queue
  const addCriticsPicksToQueue = async (album) => {
    const context = { type: 'album', id: album.id, name: album.title, artist: album.artist };

    // Check if we have prefetched tracks
    const prefetched = prefetchedReleases[album.id];

    if (prefetched?.tracks?.length > 0) {
      addToQueue(prefetched.tracks, context);
      return;
    }

    // Otherwise, fetch and add
    await prefetchCriticsPicksTracks(album);
    const newPrefetched = prefetchedReleases[album.id];
    if (newPrefetched?.tracks?.length > 0) {
      addToQueue(newPrefetched.tracks, context);
    }
  };

  // Cache for mapping artist+album -> MusicBrainz release ID (to avoid repeated searches)
  const albumToReleaseIdCache = useRef({});

  // Fetch album art for a track by searching MusicBrainz first, then using the shared albumArtCache
  const getAlbumArt = async (artist, album) => {
    if (!artist || !album) return null;

    const lookupKey = `${artist}-${album}`.toLowerCase();

    // Check if we've already looked up this artist+album combo
    if (albumToReleaseIdCache.current[lookupKey] !== undefined) {
      const releaseId = albumToReleaseIdCache.current[lookupKey];
      if (releaseId === null) return null; // Previously failed lookup

      // If we have cached art, return it
      if (albumArtCache.current[releaseId]?.url) {
        return albumArtCache.current[releaseId].url;
      }

      // We have a release ID but no cached art - try to fetch cover art
      try {
        const caaResponse = await fetch(
          `https://coverartarchive.org/release/${releaseId}/front-250`,
          { redirect: 'follow' }
        );
        if (caaResponse.ok) {
          const artUrl = caaResponse.url;
          albumArtCache.current[releaseId] = { url: artUrl, timestamp: Date.now() };
          return artUrl;
        }
      } catch (error) {
        console.log(`Cover art fetch failed for release ${releaseId}:`, error.message);
      }
      return null; // No art available for this release
    }

    try {
      // Search MusicBrainz for the release (with fallback for multi-artist names)
      const releases = await searchMusicBrainzRelease(album, artist);

      if (releases.length === 0) {
        albumToReleaseIdCache.current[lookupKey] = null;
        return null;
      }

      const releaseId = releases[0].id;
      albumToReleaseIdCache.current[lookupKey] = releaseId;

      // Check if we already have art for this release in the shared cache
      if (albumArtCache.current[releaseId]?.url) {
        return albumArtCache.current[releaseId].url;
      }

      // Fetch cover art from Cover Art Archive
      const caaResponse = await fetch(
        `https://coverartarchive.org/release/${releaseId}/front-250`,
        { redirect: 'follow' }
      );

      if (caaResponse.ok) {
        const artUrl = caaResponse.url;
        // Store in the shared albumArtCache with timestamp
        albumArtCache.current[releaseId] = { url: artUrl, timestamp: Date.now() };
        return artUrl;
      }

      return null;
    } catch (error) {
      console.log(`Cover art not found for: ${artist} - ${album}`);
      albumToReleaseIdCache.current[lookupKey] = null;
      return null;
    }
  };

  // Synchronous check for cached album art (doesn't fetch, just checks existing cache)
  // Prioritizes our cache over resolver-provided art for consistency
  const getCachedAlbumArt = (artist, album) => {
    if (!artist || !album) return null;

    const lookupKey = `${artist}-${album}`.toLowerCase();
    const releaseId = albumToReleaseIdCache.current[lookupKey];

    if (releaseId && albumArtCache.current[releaseId]?.url) {
      return albumArtCache.current[releaseId].url;
    }

    return null;
  };

  // Fetch album art for current track if missing
  useEffect(() => {
    if (currentTrack && !currentTrack.albumArt && currentTrack.artist && currentTrack.album) {
      getAlbumArt(currentTrack.artist, currentTrack.album).then(artUrl => {
        if (artUrl) {
          setCurrentTrack(prev => {
            // Only update if still the same track and still missing art
            if (prev && prev.artist === currentTrack.artist && prev.title === currentTrack.title && !prev.albumArt) {
              return { ...prev, albumArt: artUrl };
            }
            return prev;
          });
        }
      });
    }
  }, [currentTrack?.artist, currentTrack?.album, currentTrack?.albumArt]);

  // Detect face position in an image using browser's FaceDetector API
  const detectFacePosition = async (imageUrl) => {
    // Check if FaceDetector API is available (Chromium/Electron)
    if (!('FaceDetector' in window)) {
      console.log('FaceDetector API not available');
      return null;
    }

    try {
      // Load image into an HTMLImageElement
      const img = new Image();
      img.crossOrigin = 'anonymous';
      await new Promise((resolve, reject) => {
        img.onload = resolve;
        img.onerror = reject;
        img.src = imageUrl;
      });

      // Detect faces
      const detector = new FaceDetector();
      const faces = await detector.detect(img);

      if (faces.length === 0) {
        console.log('No faces detected in image');
        return null;
      }

      // Find largest face (by bounding box area) - likely the main artist
      const largest = faces.reduce((a, b) =>
        (a.boundingBox.width * a.boundingBox.height) >
        (b.boundingBox.width * b.boundingBox.height) ? a : b
      );

      // Calculate vertical center of face as percentage
      const faceCenter = largest.boundingBox.y + (largest.boundingBox.height / 2);
      const percentage = Math.round((faceCenter / img.height) * 100);

      console.log(`Face detected at ${percentage}% from top`);
      return `center ${percentage}%`;
    } catch (error) {
      console.error('Face detection failed:', error);
      return null;
    }
  };

  // Fetch artist image from Spotify API with caching and face detection
  // Track in-flight requests to prevent duplicate concurrent fetches
  const artistImageFetchPromises = useRef({});

  const getArtistImage = async (artistName) => {
    if (!artistName) return null;

    const normalizedName = artistName.trim().toLowerCase();
    const cached = artistImageCache.current[normalizedName];
    const now = Date.now();

    // Check cache validity - return both url and facePosition
    if (cached && (now - cached.timestamp) < CACHE_TTL.artistImage) {
      return { url: cached.url, facePosition: cached.facePosition };
    }

    // Check if there's already a fetch in progress for this artist
    if (artistImageFetchPromises.current[normalizedName]) {
      return artistImageFetchPromises.current[normalizedName];
    }

    // Spotify requires authentication
    if (!spotifyToken) {
      console.log('Spotify not connected, cannot fetch artist image');
      return null;
    }

    // Create the fetch promise and store it
    const fetchPromise = (async () => {
      try {
        // Search for the artist on Spotify with exact artist name matching
        const searchUrl = `https://api.spotify.com/v1/search?q=artist:"${encodeURIComponent(artistName)}"&type=artist&limit=5`;
        const response = await fetch(searchUrl, {
          headers: { 'Authorization': `Bearer ${spotifyToken}` }
        });

        if (!response.ok) {
          console.error('Spotify artist search failed:', response.status);
          return null;
        }

        const data = await response.json();

        // Find the artist with exact name match only (case-insensitive)
        // Don't fall back to first result - this causes wrong images for similar artist names
        const artists = data.artists?.items || [];
        const artist = artists.find(a => a.name.toLowerCase() === artistName.toLowerCase());

        if (artist?.images?.length > 0) {
          // Spotify returns images sorted by size (largest first)
          const imageUrl = artist.images[0].url;

          // Detect face position for smart cropping
          const facePosition = await detectFacePosition(imageUrl);

          artistImageCache.current[normalizedName] = {
            url: imageUrl,
            facePosition: facePosition, // may be null
            timestamp: now
          };

          return { url: imageUrl, facePosition };
        }

        return null; // No image available, don't cache failure
      } catch (error) {
        console.error('Failed to fetch artist image from Spotify:', error);
        return null; // Don't cache failures
      } finally {
        // Clean up the in-flight promise
        delete artistImageFetchPromises.current[normalizedName];
      }
    })();

    artistImageFetchPromises.current[normalizedName] = fetchPromise;
    return fetchPromise;
  };

  // Fetch artist image and bio for search preview pane
  useEffect(() => {
    // Only fetch for artist previews when we have a preview item
    if (searchDetailCategory !== 'artists' || !searchPreviewItem) {
      setSearchPreviewArtistImage(null);
      setSearchPreviewArtistBio(null);
      return;
    }

    const artistName = searchPreviewItem.name;
    if (!artistName) return;

    // Fetch artist image from Spotify (uses existing cache)
    const fetchArtistImage = async () => {
      const result = await getArtistImage(artistName);
      if (result?.url) {
        setSearchPreviewArtistImage(result);
      } else {
        setSearchPreviewArtistImage(null);
      }
    };

    // Fetch artist bio snippet from Last.fm (lightweight version, no loading state)
    const fetchArtistBioSnippet = async () => {
      const apiKey = lastfmApiKey.current;
      if (!apiKey) {
        setSearchPreviewArtistBio(null);
        return;
      }

      try {
        const url = `https://ws.audioscrobbler.com/2.0/?method=artist.getinfo&artist=${encodeURIComponent(artistName)}&api_key=${apiKey}&format=json`;
        const response = await fetch(url);
        if (!response.ok) {
          setSearchPreviewArtistBio(null);
          return;
        }

        const data = await response.json();
        if (data.artist?.bio) {
          // Use summary for preview (shorter than content)
          const bioSummary = data.artist.bio.summary || data.artist.bio.content || '';
          // Strip HTML tags and limit to ~200 chars for preview
          const cleanBio = bioSummary.replace(/<[^>]*>/g, '').trim();
          const truncatedBio = cleanBio.length > 200 ? cleanBio.substring(0, 200) + '...' : cleanBio;
          setSearchPreviewArtistBio(truncatedBio);
        } else {
          setSearchPreviewArtistBio(null);
        }
      } catch (error) {
        console.error('Failed to fetch artist bio snippet:', error);
        setSearchPreviewArtistBio(null);
      }
    };

    fetchArtistImage();
    fetchArtistBioSnippet();
  }, [searchDetailCategory, searchPreviewItem?.id]);

  // Fetch artist biography from Last.fm (lazy loaded on Biography tab click)
  const getLastfmBio = async (artistName) => {
    if (!artistName) return null;

    const apiKey = lastfmApiKey.current;
    if (!apiKey) {
      console.warn('âš ï¸ Last.fm API key not available, cannot fetch artist bio');
      return null;
    }

    try {
      const url = `https://ws.audioscrobbler.com/2.0/?method=artist.getinfo&artist=${encodeURIComponent(artistName)}&api_key=${apiKey}&format=json`;

      const response = await fetch(url);
      if (!response.ok) {
        console.error('Last.fm artist info request failed:', response.status);
        return null;
      }

      const data = await response.json();
      if (data.artist?.bio) {
        // Strip HTML tags from bio content
        const bioContent = data.artist.bio.content || data.artist.bio.summary || '';
        const cleanBio = bioContent.replace(/<[^>]*>/g, '').trim();

        // Check if bio has meaningful content (not just "Read more on Last.fm" or similar)
        // Last.fm often returns empty bios with just a link
        if (!cleanBio || cleanBio.length < 50 || cleanBio.toLowerCase().includes('read more on last.fm')) {
          console.log('ðŸŽ§ Last.fm bio is empty or too short, skipping');
          return null;
        }

        // Also get the Last.fm URL for "Read more" link
        const lastfmUrl = data.artist.url || null;

        return { bio: cleanBio, url: lastfmUrl, source: 'lastfm' };
      }

      return null;
    } catch (error) {
      console.error('Failed to fetch artist bio from Last.fm:', error);
      return null;
    }
  };

  // Fetch artist biography from Wikipedia via Wikidata (uses MBID)
  const getWikipediaBio = async (artistMbid) => {
    if (!artistMbid) {
      console.log('ðŸ“š Wikipedia bio skipped: no MBID');
      return null;
    }

    try {
      // Step 1: Query MusicBrainz for Wikidata relation
      const mbUrl = `https://musicbrainz.org/ws/2/artist/${artistMbid}?inc=url-rels&fmt=json`;
      const mbResponse = await fetch(mbUrl, {
        headers: { 'User-Agent': 'Parachord/1.0 (https://parachord.app)' }
      });

      if (!mbResponse.ok) {
        console.log('ðŸ“š MusicBrainz artist lookup failed:', mbResponse.status);
        return null;
      }

      const mbData = await mbResponse.json();

      // Find Wikidata URL in relations
      const wikidataRel = mbData.relations?.find(r =>
        r.type === 'wikidata' && r.url?.resource
      );

      if (!wikidataRel) {
        console.log('ðŸ“š No Wikidata link found for artist');
        return null;
      }

      // Extract Wikidata ID (e.g., "Q1299" from "https://www.wikidata.org/wiki/Q1299")
      const wikidataUrl = wikidataRel.url.resource;
      const wikidataId = wikidataUrl.split('/').pop();

      // Step 2: Query Wikidata for Wikipedia article title
      const wdUrl = `https://www.wikidata.org/w/api.php?action=wbgetentities&ids=${wikidataId}&props=sitelinks&sitefilter=enwiki&format=json&origin=*`;
      const wdResponse = await fetch(wdUrl);

      if (!wdResponse.ok) {
        console.log('ðŸ“š Wikidata lookup failed:', wdResponse.status);
        return null;
      }

      const wdData = await wdResponse.json();
      const wikiTitle = wdData.entities?.[wikidataId]?.sitelinks?.enwiki?.title;

      if (!wikiTitle) {
        console.log('ðŸ“š No English Wikipedia article found');
        return null;
      }

      // Step 3: Fetch Wikipedia article extract (longer bio)
      // Using MediaWiki API with extracts to get more content than the summary endpoint
      const wpUrl = `https://en.wikipedia.org/w/api.php?action=query&titles=${encodeURIComponent(wikiTitle)}&prop=extracts&exintro=1&explaintext=1&format=json&origin=*`;
      const wpResponse = await fetch(wpUrl);

      if (!wpResponse.ok) {
        console.log('ðŸ“š Wikipedia extract fetch failed:', wpResponse.status);
        return null;
      }

      const wpData = await wpResponse.json();
      const pages = wpData.query?.pages;
      const pageId = pages ? Object.keys(pages)[0] : null;
      const extract = pageId && pageId !== '-1' ? pages[pageId].extract : null;

      if (extract) {
        console.log('ðŸ“š Wikipedia bio fetched successfully');
        // Normalize line breaks: ensure double newlines between paragraphs for visual separation
        const formattedBio = extract.trim().replace(/\n+/g, '\n\n');
        return {
          bio: formattedBio,
          url: `https://en.wikipedia.org/wiki/${encodeURIComponent(wikiTitle)}`,
          source: 'wikipedia'
        };
      }

      return null;
    } catch (error) {
      console.error('ðŸ“š Failed to fetch Wikipedia bio:', error);
      return null;
    }
  };

  // Fetch artist image from Wikipedia/Wikidata (fallback when Spotify has no image)
  const getWikipediaArtistImage = async (artistMbid) => {
    if (!artistMbid) return null;

    try {
      // Step 1: Get Wikidata ID via MusicBrainz
      const mbUrl = `https://musicbrainz.org/ws/2/artist/${artistMbid}?inc=url-rels&fmt=json`;
      const mbResponse = await fetch(mbUrl, {
        headers: { 'User-Agent': 'Parachord/1.0 (https://parachord.app)' }
      });

      if (!mbResponse.ok) return null;

      const mbData = await mbResponse.json();
      const wikidataRel = mbData.relations?.find(r =>
        r.type === 'wikidata' && r.url?.resource
      );

      if (!wikidataRel) return null;

      const wikidataId = wikidataRel.url.resource.split('/').pop();

      // Step 2: Get Wikipedia article title
      const wdUrl = `https://www.wikidata.org/w/api.php?action=wbgetentities&ids=${wikidataId}&props=sitelinks&sitefilter=enwiki&format=json&origin=*`;
      const wdResponse = await fetch(wdUrl);

      if (!wdResponse.ok) return null;

      const wdData = await wdResponse.json();
      const wikiTitle = wdData.entities?.[wikidataId]?.sitelinks?.enwiki?.title;

      if (!wikiTitle) return null;

      // Step 3: Fetch Wikipedia page summary (includes thumbnail)
      const wpUrl = `https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(wikiTitle)}`;
      const wpResponse = await fetch(wpUrl);

      if (!wpResponse.ok) return null;

      const wpData = await wpResponse.json();

      if (wpData.thumbnail?.source) {
        console.log('ðŸ“š Wikipedia artist image found');
        return wpData.thumbnail.source;
      }

      return null;
    } catch (error) {
      console.error('ðŸ“š Failed to fetch Wikipedia artist image:', error);
      return null;
    }
  };

  // Fetch artist biography from Discogs (uses MBID or artist name)
  const getDiscogsBio = async (artistMbid, artistName) => {
    if (!artistMbid && !artistName) {
      console.log('ðŸ“€ Discogs bio skipped: no MBID or name');
      return null;
    }

    try {
      // Get Discogs token from metaservice config if available
      const discogsConfig = metaServiceConfigs?.discogs || {};
      const token = discogsConfig.personalAccessToken;

      const headers = {
        'User-Agent': 'Parachord/1.0 (https://parachord.app)'
      };
      if (token) {
        headers['Authorization'] = `Discogs token=${token}`;
      }

      // Search for artist on Discogs
      const searchQuery = artistName || artistMbid;
      const searchUrl = `https://api.discogs.com/database/search?q=${encodeURIComponent(searchQuery)}&type=artist&per_page=5`;

      const searchResponse = await fetch(searchUrl, { headers });

      if (!searchResponse.ok) {
        console.log('ðŸ“€ Discogs search failed:', searchResponse.status);
        return null;
      }

      const searchData = await searchResponse.json();

      if (!searchData.results?.length) {
        console.log('ðŸ“€ No Discogs results found');
        return null;
      }

      // Find best match - prefer exact name match
      let artistResult = searchData.results.find(r =>
        r.title?.toLowerCase() === artistName?.toLowerCase()
      );

      // Fall back to first result if no exact match
      if (!artistResult) {
        artistResult = searchData.results[0];
      }

      // Fetch full artist profile
      const artistUrl = artistResult.resource_url;
      const artistResponse = await fetch(artistUrl, { headers });

      if (!artistResponse.ok) {
        console.log('ðŸ“€ Discogs artist fetch failed:', artistResponse.status);
        return null;
      }

      const artistData = await artistResponse.json();

      if (artistData.profile) {
        // Clean up Discogs profile (remove [a=Artist] style links)
        const cleanProfile = artistData.profile
          .replace(/\[a=([^\]]+)\]/g, '$1')  // [a=Artist Name] -> Artist Name
          .replace(/\[l=([^\]]+)\]/g, '$1')  // [l=Label Name] -> Label Name
          .replace(/\[m=([^\]]+)\]/g, '$1')  // [m=Master] -> Master
          .replace(/\[r=([^\]]+)\]/g, '$1')  // [r=Release] -> Release
          .replace(/\[url=([^\]]+)\]([^\[]+)\[\/url\]/g, '$2')  // [url=...]text[/url] -> text
          .trim();

        console.log('ðŸ“€ Discogs bio fetched successfully');
        return {
          bio: cleanProfile,
          url: artistData.uri || `https://www.discogs.com/artist/${artistData.id}`,
          source: 'discogs'
        };
      }

      return null;
    } catch (error) {
      console.error('ðŸ“€ Failed to fetch Discogs bio:', error);
      return null;
    }
  };

  // Fetch artist image from Discogs (fallback when Spotify and Wikipedia have no image)
  const getDiscogsArtistImage = async (artistMbid, artistName) => {
    if (!artistName) return null;

    try {
      const discogsConfig = metaServiceConfigs?.discogs || {};
      const token = discogsConfig.personalAccessToken;

      const headers = {
        'User-Agent': 'Parachord/1.0 (https://parachord.app)'
      };
      if (token) {
        headers['Authorization'] = `Discogs token=${token}`;
      }

      // Search for artist
      const searchUrl = `https://api.discogs.com/database/search?q=${encodeURIComponent(artistName)}&type=artist&per_page=5`;
      const searchResponse = await fetch(searchUrl, { headers });

      if (!searchResponse.ok) return null;

      const searchData = await searchResponse.json();

      if (!searchData.results?.length) return null;

      // Find best match
      let artistResult = searchData.results.find(r =>
        r.title?.toLowerCase() === artistName.toLowerCase()
      ) || searchData.results[0];

      // Fetch full artist profile for images
      const artistResponse = await fetch(artistResult.resource_url, { headers });

      if (!artistResponse.ok) return null;

      const artistData = await artistResponse.json();

      // Discogs images array - first is primary
      if (artistData.images?.length > 0) {
        // Prefer primary image, fall back to first
        const primaryImage = artistData.images.find(img => img.type === 'primary');
        const imageUrl = primaryImage?.uri || artistData.images[0].uri;
        console.log('ðŸ“€ Discogs artist image found');
        return imageUrl;
      }

      return null;
    } catch (error) {
      console.error('ðŸ“€ Failed to fetch Discogs artist image:', error);
      return null;
    }
  };

  // Fetch artist biography from all sources with priority: Wikipedia > Discogs > Last.fm
  const getArtistBio = async (artistName, artistMbid) => {
    if (!artistName) return null;

    setLoadingBio(true);
    try {
      // Fetch from all sources in parallel
      const [wikipediaBio, discogsBio, lastfmBio] = await Promise.all([
        getWikipediaBio(artistMbid),
        getDiscogsBio(artistMbid, artistName),
        getLastfmBio(artistName)
      ]);

      // Store all sources for potential future use
      const allSources = {};
      if (wikipediaBio) allSources.wikipedia = wikipediaBio;
      if (discogsBio) allSources.discogs = discogsBio;
      if (lastfmBio) allSources.lastfm = lastfmBio;

      // Select best bio based on priority: Wikipedia > Discogs > Last.fm
      const selected = wikipediaBio ?? discogsBio ?? lastfmBio;

      if (selected) {
        console.log(`ðŸŽ¤ Selected bio from ${selected.source}`);
        return { ...selected, allSources };
      }

      console.log('ðŸŽ¤ No biography found from any source');
      return null;
    } catch (error) {
      console.error('Failed to fetch artist bio:', error);
      return null;
    } finally {
      setLoadingBio(false);
    }
  };

  // Fetch extended artist info from MusicBrainz (founded date, location, URLs, members)
  const fetchArtistExtendedInfo = async (artistMbid) => {
    if (!artistMbid) {
      console.log('ðŸŽµ Extended info skipped: no MBID');
      return null;
    }

    // Check cache first
    const cached = artistExtendedInfoCache.current[artistMbid];
    if (cached && (Date.now() - cached.timestamp) < CACHE_TTL.artistExtendedInfo) {
      console.log('ðŸ“¦ Using cached extended info for:', artistMbid);
      return cached.info;
    }

    setLoadingExtendedInfo(true);
    try {
      // Query MusicBrainz for artist with URL relations and artist relations (members)
      const mbUrl = `https://musicbrainz.org/ws/2/artist/${artistMbid}?inc=url-rels+artist-rels&fmt=json`;
      const response = await fetch(mbUrl, {
        headers: { 'User-Agent': 'Parachord/1.0 (https://parachord.app)' }
      });

      if (!response.ok) {
        console.log('ðŸŽµ MusicBrainz extended info fetch failed:', response.status);
        return null;
      }

      const data = await response.json();
      console.log('ðŸŽµ MusicBrainz extended info:', data);

      // Extract founded date and location
      const foundedDate = data['life-span']?.begin || null;
      const endedDate = data['life-span']?.end || null;
      const isActive = !data['life-span']?.ended;
      const foundedIn = data.area?.name || data['begin-area']?.name || null;

      // Extract URLs from relations
      const urls = {
        officialHomepage: null,
        wikipedia: null,
        twitter: null,
        instagram: null,
        facebook: null,
        youtube: null,
        bandcamp: null,
        soundcloud: null,
        spotify: null,
        appleMusic: null,
        discogs: null,
        allmusic: null
      };

      if (data.relations) {
        for (const rel of data.relations) {
          if (rel.type === 'official homepage' && rel.url?.resource) {
            urls.officialHomepage = rel.url.resource;
          } else if (rel.type === 'wikipedia' && rel.url?.resource) {
            urls.wikipedia = rel.url.resource;
          } else if (rel.type === 'social network' && rel.url?.resource) {
            const url = rel.url.resource.toLowerCase();
            if (url.includes('twitter.com') || url.includes('x.com')) {
              urls.twitter = rel.url.resource;
            } else if (url.includes('instagram.com')) {
              urls.instagram = rel.url.resource;
            } else if (url.includes('facebook.com')) {
              urls.facebook = rel.url.resource;
            }
          } else if (rel.type === 'youtube' && rel.url?.resource) {
            urls.youtube = rel.url.resource;
          } else if (rel.type === 'bandcamp' && rel.url?.resource) {
            urls.bandcamp = rel.url.resource;
          } else if (rel.type === 'soundcloud' && rel.url?.resource) {
            urls.soundcloud = rel.url.resource;
          } else if (rel.type === 'streaming' && rel.url?.resource) {
            const url = rel.url.resource.toLowerCase();
            if (url.includes('spotify.com')) {
              urls.spotify = rel.url.resource;
            } else if (url.includes('music.apple.com') || url.includes('itunes.apple.com')) {
              urls.appleMusic = rel.url.resource;
            }
          } else if (rel.type === 'discogs' && rel.url?.resource) {
            urls.discogs = rel.url.resource;
          } else if (rel.type === 'allmusic' && rel.url?.resource) {
            urls.allmusic = rel.url.resource;
          }
        }
      }

      // Extract members from artist relations
      const members = {
        current: [],
        former: []
      };

      if (data.relations) {
        for (const rel of data.relations) {
          // "member of band" relation means rel.artist is the band, current artist is the member
          // "has member" relation (type-id) means current artist is band, rel.artist is member
          if (rel.type === 'member of band' && rel.direction === 'backward' && rel.artist) {
            const member = {
              name: rel.artist.name,
              mbid: rel.artist.id,
              attributes: rel.attributes || [], // e.g., ["guitar", "vocals"]
              beginDate: rel.begin || null,
              endDate: rel.end || null
            };

            // If the relation has ended, it's a former member
            if (rel.ended) {
              members.former.push(member);
            } else {
              members.current.push(member);
            }
          }
        }
      }

      // Sort members by start date (oldest first)
      members.current.sort((a, b) => (a.beginDate || '').localeCompare(b.beginDate || ''));
      members.former.sort((a, b) => (a.beginDate || '').localeCompare(b.beginDate || ''));

      const info = {
        foundedDate,
        endedDate,
        isActive,
        foundedIn,
        type: data.type, // Person, Group, Orchestra, etc.
        gender: data.gender, // For solo artists
        urls,
        members
      };

      // Cache the result
      artistExtendedInfoCache.current[artistMbid] = {
        info,
        timestamp: Date.now()
      };

      console.log('ðŸŽµ Extended info parsed:', info);
      return info;
    } catch (error) {
      console.error('ðŸŽµ Failed to fetch extended info:', error);
      return null;
    } finally {
      setLoadingExtendedInfo(false);
    }
  };

  // Fetch similar artists from ListenBrainz Labs API
  const getListenBrainzSimilarArtists = async (artistMbid) => {
    if (!artistMbid) {
      console.log('ðŸŽ¸ ListenBrainz similar artists skipped: no MBID');
      return [];
    }

    try {
      const url = 'https://labs.api.listenbrainz.org/similar-artists/json';
      const payload = [
        {
          artist_mbids: [artistMbid],
          algorithm: 'session_based_days_7500_session_300_contribution_5_threshold_10_limit_100_filter_True_skip_30'
        }
      ];

      console.log(`ðŸŽ¸ Fetching ListenBrainz similar artists for MBID: ${artistMbid}`);
      const response = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      if (!response.ok) {
        console.error('ListenBrainz similar artists request failed:', response.status);
        return [];
      }

      const data = await response.json();
      console.log(`ðŸŽ¸ ListenBrainz returned ${data?.length || 0} results`);

      // Filter out the reference artist (first result) and map to our format
      // ListenBrainz returns results with score field, higher is more similar
      if (data && Array.isArray(data) && data.length > 1) {
        // Skip first result (reference artist) and take next 20
        const similarArtists = data.slice(1, 21).map((a, index) => ({
          name: a.name || a.artist_name,
          mbid: a.artist_mbid,
          match: Math.round(a.score * 100) || Math.max(95 - (index * 4), 20), // Convert score to percentage
          source: 'listenbrainz',
          imageLoaded: false
        }));
        console.log(`ðŸŽ¸ Returning ${similarArtists.length} ListenBrainz similar artists:`, similarArtists.map(a => a.name));
        return similarArtists;
      }

      return [];
    } catch (error) {
      console.error('Failed to fetch similar artists from ListenBrainz:', error);
      return [];
    }
  };

  // Fetch similar artists from Last.fm API
  const getLastfmSimilarArtists = async (artistName) => {
    if (!artistName) return [];

    const apiKey = lastfmApiKey.current;
    if (!apiKey) {
      console.log('ðŸŽ¸ Last.fm similar artists skipped: no API key');
      return [];
    }

    try {
      const url = `https://ws.audioscrobbler.com/2.0/?method=artist.getsimilar&artist=${encodeURIComponent(artistName)}&api_key=${apiKey}&format=json&limit=20`;

      const response = await fetch(url);
      if (!response.ok) {
        console.error('Last.fm similar artists request failed:', response.status);
        return [];
      }

      const data = await response.json();
      if (data.similarartists?.artist) {
        const artists = data.similarartists.artist.map(a => ({
          name: a.name,
          match: Math.round(parseFloat(a.match) * 100), // Convert 0-1 to percentage
          url: a.url,
          source: 'lastfm',
          imageLoaded: false
        }));
        console.log(`ðŸŽ¸ Returning ${artists.length} Last.fm similar artists`);
        return artists;
      }

      return [];
    } catch (error) {
      console.error('Failed to fetch similar artists from Last.fm:', error);
      return [];
    }
  };

  // Fetch top tracks for an artist from Last.fm API
  const getArtistTopTracks = async (artistName, limit = 10) => {
    if (!artistName) return [];

    const apiKey = lastfmApiKey.current;
    if (!apiKey) {
      console.log('ðŸŽ¤ Last.fm artist top tracks skipped: no API key');
      return [];
    }

    try {
      const url = `https://ws.audioscrobbler.com/2.0/?method=artist.gettoptracks&artist=${encodeURIComponent(artistName)}&api_key=${apiKey}&format=json&limit=${limit}`;

      console.log(`ðŸŽ¤ Fetching top tracks for "${artistName}"`);
      const response = await fetch(url);
      if (!response.ok) {
        console.error('Last.fm artist top tracks request failed:', response.status);
        return [];
      }

      const data = await response.json();
      if (data.toptracks?.track) {
        const tracks = data.toptracks.track.map((t, index) => ({
          // Generate unique ID from artist and title
          id: `lastfm-${artistName.toLowerCase().replace(/[^a-z0-9]/g, '')}-${t.name.toLowerCase().replace(/[^a-z0-9]/g, '')}-${index}`,
          title: t.name,
          artist: artistName,
          album: '', // Last.fm doesn't include album in this endpoint
          duration: t.duration ? parseInt(t.duration) * 1000 : 0, // Convert to ms
          playCount: parseInt(t.playcount) || 0,
          position: index + 1,
          sources: {} // Empty sources triggers on-demand resolution in handlePlay
        }));
        console.log(`ðŸŽ¤ Found ${tracks.length} top tracks for "${artistName}"`);
        return tracks;
      }

      return [];
    } catch (error) {
      console.error('Failed to fetch top tracks from Last.fm:', error);
      return [];
    }
  };

  // Fetch similar tracks from Last.fm API (for Spinoff feature)
  const fetchSimilarTracks = async (artistName, trackName) => {
    if (!artistName || !trackName) return [];

    const apiKey = lastfmApiKey.current;
    if (!apiKey) {
      console.log('ðŸ”€ Last.fm similar tracks skipped: no API key');
      return [];
    }

    try {
      const url = `https://ws.audioscrobbler.com/2.0/?method=track.getsimilar&artist=${encodeURIComponent(artistName)}&track=${encodeURIComponent(trackName)}&api_key=${apiKey}&format=json&limit=20`;

      console.log(`ðŸ”€ Fetching similar tracks for "${trackName}" by ${artistName}`);
      const response = await fetch(url);
      if (!response.ok) {
        console.error('Last.fm similar tracks request failed:', response.status);
        return [];
      }

      const data = await response.json();
      if (data.similartracks?.track) {
        const tracks = data.similartracks.track.map(t => ({
          title: t.name,
          artist: t.artist?.name || 'Unknown Artist',
          match: Math.round(parseFloat(t.match) * 100),
          source: 'lastfm-similar'
        }));
        // Shuffle the tracks for variety (Fisher-Yates shuffle)
        for (let i = tracks.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [tracks[i], tracks[j]] = [tracks[j], tracks[i]];
        }
        console.log(`ðŸ”€ Found ${tracks.length} similar tracks (shuffled)`);
        return tracks;
      }

      return [];
    } catch (error) {
      console.error('Failed to fetch similar tracks from Last.fm:', error);
      return [];
    }
  };

  // Check if similar tracks are available for spinoff (lightweight check)
  const checkSpinoffAvailability = async (artistName, trackName) => {
    if (!artistName || !trackName) return false;

    const apiKey = lastfmApiKey.current;
    if (!apiKey) {
      console.log('ðŸ”€ Spinoff availability check skipped: no API key');
      return false;
    }

    try {
      // Request just 1 track to check if any similar tracks exist
      const url = `https://ws.audioscrobbler.com/2.0/?method=track.getsimilar&artist=${encodeURIComponent(artistName)}&track=${encodeURIComponent(trackName)}&api_key=${apiKey}&format=json&limit=1`;

      const response = await fetch(url);
      if (!response.ok) {
        console.log('ðŸ”€ Spinoff availability check failed:', response.status);
        return false;
      }

      const data = await response.json();
      const hasSimilarTracks = data.similartracks?.track?.length > 0;
      console.log(`ðŸ”€ Spinoff availability for "${trackName}": ${hasSimilarTracks}`);
      return hasSimilarTracks;
    } catch (error) {
      console.error('Failed to check spinoff availability:', error);
      return false;
    }
  };

  // Start spinoff mode - play similar tracks based on current track
  const startSpinoff = async (track) => {
    if (!track || !track.artist || !track.title) {
      console.log('ðŸ”€ Cannot start spinoff: missing track info');
      return;
    }

    setSpinoffLoading(true);
    console.log(`ðŸ”€ Starting spinoff from "${track.title}" by ${track.artist}`);

    // If we're in listen-along mode, exit it first (we're leaving to explore similar music)
    if (listenAlongFriend) {
      console.log(`ðŸ”€ Exiting listen-along with ${listenAlongFriend.displayName} to start spinoff`);
      abortSchedulerContext('listen-along');
      setListenAlongFriend(null);
      listenAlongLastTrackRef.current = null;
      // Don't show the "stopped listening along" toast since we'll show the spinoff toast
    }

    try {
      const similarTracks = await fetchSimilarTracks(track.artist, track.title);

      if (similarTracks.length === 0) {
        showToast(`No similar tracks found for "${track.title}"`);
        return;
      }

      // Save current playback context to restore when spinoff ends
      // (but not if it was a listenAlong context - that session is over)
      if (playbackContext?.type !== 'listenAlong') {
        spinoffPreviousContextRef.current = playbackContext;
      } else {
        spinoffPreviousContextRef.current = null;
      }

      // Enter spinoff mode
      setSpinoffMode(true);
      setSpinoffSourceTrack({ title: track.title, artist: track.artist });
      spinoffTracksRef.current = similarTracks;

      // Register pool context for spinoff resolution
      registerPoolContext('spinoff', 5);

      // Update pool visibility for resolution - next 5 tracks
      // Use track ID as key to avoid re-resolution when tracks shift
      const poolTracks = spinoffTracksRef.current.slice(0, 5).map((t) => ({
        key: t.id || `${t.artist}-${t.title}`,
        data: { track: t, artistName: t.artist || 'Unknown Artist' }
      }));
      updateSchedulerVisibility('spinoff', poolTracks);

      // Set playback context
      setPlaybackContext({
        type: 'spinoff',
        sourceTrack: { title: track.title, artist: track.artist }
      });

      showToast(`Spinning off of ${track.title} - ${track.artist}`);
      console.log(`ðŸ”€ Spinoff mode activated with ${similarTracks.length} tracks`);
    } catch (error) {
      console.error('Failed to start spinoff:', error);
      showToast('Failed to fetch similar tracks');
    } finally {
      setSpinoffLoading(false);
    }
  };

  // Exit spinoff mode - return to normal queue playback
  const exitSpinoff = () => {
    // Abort and cleanup pool context
    abortSchedulerContext('spinoff');

    console.log('ðŸ”€ Exiting spinoff mode, restoring previous context...');
    setSpinoffMode(false);
    setSpinoffSourceTrack(null);
    spinoffTracksRef.current = [];
    // Restore the previous playback context (if any)
    const previousContext = spinoffPreviousContextRef.current;
    setPlaybackContext(previousContext);
    spinoffPreviousContextRef.current = null;
    console.log('ðŸ”€ Spinoff state cleared, restored context:', previousContext?.type || 'none');
  };

  // Fetch related artists from both Last.fm and ListenBrainz (merged and de-duped)
  const getRelatedArtists = async (artistName, artistMbid) => {
    if (!artistName) return [];

    setLoadingRelated(true);
    try {
      // Fetch from both sources in parallel
      const [lastfmArtists, listenbrainzArtists] = await Promise.all([
        getLastfmSimilarArtists(artistName),
        getListenBrainzSimilarArtists(artistMbid)
      ]);

      console.log(`ðŸŽ¸ Fetched ${lastfmArtists.length} from Last.fm, ${listenbrainzArtists.length} from ListenBrainz`);

      // Merge and de-dupe by artist name (case-insensitive)
      const artistMap = new Map();

      // Add Last.fm artists first
      for (const artist of lastfmArtists) {
        const key = artist.name.toLowerCase().trim();
        artistMap.set(key, { ...artist });
      }

      // Merge ListenBrainz artists, combining data for duplicates
      for (const artist of listenbrainzArtists) {
        const key = artist.name.toLowerCase().trim();
        if (artistMap.has(key)) {
          const existing = artistMap.get(key);
          // Keep the higher match score and add ListenBrainz MBID
          artistMap.set(key, {
            ...existing,
            match: Math.max(existing.match, artist.match),
            mbid: artist.mbid || existing.mbid,
            source: 'both' // Mark as appearing in both sources
          });
        } else {
          artistMap.set(key, { ...artist });
        }
      }

      const merged = Array.from(artistMap.values());
      console.log(`ðŸŽ¸ Merged to ${merged.length} unique related artists`);

      return merged;
    } catch (error) {
      console.error('Failed to fetch related artists:', error);
      return [];
    } finally {
      setLoadingRelated(false);
    }
  };

  // Fetch images for related artists
  const resolveRelatedArtistImages = async (artists) => {
    console.log(`ðŸŽ¸ Fetching images for ${artists.length} related artists...`);

    for (const artist of artists) {
      try {
        const result = await getArtistImage(artist.name);
        // Update with image URL and mark as loaded
        setRelatedArtists(prev => prev.map(a =>
          a.name === artist.name ? { ...a, image: result?.url || null, imageLoaded: true } : a
        ));
      } catch (err) {
        console.error(`Error fetching image for ${artist.name}:`, err);
        // Mark as loaded even on error so we show the fallback icon
        setRelatedArtists(prev => prev.map(a =>
          a.name === artist.name ? { ...a, imageLoaded: true } : a
        ));
      }
    }
    console.log(`ðŸŽ¸ Finished fetching related artist images`);
  };

  // Get 4 unique covers for a playlist's 2x2 grid display
  // Prioritizes album art, falls back to artist images
  // Returns array of up to 4 image URLs, using cache when available
  const getPlaylistCovers = async (playlistId, tracks) => {
    // Check cache first - only use cache if we have all 4 covers or it's recent
    const cached = playlistCoverCache.current[playlistId];
    if (cached && Date.now() - cached.timestamp < CACHE_TTL.playlistCover) {
      // If cache has 4 covers or is less than 1 day old, use it
      if (cached.covers.length >= 4 || Date.now() - cached.timestamp < 24 * 60 * 60 * 1000) {
        return cached.covers;
      }
    }

    // Collect unique covers from tracks
    const seenAlbums = new Set(); // Albums we've already tried
    const seenArtists = new Set(); // Artists we've successfully used for images
    const triedArtists = new Set(); // Artists we've attempted (including failures)
    const covers = [];

    // First pass: try album art, then artist image as fallback
    for (const track of tracks) {
      if (covers.length >= 4) break;

      let foundCover = false;

      // First try album art if we have album info
      if (track.album && track.artist) {
        const albumKey = `${track.artist}-${track.album}`.toLowerCase();
        if (!seenAlbums.has(albumKey)) {
          seenAlbums.add(albumKey);

          // If track already has albumArt, use it
          if (track.albumArt) {
            covers.push(track.albumArt);
            seenArtists.add(track.artist.toLowerCase()); // Mark artist as used
            foundCover = true;
          } else {
            // Try to fetch album art
            const artUrl = await getAlbumArt(track.artist, track.album);
            if (artUrl) {
              covers.push(artUrl);
              seenArtists.add(track.artist.toLowerCase()); // Mark artist as used
              foundCover = true;
            }
          }
        }
      }

      // Fall back to artist image if no album art found for this track
      if (!foundCover && track.artist) {
        const artistKey = track.artist.toLowerCase();
        if (!seenArtists.has(artistKey) && !triedArtists.has(artistKey)) {
          triedArtists.add(artistKey);

          const artistResult = await getArtistImage(track.artist);
          if (artistResult?.url) {
            covers.push(artistResult.url);
            seenArtists.add(artistKey);
          }
        }
      }
    }

    // Second pass: if we still don't have 4 covers, try more artist images
    if (covers.length < 4) {
      for (const track of tracks) {
        if (covers.length >= 4) break;
        if (!track.artist) continue;

        const artistKey = track.artist.toLowerCase();
        // Skip if we already have art from this artist or already tried and failed
        if (seenArtists.has(artistKey) || triedArtists.has(artistKey)) continue;

        triedArtists.add(artistKey);
        const artistResult = await getArtistImage(track.artist);
        if (artistResult?.url) {
          covers.push(artistResult.url);
          seenArtists.add(artistKey);
        }
      }
    }

    // Cache the result
    if (covers.length > 0) {
      playlistCoverCache.current[playlistId] = {
        covers,
        timestamp: Date.now()
      };
    }

    return covers;
  };

  // Fetch and update covers for a single playlist (used after import)
  const fetchPlaylistCovers = async (playlistId, tracks) => {
    if (!tracks || tracks.length === 0) return;

    const covers = await getPlaylistCovers(playlistId, tracks);
    if (covers.length > 0) {
      setAllPlaylistCovers(prev => ({
        ...prev,
        [playlistId]: covers
      }));
    }
  };

  // State for current playlist's cover art grid
  const [playlistCoverArt, setPlaylistCoverArt] = useState([]);

  const loadPlaylist = async (playlistOrId, { skipNavigation = false } = {}) => {
    // Accept either a playlist object or an ID for backwards compatibility
    let playlist;
    if (typeof playlistOrId === 'string') {
      console.log('ðŸ–±ï¸ Playlist clicked, ID:', playlistOrId);
      playlist = playlists.find(p => p.id === playlistOrId);
      if (!playlist) {
        console.error('âŒ Playlist not found:', playlistOrId);
        return;
      }
    } else {
      playlist = playlistOrId;
      console.log('ðŸ–±ï¸ Playlist clicked, ID:', playlist.id);
    }

    // Skip if already viewing this playlist (avoid unnecessary reloads)
    if (activeView === 'playlist-view' && selectedPlaylist?.id === playlist.id) {
      console.log('ðŸ“‹ Already viewing playlist:', playlist.title);
      return;
    }

    console.log('ðŸ“‹ Found playlist:', playlist.title);

    setSelectedPlaylist(playlist);
    setPlaylistCoverArt([]); // Reset cover art
    if (!skipNavigation) {
      navigateTo('playlist-view');
    }
    console.log(`ðŸ“‹ Loading playlist: ${playlist.title}`);

    // Parse XSPF if we have the content
    if (playlist.xspf) {
      const parsed = parseXSPF(playlist.xspf);
      if (parsed) {
        console.log(`ðŸŽµ Parsed ${parsed.tracks.length} tracks from XSPF`);

        // Step 1: Immediately display all tracks with metadata (no sources yet)
        const tracksWithIds = parsed.tracks.map(track => {
          const trackId = `${track.artist || 'unknown'}-${track.title || 'untitled'}-${track.album || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
          return { ...track, id: trackId, sources: {} };
        });
        setPlaylistTracks(tracksWithIds);

        // Step 1.5: Fetch playlist cover art (4 unique album covers for 2x2 grid)
        getPlaylistCovers(playlist.id, tracksWithIds).then(covers => {
          setPlaylistCoverArt(covers);
        });

        // Step 1.6: Fetch album art for tracks that don't have it (background, non-blocking)
        tracksWithIds.forEach(async (track) => {
          if (!track.albumArt && track.album) {
            const artUrl = await getAlbumArt(track.artist, track.album);
            if (artUrl) {
              setPlaylistTracks(prevTracks =>
                prevTracks.map(t =>
                  t.id === track.id && !t.albumArt
                    ? { ...t, albumArt: artUrl }
                    : t
                )
              );
            }
          }
        });

        // Resolution handled by scheduler via IntersectionObserver
        console.log(`âœ… Loaded ${tracksWithIds.length} tracks (resolution via scheduler)`);
      }
    } else if (playlist.tracks && playlist.tracks.length > 0) {
      // Handle playlists with tracks array directly (e.g., newly created playlists)
      console.log(`ðŸŽµ Loading ${playlist.tracks.length} tracks from playlist object`);

      // Add IDs and sources to tracks if not present
      const tracksWithIds = playlist.tracks.map(track => {
        const trackId = track.id || `${track.artist || 'unknown'}-${track.title || 'untitled'}-${track.album || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
        return { ...track, id: trackId, sources: track.sources || {} };
      });
      setPlaylistTracks(tracksWithIds);

      // Fetch playlist cover art
      getPlaylistCovers(playlist.id, tracksWithIds).then(covers => {
        setPlaylistCoverArt(covers);
      });

      // Fetch album art for tracks that don't have it
      tracksWithIds.forEach(async (track) => {
        if (!track.albumArt && track.album) {
          const artUrl = await getAlbumArt(track.artist, track.album);
          if (artUrl) {
            setPlaylistTracks(prevTracks =>
              prevTracks.map(t =>
                t.id === track.id && !t.albumArt
                  ? { ...t, albumArt: artUrl }
                  : t
              )
            );
          }
        }
      });

      // Resolution handled by scheduler via IntersectionObserver
      console.log(`âœ… Loaded ${tracksWithIds.length} tracks (resolution via scheduler)`);
    } else {
      // No tracks to display
      console.log('âš ï¸ Playlist has no tracks');
      setPlaylistTracks([]);
    }
  };

  // Keep queue in sync with playlistTracks as they get resolved
  // This ensures queue items get their sources updated without re-setting the entire queue
  useEffect(() => {
    if (currentQueue.length === 0 || playlistTracks.length === 0) return;

    // Check if queue tracks match playlist tracks (by id)
    const queueIds = new Set(currentQueue.map(t => t.id));
    const playlistIds = new Set(playlistTracks.map(t => t.id));

    // Only sync if the queue was created from this playlist
    const isQueueFromPlaylist = currentQueue.every(t => playlistIds.has(t.id));
    if (!isQueueFromPlaylist) return;

    // Update queue items with resolved sources and duration from playlistTracks
    setCurrentQueue(prevQueue =>
      prevQueue.map(queueTrack => {
        const playlistTrack = playlistTracks.find(t => t.id === queueTrack.id);
        if (playlistTrack) {
          const hasMoreSources = Object.keys(playlistTrack.sources || {}).length > Object.keys(queueTrack.sources || {}).length;
          const hasDuration = playlistTrack.duration && !queueTrack.duration;

          if (hasMoreSources || hasDuration) {
            // Update queue track with new sources and/or duration
            return {
              ...queueTrack,
              sources: { ...queueTrack.sources, ...playlistTrack.sources },
              duration: queueTrack.duration || playlistTrack.duration || 0
            };
          }
        }
        return queueTrack;
      })
    );
  }, [playlistTracks]);

  // Sync queue tracks with trackSources updates (for release/album tracks)
  // This ensures queue items get their sources updated when resolution completes
  useEffect(() => {
    if (currentQueue.length === 0 || Object.keys(trackSources).length === 0) return;

    // Check if any queue tracks need source updates from trackSources
    // trackSources uses track.id as the key
    let hasUpdates = false;
    const updatedQueue = currentQueue.map(queueTrack => {
      // Try to find matching sources in trackSources using track.id
      if (queueTrack.id) {
        const resolvedSources = trackSources[queueTrack.id];

        if (resolvedSources && Object.keys(resolvedSources).length > Object.keys(queueTrack.sources || {}).length) {
          hasUpdates = true;
          return { ...queueTrack, sources: { ...queueTrack.sources, ...resolvedSources } };
        }
      }
      return queueTrack;
    });

    if (hasUpdates) {
      setCurrentQueue(updatedQueue);
    }
  }, [trackSources]);

  // Queue track resolution is now handled by ResolutionScheduler via queue context visibility
  // The scheduler monitors queue tracks and resolves them based on priority

  // Navigation helpers
  const navigateTo = (view) => {
    if (view !== activeView) {
      // Clear search state when leaving search view
      if (activeView === 'search') {
        setSearchQuery('');
        setSearchResults({ artists: [], albums: [], tracks: [], playlists: [] });
        setIsSearching(false);
        setDisplayLimits({ artists: 5, albums: 5, tracks: 8, playlists: 5 });
        setSearchDetailCategory(null);
        setSearchPreviewItem(null);
      }
      setViewHistory(prev => [...prev, view]);
      setForwardHistory([]); // Clear forward history when navigating to a new view
      setActiveView(view);
      if (view === 'settings') {
        setSettingsTab('marketplace');
      }
    }
  };

  const navigateBack = () => {
    // If we're viewing a release/album, close it first and go back to artist page
    if (activeView === 'artist' && currentRelease) {
      setCurrentRelease(null);
      return;
    }

    // If we're on artist page and have artist history, go to previous artist
    if (activeView === 'artist' && artistHistory.length > 0) {
      const newArtistHistory = [...artistHistory];
      const previousArtist = newArtistHistory.pop();
      setArtistHistory(newArtistHistory);

      // Fetch the previous artist's data
      const loadPreviousArtist = async () => {
        const cacheKey = previousArtist.toLowerCase();
        const cachedData = artistDataCache.current[cacheKey];
        const now = Date.now();

        // Check if artist image is in cache
        const normalizedName = previousArtist.trim().toLowerCase();
        const cachedImage = artistImageCache.current[normalizedName];
        const imageCacheValid = cachedImage && (now - cachedImage.timestamp) < CACHE_TTL.artistImage;

        // Cache is valid if data exists and not expired
        const cacheValid = cachedData &&
                          (now - cachedData.timestamp) < CACHE_TTL.artistData;

        if (cacheValid) {
          // Set artist image immediately from cache if available
          if (imageCacheValid) {
            setArtistImage(cachedImage.url);
            setArtistImagePosition(cachedImage.facePosition || 'center 25%');
          } else {
            setArtistImage(null);
            setArtistImagePosition('center 25%');
            getArtistImage(previousArtist).then(result => {
              if (result) {
                setArtistImage(result.url);
                setArtistImagePosition(result.facePosition || 'center 25%');
              }
            });
          }

          setCurrentArtist(cachedData.artist);
          const releasesWithCache = cachedData.releases.map(release => ({
            ...release,
            // Use cached URL if available, undefined if needs fetch (shows shimmer)
            albumArt: albumArtCache.current[release.id]?.url !== undefined
              ? albumArtCache.current[release.id]?.url
              : undefined
          }));
          setArtistReleases(releasesWithCache);
          setSmartReleaseTypeFilter(releasesWithCache);
          setLoadingArtist(false);
          // Queue album art fetches for releases without cached art (viewport-prioritized)
          const releasesNeedingArt = cachedData.releases.filter(r => !albumArtCache.current[r.id]);
          albumArtFetchId.current++; // Cancel any previous fetch session
          isAlbumArtFetching.current = false;
          albumArtQueue.current = releasesNeedingArt;
          visibleAlbumIds.current.clear();
          processAlbumArtQueue();
        } else {
          // No valid cache - show loading state
          setLoadingArtist(true);
          setArtistImage(null);
          setArtistImagePosition('center 25%');

          // Refetch if not in cache (rare case)
          const searchResponse = await fetch(
            `https://musicbrainz.org/ws/2/artist?query=${encodeURIComponent(previousArtist)}&fmt=json&limit=1`,
            { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' } }
          );
          const searchData = await searchResponse.json();
          if (searchData.artists?.[0]) {
            const artist = searchData.artists[0];
            setCurrentArtist(artist);
            getArtistImage(previousArtist).then(result => {
              if (result) {
                setArtistImage(result.url);
                setArtistImagePosition(result.facePosition || 'center 25%');
              }
            });
          }
          setLoadingArtist(false);
        }
      };
      loadPreviousArtist();
      return;
    }

    if (viewHistory.length > 1) {
      const newHistory = [...viewHistory];
      const activeView = newHistory.pop(); // Remove current view
      const previousView = newHistory[newHistory.length - 1];
      setViewHistory(newHistory);
      setForwardHistory(prev => [...prev, activeView]); // Add current view to forward history
      setActiveView(previousView);

      // Clear associated state when leaving certain views
      if (activeView === 'artist') {
        setCurrentArtist(null);
        setArtistImage(null);
        setArtistImagePosition('center 25%');
        setArtistReleases([]);
        setReleaseTypeFilter('all');
        setArtistHistory([]); // Clear artist history when leaving artist view
        // Clear album art loading queue
        albumArtQueue.current = [];
        visibleAlbumIds.current.clear();
      }
      if (activeView === 'release') {
        setCurrentRelease(null);
      }
      if (activeView === 'playlist-view') {
        setSelectedPlaylist(null);
        setPlaylistTracks([]);
      }
    }
  };

  const navigateForward = () => {
    if (forwardHistory.length > 0) {
      const newForwardHistory = [...forwardHistory];
      const nextView = newForwardHistory.pop();
      setForwardHistory(newForwardHistory);
      setViewHistory(prev => [...prev, nextView]);
      setActiveView(nextView);
    }
  };

  // Playlist import/export functions
  const handleImportPlaylist = async () => {
    try {
      console.log('ðŸ“¥ Importing playlist...');
      const result = await window.electron.playlists.import();
      
      if (!result) {
        console.log('Import cancelled');
        return;
      }
      
      if (result.error) {
        showConfirmDialog({
          type: 'error',
          title: 'Import Failed',
          message: result.error
        });
        return;
      }

      const { content, filename } = result;

      // Parse to get playlist info
      const parsed = parseXSPF(content);
      if (!parsed) {
        showConfirmDialog({
          type: 'error',
          title: 'Import Failed',
          message: 'Failed to parse XSPF file'
        });
        return;
      }
      
      // Generate unique ID for imported playlist
      const id = `imported-${Date.now()}`;

      // Create playlist object
      const newPlaylist = {
        id: id,
        title: parsed.title,
        creator: parsed.creator,
        tracks: parsed.tracks || [],
        xspf: content,
        createdAt: parsed.date || Date.now(), // Use XSPF date (original creation) or import time
        addedAt: Date.now(), // When added to library
        lastModified: Date.now()
      };

      // Save to electron-store
      const saveResult = await window.electron.playlists.save(newPlaylist);

      if (!saveResult.success) {
        showConfirmDialog({
          type: 'error',
          title: 'Save Failed',
          message: saveResult.error
        });
        return;
      }

      // Add to state (prepend so it appears at top immediately)
      setPlaylists(prev => [newPlaylist, ...prev]);

      // Fetch covers for the 2x2 grid display immediately
      fetchPlaylistCovers(id, parsed.tracks || []);

      console.log(`âœ… Imported playlist: ${parsed.title} (${newPlaylist.tracks.length} tracks)`);
      showConfirmDialog({
        type: 'success',
        title: 'Playlist Imported',
        message: parsed.title
      });
    } catch (error) {
      console.error('Import error:', error);
      showConfirmDialog({
        type: 'error',
        title: 'Import Failed',
        message: error.message
      });
    }
  };

  // Import playlist from URL (hosted XSPF)
  // skipStorageUpdate: true when loading from storage on app start (to avoid duplicates)
  const handleImportPlaylistFromUrl = async (url, skipStorageUpdate = false, storedAddedAt = null) => {
    try {
      console.log('ðŸŒ Importing playlist from URL:', url);

      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`Failed to fetch: ${response.status} ${response.statusText}`);
      }

      const content = await response.text();

      // Parse to get playlist info
      const parsed = parseXSPF(content);
      if (!parsed) {
        showConfirmDialog({
          type: 'error',
          title: 'Import Failed',
          message: 'Failed to parse XSPF file from URL'
        });
        return;
      }

      // Generate ID from URL using a simple hash for uniqueness
      // Using full URL hash instead of truncated base64 to avoid collisions
      const hashCode = (str) => {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash; // Convert to 32bit integer
        }
        return Math.abs(hash).toString(36);
      };
      const id = 'hosted-' + hashCode(url);

      // Check if playlist already exists
      const existingIndex = playlists.findIndex(p => p.sourceUrl === url);
      if (existingIndex >= 0) {
        // Update existing playlist
        setPlaylists(prev => prev.map((p, i) =>
          i === existingIndex
            ? { ...p, xspf: content, title: parsed.title, creator: parsed.creator, tracks: parsed.tracks || [], lastUpdated: Date.now() }
            : p
        ));
        console.log(`ðŸ”„ Updated hosted playlist: ${parsed.title} (${parsed.tracks?.length || 0} tracks)`);
        return { updated: true, playlist: parsed };
      }

      // Add new hosted playlist
      const newPlaylist = {
        id: id,
        filename: null,  // No local file for hosted playlists
        title: parsed.title,
        creator: parsed.creator,
        tracks: parsed.tracks || [],
        xspf: content,
        sourceUrl: url,  // Track the source URL for updates
        createdAt: parsed.date || Date.now(), // Use XSPF date (original creation) or import time
        addedAt: storedAddedAt || Date.now(), // When added to library (use stored value on reload)
        lastModified: Date.now()
      };

      // Add to state (prepend so it appears at top immediately, unless loading from storage)
      setPlaylists(prev => skipStorageUpdate ? [...prev, newPlaylist] : [newPlaylist, ...prev]);

      // Fetch covers for the 2x2 grid display immediately
      fetchPlaylistCovers(id, parsed.tracks || []);

      // Save URL to persistent storage for reload on app start
      // Skip this when loading from storage to avoid duplicates
      if (!skipStorageUpdate) {
        const hostedPlaylists = await window.electron?.store?.get('hosted_playlists') || [];
        hostedPlaylists.push({ url, id, addedAt: Date.now() });
        await window.electron?.store?.set('hosted_playlists', hostedPlaylists);
      }

      console.log(`âœ… Imported hosted playlist: ${parsed.title}`);
      return { updated: false, playlist: parsed };
    } catch (error) {
      console.error('URL import error:', error);
      throw error;
    }
  };

  // Refresh a hosted playlist
  const refreshHostedPlaylist = async (playlistId) => {
    const playlist = playlists.find(p => p.id === playlistId);
    if (!playlist?.sourceUrl) {
      console.log('Not a hosted playlist, cannot refresh');
      return false;
    }

    try {
      console.log(`ðŸ”„ Refreshing hosted playlist: ${playlist.title}`);
      const result = await handleImportPlaylistFromUrl(playlist.sourceUrl);

      // If currently viewing this playlist, reload the tracks
      if (selectedPlaylist?.id === playlistId) {
        const parsed = parseXSPF(result?.playlist ? playlists.find(p => p.id === playlistId)?.xspf : playlist.xspf);
        if (parsed) {
          const tracksWithIds = parsed.tracks.map(track => {
            const trackId = `${track.artist || 'unknown'}-${track.title || 'untitled'}-${track.album || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
            return { ...track, id: trackId, sources: {} };
          });
          // Resolution handled by scheduler via IntersectionObserver
          setPlaylistTracks(tracksWithIds);
        }
      }

      return true;
    } catch (error) {
      console.error('Refresh error:', error);
      return false;
    }
  };

  // Poll hosted playlists for updates
  const hostedPlaylistPollInterval = useRef(null);

  useEffect(() => {
    // Start polling for hosted playlist updates (every 5 minutes)
    const pollHostedPlaylists = async () => {
      const hostedPlaylists = playlists.filter(p => p.sourceUrl);
      if (hostedPlaylists.length === 0) return;

      console.log(`ðŸ”„ Checking ${hostedPlaylists.length} hosted playlist(s) for updates...`);

      for (const playlist of hostedPlaylists) {
        try {
          const response = await fetch(playlist.sourceUrl);
          if (!response.ok) continue;

          const content = await response.text();

          // Check if content changed
          if (content !== playlist.xspf) {
            console.log(`ðŸ“ Hosted playlist changed: ${playlist.title}`);
            await handleImportPlaylistFromUrl(playlist.sourceUrl);
          }
        } catch (error) {
          console.error(`Failed to check playlist ${playlist.title}:`, error);
        }
      }
    };

    // Poll every 5 minutes
    hostedPlaylistPollInterval.current = setInterval(pollHostedPlaylists, 5 * 60 * 1000);

    // Also poll on mount (after a short delay to let playlists load)
    const initialPoll = setTimeout(pollHostedPlaylists, 10000);

    return () => {
      clearInterval(hostedPlaylistPollInterval.current);
      clearTimeout(initialPoll);
    };
  }, [playlists.filter(p => p.sourceUrl).length]); // Re-run when hosted playlist count changes

  // Load hosted playlists on app start
  useEffect(() => {
    const loadHostedPlaylists = async () => {
      let hostedPlaylistUrls = await window.electron?.store?.get('hosted_playlists') || [];
      if (hostedPlaylistUrls.length === 0) {
        setPlaylistsLoading(false);
        return;
      }

      // Deduplicate by URL (in case duplicates accumulated from previous bug)
      const seenUrls = new Set();
      const deduped = hostedPlaylistUrls.filter(item => {
        if (seenUrls.has(item.url)) return false;
        seenUrls.add(item.url);
        return true;
      });

      // Save deduped list back to storage if we removed duplicates
      if (deduped.length < hostedPlaylistUrls.length) {
        console.log(`ðŸ§¹ Cleaned up ${hostedPlaylistUrls.length - deduped.length} duplicate hosted playlist entries`);
        await window.electron?.store?.set('hosted_playlists', deduped);
        hostedPlaylistUrls = deduped;
      }

      console.log(`ðŸ“¦ Loading ${hostedPlaylistUrls.length} hosted playlist(s)...`);

      for (const { url, addedAt } of hostedPlaylistUrls) {
        try {
          // Pass true to skip storage update (already in storage), and stored addedAt to preserve order
          await handleImportPlaylistFromUrl(url, true, addedAt);
        } catch (error) {
          console.error(`Failed to load hosted playlist from ${url}:`, error);
        }
      }

      // All hosted playlists loaded
      setPlaylistsLoading(false);
    };

    // Delay to allow local playlists to load first
    const timer = setTimeout(loadHostedPlaylists, 2000);
    return () => clearTimeout(timer);
  }, []);

  const handleExportPlaylist = async (playlist) => {
    try {
      console.log(`ðŸ“¤ Exporting playlist: ${playlist.id}`);
      
      const defaultFilename = playlist.filename || `${playlist.id}.xspf`;
      const result = await window.electron.playlists.export(defaultFilename, playlist.xspf);
      
      if (!result) {
        console.log('Export cancelled');
        return;
      }
      
      if (!result.success) {
        showConfirmDialog({
          type: 'error',
          title: 'Export Failed',
          message: result.error
        });
        return;
      }

      console.log(`âœ… Exported to: ${result.filepath}`);
      showConfirmDialog({
        type: 'success',
        title: 'Playlist Exported',
        message: 'Successfully saved to disk'
      });
    } catch (error) {
      console.error('Export error:', error);
      showConfirmDialog({
        type: 'error',
        title: 'Export Error',
        message: error.message
      });
    }
  };

  // Add Spotify authentication functions

  // Refresh the Spotify token and return the new token (or null if refresh failed)
  // This is called when a 401 is detected to get a fresh token
  const refreshSpotifyToken = async () => {
    console.log('ðŸ”„ Refreshing Spotify token...');
    if (!window.electron?.spotify) {
      console.log('window.electron.spotify not available');
      return null;
    }

    const tokenData = await window.electron.spotify.checkToken();
    if (tokenData && tokenData.token) {
      console.log('âœ… Token refreshed successfully');
      setSpotifyToken(tokenData.token);
      setSpotifyConnected(true);
      return tokenData.token;
    } else {
      console.log('âŒ Token refresh failed - no valid token returned');
      setSpotifyToken(null);
      setSpotifyConnected(false);
      return null;
    }
  };

  const checkSpotifyToken = async () => {
    console.log('Checking Spotify token...');
    if (window.electron?.spotify) {
      const tokenData = await window.electron.spotify.checkToken();
      console.log('Token data received:', {
        hasData: !!tokenData,
        hasToken: !!tokenData?.token,
        tokenLength: tokenData?.token?.length,
        tokenPreview: tokenData?.token ? tokenData.token.substring(0, 20) + '...' : 'null',
        expiry: tokenData?.expiry,
        hasRefresh: !!tokenData?.refreshToken
      });
      if (tokenData && tokenData.token) {
        console.log('Valid token found, setting connected state');
        setSpotifyToken(tokenData.token);
        setSpotifyConnected(true);
        // Enable Spotify resolver if authenticated
        setActiveResolvers(prev => {
          if (!prev.includes('spotify')) {
            console.log('Adding Spotify to active resolvers');
            return [...prev, 'spotify'];
          }
          return prev;
        });
      } else {
        console.log('No valid token found');
      }
    } else {
      console.log('window.electron.spotify not available');
    }
  };

  const connectSpotify = async () => {
    console.log('=== Connect Spotify Clicked ===');
    console.log('window.electron:', !!window.electron);
    console.log('window.electron.spotify:', !!window.electron?.spotify);
    
    if (window.electron?.spotify) {
      try {
        console.log('Calling authenticate...');
        const result = await window.electron.spotify.authenticate();
        console.log('Authenticate result:', result);
      } catch (error) {
        console.error('Spotify auth error:', error);
        showConfirmDialog({
          type: 'error',
          title: 'Authentication Failed',
          message: 'Spotify authentication failed. Check console for details.'
        });
      }
    } else {
      console.error('window.electron.spotify not available!');
      showConfirmDialog({
        type: 'error',
        title: 'API Not Available',
        message: 'Electron API not available. Make sure preload.js is loaded correctly.'
      });
    }
  };

  const disconnectSpotify = async () => {
    if (window.electron?.spotify) {
      await window.electron.store.delete('spotify_token');
      await window.electron.store.delete('spotify_refresh_token');
      await window.electron.store.delete('spotify_token_expiry');
      setSpotifyToken(null);
      setSpotifyConnected(false);
      // Remove Spotify sources from all tracks and remove from active resolvers
      removeResolverSources('spotify');
      setActiveResolvers(prev => prev.filter(id => id !== 'spotify'));
    }
  };

  // Meta Service config helpers
  const saveMetaServiceConfig = async (serviceId, config) => {
    const newConfigs = { ...metaServiceConfigs, [serviceId]: config };
    setMetaServiceConfigs(newConfigs);
    if (window.electron?.store) {
      await window.electron.store.set('meta_service_configs', newConfigs);
      console.log(`ðŸ’¾ Saved ${serviceId} config`);
    }
  };

  const clearMetaServiceConfig = async (serviceId) => {
    const newConfigs = { ...metaServiceConfigs };
    delete newConfigs[serviceId];
    setMetaServiceConfigs(newConfigs);
    if (window.electron?.store) {
      await window.electron.store.set('meta_service_configs', newConfigs);
      console.log(`ðŸ—‘ï¸ Cleared ${serviceId} config`);
    }
  };

  // Last.fm specific helpers
  const connectLastfm = async (username, apiKey, apiSecret) => {
    if (!username?.trim()) {
      showConfirmDialog({
        type: 'error',
        title: 'Username Required',
        message: 'Please enter your Last.fm username.'
      });
      return false;
    }

    setLastfmConnecting(true);

    // Validate username exists by checking the recommendations endpoint
    try {
      const response = await fetch(`https://www.last.fm/player/station/user/${encodeURIComponent(username.trim())}/recommended`);
      if (!response.ok) {
        setLastfmConnecting(false);
        showConfirmDialog({
          type: 'error',
          title: 'Invalid Username',
          message: `Could not find Last.fm user "${username}". Please check the username and try again.`
        });
        return false;
      }
    } catch (error) {
      console.error('Last.fm validation error:', error);
      setLastfmConnecting(false);
      showConfirmDialog({
        type: 'error',
        title: 'Connection Error',
        message: 'Could not connect to Last.fm. Please check your internet connection.'
      });
      return false;
    }

    await saveMetaServiceConfig('lastfm', {
      username: username.trim(),
      apiKey: apiKey?.trim() || null,
      apiSecret: apiSecret?.trim() || null
    });

    // Also set API credentials on the scrobbler for scrobbling support
    // Note: Last.fm scrobbling also requires OAuth (sessionKey) which is done via ScrobblerSettingsCard
    if (apiKey?.trim() && apiSecret?.trim() && window.lastfmScrobbler) {
      window.lastfmScrobbler.setApiCredentials(apiKey.trim(), apiSecret.trim());
      console.log('ðŸŽ§ Last.fm scrobbler API credentials set');
    }

    setLastfmConnecting(false);
    // Clear inputs after successful connection
    setLastfmUsernameInput('');
    setLastfmApiKeyInput('');
    setLastfmApiSecretInput('');

    console.log(`ðŸŽ§ Connected to Last.fm as ${username}`);
    return true;
  };

  const disconnectLastfm = async () => {
    await clearMetaServiceConfig('lastfm');
    console.log('ðŸŽ§ Disconnected from Last.fm');
  };

  // ListenBrainz specific helpers
  const connectListenbrainz = async (username, userToken) => {
    if (!username?.trim()) {
      showConfirmDialog({
        type: 'error',
        title: 'Username Required',
        message: 'Please enter your ListenBrainz username.'
      });
      return false;
    }

    setListenbrainzConnecting(true);

    // Validate username exists by checking the user endpoint
    try {
      const response = await fetch(`https://api.listenbrainz.org/1/user/${encodeURIComponent(username.trim())}/listen-count`);
      if (!response.ok) {
        setListenbrainzConnecting(false);
        showConfirmDialog({
          type: 'error',
          title: 'Invalid Username',
          message: `Could not find ListenBrainz user "${username}". Please check the username and try again.`
        });
        return false;
      }
    } catch (error) {
      console.error('ListenBrainz validation error:', error);
      setListenbrainzConnecting(false);
      showConfirmDialog({
        type: 'error',
        title: 'Connection Error',
        message: 'Could not connect to ListenBrainz. Please check your internet connection.'
      });
      return false;
    }

    // If token provided, validate it
    if (userToken?.trim()) {
      try {
        const tokenResponse = await fetch('https://api.listenbrainz.org/1/validate-token', {
          headers: {
            'Authorization': `Token ${userToken.trim()}`
          }
        });
        const tokenData = await tokenResponse.json();
        if (!tokenData.valid) {
          setListenbrainzConnecting(false);
          showConfirmDialog({
            type: 'error',
            title: 'Invalid Token',
            message: 'The user token is invalid. Please check and try again, or leave it blank to connect without a token.'
          });
          return false;
        }
      } catch (error) {
        console.error('ListenBrainz token validation error:', error);
        // Non-fatal - continue without token
      }
    }

    await saveMetaServiceConfig('listenbrainz', {
      username: username.trim(),
      userToken: userToken?.trim() || null
    });

    // Also connect the scrobbler if token is provided
    if (userToken?.trim() && window.listenbrainzScrobbler) {
      try {
        await window.listenbrainzScrobbler.connect(userToken.trim());
        // Update scrobbler configs state
        const newConfig = await window.listenbrainzScrobbler.getConfig();
        setScrobblerConfigs(prev => ({ ...prev, listenbrainz: newConfig }));
        console.log('ðŸŽµ ListenBrainz scrobbler connected');
      } catch (err) {
        console.error('Failed to connect ListenBrainz scrobbler:', err);
        // Non-fatal - meta service still works for recommendations
      }
    }

    setListenbrainzConnecting(false);
    // Clear inputs after successful connection
    setListenbrainzUsernameInput('');
    setListenbrainzTokenInput('');

    console.log(`ðŸŽµ Connected to ListenBrainz as ${username}`);
    return true;
  };

  const disconnectListenbrainz = async () => {
    await clearMetaServiceConfig('listenbrainz');
    console.log('ðŸŽµ Disconnected from ListenBrainz');
  };

// Listen for Spotify auth events
useEffect(() => {
  checkSpotifyToken();

  if (window.electron?.spotify) {
    window.electron.spotify.onAuthSuccess((data) => {
      console.log('Spotify auth success!', {
        hasToken: !!data.token,
        tokenLength: data.token?.length,
        tokenPreview: data.token ? data.token.substring(0, 20) + '...' : 'null'
      });
      setSpotifyToken(data.token);
      setSpotifyConnected(true);
      // Automatically enable Spotify resolver after successful auth
      setActiveResolvers(prev => {
        if (!prev.includes('spotify')) {
          return [...prev, 'spotify'];
        }
        return prev;
      });
      console.log('Spotify connected and enabled!');
    });
    window.electron.spotify.onAuthError((error) => {
      console.error('Spotify auth failed:', error);
      showConfirmDialog({
        type: 'error',
        title: 'Spotify Authentication Failed',
        message: error
      });
    });
  }

  // Periodically check and refresh token every 5 minutes
  const tokenRefreshInterval = setInterval(() => {
    console.log('â° Periodic token refresh check...');
    checkSpotifyToken();
  }, 5 * 60 * 1000); // 5 minutes

  return () => clearInterval(tokenRefreshInterval);
}, []);

// Spotify Connect - Get available devices
const getSpotifyDevices = async () => {
  if (!spotifyToken) return [];
  
  try {
    const response = await fetch('https://api.spotify.com/v1/me/player/devices', {
      headers: {
        'Authorization': `Bearer ${spotifyToken}`
      }
    });
    
    if (response.ok) {
      const data = await response.json();
      return data.devices || [];
    }
  } catch (error) {
    console.error('Failed to get devices:', error);
  }
  return [];
};

// Play on Spotify Connect (controls external Spotify clients)
const playOnSpotifyConnect = async (track) => {
  if (!spotifyToken) {
    showConfirmDialog({
      type: 'error',
      title: 'Spotify Not Connected',
      message: 'Please connect to Spotify in Settings to use this feature.'
    });
    return false;
  }

  try {
    // Get available devices
    const devices = await getSpotifyDevices();
    console.log('Available Spotify devices:', devices);

    if (devices.length === 0) {
      showConfirmDialog({
        type: 'info',
        title: 'No Devices Found',
        message: 'No Spotify devices found. Please open Spotify on your phone, computer, or web player (spotify.com), then try again.'
      });
      return false;
    }
    
    // Log all devices for debugging
    console.log(`Found ${devices.length} Spotify device(s):`);
    devices.forEach((d, i) => {
      console.log(`Device ${i + 1}:`, {
        name: d.name,
        type: d.type,
        id: d.id,
        is_active: d.is_active,
        is_restricted: d.is_restricted,
        volume_percent: d.volume_percent
      });
    });

    // Filter out restricted devices (can't be controlled remotely)
    const controllableDevices = devices.filter(d => !d.is_restricted);
    if (controllableDevices.length === 0) {
      console.warn('âš ï¸ All devices are restricted, trying with all devices anyway');
    }
    const availableDevices = controllableDevices.length > 0 ? controllableDevices : devices;

    // Device selection priority:
    // 1. Active device (if any)
    // 2. Computer type devices (Spotify desktop app)
    // 3. Smartphone type devices
    // 4. Any other device (but NOT Web Browser - these are often phantom devices)
    let activeDevice = availableDevices.find(d => d.is_active);

    if (!activeDevice) {
      // No active device - select by preference
      // Prefer Computer > Smartphone > Speaker > other, but avoid "Web Player" type
      const computerDevice = availableDevices.find(d => d.type === 'Computer');
      const smartphoneDevice = availableDevices.find(d => d.type === 'Smartphone');
      const speakerDevice = availableDevices.find(d => d.type === 'Speaker');
      const nonWebDevice = availableDevices.find(d => d.type !== 'Computer' && !d.name.toLowerCase().includes('web'));

      activeDevice = computerDevice || smartphoneDevice || speakerDevice || nonWebDevice || availableDevices[0];
      console.log(`ðŸ“± No active device, selected by preference: "${activeDevice.name}" (${activeDevice.type})`);
    } else {
      console.log(`ðŸ“± Using active device: "${activeDevice.name}" (${activeDevice.type})`);
    }
    
    // If device is not active, wake it up by transferring playback
    // Use play: false to avoid briefly playing the previous track
    if (!activeDevice.is_active) {
      console.log('Device not active, waking device...');
      const transferResponse = await fetch('https://api.spotify.com/v1/me/player', {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${spotifyToken}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          device_ids: [activeDevice.id],
          play: false // Wake device but don't resume previous track
        })
      });

      if (!transferResponse.ok && transferResponse.status !== 204) {
        console.error('Failed to wake device:', transferResponse.status);
        const error = await transferResponse.text();
        console.error('Wake error details:', error);
        // Don't return - try the play call anyway as fallback
      } else {
        console.log('Device woken up, waiting for it to become ready...');
        // Longer delay to let device fully wake up
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    // Now play the specific track on the device
    console.log('Starting playback on device:', activeDevice.name);
    const response = await fetch(`https://api.spotify.com/v1/me/player/play?device_id=${activeDevice.id}`, {
      method: 'PUT',
      headers: {
        'Authorization': `Bearer ${spotifyToken}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        uris: [track.spotifyUri]
      })
    });
    
    if (response.ok || response.status === 204) {
      console.log('âœ… Play command accepted by Spotify:', activeDevice.name);

      // Verify playback actually started by polling the player state
      // This catches cases where the command was accepted but playback didn't start
      await new Promise(resolve => setTimeout(resolve, 500)); // Brief delay before checking

      try {
        const verifyResponse = await fetch('https://api.spotify.com/v1/me/player', {
          headers: { 'Authorization': `Bearer ${spotifyToken}` }
        });

        if (verifyResponse.ok) {
          const verifyData = await verifyResponse.json();
          if (verifyData.is_playing) {
            console.log('âœ… Verified: Spotify is now playing');
          } else {
            console.warn('âš ï¸ Play command accepted but Spotify reports is_playing=false');
            console.log('Player state:', {
              is_playing: verifyData.is_playing,
              progress_ms: verifyData.progress_ms,
              item: verifyData.item?.name,
              device: verifyData.device?.name
            });
          }
          // Store device info for volume control capability check
          if (verifyData.device) {
            setSpotifyDevice({
              name: verifyData.device.name,
              type: verifyData.device.type,
              supports_volume: verifyData.device.supports_volume
            });
          }
        }
      } catch (verifyError) {
        console.warn('Could not verify playback state:', verifyError.message);
      }

      setCurrentTrack(track);
      setIsPlaying(true);
      // Reset browser playback state since we're now using Spotify Connect
      setBrowserPlaybackActive(false);
      setIsExternalPlayback(false);

      // Don't call getCurrentPlaybackState() here - let polling handle it
      // This prevents flickering when starting playback
      return true;
    } else {
      const error = await response.text();
      console.error('Spotify play failed:', response.status, error);
      
      // Provide specific error messages
      if (response.status === 404) {
        showConfirmDialog({
          type: 'error',
          title: 'Device Not Responding',
          message: `Spotify device "${activeDevice.name}" is not responding.\n\nTry playing any song on Spotify first, then use Parachord.`
        });
      } else if (response.status === 403) {
        showConfirmDialog({
          type: 'error',
          title: 'Premium Required',
          message: 'Spotify Premium is required for remote playback.'
        });
      } else {
        showConfirmDialog({
          type: 'error',
          title: 'Playback Failed',
          message: `Failed to play on Spotify. Error: ${response.status}`
        });
      }
      return false;
    }
  } catch (error) {
    console.error('Spotify Connect error:', error);
    showConfirmDialog({
      type: 'error',
      title: 'Spotify Error',
      message: error.message
    });
    return false;
  }
};

// Get current playback state from Spotify
const getCurrentPlaybackState = async () => {
  if (!spotifyToken) return;

  // Don't update track info from Spotify when browser playback is active
  // This prevents overwriting the current track with whatever Spotify last played
  if (browserPlaybackActive || isExternalPlayback) {
    return;
  }

  try {
    const response = await fetch('https://api.spotify.com/v1/me/player', {
      headers: {
        'Authorization': `Bearer ${spotifyToken}`
      }
    });

    if (response.ok) {
      const data = await response.json();
      if (data && data.item) {
        const newIsPlaying = data.is_playing;
        const newProgress = data.progress_ms / 1000;
        const newTrackId = `spotify-${data.item.id}`;

        // Only update if something changed
        if (isPlaying !== newIsPlaying) {
          setIsPlaying(newIsPlaying);
        }

        // Update progress baseline for smooth interpolation
        // The interpolation effect will smoothly update between API polls
        // Include isPlaying so interpolation only runs when Spotify is actually playing
        spotifyProgressBaselineRef.current = {
          progress: newProgress,
          timestamp: Date.now(),
          isPlaying: newIsPlaying
        };
        setProgress(newProgress);

        // Check if Spotify is playing a different track than what we initiated
        // Use currentTrackRef to avoid stale closure issues
        const track = currentTrackRef.current;
        const currentSpotifyUri = track?.spotifyUri || track?.sources?.spotify?.spotifyUri;
        const newSpotifyUri = data.item.uri;

        // Determine if this is the same track we're playing (even if URIs weren't set yet)
        const isSameTrack = currentSpotifyUri === newSpotifyUri ||
          (track && !currentSpotifyUri && track.title?.toLowerCase() === data.item.name?.toLowerCase());

        // Debug: Log track comparison for highlight debugging
        if (!isSameTrack) {
          console.log('ðŸ”„ Spotify polling: Track mismatch detected', {
            currentSpotifyUri,
            newSpotifyUri,
            trackTitle: track?.title,
            spotifyTitle: data.item.name,
            trackId: track?.id,
            hasPlaybackContext: !!track?._playbackContext
          });
        }

        if (!isSameTrack) {
          // Different track is playing - this is an external change (user changed track in Spotify app)
          // Create new track without playback context since we didn't initiate this
          setCurrentTrack({
            id: newTrackId,
            title: data.item.name,
            artist: data.item.artists.map(a => a.name).join(', '),
            album: data.item.album.name,
            duration: data.item.duration_ms / 1000,
            albumArt: data.item.album.images[0]?.url,
            spotifyUri: data.item.uri,
            spotifyId: data.item.id,
            sources: ['spotify']
            // Note: _playbackContext is intentionally not set here since this is an external track change
          });
        } else {
          // Same track - update metadata while preserving original ID and playback context
          setCurrentTrack(prev => ({
            ...prev,
            // Preserve original ID and context - never overwrite these
            duration: data.item.duration_ms / 1000,
            albumArt: prev.albumArt || data.item.album.images[0]?.url,
            spotifyUri: data.item.uri,
            spotifyId: data.item.id
          }));
        }

        // Update device info if available
        if (data.device) {
          setSpotifyDevice({
            name: data.device.name,
            type: data.device.type,
            supports_volume: data.device.supports_volume
          });
        }
      }
    }
  } catch (error) {
    console.error('Failed to get playback state:', error);
  }
};

// Poll Spotify playback state when playing
useEffect(() => {
  if (!spotifyToken || !isPlaying) return;
  
  const currentIsSpotify = currentTrack?.sources?.spotify || currentTrack?.spotifyUri;
  if (!currentIsSpotify) return;
  
  // Poll every 5 seconds (reduced from 2 to minimize flickering)
  const interval = setInterval(() => {
    getCurrentPlaybackState();
  }, 5000);
  
  return () => clearInterval(interval);
}, [spotifyToken, isPlaying, currentTrack]);

  const formatTime = (seconds) => {
    if (!seconds || isNaN(seconds)) return '0:00';
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  const formatTimeAgo = (timestamp) => {
    if (!timestamp) return '';
    const now = Date.now();
    const diff = now - timestamp;
    const minutes = Math.floor(diff / 60000);
    const hours = Math.floor(diff / 3600000);
    const days = Math.floor(diff / 86400000);

    if (minutes < 1) return 'Just now';
    if (minutes < 60) return `${minutes}m ago`;
    if (hours < 24) return `${hours}h ago`;
    if (days < 7) return `${days}d ago`;

    // For older, show date with year
    const date = new Date(timestamp);
    const currentYear = new Date().getFullYear();
    const dateYear = date.getFullYear();
    // Show year if it's not the current year
    if (dateYear !== currentYear) {
      return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
    }
    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
  };

  return React.createElement('div', {
    className: 'h-screen bg-gray-100 text-gray-900 flex flex-col'
  },

    // Main content with sidebar (no separate header - search is in sidebar)
    React.createElement('div', {
      className: 'flex-1 flex overflow-hidden'
    },
      // Sidebar
      React.createElement('div', {
        className: 'w-64 bg-gray-50 border-r border-gray-200 flex flex-col no-drag',
        onDragOver: (e) => {
          // Show Add to Playlist panel when dragging a track over sidebar
          if (draggingTrackForPlaylist && !addToPlaylistPanel.open) {
            e.preventDefault();
            setAddToPlaylistPanel({
              open: true,
              tracks: [draggingTrackForPlaylist],
              sourceName: draggingTrackForPlaylist.title,
              sourceType: 'track'
            });
            setSelectedPlaylistsForAdd([]);
          }
        }
      },
        // Draggable title bar area (space for macOS traffic lights)
        React.createElement('div', {
          className: 'h-8 drag flex-shrink-0'
        }),
        // Navigation arrows
        React.createElement('div', {
          className: 'flex items-center gap-2 px-4 pb-2'
        },
          React.createElement('button', {
            onClick: navigateBack,
            disabled: viewHistory.length <= 1,
            className: `p-1.5 rounded hover:bg-gray-200 transition-colors no-drag ${viewHistory.length <= 1 ? 'text-gray-300 cursor-not-allowed' : 'text-gray-600'}`
          },
            React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
              React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M15 19l-7-7 7-7' })
            )
          ),
          React.createElement('button', {
            onClick: navigateForward,
            disabled: forwardHistory.length === 0,
            className: `p-1.5 rounded hover:bg-gray-200 transition-colors no-drag ${forwardHistory.length === 0 ? 'text-gray-300 cursor-not-allowed' : 'text-gray-600'}`
          },
            React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
              React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M9 5l7 7-7 7' })
            )
          )
        ),

        // Search - navigates to search page
        React.createElement('div', {
          style: {
            padding: '4px 16px 12px',
            borderBottom: '1px solid rgba(0, 0, 0, 0.06)'
          }
        },
          React.createElement('button', {
            className: 'w-full flex items-center gap-2 cursor-pointer transition-colors',
            style: {
              color: activeView === 'search' ? '#1f2937' : '#6b7280',
              fontWeight: activeView === 'search' ? '500' : '400'
            },
            onClick: () => navigateTo('search')
          },
            React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
              React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' })
            ),
            React.createElement('span', {
              style: {
                fontSize: '11px',
                fontWeight: '600',
                textTransform: 'uppercase',
                letterSpacing: '0.08em'
              }
            }, 'Search')
          )
        ),

        // Scrollable navigation area
        React.createElement('div', { className: 'flex-1 overflow-y-auto scrollable-content px-2 py-2' },
          // DISCOVER section
          React.createElement('div', { className: 'mb-4' },
            React.createElement('div', {
              style: {
                padding: '8px 12px',
                fontSize: '11px',
                fontWeight: '600',
                color: '#9ca3af',
                textTransform: 'uppercase',
                letterSpacing: '0.08em'
              }
            }, 'Discover'),
            React.createElement('button', {
              onClick: () => navigateTo('recommendations'),
              className: 'w-full flex items-center gap-3 px-3 py-1.5 rounded text-sm transition-colors',
              style: {
                backgroundColor: activeView === 'recommendations' ? 'rgba(0, 0, 0, 0.06)' : 'transparent',
                color: activeView === 'recommendations' ? '#1f2937' : '#4b5563',
                fontWeight: activeView === 'recommendations' ? '500' : '400'
              }
            },
              // Star icon for Recommendations
              React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z' })
              ),
              "Recommendations"
            ),
            React.createElement('button', {
              onClick: () => {
                navigateTo('discover');
                loadCharts();
              },
              className: 'w-full flex items-center gap-3 px-3 py-1.5 rounded text-sm transition-colors',
              style: {
                backgroundColor: activeView === 'discover' ? 'rgba(0, 0, 0, 0.06)' : 'transparent',
                color: activeView === 'discover' ? '#1f2937' : '#4b5563',
                fontWeight: activeView === 'discover' ? '500' : '400'
              }
            },
              // Bar chart icon for Charts
              React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z' })
              ),
              'Pop of the Tops'
            ),
            React.createElement('button', {
              onClick: () => {
                navigateTo('critics-picks');
                loadCriticsPicks();
              },
              className: 'w-full flex items-center gap-3 px-3 py-1.5 rounded text-sm transition-colors',
              style: {
                backgroundColor: activeView === 'critics-picks' ? 'rgba(0, 0, 0, 0.06)' : 'transparent',
                color: activeView === 'critics-picks' ? '#1f2937' : '#4b5563',
                fontWeight: activeView === 'critics-picks' ? '500' : '400'
              }
            },
              // Award/trophy icon for Critical Darlings
              React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M5 3h14a1 1 0 011 1v3a7 7 0 01-7 7 7 7 0 01-7-7V4a1 1 0 011-1zM8.5 21h7M12 17v4M8 14l-3-3m11 3l3-3' })
              ),
              "Critical Darlings"
            )
          ),

          // YOUR MUSIC section
          React.createElement('div', { className: 'mb-4' },
            React.createElement('div', {
              style: {
                padding: '8px 12px',
                fontSize: '11px',
                fontWeight: '600',
                color: '#9ca3af',
                textTransform: 'uppercase',
                letterSpacing: '0.08em'
              }
            }, 'Your Music'),
            React.createElement('button', {
              onClick: () => navigateTo('library'),
              onDragOver: (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; },
              onDragEnter: (e) => { e.preventDefault(); setCollectionDropHighlight(true); },
              onDragLeave: (e) => { e.preventDefault(); setCollectionDropHighlight(false); },
              onDrop: handleCollectionDrop,
              className: 'w-full flex items-center gap-3 px-3 py-1.5 rounded text-sm transition-colors',
              style: collectionDropHighlight ? {
                backgroundColor: 'rgba(124, 58, 237, 0.1)',
                border: '2px solid #a78bfa',
                color: '#7c3aed'
              } : {
                backgroundColor: activeView === 'library' ? 'rgba(0, 0, 0, 0.06)' : 'transparent',
                color: activeView === 'library' ? '#1f2937' : '#4b5563',
                fontWeight: activeView === 'library' ? '500' : '400'
              }
            },
              React.createElement('svg', { className: 'w-4 h-4 flex-shrink-0', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10' })
              ),
              'Collection',
              sidebarBadges.collection && React.createElement('span', {
                key: `collection-badge-${Date.now()}`,
                className: 'ml-auto sidebar-badge',
                style: {
                  fontSize: '11px',
                  backgroundColor: '#7c3aed',
                  color: '#ffffff',
                  padding: '2px 6px',
                  borderRadius: '10px'
                }
              }, `+${sidebarBadges.collection}`)
            ),
            React.createElement('button', {
              onClick: () => navigateTo('playlists'),
              className: 'w-full flex items-center gap-3 px-3 py-1.5 rounded text-sm transition-colors',
              style: {
                backgroundColor: (activeView === 'playlists' || activeView === 'playlist-view') ? 'rgba(0, 0, 0, 0.06)' : 'transparent',
                color: (activeView === 'playlists' || activeView === 'playlist-view') ? '#1f2937' : '#4b5563',
                fontWeight: (activeView === 'playlists' || activeView === 'playlist-view') ? '500' : '400'
              }
            },
              React.createElement('svg', { className: 'w-4 h-4 flex-shrink-0', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M4 6h16M4 10h16M4 14h16M4 18h16' })
              ),
              'Playlists',
              sidebarBadges.playlists && React.createElement('span', {
                key: `playlists-badge-${Date.now()}`,
                className: 'ml-auto sidebar-badge',
                style: {
                  fontSize: '11px',
                  backgroundColor: '#7c3aed',
                  color: '#ffffff',
                  padding: '2px 6px',
                  borderRadius: '10px'
                }
              }, `+${sidebarBadges.playlists}`)
            ),
            React.createElement('button', {
              onClick: () => {}, // Placeholder
              className: 'w-full flex items-center gap-3 px-3 py-1.5 rounded text-sm',
              style: { color: '#9ca3af', cursor: 'not-allowed' }
            },
              React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M5.636 18.364a9 9 0 010-12.728m12.728 0a9 9 0 010 12.728m-9.9-2.829a5 5 0 010-7.07m7.072 0a5 5 0 010 7.07M13 12a1 1 0 11-2 0 1 1 0 012 0z' })
              ),
              'Stations'
            ),
            React.createElement('button', {
              onClick: () => {
                navigateTo('history');
                loadTopTracks();
              },
              className: 'w-full flex items-center gap-3 px-3 py-1.5 rounded text-sm transition-colors',
              style: {
                backgroundColor: activeView === 'history' ? 'rgba(0, 0, 0, 0.06)' : 'transparent',
                color: activeView === 'history' ? '#1f2937' : '#4b5563',
                fontWeight: activeView === 'history' ? '500' : '400'
              }
            },
              React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z' })
              ),
              'History'
            )
          ),

          // FRIENDS section (only show if there are pinned friends OR dragging a friend over)
          (pinnedFriendIds.length > 0 || friendDragOverSidebar) && React.createElement('div', {
            className: 'rounded-lg transition-colors',
            style: friendDragOverSidebar ? {
              backgroundColor: 'rgba(124, 58, 237, 0.05)',
              boxShadow: 'inset 0 0 0 2px rgba(167, 139, 250, 0.5)'
            } : {},
            onDragOver: (e) => {
              if (e.dataTransfer.types.includes('friendid')) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
                setFriendDragOverSidebar(true);
              }
            },
            onDragLeave: (e) => {
              // Only reset if leaving the section entirely
              if (!e.currentTarget.contains(e.relatedTarget)) {
                setFriendDragOverSidebar(false);
              }
            },
            onDrop: (e) => {
              e.preventDefault();
              setFriendDragOverSidebar(false);
              const friendId = e.dataTransfer.getData('friendId');
              if (friendId && !pinnedFriendIds.includes(friendId)) {
                pinFriend(friendId);
              }
            }
          },
          React.createElement('div', { className: 'flex items-center justify-between', style: { padding: '8px 12px' } },
            React.createElement('span', {
              style: {
                fontSize: '11px',
                fontWeight: '600',
                color: '#9ca3af',
                textTransform: 'uppercase',
                letterSpacing: '0.08em'
              }
            }, 'Friends'),
            React.createElement('button', {
              onClick: (e) => { e.stopPropagation(); setAddFriendModalOpen(true); },
              className: 'w-4 h-4 flex items-center justify-center text-gray-400 hover:text-gray-600 transition-colors rounded hover:bg-gray-200',
              title: 'Add friend'
            },
              React.createElement('svg', { className: 'w-3 h-3', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor', strokeWidth: 2 },
                React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', d: 'M12 4v16m8-8H4' })
              )
            )
          ),
          // Show drop hint when dragging but no friends pinned yet
          friendDragOverSidebar && pinnedFriendIds.length === 0 && React.createElement('div', {
            className: 'px-3 py-4 text-sm text-purple-600 text-center'
          }, 'Drop to pin'),
          // Sort pinned friends: active (on-air) friends first, then by original order
          [...pinnedFriendIds].sort((a, b) => {
            const friendA = friends.find(f => f.id === a);
            const friendB = friends.find(f => f.id === b);
            const aOnAir = friendA && isOnAir(friendA);
            const bOnAir = friendB && isOnAir(friendB);
            if (aOnAir && !bOnAir) return -1;
            if (!aOnAir && bOnAir) return 1;
            return 0; // Keep original order within same group
          }).map((friendId, index) => {
            const friend = friends.find(f => f.id === friendId);
            if (!friend) return null;
            const onAir = isOnAir(friend);
            const isSelected = activeView === 'friendHistory' && currentFriend?.id === friend.id;

            const isNewlyPinned = newlyPinnedFriendIds.has(friend.id);
            const wasMoved = movedFriendIds.has(friend.id);

            return React.createElement('div', {
              key: friend.id,
              ref: (el) => {
                if (el) {
                  friendEntryRefs.current.set(friend.id, el);
                  if (friendsObserverRef.current) {
                    friendsObserverRef.current.observe(el);
                  }
                } else {
                  friendEntryRefs.current.delete(friend.id);
                }
              },
              'data-friend-id': friend.id,
              className: `px-3 py-1 rounded cursor-pointer group transition-all duration-300 ease-in-out flex items-center ${isNewlyPinned ? 'friend-entry' : ''} ${wasMoved ? 'friend-moved' : ''}`,
              style: {
                minHeight: '44px',
                backgroundColor: isSelected ? 'rgba(0, 0, 0, 0.06)' : 'transparent',
                color: isSelected ? '#1f2937' : 'inherit'
              },
              draggable: true,
              onClick: () => navigateToFriend(friend),
              onDragStart: (e) => {
                e.dataTransfer.setData('friendIndex', index.toString());
                e.dataTransfer.effectAllowed = 'move';
              },
              onDragOver: (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
              },
              onDrop: (e) => {
                e.preventDefault();
                const fromIndex = parseInt(e.dataTransfer.getData('friendIndex'));
                if (!isNaN(fromIndex) && fromIndex !== index) {
                  reorderPinnedFriends(fromIndex, index);
                }
              },
              onContextMenu: (e) => {
                e.preventDefault();
                if (window.electron?.contextMenu?.showTrackMenu) {
                  window.electron.contextMenu.showTrackMenu({
                    type: 'friend',
                    friend: friend,
                    isPinned: true,
                    isSavedToCollection: friend.savedToCollection,
                    isOnAir: onAir,
                    isListeningAlong: listenAlongFriend?.id === friend.id
                  });
                }
              }
            },
              React.createElement('div', { className: 'flex items-center gap-2' },
                // Hexagonal avatar with on-air indicator
                React.createElement('div', {
                  className: 'relative flex-shrink-0',
                  onClick: (e) => {
                    e.stopPropagation();
                    navigateToFriend(friend);
                  }
                },
                  React.createElement('div', {
                    className: 'w-8 h-8 bg-gray-200 overflow-hidden',
                    style: {
                      clipPath: 'polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%)'
                    }
                  },
                    friend.avatarUrl
                      ? React.createElement('img', {
                          src: friend.avatarUrl,
                          alt: friend.displayName,
                          className: 'w-full h-full object-cover'
                        })
                      : React.createElement('div', {
                          className: 'w-full h-full flex items-center justify-center text-gray-500 text-xs font-medium bg-gradient-to-br from-purple-400 to-pink-400 text-white'
                        }, friend.displayName.charAt(0).toUpperCase())
                  ),
                  // On-air indicator dot
                  onAir && React.createElement('div', {
                    className: 'absolute -bottom-0.5 -right-0.5 w-3 h-3 bg-green-500 rounded-full border-2 border-gray-50'
                  })
                ),
                // Name and track info
                React.createElement('div', { className: 'flex-1 min-w-0' },
                  // Friend name with listen-along toggle
                  React.createElement('div', { className: 'flex items-center gap-1' },
                    React.createElement('span', {
                      className: 'text-sm text-gray-600 truncate'
                    }, friend.displayName),
                    // Listen along toggle - only show when friend is on-air
                    // Hidden by default, show on hover OR when actively listening along
                    onAir && React.createElement(Tooltip, {
                      content: listenAlongFriend?.id === friend.id ? 'Stop listening along' : 'Listen along',
                      position: 'top',
                      variant: 'light'
                    },
                      React.createElement('button', {
                        onClick: (e) => {
                          e.stopPropagation();
                          if (listenAlongFriend?.id === friend.id) {
                            deactivateListenAlong();
                          } else {
                            activateListenAlong(friend);
                          }
                        },
                        className: `flex-shrink-0 transition-all p-1 rounded ${
                          listenAlongFriend?.id === friend.id
                            ? 'text-purple-500 hover:text-purple-400 hover:bg-purple-50 opacity-100'
                            : 'text-gray-400 hover:text-gray-600 hover:bg-gray-100 opacity-0 group-hover:opacity-100'
                        }`
                      },
                      React.createElement('svg', {
                        className: 'w-3.5 h-3.5',
                        fill: 'none',
                        viewBox: '0 0 24 24',
                        stroke: 'currentColor',
                        strokeWidth: 2
                      },
                        React.createElement('path', {
                          strokeLinecap: 'round',
                          strokeLinejoin: 'round',
                          d: 'M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1'
                        })
                      )
                    )
                    ) // Close Tooltip
                  ),
                  // Mini playbar showing friend's current track
                  onAir && friend.cachedRecentTrack && React.createElement(FriendMiniPlaybar, {
                    track: friend.cachedRecentTrack,
                    getAlbumArt: getAlbumArt,
                    onPlay: (e) => {
                      e.stopPropagation();
                      // Get cached sources for instant playback
                      const cacheKey = `${friend.cachedRecentTrack.artist.toLowerCase()}|${friend.cachedRecentTrack.name.toLowerCase()}|0`;
                      const cachedSources = trackSourcesCache.current[cacheKey]?.sources || {};
                      const track = {
                        title: friend.cachedRecentTrack.name,
                        artist: friend.cachedRecentTrack.artist,
                        album: friend.cachedRecentTrack.album,
                        albumArt: friend.cachedRecentTrack.albumArt,
                        sources: cachedSources
                      };
                      // Clear queue and play (like clicking any other track)
                      setQueueWithContext([], { type: 'friend-track', name: `${friend.displayName}'s track` });
                      handlePlay(track);
                    },
                    onContextMenu: (e) => {
                      e.preventDefault();
                      e.stopPropagation();
                      if (window.electron?.contextMenu?.showTrackMenu) {
                        // Get cached sources for context menu actions too
                        const cacheKey = `${friend.cachedRecentTrack.artist.toLowerCase()}|${friend.cachedRecentTrack.name.toLowerCase()}|0`;
                        const cachedSources = trackSourcesCache.current[cacheKey]?.sources || {};
                        window.electron.contextMenu.showTrackMenu({
                          type: 'friend-track',
                          track: {
                            title: friend.cachedRecentTrack.name,
                            artist: friend.cachedRecentTrack.artist,
                            album: friend.cachedRecentTrack.album,
                            albumArt: friend.cachedRecentTrack.albumArt,
                            sources: cachedSources
                          }
                        });
                      }
                    }
                  })
                )
              )
            );
          })
          ),

          // Empty state hint for Friends when no friends pinned but friends exist
          friends.length > 0 && pinnedFriendIds.length === 0 && !friendDragOverSidebar && React.createElement('div', {
            className: 'rounded-lg transition-colors',
            onDragOver: (e) => {
              if (e.dataTransfer.types.includes('friendid')) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
                setFriendDragOverSidebar(true);
              }
            },
            onDragLeave: () => setFriendDragOverSidebar(false),
            onDrop: (e) => {
              e.preventDefault();
              setFriendDragOverSidebar(false);
              const friendId = e.dataTransfer.getData('friendId');
              if (friendId && !pinnedFriendIds.includes(friendId)) {
                pinFriend(friendId);
              }
            }
          },
            React.createElement('div', { className: 'px-3 py-2 text-xs font-semibold text-gray-400 uppercase tracking-wider' }, 'Friends'),
            React.createElement('div', { className: 'px-3 py-2 text-xs text-gray-400 italic' }, 'Drag friends here to pin')
          )
        ),

        // Settings button at bottom of sidebar - styled to match Search
        React.createElement('div', {
          style: {
            padding: '12px 16px 16px',
            borderTop: '1px solid rgba(0, 0, 0, 0.06)'
          }
        },
          React.createElement('button', {
            className: 'w-full flex items-center gap-2 cursor-pointer transition-colors',
            style: {
              color: activeView === 'settings' ? '#1f2937' : '#6b7280',
              fontWeight: activeView === 'settings' ? '500' : '400'
            },
            onClick: () => navigateTo('settings')
          },
            React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
              React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z' }),
              React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M15 12a3 3 0 11-6 0 3 3 0 016 0z' })
            ),
            React.createElement('span', {
              style: {
                fontSize: '11px',
                fontWeight: '600',
                textTransform: 'uppercase',
                letterSpacing: '0.08em'
              }
            }, 'Settings')
          )
        )
      ),

      // Toast notification - refined styling with optional action button
      toast && React.createElement('div', {
        className: 'fixed bottom-24 left-1/2 transform -translate-x-1/2 z-50 transition-all flex items-center gap-3',
        style: {
          padding: '12px 20px',
          backgroundColor: toast.type === 'error' ? '#dc2626' : toast.type === 'info' ? '#2563eb' : '#1f2937',
          color: '#ffffff',
          fontSize: '13px',
          fontWeight: '500',
          borderRadius: '10px',
          boxShadow: '0 4px 16px rgba(0, 0, 0, 0.2), 0 8px 32px rgba(0, 0, 0, 0.15)'
        }
      },
        toast.message,
        toast.action && React.createElement('button', {
          onClick: () => {
            toast.action.onClick();
            setToast(null);
          },
          style: {
            marginLeft: '8px',
            padding: '4px 12px',
            backgroundColor: 'rgba(255, 255, 255, 0.2)',
            border: '1px solid rgba(255, 255, 255, 0.3)',
            borderRadius: '6px',
            color: '#ffffff',
            fontSize: '12px',
            fontWeight: '600',
            cursor: 'pointer'
          }
        }, toast.action.label)
      ),

      // Main content area
      React.createElement('div', {
        ref: mainContentRef,
        className: 'flex-1 flex flex-col overflow-hidden bg-white'
      },

    // External Track Prompt Modal - refined styling
    showExternalPrompt && pendingExternalTrack && React.createElement('div', {
      className: 'fixed inset-0 flex items-center justify-center z-50',
      style: {
        backgroundColor: 'rgba(0, 0, 0, 0.4)',
        backdropFilter: 'blur(4px)'
      },
      onClick: (e) => {
        if (e.target === e.currentTarget) {
          // Clear the auto-skip timeout and interval
          if (externalTrackTimeoutRef.current) {
            clearTimeout(externalTrackTimeoutRef.current);
            externalTrackTimeoutRef.current = null;
          }
          if (externalTrackIntervalRef.current) {
            clearInterval(externalTrackIntervalRef.current);
            externalTrackIntervalRef.current = null;
          }
          setIsPlaying(false);
          setShowExternalPrompt(false);
          setPendingExternalTrack(null);
          setPendingExternalResolverId(null);
        }
      }
    },
      React.createElement('div', {
        style: {
          backgroundColor: '#ffffff',
          borderRadius: '16px',
          boxShadow: '0 4px 24px rgba(0, 0, 0, 0.15), 0 12px 48px rgba(0, 0, 0, 0.1)',
          maxWidth: '380px',
          width: '100%',
          margin: '0 16px',
          overflow: 'hidden',
          position: 'relative'
        },
        onClick: (e) => e.stopPropagation()
      },
        // Close button
        React.createElement('button', {
          onClick: () => {
            // Clear the auto-skip timeout and interval
            if (externalTrackTimeoutRef.current) {
              clearTimeout(externalTrackTimeoutRef.current);
              externalTrackTimeoutRef.current = null;
            }
            if (externalTrackIntervalRef.current) {
              clearInterval(externalTrackIntervalRef.current);
              externalTrackIntervalRef.current = null;
            }
            // Pause playback and dismiss the prompt
            setIsPlaying(false);
            setShowExternalPrompt(false);
            setPendingExternalTrack(null);
            setPendingExternalResolverId(null);
            console.log('â¸ï¸ User dismissed external track prompt, pausing playback');
          },
          className: 'absolute transition-colors',
          style: {
            top: '16px',
            right: '16px',
            padding: '6px',
            color: '#9ca3af',
            backgroundColor: 'transparent',
            border: 'none',
            borderRadius: '8px',
            cursor: 'pointer'
          },
          title: 'Dismiss and pause'
        }, React.createElement(X, { size: 18 })),
        // Header with icon
        React.createElement('div', {
          className: 'flex flex-col items-center text-center',
          style: { padding: '32px 24px 20px' }
        },
          // Icon circle
          React.createElement('div', {
            className: 'flex items-center justify-center',
            style: {
              width: '56px',
              height: '56px',
              borderRadius: '50%',
              backgroundColor: 'rgba(124, 58, 237, 0.1)',
              marginBottom: '16px'
            }
          },
            React.createElement('svg', {
              style: { width: '28px', height: '28px', color: '#7c3aed' },
              fill: 'none',
              viewBox: '0 0 24 24',
              stroke: 'currentColor',
              strokeWidth: 2
            },
              React.createElement('path', {
                strokeLinecap: 'round',
                strokeLinejoin: 'round',
                d: 'M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14'
              })
            )
          ),
          // Title
          React.createElement('h3', {
            style: {
              fontSize: '16px',
              fontWeight: '600',
              color: '#1f2937',
              marginBottom: '12px'
            }
          },
            'Open in Browser'
          ),
          // Track info
          React.createElement('div', { style: { marginBottom: '8px' } },
            React.createElement('div', {
              style: {
                fontSize: '14px',
                fontWeight: '500',
                color: '#1f2937'
              }
            }, pendingExternalTrack.title),
            React.createElement('div', {
              style: {
                fontSize: '13px',
                color: '#6b7280',
                marginTop: '4px'
              }
            }, pendingExternalTrack.artist)
          ),
          // Source badge
          React.createElement('div', {
            className: 'inline-flex items-center gap-1.5',
            style: {
              padding: '6px 12px',
              borderRadius: '16px',
              fontSize: '12px',
              fontWeight: '500',
              marginTop: '8px',
              backgroundColor: pendingExternalTrack.bandcampUrl ? 'rgba(6, 182, 212, 0.1)' :
                pendingExternalTrack.youtubeUrl || pendingExternalTrack.youtubeId ? 'rgba(239, 68, 68, 0.1)' :
                'rgba(124, 58, 237, 0.1)',
              color: pendingExternalTrack.bandcampUrl ? '#0891b2' :
                pendingExternalTrack.youtubeUrl || pendingExternalTrack.youtubeId ? '#dc2626' :
                '#7c3aed'
            }
          },
            (allResolvers.find(r =>
              r.id === (pendingExternalTrack.bandcampUrl ? 'bandcamp' :
                       pendingExternalTrack.youtubeUrl || pendingExternalTrack.youtubeId ? 'youtube' : 'unknown')
            )?.name || 'External')
          )
        ),
        // Auto-skip notice with countdown
        React.createElement('div', {
          style: {
            textAlign: 'center',
            fontSize: '12px',
            color: '#9ca3af',
            paddingBottom: '12px'
          }
        },
          `Auto-skipping in ${externalTrackCountdown} second${externalTrackCountdown !== 1 ? 's' : ''}...`
        ),
        // "Don't show again" checkbox
        React.createElement('label', {
          className: 'flex items-center justify-center gap-2 cursor-pointer select-none',
          style: { padding: '0 24px 20px' }
        },
          React.createElement('input', {
            type: 'checkbox',
            id: 'skip-external-prompt-checkbox',
            style: {
              width: '16px',
              height: '16px',
              accentColor: '#7c3aed',
              cursor: 'pointer'
            },
            onChange: async (e) => {
              const checked = e.target.checked;
              setSkipExternalPrompt(checked);
              if (window.electron?.store) {
                await window.electron.store.set('skip_external_prompt', checked);
              }
            }
          }),
          React.createElement('span', {
            style: {
              fontSize: '12px',
              color: '#6b7280'
            }
          }, "Don't show this again")
        ),
        // Buttons
        React.createElement('div', {
          className: 'flex gap-3',
          style: { padding: '0 24px 24px' }
        },
          React.createElement('button', {
            onClick: () => handleOpenExternalTrack(pendingExternalTrack),
            className: 'flex-1 transition-colors',
            style: {
              padding: '12px 16px',
              fontSize: '13px',
              fontWeight: '500',
              color: '#ffffff',
              backgroundColor: '#7c3aed',
              border: 'none',
              borderRadius: '10px',
              cursor: 'pointer'
            }
          }, 'Open in Browser'),
          React.createElement('button', {
            onClick: handleSkipExternalTrack,
            className: 'flex-1 transition-colors',
            style: {
              padding: '12px 16px',
              fontSize: '13px',
              fontWeight: '500',
              color: '#374151',
              backgroundColor: 'rgba(0, 0, 0, 0.04)',
              border: 'none',
              borderRadius: '10px',
              cursor: 'pointer'
            }
          }, 'Skip')
        )
      )
    ),

    // Unsaved friend unpin warning dialog - refined styling
    unsavedFriendWarningOpen && pendingUnpinFriend && React.createElement('div', {
      className: 'fixed inset-0 flex items-center justify-center z-50',
      style: {
        backgroundColor: 'rgba(0, 0, 0, 0.4)',
        backdropFilter: 'blur(4px)'
      },
      onClick: (e) => {
        if (e.target === e.currentTarget) {
          setUnsavedFriendWarningOpen(false);
          setPendingUnpinFriend(null);
        }
      }
    },
      React.createElement('div', {
        style: {
          backgroundColor: '#ffffff',
          borderRadius: '16px',
          boxShadow: '0 4px 24px rgba(0, 0, 0, 0.15), 0 12px 48px rgba(0, 0, 0, 0.1)',
          maxWidth: '380px',
          width: '100%',
          margin: '0 16px',
          overflow: 'hidden'
        },
        onClick: (e) => e.stopPropagation()
      },
        // Header
        React.createElement('div', {
          className: 'text-center',
          style: { padding: '32px 24px 20px' }
        },
          React.createElement('div', {
            className: 'mx-auto flex items-center justify-center',
            style: {
              width: '48px',
              height: '48px',
              borderRadius: '50%',
              backgroundColor: 'rgba(245, 158, 11, 0.1)',
              marginBottom: '16px'
            }
          },
            React.createElement('svg', {
              style: { width: '24px', height: '24px', color: '#f59e0b' },
              fill: 'none',
              viewBox: '0 0 24 24',
              stroke: 'currentColor'
            },
              React.createElement('path', {
                strokeLinecap: 'round',
                strokeLinejoin: 'round',
                strokeWidth: 2,
                d: 'M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z'
              })
            )
          ),
          React.createElement('h3', {
            style: {
              fontSize: '16px',
              fontWeight: '600',
              color: '#1f2937',
              marginBottom: '8px'
            }
          }, 'Friend Not Saved'),
          React.createElement('p', {
            style: {
              fontSize: '13px',
              color: '#6b7280',
              lineHeight: '1.5'
            }
          }, `${pendingUnpinFriend.displayName} isn't saved to your collection. If you unpin them, you'll need to add them again to pin them later.`)
        ),
        // "Don't show again" checkbox
        React.createElement('label', {
          className: 'flex items-center justify-center gap-2 cursor-pointer select-none',
          style: { padding: '0 24px 20px' }
        },
          React.createElement('input', {
            type: 'checkbox',
            style: {
              width: '16px',
              height: '16px',
              accentColor: '#7c3aed',
              cursor: 'pointer'
            },
            onChange: async (e) => {
              const checked = e.target.checked;
              setSkipUnsavedFriendWarning(checked);
              if (window.electron?.store) {
                await window.electron.store.set('skip_unsaved_friend_warning', checked);
              }
            }
          }),
          React.createElement('span', {
            style: {
              fontSize: '12px',
              color: '#6b7280'
            }
          }, "Don't show this again")
        ),
        // Buttons
        React.createElement('div', {
          className: 'flex gap-3',
          style: { padding: '0 24px 24px' }
        },
          React.createElement('button', {
            onClick: () => {
              // Save to collection, then unpin
              saveFriendToCollection(pendingUnpinFriend.id);
              setPinnedFriendIds(prev => prev.filter(id => id !== pendingUnpinFriend.id));
              showToast(`${pendingUnpinFriend.displayName} saved and unpinned`);
              setUnsavedFriendWarningOpen(false);
              setPendingUnpinFriend(null);
            },
            className: 'flex-1 transition-colors',
            style: {
              padding: '12px 16px',
              fontSize: '13px',
              fontWeight: '500',
              color: '#ffffff',
              backgroundColor: '#7c3aed',
              border: 'none',
              borderRadius: '10px',
              cursor: 'pointer'
            }
          }, 'Save & Unpin'),
          React.createElement('button', {
            onClick: confirmUnpinFriend,
            className: 'flex-1 transition-colors',
            style: {
              padding: '12px 16px',
              fontSize: '13px',
              fontWeight: '500',
              color: '#374151',
              backgroundColor: 'rgba(0, 0, 0, 0.04)',
              border: 'none',
              borderRadius: '10px',
              cursor: 'pointer'
            }
          }, 'Just Unpin')
        )
      )
    ),

    // Show loading state until cache is loaded (prevents flash of default view)
    !cacheLoaded ? React.createElement('div', {
      className: 'flex-1 flex items-center justify-center bg-white'
    },
      React.createElement('div', { className: 'animate-pulse text-gray-400' }, 'Loading...')
    ) :

    // Search Page - Full page search view
    activeView === 'search' ? (
      searchDetailCategory ?
        // DETAIL VIEW - Similar structure to artist page with collapsible header
        React.createElement('div', {
          className: 'flex-1 flex flex-col bg-white',
          style: { overflow: 'hidden' }
        },
          // Header section (outside scrollable area)
          React.createElement('div', {
            className: 'relative',
            style: {
              height: searchHeaderCollapsed ? '70px' : '120px',
              flexShrink: 0,
              transition: 'height 300ms ease-out',
              overflow: 'hidden'
            }
          },
            // Background - light gray gradient
            React.createElement('div', {
              className: 'absolute inset-0',
              style: {
                background: 'linear-gradient(135deg, #6b7280 0%, #9ca3af 50%, #6b7280 100%)'
              }
            }),
            // Header content - matches artist page collapsed header style
            React.createElement('div', {
              className: 'absolute inset-0 flex items-center px-6 z-10'
            },
              // Left: Search icon + query in quotes
              React.createElement('div', { className: 'flex items-center gap-3 flex-shrink-0 mr-6' },
                React.createElement('svg', { className: 'w-5 h-5 text-white/70', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                  React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' })
                ),
                React.createElement('span', {
                  className: 'text-2xl font-light text-white uppercase',
                  style: { textShadow: '0 2px 10px rgba(0,0,0,0.3)', letterSpacing: '0.2em' }
                }, `"${searchQuery}"`)
              ),
              // Tabs (next to title, like artist page)
              React.createElement('div', {
                className: 'flex items-center gap-1',
                style: { textShadow: '0 1px 10px rgba(0,0,0,0.3)' }
              },
                [
                  { key: 'artists', label: 'Artists', count: searchResults.artists.length },
                  { key: 'albums', label: 'Albums', count: searchResults.albums.length },
                  { key: 'tracks', label: 'Songs', count: searchResults.tracks.length }
                ].map((tab, i) => React.createElement(React.Fragment, { key: tab.key },
                  i > 0 && React.createElement('span', {
                    className: 'text-white/50 mx-2'
                  }, '|'),
                  React.createElement('button', {
                    onClick: () => {
                      setSearchDetailCategory(tab.key);
                    },
                    className: `px-2 py-1 text-sm font-medium uppercase tracking-wider transition-colors no-drag ${
                      searchDetailCategory === tab.key ? 'text-white' : 'text-white/60 hover:text-white'
                    }`
                  }, `${tab.count} ${tab.label}`)
                ))
              )
            )
          ),
          // Scrollable content area - single column layout with grids/lists
          React.createElement('div', {
            ref: (el) => {
              searchScrollContainerRef.current = el;
              if (el && !searchScrollContainerReady) {
                setSearchScrollContainerReady(true);
              }
            },
            className: 'flex-1 overflow-y-auto bg-white scrollable-content',
            onScroll: handleSearchDetailScroll
          },
            // Sticky filter bar for Artists (sort dropdown + search on right like other pages)
            searchDetailCategory === 'artists' && React.createElement('div', {
              className: 'sticky top-0 z-10 flex items-center px-6 py-3 bg-white border-b border-gray-200'
            },
              // Sort dropdown
              React.createElement('div', { className: 'relative' },
                React.createElement('button', {
                  onClick: (e) => { e.stopPropagation(); setSearchResultsSortDropdownOpen(!searchResultsSortDropdownOpen); },
                  className: 'flex items-center gap-1 px-3 py-1.5 text-sm text-gray-500 hover:text-gray-700 transition-colors no-drag'
                },
                  React.createElement('span', null,
                    searchResultsSort === 'relevance' ? 'Relevance' :
                    searchResultsSort === 'name' ? 'Name' : 'Sort'
                  ),
                  React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M19 9l-7 7-7-7' })
                  )
                ),
                searchResultsSortDropdownOpen && React.createElement('div', {
                  className: 'absolute left-0 top-full mt-1 bg-white rounded-lg shadow-lg py-1 min-w-[160px] z-30 border border-gray-200'
                },
                  [
                    { value: 'relevance', label: 'Relevance' },
                    { value: 'name', label: 'Name' }
                  ].map(option =>
                    React.createElement('button', {
                      key: option.value,
                      onClick: (e) => {
                        e.stopPropagation();
                        setSearchResultsSort(option.value);
                        setSearchResultsSortDropdownOpen(false);
                      },
                      className: `w-full px-4 py-2 text-left text-sm hover:bg-gray-100 flex items-center justify-between no-drag ${
                        searchResultsSort === option.value ? 'text-gray-900 font-medium' : 'text-gray-600'
                      }`
                    },
                      option.label,
                      searchResultsSort === option.value && React.createElement('svg', {
                        className: 'w-4 h-4',
                        fill: 'none',
                        viewBox: '0 0 24 24',
                        stroke: 'currentColor'
                      },
                        React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M5 13l4 4L19 7' })
                      )
                    )
                  )
                )
              ),
              React.createElement('div', { className: 'flex-1' }),
              // Search/filter on right
              React.createElement('div', { className: 'flex items-center' },
                searchResultsFilterOpen ?
                  React.createElement('div', { className: 'flex items-center border border-gray-300 rounded-full px-3 py-1.5' },
                    React.createElement('input', {
                      type: 'text',
                      value: searchResultsFilter,
                      onChange: (e) => setSearchResultsFilter(e.target.value),
                      onBlur: () => { if (!searchResultsFilter.trim()) setSearchResultsFilterOpen(false); },
                      autoFocus: true,
                      placeholder: 'Filter...',
                      className: 'bg-transparent text-gray-700 text-sm placeholder-gray-400 outline-none no-drag',
                      style: { width: '150px' }
                    }),
                    searchResultsFilter && React.createElement('button', {
                      onClick: () => { setSearchResultsFilter(''); setSearchResultsFilterOpen(false); },
                      className: 'ml-2 text-gray-400 hover:text-gray-600 no-drag'
                    },
                      React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                        React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M6 18L18 6M6 6l12 12' })
                      )
                    )
                  )
                :
                  React.createElement('button', {
                    onClick: () => setSearchResultsFilterOpen(true),
                    className: 'p-1.5 text-gray-400 hover:text-gray-600 transition-colors no-drag'
                  },
                    React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                      React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' })
                    )
                  )
              )
            ),

            // Sticky filter bar for Albums (sort dropdown + search like Critical Darlings)
            searchDetailCategory === 'albums' && React.createElement('div', {
              className: 'sticky top-0 z-10 flex items-center px-6 py-3 bg-white border-b border-gray-200'
            },
              // Sort dropdown
              React.createElement('div', { className: 'relative' },
                React.createElement('button', {
                  onClick: (e) => { e.stopPropagation(); setSearchResultsSortDropdownOpen(!searchResultsSortDropdownOpen); },
                  className: 'flex items-center gap-1 px-3 py-1.5 text-sm text-gray-500 hover:text-gray-700 transition-colors no-drag'
                },
                  React.createElement('span', null,
                    searchResultsSort === 'relevance' ? 'Relevance' :
                    searchResultsSort === 'title' ? 'Title' :
                    searchResultsSort === 'artist' ? 'Artist' :
                    searchResultsSort === 'year-desc' ? 'Year (Newest)' :
                    searchResultsSort === 'year-asc' ? 'Year (Oldest)' : 'Sort'
                  ),
                  React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M19 9l-7 7-7-7' })
                  )
                ),
                searchResultsSortDropdownOpen && React.createElement('div', {
                  className: 'absolute left-0 top-full mt-1 bg-white rounded-lg shadow-lg py-1 min-w-[160px] z-30 border border-gray-200'
                },
                  [
                    { value: 'relevance', label: 'Relevance' },
                    { value: 'title', label: 'Title' },
                    { value: 'artist', label: 'Artist' },
                    { value: 'year-desc', label: 'Year (Newest)' },
                    { value: 'year-asc', label: 'Year (Oldest)' }
                  ].map(option =>
                    React.createElement('button', {
                      key: option.value,
                      onClick: (e) => {
                        e.stopPropagation();
                        setSearchResultsSort(option.value);
                        setSearchResultsSortDropdownOpen(false);
                      },
                      className: `w-full px-4 py-2 text-left text-sm hover:bg-gray-100 flex items-center justify-between no-drag ${
                        searchResultsSort === option.value ? 'text-gray-900 font-medium' : 'text-gray-600'
                      }`
                    },
                      option.label,
                      searchResultsSort === option.value && React.createElement('svg', {
                        className: 'w-4 h-4',
                        fill: 'none',
                        viewBox: '0 0 24 24',
                        stroke: 'currentColor'
                      },
                        React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M5 13l4 4L19 7' })
                      )
                    )
                  )
                )
              ),
              React.createElement('div', { className: 'flex-1' }),
              // Search/filter
              React.createElement('div', { className: 'flex items-center' },
                searchResultsFilterOpen ?
                  React.createElement('div', { className: 'flex items-center border border-gray-300 rounded-full px-3 py-1.5' },
                    React.createElement('input', {
                      type: 'text',
                      value: searchResultsFilter,
                      onChange: (e) => setSearchResultsFilter(e.target.value),
                      onBlur: () => { if (!searchResultsFilter.trim()) setSearchResultsFilterOpen(false); },
                      autoFocus: true,
                      placeholder: 'Filter...',
                      className: 'bg-transparent text-gray-700 text-sm placeholder-gray-400 outline-none no-drag',
                      style: { width: '150px' }
                    }),
                    searchResultsFilter && React.createElement('button', {
                      onClick: () => { setSearchResultsFilter(''); setSearchResultsFilterOpen(false); },
                      className: 'ml-2 text-gray-400 hover:text-gray-600 no-drag'
                    },
                      React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                        React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M6 18L18 6M6 6l12 12' })
                      )
                    )
                  )
                :
                  React.createElement('button', {
                    onClick: () => setSearchResultsFilterOpen(true),
                    className: 'p-1.5 text-gray-400 hover:text-gray-600 transition-colors no-drag'
                  },
                    React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                      React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' })
                    )
                  )
              )
            ),

            // Sticky filter bar for Songs (sort dropdown + search)
            searchDetailCategory === 'tracks' && React.createElement('div', {
              className: 'sticky top-0 z-10 flex items-center px-6 py-3 bg-white border-b border-gray-200'
            },
              // Sort dropdown
              React.createElement('div', { className: 'relative' },
                React.createElement('button', {
                  onClick: (e) => { e.stopPropagation(); setSearchResultsSortDropdownOpen(!searchResultsSortDropdownOpen); },
                  className: 'flex items-center gap-1 px-3 py-1.5 text-sm text-gray-500 hover:text-gray-700 transition-colors no-drag'
                },
                  React.createElement('span', null,
                    searchResultsSort === 'relevance' ? 'Relevance' :
                    searchResultsSort === 'title' ? 'Title' :
                    searchResultsSort === 'artist' ? 'Artist' :
                    searchResultsSort === 'duration-asc' ? 'Duration (Short)' :
                    searchResultsSort === 'duration-desc' ? 'Duration (Long)' : 'Sort'
                  ),
                  React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M19 9l-7 7-7-7' })
                  )
                ),
                searchResultsSortDropdownOpen && React.createElement('div', {
                  className: 'absolute left-0 top-full mt-1 bg-white rounded-lg shadow-lg py-1 min-w-[160px] z-30 border border-gray-200'
                },
                  [
                    { value: 'relevance', label: 'Relevance' },
                    { value: 'title', label: 'Title' },
                    { value: 'artist', label: 'Artist' },
                    { value: 'duration-asc', label: 'Duration (Short)' },
                    { value: 'duration-desc', label: 'Duration (Long)' }
                  ].map(option =>
                    React.createElement('button', {
                      key: option.value,
                      onClick: (e) => {
                        e.stopPropagation();
                        setSearchResultsSort(option.value);
                        setSearchResultsSortDropdownOpen(false);
                      },
                      className: `w-full px-4 py-2 text-left text-sm hover:bg-gray-100 flex items-center justify-between no-drag ${
                        searchResultsSort === option.value ? 'text-gray-900 font-medium' : 'text-gray-600'
                      }`
                    },
                      option.label,
                      searchResultsSort === option.value && React.createElement('svg', {
                        className: 'w-4 h-4',
                        fill: 'none',
                        viewBox: '0 0 24 24',
                        stroke: 'currentColor'
                      },
                        React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M5 13l4 4L19 7' })
                      )
                    )
                  )
                )
              ),
              React.createElement('div', { className: 'flex-1' }),
              // Search/filter
              React.createElement('div', { className: 'flex items-center' },
                searchResultsFilterOpen ?
                  React.createElement('div', { className: 'flex items-center border border-gray-300 rounded-full px-3 py-1.5' },
                    React.createElement('input', {
                      type: 'text',
                      value: searchResultsFilter,
                      onChange: (e) => setSearchResultsFilter(e.target.value),
                      onBlur: () => { if (!searchResultsFilter.trim()) setSearchResultsFilterOpen(false); },
                      autoFocus: true,
                      placeholder: 'Filter...',
                      className: 'bg-transparent text-gray-700 text-sm placeholder-gray-400 outline-none no-drag',
                      style: { width: '150px' }
                    }),
                    searchResultsFilter && React.createElement('button', {
                      onClick: () => { setSearchResultsFilter(''); setSearchResultsFilterOpen(false); },
                      className: 'ml-2 text-gray-400 hover:text-gray-600 no-drag'
                    },
                      React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                        React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M6 18L18 6M6 6l12 12' })
                      )
                    )
                  )
                :
                  React.createElement('button', {
                    onClick: () => setSearchResultsFilterOpen(true),
                    className: 'p-1.5 text-gray-400 hover:text-gray-600 transition-colors no-drag'
                  },
                    React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                      React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' })
                    )
                  )
              )
            ),

            // Content container with padding
            React.createElement('div', { className: 'px-6 py-6' },
              // Artists grid (like Recommendations)
              searchDetailCategory === 'artists' && (() => {
                // Filter and sort artists
                let filteredArtists = searchResultsFilter
                  ? searchResults.artists.filter(a => a.name?.toLowerCase().includes(searchResultsFilter.toLowerCase()))
                  : [...searchResults.artists];

                // Sort artists
                if (searchResultsSort === 'name') {
                  filteredArtists.sort((a, b) => (a.name || '').localeCompare(b.name || ''));
                }
                // 'relevance' keeps original order from search results

                return filteredArtists.length > 0 && React.createElement('div', {
                  className: 'grid gap-4',
                  style: { gridTemplateColumns: 'repeat(auto-fill, minmax(160px, 1fr))' }
                },
                  ...filteredArtists.map((artist, index) => {
                    const animationDelay = Math.min(index * 30, 300);
                    const searchArtistPattern = generateArtistPattern(artist.name);
                    return React.createElement('div', {
                      key: artist.id,
                      className: 'bg-white rounded-lg overflow-hidden hover:shadow-lg transition-shadow cursor-pointer group release-card card-fade-up',
                      style: { animationDelay: `${animationDelay}ms` },
                      draggable: true,
                      onDragStart: (e) => {
                        e.dataTransfer.effectAllowed = 'copy';
                        e.dataTransfer.setData('text/plain', JSON.stringify({
                          type: 'artist',
                          artist: {
                            id: (artist.name || 'unknown').toLowerCase().replace(/[^a-z0-9-]/g, ''),
                            name: artist.name,
                            image: artist.image || null
                          }
                        }));
                      },
                      onClick: () => fetchArtistData(artist.name),
                      onContextMenu: (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        if (window.electron?.contextMenu?.showTrackMenu) {
                          window.electron.contextMenu.showTrackMenu({
                            type: 'artist',
                            artist: {
                              id: (artist.name || 'unknown').toLowerCase().replace(/[^a-z0-9-]/g, ''),
                              name: artist.name,
                              image: artist.image || null
                            }
                          });
                        }
                      }
                    },
                      // Square image container - gray while loading, pattern only when imageLoaded && no image
                      React.createElement('div', {
                        className: 'aspect-square relative group/art',
                        style: { background: artist.imageLoaded && !artist.image ? searchArtistPattern.gradient : '#e5e7eb' }
                      },
                        // Shimmer while loading (imageLoaded not yet true)
                        !artist.imageLoaded && React.createElement('div', {
                          className: 'absolute inset-0 bg-gradient-to-r from-gray-300 via-gray-200 to-gray-300 animate-shimmer',
                          style: { backgroundSize: '200% 100%' }
                        }),
                        // Initials fallback (only show when imageLoaded && no image)
                        artist.imageLoaded && !artist.image && React.createElement('div', {
                          className: 'absolute inset-0 flex items-center justify-center',
                          style: { color: searchArtistPattern.textColor, opacity: 0.4 }
                        },
                          React.createElement('span', {
                            className: 'font-bold tracking-wider',
                            style: { fontSize: '2.5rem', textShadow: '0 2px 8px rgba(0,0,0,0.3)' }
                          }, searchArtistPattern.initials)
                        ),
                        // Artist image with fade-in
                        artist.image && React.createElement('img', {
                          src: artist.image,
                          alt: artist.name,
                          className: 'absolute inset-0 w-full h-full object-cover transition-all duration-300 group-hover/art:scale-105',
                          style: { opacity: 0 },
                          ref: (el) => { if (el && el.complete && el.naturalWidth > 0) el.style.opacity = '1'; },
                          onLoad: (e) => { e.target.style.opacity = '1'; },
                          onError: (e) => { e.target.style.display = 'none'; }
                        }),
                        // Hover overlay with Play and Queue buttons
                        React.createElement('div', {
                          className: 'absolute inset-0 bg-black/50 opacity-0 group-hover/art:opacity-100 transition-opacity duration-200 flex items-center justify-center gap-3',
                          style: { pointerEvents: 'auto' }
                        },
                          // Play top 10 button
                          React.createElement('button', {
                            onClick: async (e) => {
                              e.stopPropagation();
                              setTrackLoading(true);
                              const tracks = await getArtistTopTracks(artist.name);
                              if (tracks.length > 0) {
                                const context = { type: 'artist', name: artist.name };
                                const [firstTrack, ...remainingTracks] = tracks;
                                const taggedFirstTrack = { ...firstTrack, _playbackContext: context };
                                setQueueWithContext(remainingTracks, context);
                                handlePlay(taggedFirstTrack);
                              } else {
                                setTrackLoading(false);
                                showToast(`No top tracks found for ${artist.name}`, 'error');
                              }
                            },
                            className: 'w-12 h-12 bg-white rounded-full flex items-center justify-center shadow-lg transition-all hover:scale-110',
                            style: { border: 'none', cursor: 'pointer' },
                            title: 'Play top 10 tracks'
                          },
                            React.createElement(PlayTop10Icon, { size: 26, className: 'text-gray-800' })
                          ),
                          // Add top 10 to Queue button
                          React.createElement('button', {
                            onClick: async (e) => {
                              e.stopPropagation();
                              const tracks = await getArtistTopTracks(artist.name);
                              if (tracks.length > 0) {
                                addToQueue(tracks, { type: 'artist', name: artist.name });
                                showToast(`Added ${tracks.length} tracks from ${artist.name}`, 'success');
                              } else {
                                showToast(`No top tracks found for ${artist.name}`, 'error');
                              }
                            },
                            className: 'w-10 h-10 rounded-full flex items-center justify-center transition-all hover:scale-110',
                            style: { backgroundColor: 'rgba(255, 255, 255, 0.15)', color: '#ffffff', border: 'none', cursor: 'pointer' },
                            onMouseEnter: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.25)',
                            onMouseLeave: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.15)',
                            title: 'Add top 10 to queue'
                          },
                            React.createElement(QueueTop10Icon, { size: 20 })
                          )
                        )
                      ),
                      // Artist name section
                      React.createElement('div', { className: 'p-3' },
                        React.createElement('p', {
                          className: 'font-medium text-gray-900 truncate text-sm transition-colors'
                        }, artist.name)
                      )
                    );
                  })
                );
              })(),

              // Artists empty state
              searchDetailCategory === 'artists' && (searchResultsFilter
                ? searchResults.artists.filter(a => a.name?.toLowerCase().includes(searchResultsFilter.toLowerCase())).length === 0
                : searchResults.artists.length === 0
              ) && React.createElement('div', {
                className: 'text-center py-12 text-gray-400'
              }, searchResultsFilter ? 'No artists match your filter.' : 'No artists found.'),

              // Albums grid (like Critical Darlings)
              searchDetailCategory === 'albums' && (() => {
                // Filter and sort albums
                let filteredAlbums = searchResultsFilter
                  ? searchResults.albums.filter(a =>
                      a.title?.toLowerCase().includes(searchResultsFilter.toLowerCase()) ||
                      a['artist-credit']?.[0]?.name?.toLowerCase().includes(searchResultsFilter.toLowerCase())
                    )
                  : [...searchResults.albums];

                // Sort albums
                if (searchResultsSort === 'title') {
                  filteredAlbums.sort((a, b) => (a.title || '').localeCompare(b.title || ''));
                } else if (searchResultsSort === 'artist') {
                  filteredAlbums.sort((a, b) =>
                    (a['artist-credit']?.[0]?.name || '').localeCompare(b['artist-credit']?.[0]?.name || '')
                  );
                } else if (searchResultsSort === 'year-desc') {
                  filteredAlbums.sort((a, b) => {
                    const yearA = parseInt(a['first-release-date']?.split('-')[0]) || 0;
                    const yearB = parseInt(b['first-release-date']?.split('-')[0]) || 0;
                    return yearB - yearA;
                  });
                } else if (searchResultsSort === 'year-asc') {
                  filteredAlbums.sort((a, b) => {
                    const yearA = parseInt(a['first-release-date']?.split('-')[0]) || 9999;
                    const yearB = parseInt(b['first-release-date']?.split('-')[0]) || 9999;
                    return yearA - yearB;
                  });
                }

                return filteredAlbums.length > 0 && React.createElement('div', {
                  className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-x-4 gap-y-5 pb-6'
                },
                  filteredAlbums.map((album, index) => {
                    const animationDelay = Math.min(index * 30, 300);
                    return React.createElement('div', {
                      key: album.id,
                      className: 'group cursor-pointer release-card card-fade-up',
                      style: {
                        padding: '10px',
                        borderRadius: '10px',
                        backgroundColor: '#ffffff',
                        boxShadow: '0 1px 3px rgba(0, 0, 0, 0.05), 0 4px 12px rgba(0, 0, 0, 0.03)',
                        animationDelay: `${animationDelay}ms`
                      },
                      draggable: true,
                      onDragStart: (e) => {
                        e.dataTransfer.effectAllowed = 'copy';
                        e.dataTransfer.setData('text/plain', JSON.stringify({
                          type: 'album',
                          album: {
                            id: `${album['artist-credit']?.[0]?.name || 'unknown'}-${album.title || 'untitled'}`.toLowerCase().replace(/[^a-z0-9-]/g, ''),
                            title: album.title,
                            artist: album['artist-credit']?.[0]?.name || 'Unknown',
                            year: album['first-release-date']?.split('-')[0] ? parseInt(album['first-release-date'].split('-')[0]) : null,
                            art: album.albumArt || null
                          }
                        }));
                      },
                      onMouseEnter: () => prefetchSearchAlbumTracks(album),
                      onClick: () => handleAlbumClick(album),
                      onContextMenu: (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const artistName = album['artist-credit']?.[0]?.name || 'Unknown';
                        const albumData = {
                          title: album.title,
                          artist: artistName,
                          year: album['first-release-date']?.split('-')[0] ? parseInt(album['first-release-date'].split('-')[0]) : null,
                          art: album.albumArt || null
                        };
                        const prefetched = prefetchedReleasesRef.current[album.id];
                        const isLoading = prefetchInProgress.has(album.id);
                        window.electron.contextMenu.showTrackMenu({
                          type: 'release',
                          name: album.title,
                          album: albumData,
                          tracks: prefetched?.tracks || [],
                          loading: isLoading
                        });
                      }
                    },
                      // Album art with dark placeholder and inner shadow
                      React.createElement('div', {
                        className: 'aspect-square rounded-lg overflow-hidden mb-2 relative album-art-container'
                      },
                        // Dark placeholder background
                        React.createElement('div', {
                          className: 'absolute inset-0',
                          style: { background: 'linear-gradient(145deg, #1f1f1f 0%, #2d2d2d 50%, #1a1a1a 100%)' }
                        }),
                        // Image with fade-in
                        album.albumArt && React.createElement('img', {
                          src: album.albumArt,
                          alt: album.title,
                          className: 'absolute inset-0 w-full h-full object-cover transition-all duration-300',
                          style: { opacity: 0 },
                          ref: (el) => { if (el && el.complete && el.naturalWidth > 0) el.style.opacity = '1'; },
                          onLoad: (e) => { e.target.style.opacity = '1'; },
                          onError: (e) => { e.target.style.display = 'none'; }
                        }),
                        // Hover overlay with action buttons (Add to Playlist, Play, Queue)
                        React.createElement('div', {
                          className: 'absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity duration-200 flex items-center justify-center gap-3'
                        },
                          // Add to Playlist button
                          React.createElement('button', {
                            onClick: (e) => {
                              e.stopPropagation();
                              const prefetched = prefetchedReleasesRef.current[album.id];
                              if (prefetched?.tracks?.length > 0) {
                                setAddToPlaylistPanel({
                                  open: true,
                                  tracks: prefetched.tracks,
                                  sourceName: album.title,
                                  sourceType: 'album'
                                });
                              }
                            },
                            className: 'w-10 h-10 rounded-full flex items-center justify-center transition-all hover:scale-110',
                            style: { backgroundColor: 'rgba(255, 255, 255, 0.15)', color: '#ffffff' },
                            onMouseEnter: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.25)',
                            onMouseLeave: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.15)',
                            title: 'Add to Playlist'
                          },
                            React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor', strokeWidth: 2 },
                              React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', d: 'M12 4v16m8-8H4' })
                            )
                          ),
                          // Play button (center, larger)
                          React.createElement('button', {
                            onClick: (e) => {
                              e.stopPropagation();
                              setTrackLoading(true);
                              const prefetched = prefetchedReleasesRef.current[album.id];
                              if (prefetched?.tracks?.length > 0) {
                                const context = { type: 'album', id: album.id, name: album.title, artist: album['artist-credit']?.[0]?.name };
                                const [firstTrack, ...remainingTracks] = prefetched.tracks;
                                // Tag the first track with context so queue navigation works correctly
                                const taggedFirstTrack = { ...firstTrack, _playbackContext: context };
                                setQueueWithContext(remainingTracks, context);
                                handlePlay(taggedFirstTrack);
                              } else {
                                setTrackLoading(false);
                              }
                            },
                            className: 'w-12 h-12 bg-white rounded-full flex items-center justify-center shadow-lg transition-all hover:scale-110',
                            title: 'Play'
                          },
                            React.createElement(Play, { size: 22, className: 'text-gray-800 ml-0.5' })
                          ),
                          // Add to Queue button
                          React.createElement('button', {
                            onClick: (e) => {
                              e.stopPropagation();
                              const prefetched = prefetchedReleasesRef.current[album.id];
                              if (prefetched?.tracks?.length > 0) {
                                const context = { type: 'album', id: album.id, name: album.title, artist: album['artist-credit']?.[0]?.name };
                                addToQueue(prefetched.tracks, context);
                              }
                            },
                            className: 'w-10 h-10 rounded-full flex items-center justify-center transition-all hover:scale-110',
                            style: { backgroundColor: 'rgba(255, 255, 255, 0.15)', color: '#ffffff' },
                            onMouseEnter: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.25)',
                            onMouseLeave: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.15)',
                            title: 'Add to Queue'
                          },
                            React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor', strokeWidth: 2 },
                              React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', d: 'M4 6h16M4 12h16M4 18h7' })
                            )
                          )
                        )
                      ),
                      // Album title - refined typography
                      React.createElement('div', {
                        className: 'truncate transition-colors',
                        style: {
                          fontSize: '13px',
                          fontWeight: '500',
                          color: '#1f2937',
                          marginTop: '6px'
                        }
                      }, album.title),
                      // Artist name - clickable
                      React.createElement('div', {
                        className: 'truncate hover:text-purple-600 hover:underline cursor-pointer transition-colors',
                        style: {
                          fontSize: '11px',
                          color: '#6b7280',
                          marginTop: '2px'
                        },
                        onClick: (e) => {
                          e.stopPropagation();
                          fetchArtistData(album['artist-credit']?.[0]?.name);
                        }
                      }, album['artist-credit']?.[0]?.name || 'Unknown Artist')
                    );
                  })
                );
              })(),

              // Albums empty state
              searchDetailCategory === 'albums' && (() => {
                const filteredAlbums = searchResultsFilter
                  ? searchResults.albums.filter(a =>
                      a.title?.toLowerCase().includes(searchResultsFilter.toLowerCase()) ||
                      a['artist-credit']?.[0]?.name?.toLowerCase().includes(searchResultsFilter.toLowerCase())
                    )
                  : searchResults.albums;
                return filteredAlbums.length === 0;
              })() && React.createElement('div', {
                className: 'text-center py-12 text-gray-400'
              }, searchResultsFilter ? 'No albums match your filter.' : 'No albums found.'),

              // Tracks list (like Recommended Songs)
              searchDetailCategory === 'tracks' && (() => {
                // Filter and sort tracks
                let filteredTracks = searchResultsFilter
                  ? searchResults.tracks.filter(t =>
                      t.title?.toLowerCase().includes(searchResultsFilter.toLowerCase()) ||
                      t.artist?.toLowerCase().includes(searchResultsFilter.toLowerCase())
                    )
                  : [...searchResults.tracks];

                // Sort tracks
                if (searchResultsSort === 'title') {
                  filteredTracks.sort((a, b) => (a.title || '').localeCompare(b.title || ''));
                } else if (searchResultsSort === 'artist') {
                  filteredTracks.sort((a, b) => (a.artist || '').localeCompare(b.artist || ''));
                } else if (searchResultsSort === 'duration-asc') {
                  filteredTracks.sort((a, b) => (a.duration || 0) - (b.duration || 0));
                } else if (searchResultsSort === 'duration-desc') {
                  filteredTracks.sort((a, b) => (b.duration || 0) - (a.duration || 0));
                }

                return filteredTracks.length > 0 && React.createElement('div', { className: 'space-y-0' },
                  ...filteredTracks.map((track, index) => {
                    // Use track.id to look up resolved sources from trackSources state
                    const resolvedSources = trackSources[track.id] || track.sources || {};
                    const hasResolved = Object.keys(resolvedSources).length > 0;
                    const isResolving = !hasResolved && track.resolving;
                    const isCurrentTrack = currentTrack?.id === track.id;
                    const isNowPlaying = isCurrentTrack && playbackContext?.type === 'search';

                    return React.createElement('div', {
                      key: track.id,
                      'data-track-id': track.id,
                      ref: (el) => {
                        if (el) {
                          searchTracksRowRefs.current.set(track.id, el);
                          if (searchTracksObserverRef.current) {
                            searchTracksObserverRef.current.observe(el);
                          }
                        } else {
                          searchTracksRowRefs.current.delete(track.id);
                        }
                      },
                      draggable: true,
                      onDragStart: (e) => {
                        setDraggingTrackForPlaylist(track);
                        e.dataTransfer.effectAllowed = 'copy';
                      e.dataTransfer.setData('text/plain', JSON.stringify({
                        type: 'track',
                        track: {
                          id: track.id,
                          title: track.title,
                          artist: track.artist,
                          album: track.album,
                          duration: track.duration,
                          albumArt: track.albumArt,
                          sources: track.sources || {}
                        }
                      }));
                    },
                    onDragEnd: () => {
                      setDraggingTrackForPlaylist(null);
                      setDropTargetPlaylistId(null);
                      setDropTargetNewPlaylist(false);
                      if (addToPlaylistPanel.open && selectedPlaylistsForAdd.length === 0) {
                        setAddToPlaylistPanel(prev => ({ ...prev, open: false }));
                      }
                    },
                    className: `flex items-center gap-4 py-3 px-4 cursor-grab active:cursor-grabbing transition-all group ${
                      isResolving ? 'opacity-60' : ''
                    } ${isNowPlaying && isPlaying ? 'bg-purple-50' : 'hover:bg-gray-50/80'}`,
                    style: {
                      borderRadius: '8px',
                      marginBottom: '2px'
                    },
                    onClick: () => {
                      const tracksAfter = filteredTracks.slice(index + 1);
                      const context = { type: 'search', name: searchQuery };
                      setQueueWithContext(tracksAfter, context);
                      handlePlay(track);
                    },
                    onContextMenu: (e) => {
                      e.preventDefault();
                      if (window.electron?.contextMenu?.showTrackMenu) {
                        window.electron.contextMenu.showTrackMenu({
                          type: 'track',
                          track: track
                        });
                      }
                    }
                  },
                    // Track number or playing indicator
                    React.createElement('span', {
                      className: 'flex-shrink-0 text-right',
                      style: {
                        pointerEvents: 'none',
                        width: '32px',
                        fontSize: '12px',
                        fontWeight: '500',
                        color: isNowPlaying && isPlaying ? '#8b5cf6' : '#9ca3af'
                      }
                    }, isNowPlaying && isPlaying ? 'â–¶' : String(index + 1).padStart(2, '0')),

                    // Track title - fixed width column
                    React.createElement('span', {
                      className: 'truncate transition-colors',
                      style: {
                        pointerEvents: 'none',
                        width: '360px',
                        flexShrink: 0,
                        fontSize: '13px',
                        fontWeight: isNowPlaying && isPlaying ? '500' : '400',
                        color: isNowPlaying && isPlaying ? '#7c3aed' : hasResolved ? '#374151' : '#9ca3af'
                      }
                    }, track.title),

                    // Artist name - fixed width column, clickable
                    React.createElement('span', {
                      className: 'truncate hover:text-purple-600 hover:underline cursor-pointer transition-colors',
                      style: {
                        width: '220px',
                        flexShrink: 0,
                        fontSize: '13px',
                        color: '#6b7280'
                      },
                      onClick: (e) => {
                        e.stopPropagation();
                        fetchArtistData(track.artist);
                      }
                    }, track.artist),

                    // Album name - fixed width column, clickable
                    track.album ? React.createElement('span', {
                      className: 'truncate hover:text-purple-600 hover:underline cursor-pointer transition-colors',
                      style: {
                        width: '150px',
                        flexShrink: 0,
                        fontSize: '13px',
                        color: '#6b7280'
                      },
                      onClick: (e) => {
                        e.stopPropagation();
                        openChartsAlbum({ artist: track.artist, title: track.album, albumArt: track.albumArt });
                      }
                    }, track.album) : React.createElement('span', {
                      className: 'truncate',
                      style: {
                        pointerEvents: 'none',
                        width: '150px',
                        flexShrink: 0,
                        fontSize: '13px',
                        color: '#6b7280'
                      }
                    }, ''),

                    // Spacer to push duration and resolvers to the right
                    React.createElement('div', { className: 'flex-1' }),

                    // Duration - right-justified before resolver icons
                    React.createElement('span', {
                      className: 'flex-shrink-0 tabular-nums',
                      style: {
                        pointerEvents: 'none',
                        width: '50px',
                        marginLeft: 'auto',
                        marginRight: '16px',
                        fontSize: '12px',
                        color: '#9ca3af',
                        textAlign: 'right'
                      }
                    }, formatTime(track.duration)),

                    // Resolver icons - fixed width column
                    React.createElement('div', {
                      className: 'flex items-center gap-1 justify-end',
                      style: { width: '100px', flexShrink: 0, minHeight: '24px' }
                    },
                      isResolving ?
                        React.createElement('div', {
                          className: 'flex items-center gap-1'
                        },
                          React.createElement('div', {
                            className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer',
                            title: 'Resolving track...'
                          }),
                          React.createElement('div', {
                            className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer',
                            style: { animationDelay: '0.1s' }
                          })
                        )
                      : hasResolved ?
                        Object.entries(resolvedSources)
                          .sort(([aId], [bId]) => {
                            const aIndex = resolverOrder.indexOf(aId);
                            const bIndex = resolverOrder.indexOf(bId);
                            return aIndex - bIndex;
                          })
                          .map(([resolverId, source]) => {
                            const resolver = allResolvers.find(r => r.id === resolverId);
                            if (!resolver || !resolver.play) return null;
                            return React.createElement('button', {
                              key: resolverId,
                              className: 'no-drag',
                              onClick: (e) => {
                                e.stopPropagation();
                                const tracksAfter = filteredTracks.slice(index + 1);
                                const context = { type: 'search', name: searchQuery };
                                setQueueWithContext(tracksAfter, context);
                                handlePlay({ ...track, preferredResolver: resolverId });
                              },
                              style: {
                                width: '20px',
                                height: '20px',
                                borderRadius: '4px',
                                backgroundColor: resolver.color,
                                border: 'none',
                                cursor: 'pointer',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                pointerEvents: 'auto',
                                opacity: (source.confidence || 0) > 0.8 ? 1 : 0.6,
                                transition: 'transform 0.1s'
                              },
                              onMouseEnter: (e) => e.currentTarget.style.transform = 'scale(1.1)',
                              onMouseLeave: (e) => e.currentTarget.style.transform = 'scale(1)',
                              title: `Play from ${resolver.name}${source.confidence ? ` (${Math.round(source.confidence * 100)}% match)` : ''}`
                            }, React.createElement(ResolverIcon, { resolverId, size: 12 }));
                          })
                      :
                        null
                    )
                  );
                  })
                );
              })(),

              // Tracks empty state
              searchDetailCategory === 'tracks' && (() => {
                const filteredTracks = searchResultsFilter
                  ? searchResults.tracks.filter(t =>
                      t.title?.toLowerCase().includes(searchResultsFilter.toLowerCase()) ||
                      t.artist?.toLowerCase().includes(searchResultsFilter.toLowerCase())
                    )
                  : searchResults.tracks;
                return filteredTracks.length === 0;
              })() && React.createElement('div', {
                className: 'text-center py-12 text-gray-400'
              }, searchResultsFilter ? 'No songs match your filter.' : 'No songs found.'),

              // Playlists grid with cards
              searchDetailCategory === 'playlists' && searchResults.playlists.length > 0 && React.createElement('div', {
                className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-x-4 gap-y-5 pb-6'
              },
                searchResults.playlists.map((playlist, index) => {
                  const animationDelay = Math.min(index * 30, 300);
                  return React.createElement('div', {
                    key: playlist.title,
                    className: 'cursor-pointer group release-card card-fade-up',
                    style: {
                      padding: '10px',
                      borderRadius: '10px',
                      backgroundColor: '#ffffff',
                      boxShadow: '0 1px 3px rgba(0, 0, 0, 0.05), 0 4px 12px rgba(0, 0, 0, 0.03)',
                      animationDelay: `${animationDelay}ms`
                    },
                    onClick: () => handlePlaylistClick(playlist)
                  },
                    // Playlist icon square with hover overlay
                    React.createElement('div', {
                      className: 'w-full aspect-square rounded-lg mb-2 relative overflow-hidden',
                      style: { background: 'linear-gradient(145deg, #1f1f1f 0%, #2d2d2d 50%, #1a1a1a 100%)' }
                    },
                      // Playlist icon
                      React.createElement('div', {
                        className: 'absolute inset-0 flex items-center justify-center'
                      },
                        React.createElement('svg', {
                          className: 'w-12 h-12 text-gray-500',
                          fill: 'none',
                          viewBox: '0 0 24 24',
                          stroke: 'currentColor',
                          strokeWidth: 1.5
                        },
                          React.createElement('path', {
                            strokeLinecap: 'round',
                            strokeLinejoin: 'round',
                            d: 'M9 9l10.5-3m0 6.553v3.75a2.25 2.25 0 01-1.632 2.163l-1.32.377a1.803 1.803 0 11-.99-3.467l2.31-.66a2.25 2.25 0 001.632-2.163zm0 0V4.5L9 7.5v9.75a2.25 2.25 0 01-1.632 2.163l-1.32.377a1.803 1.803 0 01-.99-3.467l2.31-.66A2.25 2.25 0 009 13.125V9'
                          })
                        )
                      ),
                      // Hover overlay with action buttons
                      React.createElement('div', {
                        className: 'absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity duration-200 flex items-center justify-center gap-3'
                      },
                        // Add to Playlist button
                        React.createElement('button', {
                          onClick: (e) => {
                            e.stopPropagation();
                            if (playlist.tracks?.length > 0) {
                              const tracksWithIds = playlist.tracks.map(track => ({
                                ...track,
                                id: `${track.artist || 'unknown'}-${track.title || 'untitled'}`.toLowerCase().replace(/[^a-z0-9-]/g, ''),
                                sources: {}
                              }));
                              setAddToPlaylistPanel({
                                open: true,
                                tracks: tracksWithIds,
                                sourceName: playlist.title,
                                sourceType: 'playlist'
                              });
                            }
                          },
                          className: 'w-10 h-10 rounded-full flex items-center justify-center transition-all hover:scale-110',
                          style: { backgroundColor: 'rgba(255, 255, 255, 0.15)', color: '#ffffff' },
                          onMouseEnter: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.25)',
                          onMouseLeave: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.15)',
                          title: 'Add to Playlist'
                        },
                          React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor', strokeWidth: 2 },
                            React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', d: 'M12 4v16m8-8H4' })
                          )
                        ),
                        // Play button (center, larger)
                        React.createElement('button', {
                          onClick: (e) => {
                            e.stopPropagation();
                            setTrackLoading(true);
                            if (playlist.tracks?.length > 0) {
                              const tracksWithIds = playlist.tracks.map(track => ({
                                ...track,
                                id: `${track.artist || 'unknown'}-${track.title || 'untitled'}`.toLowerCase().replace(/[^a-z0-9-]/g, ''),
                                sources: {}
                              }));
                              const context = { type: 'playlist', id: playlist.title, name: playlist.title };
                              const [firstTrack, ...remainingTracks] = tracksWithIds;
                              // Tag the first track with context so queue navigation works correctly
                              const taggedFirstTrack = { ...firstTrack, _playbackContext: context };
                              setQueueWithContext(remainingTracks, context);
                              handlePlay(taggedFirstTrack);
                            } else {
                              setTrackLoading(false);
                            }
                          },
                          className: 'w-12 h-12 bg-white rounded-full flex items-center justify-center shadow-lg transition-all hover:scale-110',
                          title: 'Play'
                        },
                          React.createElement(Play, { size: 22, className: 'text-gray-800 ml-0.5' })
                        ),
                        // Add to Queue button
                        React.createElement('button', {
                          onClick: (e) => {
                            e.stopPropagation();
                            if (playlist.tracks?.length > 0) {
                              const tracksWithIds = playlist.tracks.map(track => ({
                                ...track,
                                id: `${track.artist || 'unknown'}-${track.title || 'untitled'}`.toLowerCase().replace(/[^a-z0-9-]/g, ''),
                                sources: {}
                              }));
                              const context = { type: 'playlist', id: playlist.title, name: playlist.title };
                              addToQueue(tracksWithIds, context);
                            }
                          },
                          className: 'w-10 h-10 rounded-full flex items-center justify-center transition-all hover:scale-110',
                          style: { backgroundColor: 'rgba(255, 255, 255, 0.15)', color: '#ffffff' },
                          onMouseEnter: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.25)',
                          onMouseLeave: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.15)',
                          title: 'Add to Queue'
                        },
                          React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor', strokeWidth: 2 },
                            React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', d: 'M4 6h16M4 12h16M4 18h7' })
                          )
                        )
                      )
                    ),
                    // Playlist title
                    React.createElement('div', {
                      className: 'truncate transition-colors',
                      style: {
                        fontSize: '13px',
                        fontWeight: '500',
                        color: '#1f2937',
                        marginTop: '6px'
                      }
                    }, playlist.title),
                    // Creator and track count
                    React.createElement('div', {
                      className: 'truncate',
                      style: {
                        fontSize: '11px',
                        color: '#6b7280',
                        marginTop: '2px'
                      }
                    }, `${playlist.creator || 'Unknown'} â€¢ ${playlist.tracks?.length || 0} tracks`)
                  );
                })
              )
            )
          ) // end scrollable content
        ) // end detail view container
      :
        // MAIN VIEW - clean white layout matching reference
        React.createElement('div', {
          className: 'h-full overflow-y-auto bg-white'
        },
          // Header bar with SEARCH title and CLOSE button
          React.createElement('div', { className: 'flex items-center justify-between px-8 py-3 border-b border-gray-200' },
            React.createElement('span', { className: 'text-xs font-medium tracking-widest text-gray-400 uppercase' }, 'Search'),
            React.createElement('button', {
              onClick: () => navigateBack(),
              className: 'flex items-center gap-1 px-3 py-1 text-xs text-gray-500 hover:text-gray-700 border border-gray-300 rounded hover:bg-gray-50 transition-colors no-drag'
            },
              'CLOSE',
              React.createElement('span', { className: 'text-gray-400' }, 'Ã—')
            )
          ),

          // Content area
          React.createElement('div', { className: 'px-8 py-6', ref: searchResultsContainerRef },
        // Main view content
        React.createElement('div', null,
          // Large search input with cursor styling
          React.createElement('div', { className: 'mb-8' },
            React.createElement('input', {
              ref: (el) => el && activeView === 'search' && !searchQuery && el.focus(),
              type: 'text',
              value: searchQuery,
              onChange: (e) => handleSearchInput(e.target.value),
              placeholder: '',
              className: 'w-full text-6xl font-extralight text-gray-900 bg-transparent border-none outline-none tracking-tight',
              style: {
                caretColor: '#9ca3af',
                fontFamily: 'system-ui, -apple-system, sans-serif'
              }
            })
          ),

        // Results area
        // Show search history when no query
        (!searchQuery) ?
          // Search history view
          (searchHistory.length > 0 ?
            React.createElement('div', { className: 'space-y-4' },
              // Header with clear all button
              React.createElement('div', { className: 'flex items-center justify-between' },
                React.createElement('h3', {
                  className: 'text-xs font-semibold text-gray-400 uppercase tracking-wider'
                }, 'Recent Searches'),
                React.createElement('button', {
                  onClick: () => clearSearchHistory(),
                  className: 'text-xs text-gray-400 hover:text-red-500 transition-colors'
                }, 'Clear All')
              ),
              // History list
              React.createElement('div', { className: 'space-y-1' },
                ...searchHistory.slice(0, 10).map((entry, i) =>
                  React.createElement(SearchHistoryItem, {
                    key: `history-${i}-${entry.query}`,
                    entry,
                    onQueryClick: (query) => {
                      handleSearchInput(query);
                    },
                    onResultClick: (result) => {
                      // Navigate directly to the result
                      if (result.type === 'artist') {
                        fetchArtistData(result.name);
                      } else if (result.type === 'album') {
                        handleAlbumClick({ id: result.id, title: result.name, 'artist-credit': [{ name: result.artist }] });
                      } else if (result.type === 'playlist') {
                        const playlist = playlists.find(p => p.id === result.id);
                        if (playlist) handlePlaylistClick(playlist);
                      } else if (result.type === 'track') {
                        // Play the track directly - create a minimal track object for resolution
                        const track = {
                          id: result.id,
                          title: result.name,
                          artist: result.artist,
                          albumArt: result.imageUrl,
                          sources: {}
                        };
                        handlePlay(track);
                      }
                    },
                    onRemove: (query) => clearSearchHistory(query)
                  })
                )
              )
            ) :
            // No history yet - show placeholder
            React.createElement('div', { className: 'text-center py-12' },
              React.createElement('svg', {
                className: 'w-12 h-12 mx-auto text-gray-300 mb-4',
                fill: 'none',
                stroke: 'currentColor',
                viewBox: '0 0 24 24'
              },
                React.createElement('path', {
                  strokeLinecap: 'round',
                  strokeLinejoin: 'round',
                  strokeWidth: 1.5,
                  d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z'
                })
              ),
              React.createElement('p', { className: 'text-gray-400 text-sm' }, 'Start typing to search')
            )
          ) :
        isSearching ?
          // Loading skeletons - dynamically sized based on container width
          React.createElement('div', { className: 'space-y-10' },
            // Artists skeleton - square card style
            React.createElement('div', null,
              React.createElement('h3', { className: 'text-xs font-semibold text-gray-400 uppercase tracking-wider mb-4' }, 'ARTISTS'),
              React.createElement('div', {
                className: 'grid gap-4',
                style: { gridTemplateColumns: 'repeat(auto-fill, minmax(160px, 1fr))' }
              },
                ...Array(getItemsPerRow(160)).fill(null).map((_, i) =>
                  React.createElement('div', {
                    key: `artist-skeleton-${i}`,
                    className: 'bg-white rounded-lg overflow-hidden'
                  },
                    React.createElement('div', {
                      className: 'aspect-square bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 100}ms` }
                    }),
                    React.createElement('div', { className: 'p-3' },
                      React.createElement('div', {
                        className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 w-3/4 rounded animate-shimmer',
                        style: { backgroundSize: '200% 100%', animationDelay: `${i * 100 + 50}ms` }
                      })
                    )
                  )
                )
              )
            ),
            // Songs skeleton - rounded style
            React.createElement('div', null,
              React.createElement('h3', { className: 'text-xs font-semibold text-gray-400 uppercase tracking-wider mb-4' }, 'SONGS'),
              React.createElement('div', { className: 'flex gap-4' },
                ...Array(getItemsPerRow(110)).fill(null).map((_, i) => {
                  const skeletonWidth = Math.floor((searchContainerWidth - (getItemsPerRow(110) - 1) * 16) / getItemsPerRow(110));
                  return React.createElement('div', {
                    key: `track-skeleton-${i}`,
                    className: 'transition-all duration-300 ease-out',
                    style: { width: skeletonWidth }
                  },
                    React.createElement('div', {
                      className: 'w-full aspect-square rounded-lg bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 mb-2 animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 100}ms` }
                    }),
                    React.createElement('div', {
                      className: 'h-3 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 w-3/4 mb-1 rounded animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 100 + 50}ms` }
                    }),
                    React.createElement('div', {
                      className: 'h-2 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 w-1/2 rounded animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 100 + 100}ms` }
                    }),
                    React.createElement('div', {
                      className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 w-10 mt-1 rounded animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 100 + 150}ms` }
                    })
                  );
                })
              )
            ),
            // Albums skeleton - rounded style
            React.createElement('div', null,
              React.createElement('h3', { className: 'text-xs font-semibold text-gray-400 uppercase tracking-wider mb-4' }, 'ALBUMS'),
              React.createElement('div', { className: 'flex gap-4' },
                ...Array(getItemsPerRow(150)).fill(null).map((_, i) => {
                  const skeletonWidth = Math.floor((searchContainerWidth - (getItemsPerRow(150) - 1) * 16) / getItemsPerRow(150));
                  return React.createElement('div', {
                    key: `album-skeleton-${i}`,
                    className: 'transition-all duration-300 ease-out',
                    style: { width: skeletonWidth }
                  },
                    React.createElement('div', {
                      className: 'w-full aspect-square rounded-lg bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 mb-3 animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 100}ms` }
                    }),
                    React.createElement('div', {
                      className: 'h-3 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 w-3/4 mb-1 rounded animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 100 + 50}ms` }
                    }),
                    React.createElement('div', {
                      className: 'h-2 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 w-1/2 rounded animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 100 + 100}ms` }
                    })
                  );
                })
              )
            )
          )
        :
        // No results state
        searchResults.artists.length === 0 &&
        searchResults.albums.length === 0 &&
        searchResults.tracks.length === 0 &&
        searchResults.playlists.length === 0 ?
          React.createElement('div', { className: 'text-center py-12 text-gray-400' },
            `No results found for "${searchQuery}"`
          )
        :
        // Results
        React.createElement('div', { className: 'space-y-10' },
          // Artists section with image cards - responsive grid
          searchResults.artists.length > 0 && React.createElement('div', null,
            React.createElement('div', { className: 'flex items-center justify-between mb-4' },
              React.createElement('h3', { className: 'text-xs font-semibold text-gray-400 uppercase tracking-wider' }, 'ARTISTS'),
              searchResults.artists.length > 10 &&
                React.createElement('button', {
                  onClick: () => {
                    setSearchDetailCategory('artists');
                    setSearchPreviewItem(searchResults.artists[0] || null);
                  },
                  className: 'text-xs text-gray-500 hover:text-gray-700'
                }, 'Show more')
            ),
            React.createElement('div', {
              className: 'flex gap-4'
            },
              ...searchResults.artists.slice(0, getItemsPerRow(160)).map(artist =>
                React.createElement(SearchArtistCard, {
                  key: artist.id,
                  artist: artist,
                  onClick: () => {
                    // Get cached artist image if available
                    const normalizedName = artist.name?.trim().toLowerCase();
                    const cachedImage = normalizedName ? artistImageCache.current[normalizedName] : null;
                    saveSearchHistory(searchQuery, {
                      type: 'artist',
                      id: artist.id,
                      name: artist.name,
                      imageUrl: cachedImage?.url || null
                    });
                    fetchArtistData(artist.name);
                  },
                  getArtistImage: getArtistImage,
                  itemWidth: Math.floor((searchContainerWidth - (getItemsPerRow(160) - 1) * 16) / getItemsPerRow(160)),
                  onPlayTopTracks: async (artist) => {
                    setTrackLoading(true);
                    const tracks = await getArtistTopTracks(artist.name);
                    if (tracks.length > 0) {
                      const context = { type: 'artist', name: artist.name };
                      const [firstTrack, ...remainingTracks] = tracks;
                      // Tag the first track with context so queue navigation works correctly
                      const taggedFirstTrack = { ...firstTrack, _playbackContext: context };
                      setQueueWithContext(remainingTracks, context);
                      handlePlay(taggedFirstTrack);
                    } else {
                      setTrackLoading(false);
                      showToast(`No top tracks found for ${artist.name}`, 'error');
                    }
                  },
                  onAddToQueue: async (artist) => {
                    const tracks = await getArtistTopTracks(artist.name);
                    if (tracks.length > 0) {
                      addToQueue(tracks, { type: 'artist', name: artist.name });
                      showToast(`Added ${tracks.length} tracks from ${artist.name}`, 'success');
                    } else {
                      showToast(`No top tracks found for ${artist.name}`, 'error');
                    }
                  },
                  onContextMenu: (artist) => {
                    if (window.electron?.contextMenu?.showTrackMenu) {
                      window.electron.contextMenu.showTrackMenu({
                        type: 'artist',
                        artist: {
                          id: (artist.name || 'unknown').toLowerCase().replace(/[^a-z0-9-]/g, ''),
                          name: artist.name,
                          image: null
                        }
                      });
                    }
                  }
                })
              )
            )
          ),

          // Songs/Tracks section with album art cards - matching album card style
          searchResults.tracks.length > 0 && React.createElement('div', null,
            React.createElement('div', { className: 'flex items-center justify-between mb-4' },
              React.createElement('h3', { className: 'text-xs font-semibold text-gray-400 uppercase tracking-wider' }, 'SONGS'),
              searchResults.tracks.length > 10 &&
                React.createElement('button', {
                  onClick: () => {
                    setSearchDetailCategory('tracks');
                    setSearchPreviewItem(searchResults.tracks[0] || null);
                  },
                  className: 'text-xs text-gray-500 hover:text-gray-700'
                }, 'Show more')
            ),
            React.createElement('div', {
              className: 'flex gap-4'
            },
              ...searchResults.tracks.slice(0, getItemsPerRow(140)).map((track, index) => {
                const trackItemWidth = Math.floor((searchContainerWidth - (getItemsPerRow(140) - 1) * 16) / getItemsPerRow(140));
                const animationDelay = Math.min(index * 40, 300);
                return React.createElement('div', {
                  key: track.id,
                  className: 'group cursor-grab active:cursor-grabbing release-card card-fade-up',
                  style: {
                    width: trackItemWidth,
                    padding: '10px',
                    borderRadius: '10px',
                    backgroundColor: '#ffffff',
                    boxShadow: '0 1px 3px rgba(0, 0, 0, 0.05), 0 4px 12px rgba(0, 0, 0, 0.03)',
                    animationDelay: `${animationDelay}ms`
                  },
                  draggable: true,
                  onClick: () => {
                    const cachedArt = track.releaseId ? albumArtCache.current[track.releaseId]?.url : null;
                    saveSearchHistory(searchQuery, {
                      type: 'track',
                      id: track.id,
                      name: track.title,
                      artist: track.artist,
                      imageUrl: track.albumArt || cachedArt || null
                    });
                    handlePlay(track);
                  },
                  onDragStart: (e) => {
                    e.dataTransfer.effectAllowed = 'copy';
                    e.dataTransfer.setData('text/plain', JSON.stringify({
                      type: 'track',
                      track: {
                        id: track.id,
                        title: track.title,
                        artist: track.artist,
                        album: track.album,
                        duration: track.duration,
                        albumArt: track.albumArt,
                        sources: track.sources || {}
                      }
                    }));
                  },
                  onContextMenu: (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (window.electron?.contextMenu?.showTrackMenu) {
                      window.electron.contextMenu.showTrackMenu({
                        type: 'track',
                        track: {
                          id: track.id,
                          title: track.title,
                          artist: track.artist,
                          album: track.album,
                          duration: track.duration,
                          albumArt: track.albumArt,
                          sources: track.sources || {}
                        }
                      });
                    }
                  }
                },
                  // Album art with rounded corners
                  React.createElement('div', {
                    className: 'w-full aspect-square rounded-lg overflow-hidden mb-2 relative album-art-container group/art'
                  },
                    // Dark placeholder background
                    React.createElement('div', {
                      className: 'absolute inset-0',
                      style: { background: 'linear-gradient(145deg, #1f1f1f 0%, #2d2d2d 50%, #1a1a1a 100%)' }
                    }),
                    // Image with fade-in
                    track.albumArt && React.createElement('img', {
                      src: track.albumArt,
                      alt: track.album,
                      className: 'absolute inset-0 w-full h-full object-cover transition-all duration-300 group-hover/art:scale-105',
                      style: { opacity: 0 },
                      ref: (el) => { if (el && el.complete && el.naturalWidth > 0) el.style.opacity = '1'; },
                      onLoad: (e) => { e.target.style.opacity = '1'; },
                      onError: (e) => { e.target.style.display = 'none'; }
                    }),
                    // Hover overlay with action buttons (Add to Playlist, Play, Queue)
                    React.createElement('div', {
                      className: 'absolute inset-0 bg-black/50 opacity-0 group-hover/art:opacity-100 transition-opacity duration-200 flex items-center justify-center gap-1.5',
                      style: { pointerEvents: 'auto' }
                    },
                      // Add to Playlist button
                      React.createElement('button', {
                        onClick: (e) => {
                          e.stopPropagation();
                          setAddToPlaylistPanel({
                            open: true,
                            tracks: [track],
                            sourceName: track.title,
                            sourceType: 'track'
                          });
                        },
                        className: 'w-7 h-7 rounded-full flex items-center justify-center transition-all hover:scale-110',
                        style: { backgroundColor: 'rgba(255, 255, 255, 0.15)', color: '#ffffff', border: 'none', cursor: 'pointer' },
                        onMouseEnter: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.25)',
                        onMouseLeave: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.15)',
                        title: 'Add to Playlist'
                      },
                        React.createElement('svg', { className: 'w-3.5 h-3.5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor', strokeWidth: 2 },
                          React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', d: 'M12 4v16m8-8H4' })
                        )
                      ),
                      // Play button (center, larger)
                      React.createElement('button', {
                        onClick: (e) => {
                          e.stopPropagation();
                          const cachedArt = track.releaseId ? albumArtCache.current[track.releaseId]?.url : null;
                          saveSearchHistory(searchQuery, {
                            type: 'track',
                            id: track.id,
                            name: track.title,
                            artist: track.artist,
                            imageUrl: track.albumArt || cachedArt || null
                          });
                          handlePlay(track);
                        },
                        className: 'w-9 h-9 bg-white rounded-full flex items-center justify-center shadow-lg transition-all hover:scale-110',
                        style: { border: 'none', cursor: 'pointer' },
                        title: 'Play'
                      },
                        React.createElement(Play, { size: 16, className: 'text-gray-800 ml-0.5' })
                      ),
                      // Add to Queue button
                      React.createElement('button', {
                        onClick: (e) => {
                          e.stopPropagation();
                          addToQueue([track]);
                          showToast(`Added "${track.title}" to queue`, 'success');
                        },
                        className: 'w-7 h-7 rounded-full flex items-center justify-center transition-all hover:scale-110',
                        style: { backgroundColor: 'rgba(255, 255, 255, 0.15)', color: '#ffffff', border: 'none', cursor: 'pointer' },
                        onMouseEnter: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.25)',
                        onMouseLeave: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.15)',
                        title: 'Add to Queue'
                      },
                        React.createElement('svg', { className: 'w-3.5 h-3.5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor', strokeWidth: 2 },
                          React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', d: 'M4 6h16M4 12h16M4 18h7' })
                        )
                      )
                    ),
                    // Resolver dots - bottom right corner (hidden on hover)
                    track.sources && Object.keys(track.sources).length > 0 && React.createElement('div', {
                      className: 'absolute bottom-1.5 right-1.5 flex gap-1 transition-opacity group-hover/art:opacity-0'
                    },
                      ...Object.keys(track.sources).slice(0, 4).map(source => {
                        const colors = {
                          spotify: '#1DB954',
                          youtube: '#FF0000',
                          bandcamp: '#1DA0C3',
                          qobuz: '#0070CC',
                          applemusic: '#FA243C',
                          localfiles: '#6B7280'
                        };
                        return React.createElement('div', {
                          key: source,
                          style: {
                            width: '7px',
                            height: '7px',
                            borderRadius: '50%',
                            backgroundColor: colors[source] || '#9CA3AF',
                            boxShadow: '0 1px 2px rgba(0,0,0,0.3)'
                          }
                        });
                      })
                    )
                  ),
                  // Track title - refined typography
                  React.createElement('div', {
                    className: 'truncate',
                    style: {
                      fontSize: '13px',
                      fontWeight: '500',
                      color: '#1f2937',
                      marginTop: '6px'
                    }
                  }, track.title),
                  // Artist name
                  React.createElement('div', {
                    className: 'truncate',
                    style: {
                      fontSize: '11px',
                      color: '#6b7280',
                      marginTop: '2px'
                    }
                  }, track.artist)
                );
              })
            )
          ),

          // Albums section with album art cards - responsive grid
          searchResults.albums.length > 0 && React.createElement('div', null,
            React.createElement('div', { className: 'flex items-center justify-between mb-4' },
              React.createElement('h3', { className: 'text-xs font-semibold text-gray-400 uppercase tracking-wider' }, 'ALBUMS'),
              searchResults.albums.length > 8 &&
                React.createElement('button', {
                  onClick: () => {
                    setSearchDetailCategory('albums');
                    setSearchPreviewItem(searchResults.albums[0] || null);
                  },
                  className: 'text-xs text-gray-500 hover:text-gray-700'
                }, 'Show more')
            ),
            React.createElement('div', {
              className: 'flex gap-x-4 gap-y-5'
            },
              ...searchResults.albums.slice(0, getItemsPerRow(160)).map((album, index) => {
                const albumItemWidth = Math.floor((searchContainerWidth - (getItemsPerRow(160) - 1) * 16) / getItemsPerRow(160));
                const animationDelay = Math.min(index * 40, 300);
                return React.createElement('div', {
                  key: album.id,
                  onClick: () => {
                    saveSearchHistory(searchQuery, {
                      type: 'album',
                      id: album.id,
                      name: album.title,
                      artist: album['artist-credit']?.[0]?.name,
                      imageUrl: album.albumArt || null
                    });
                    handleAlbumClick(album);
                  },
                  onMouseEnter: () => {
                    // Prefetch album tracks on hover for context menu
                    prefetchSearchAlbumTracks(album);
                  },
                  className: 'group cursor-grab active:cursor-grabbing release-card card-fade-up',
                  style: {
                    width: albumItemWidth,
                    padding: '10px',
                    borderRadius: '10px',
                    backgroundColor: '#ffffff',
                    boxShadow: '0 1px 3px rgba(0, 0, 0, 0.05), 0 4px 12px rgba(0, 0, 0, 0.03)',
                    animationDelay: `${animationDelay}ms`
                  },
                  draggable: true,
                  onDragStart: (e) => {
                    e.dataTransfer.effectAllowed = 'copy';
                    e.dataTransfer.setData('text/plain', JSON.stringify({
                      type: 'album',
                      album: {
                        id: `${album['artist-credit']?.[0]?.name || 'unknown'}-${album.title || 'untitled'}`.toLowerCase().replace(/[^a-z0-9-]/g, ''),
                        title: album.title,
                        artist: album['artist-credit']?.[0]?.name || 'Unknown',
                        year: album['first-release-date']?.split('-')[0] ? parseInt(album['first-release-date'].split('-')[0]) : null,
                        art: null
                      }
                    }));
                  },
                  onContextMenu: (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (window.electron?.contextMenu?.showTrackMenu) {
                      const artistName = album['artist-credit']?.[0]?.name || 'Unknown';
                      const albumData = {
                        title: album.title,
                        artist: artistName,
                        year: album['first-release-date']?.split('-')[0] ? parseInt(album['first-release-date'].split('-')[0]) : null,
                        art: album.albumArt || null
                      };
                      // Check prefetched cache (use ref) and loading state (use module-level Set)
                      const prefetched = prefetchedReleasesRef.current[album.id];
                      const isLoading = prefetchInProgress.has(album.id);
                      window.electron.contextMenu.showTrackMenu({
                        type: 'release',
                        name: album.title,
                        album: albumData,
                        tracks: prefetched?.tracks || [],
                        loading: isLoading
                      });
                    }
                  }
                },
                  // Album art with rounded corners and inner shadow
                  React.createElement('div', {
                    className: 'w-full aspect-square rounded-lg overflow-hidden mb-2 relative album-art-container group/art'
                  },
                    // Dark placeholder background
                    React.createElement('div', {
                      className: 'absolute inset-0',
                      style: { background: 'linear-gradient(145deg, #1f1f1f 0%, #2d2d2d 50%, #1a1a1a 100%)' }
                    }),
                    // Image with fade-in
                    album.albumArt && React.createElement('img', {
                      src: album.albumArt,
                      alt: album.title,
                      className: 'absolute inset-0 w-full h-full object-cover transition-all duration-300 group-hover/art:scale-105',
                      style: { opacity: 0 },
                      ref: (el) => { if (el && el.complete && el.naturalWidth > 0) el.style.opacity = '1'; },
                      onLoad: (e) => { e.target.style.opacity = '1'; },
                      onError: (e) => { e.target.style.display = 'none'; }
                    }),
                    // Hover overlay with action buttons (Add to Playlist, Play, Queue)
                    React.createElement('div', {
                      className: 'absolute inset-0 bg-black/50 opacity-0 group-hover/art:opacity-100 transition-opacity duration-200 flex items-center justify-center gap-2',
                      style: { pointerEvents: 'auto' }
                    },
                      // Add to Playlist button
                      React.createElement('button', {
                        onClick: async (e) => {
                          e.stopPropagation();
                          // Get prefetched tracks for playlist, or fetch them
                          let prefetched = prefetchedReleasesRef.current[album.id];
                          if (!prefetched?.tracks?.length) {
                            showToast('Loading album...', 'info');
                            await fetchSearchAlbumTracksAsync(album);
                            prefetched = prefetchedReleasesRef.current[album.id];
                          }
                          if (prefetched?.tracks?.length > 0) {
                            setAddToPlaylistPanel({
                              open: true,
                              tracks: prefetched.tracks,
                              sourceName: album.title,
                              sourceType: 'album'
                            });
                          } else {
                            showToast('Could not load album tracks', 'error');
                          }
                        },
                        className: 'w-8 h-8 rounded-full flex items-center justify-center transition-all hover:scale-110',
                        style: { backgroundColor: 'rgba(255, 255, 255, 0.15)', color: '#ffffff', border: 'none', cursor: 'pointer' },
                        onMouseEnter: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.25)',
                        onMouseLeave: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.15)',
                        title: 'Add to Playlist'
                      },
                        React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor', strokeWidth: 2 },
                          React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', d: 'M12 4v16m8-8H4' })
                        )
                      ),
                      // Play button (center, larger - plays album)
                      React.createElement('button', {
                        onClick: async (e) => {
                          e.stopPropagation();
                          saveSearchHistory(searchQuery, {
                            type: 'album',
                            id: album.id,
                            name: album.title,
                            artist: album['artist-credit']?.[0]?.name,
                            imageUrl: album.albumArt || null
                          });
                          // Play the album - fetch tracks if needed
                          let prefetched = prefetchedReleasesRef.current[album.id];
                          if (!prefetched?.tracks?.length) {
                            showToast('Loading album...', 'info');
                            await fetchSearchAlbumTracksAsync(album);
                            prefetched = prefetchedReleasesRef.current[album.id];
                          }
                          if (prefetched?.tracks?.length > 0) {
                            const context = { type: 'album', name: album.title, artist: album['artist-credit']?.[0]?.name };
                            const [firstTrack, ...remainingTracks] = prefetched.tracks;
                            const taggedFirstTrack = { ...firstTrack, _playbackContext: context };
                            setQueueWithContext(remainingTracks, context);
                            handlePlay(taggedFirstTrack);
                          } else {
                            showToast('Could not load album tracks', 'error');
                          }
                        },
                        className: 'w-10 h-10 bg-white rounded-full flex items-center justify-center shadow-lg transition-all hover:scale-110',
                        style: { border: 'none', cursor: 'pointer' },
                        title: 'Play album'
                      },
                        React.createElement(Play, { size: 18, className: 'text-gray-800 ml-0.5' })
                      ),
                      // Add to Queue button
                      React.createElement('button', {
                        onClick: async (e) => {
                          e.stopPropagation();
                          // Fetch album tracks and add to queue
                          let prefetched = prefetchedReleasesRef.current[album.id];
                          if (!prefetched?.tracks?.length) {
                            showToast('Loading album...', 'info');
                            await fetchSearchAlbumTracksAsync(album);
                            prefetched = prefetchedReleasesRef.current[album.id];
                          }
                          if (prefetched?.tracks?.length > 0) {
                            addToQueue(prefetched.tracks, { type: 'album', name: album.title, artist: album['artist-credit']?.[0]?.name });
                            showToast(`Added ${prefetched.tracks.length} tracks from "${album.title}" to queue`, 'success');
                          } else {
                            showToast('Could not load album tracks', 'error');
                          }
                        },
                        className: 'w-8 h-8 rounded-full flex items-center justify-center transition-all hover:scale-110',
                        style: { backgroundColor: 'rgba(255, 255, 255, 0.15)', color: '#ffffff', border: 'none', cursor: 'pointer' },
                        onMouseEnter: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.25)',
                        onMouseLeave: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.15)',
                        title: 'Add to Queue'
                      },
                        React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor', strokeWidth: 2 },
                          React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', d: 'M4 6h16M4 12h16M4 18h7' })
                        )
                      )
                    )
                  ),
                  // Album title - refined typography
                  React.createElement('div', {
                    className: 'truncate',
                    style: {
                      fontSize: '13px',
                      fontWeight: '500',
                      color: '#1f2937',
                      marginTop: '6px'
                    }
                  }, album.title),
                  // Artist and year
                  React.createElement('div', {
                    className: 'truncate',
                    style: {
                      fontSize: '11px',
                      color: '#6b7280',
                      marginTop: '2px'
                    }
                  },
                    `${album['artist-credit']?.[0]?.name || 'Unknown'} â€¢ ${album['first-release-date']?.split('-')[0] || ''}`
                  )
                );
              })
            )
          ),

          // Playlists section - single row with overflow hidden
          searchResults.playlists.length > 0 && React.createElement('div', null,
            React.createElement('div', { className: 'flex items-center justify-between mb-4' },
              React.createElement('h3', { className: 'text-xs font-semibold text-gray-400 uppercase tracking-wider' }, 'PLAYLISTS'),
              searchResults.playlists.length > 5 &&
                React.createElement('button', {
                  onClick: () => {
                    setSearchDetailCategory('playlists');
                    setSearchPreviewItem(searchResults.playlists[0] || null);
                  },
                  className: 'text-xs text-gray-500 hover:text-gray-700'
                }, 'Show more')
            ),
            React.createElement('div', {
              className: 'flex gap-4 overflow-hidden'
            },
              ...searchResults.playlists.slice(0, 20).map((playlist, index) => {
                const animationDelay = Math.min(index * 40, 300);
                return React.createElement('div', {
                  key: playlist.title,
                  onClick: () => {
                    saveSearchHistory(searchQuery, {
                      type: 'playlist',
                      id: playlist.id,
                      name: playlist.title,
                      imageUrl: null
                    });
                    handlePlaylistClick(playlist);
                  },
                  className: 'flex-shrink-0 cursor-pointer group release-card card-fade-up',
                  style: {
                    width: '160px',
                    padding: '12px',
                    borderRadius: '10px',
                    backgroundColor: '#ffffff',
                    boxShadow: '0 1px 3px rgba(0, 0, 0, 0.05), 0 4px 12px rgba(0, 0, 0, 0.03)',
                    animationDelay: `${animationDelay}ms`
                  }
                },
                  // Playlist icon
                  React.createElement('div', {
                    className: 'w-full aspect-square rounded-lg mb-2 flex items-center justify-center',
                    style: { background: 'linear-gradient(145deg, #1f1f1f 0%, #2d2d2d 50%, #1a1a1a 100%)' }
                  },
                    React.createElement('svg', {
                      className: 'w-10 h-10 text-gray-500',
                      fill: 'none',
                      viewBox: '0 0 24 24',
                      stroke: 'currentColor',
                      strokeWidth: 1.5
                    },
                      React.createElement('path', {
                        strokeLinecap: 'round',
                        strokeLinejoin: 'round',
                        d: 'M9 9l10.5-3m0 6.553v3.75a2.25 2.25 0 01-1.632 2.163l-1.32.377a1.803 1.803 0 11-.99-3.467l2.31-.66a2.25 2.25 0 001.632-2.163zm0 0V4.5L9 7.5v9.75a2.25 2.25 0 01-1.632 2.163l-1.32.377a1.803 1.803 0 01-.99-3.467l2.31-.66A2.25 2.25 0 009 13.125V9'
                      })
                    )
                  ),
                  // Playlist title
                  React.createElement('div', {
                    className: 'truncate',
                    style: {
                      fontSize: '13px',
                      fontWeight: '500',
                      color: '#1f2937'
                    }
                  }, playlist.title),
                  // Track count
                  React.createElement('div', {
                    className: 'truncate',
                    style: {
                      fontSize: '11px',
                      color: '#6b7280',
                      marginTop: '2px'
                    }
                  },
                    `${playlist.tracks?.length || 0} tracks`
                  )
                );
              })
            )
          )
        )
        )
      )
    ) // end main view
    ) : // end activeView === 'search' ternary

      // Main content area - Artist Page (completely separate layout)
      activeView === 'artist' ? React.createElement('div', { 
        className: 'flex-1 flex flex-col',
        style: { overflow: 'hidden' }
      },
        // Artist page hero header (not inside scrollable area) - only show when NOT viewing or loading a release
        // Clickable to toggle collapse state
        !currentRelease && !loadingRelease && React.createElement('div', {
          className: 'relative',
          style: {
            height: isHeaderCollapsed ? '80px' : '320px',
            flexShrink: 0,
            transition: 'height 300ms ease-out',
            overflow: 'hidden',
            cursor: isHeaderCollapsed ? 'pointer' : 'default'
          },
        },
          // Clickable overlay to expand collapsed header (sits behind content)
          isHeaderCollapsed && React.createElement('div', {
            className: 'absolute inset-0 z-0',
            style: { cursor: 'pointer' },
            onClick: () => setIsHeaderCollapsed(false),
            title: 'Click to expand'
          }),
          // Background image with gradient overlay
          artistImage && React.createElement('div', {
            className: 'absolute inset-0',
            style: {
              backgroundImage: `url(${artistImage})`,
              backgroundSize: 'cover',
              backgroundPosition: artistImagePosition,
              filter: 'blur(0px)',
              pointerEvents: 'none'
            }
          }),
          // Gradient overlay for readability
          React.createElement('div', {
            className: 'absolute inset-0',
            style: {
              background: artistImage
                ? isHeaderCollapsed
                  ? 'linear-gradient(to bottom, rgba(0,0,0,0.7) 0%, rgba(17,17,17,0.95) 100%)'
                  : 'linear-gradient(to bottom, rgba(0,0,0,0.3) 0%, rgba(0,0,0,0.6) 50%, rgba(17,17,17,1) 100%)'
                : 'linear-gradient(to bottom, rgba(60,60,80,0.4) 0%, rgba(17,17,17,1) 100%)',
              pointerEvents: 'none'
            }
          }),
          // EXPANDED STATE - Artist info overlay (centered)
          !loadingRelease && currentArtist && !isHeaderCollapsed && React.createElement('div', {
            className: 'absolute inset-0 flex flex-col items-center justify-center text-center px-6 z-10',
            style: {
              opacity: isHeaderCollapsed ? 0 : 1,
              transition: 'opacity 300ms ease-out'
            }
          },
            React.createElement('h1', {
              className: 'text-5xl font-light text-white',
              style: {
                textShadow: '0 2px 20px rgba(0,0,0,0.5)',
                letterSpacing: '0.3em',
                textTransform: 'uppercase'
              }
            }, currentArtist.name),
            // Navigation tabs (centered)
            React.createElement('div', {
              className: 'flex items-center gap-1 mt-6',
              style: { textShadow: '0 1px 10px rgba(0,0,0,0.5)' }
            },
              ['music', 'biography', 'related'].map((tab, index) => [
                index > 0 && React.createElement('span', {
                  key: `sep-${tab}`,
                  className: 'text-gray-400 mx-2'
                }, '|'),
                React.createElement('button', {
                  key: tab,
                  onClick: async () => {
                    setArtistPageTab(tab);
                    // Lazy load data when tab is first clicked
                    if (tab === 'biography' && artistBio === null && !loadingBio && currentArtist) {
                      setLoadingBio(true); // Set loading immediately before async call
                      const bioData = await getArtistBio(currentArtist.name, currentArtist.mbid);
                      setArtistBio(bioData === null ? false : bioData); // Use false to indicate "fetched but no bio"
                    }
                    if (tab === 'related' && relatedArtists.length === 0 && currentArtist) {
                      const related = await getRelatedArtists(currentArtist.name, currentArtist.mbid);
                      if (related.length > 0) { setRelatedArtists(related); resolveRelatedArtistImages(related); }
                    }
                  },
                  className: `px-2 py-1 text-sm font-medium uppercase tracking-wider transition-colors no-drag ${
                    artistPageTab === tab
                      ? 'text-white'
                      : 'text-gray-400 hover:text-white'
                  }`
                }, tab === 'related' ? 'Related Artists' : tab.charAt(0).toUpperCase() + tab.slice(1))
              ]).flat().filter(Boolean)
            ),
            // Play Top Tracks button - responsive sizing
            React.createElement('button', {
              onClick: async () => {
                if (!currentArtist) return;
                setTrackLoading(true);
                const tracks = await getArtistTopTracks(currentArtist.name);
                if (tracks.length > 0) {
                  const context = { type: 'artist', name: currentArtist.name };
                  const [firstTrack, ...remainingTracks] = tracks;
                  const taggedFirstTrack = { ...firstTrack, _playbackContext: context };
                  setQueueWithContext(remainingTracks, context);
                  handlePlay(taggedFirstTrack);
                } else {
                  setTrackLoading(false);
                  showToast(`No top tracks found for ${currentArtist.name}`, 'error');
                }
              },
              className: `mt-6 rounded-full font-medium text-white no-drag transition-all hover:scale-105 ${isCompactHeader ? 'px-4 py-1.5 text-sm' : 'px-6 py-2'}`,
              style: {
                backgroundColor: '#E91E63',
                boxShadow: '0 4px 15px rgba(233, 30, 99, 0.4)'
              }
            }, isCompactHeader ? 'Play' : 'Play Top Tracks')
          ),
          // COLLAPSED STATE - Inline layout
          !loadingRelease && currentArtist && isHeaderCollapsed && React.createElement('div', {
            className: 'absolute inset-0 flex items-center px-16 z-10',
            style: {
              opacity: isHeaderCollapsed ? 1 : 0,
              transition: 'opacity 300ms ease-out'
            }
          },
            // Left side: Artist name - clickable to expand header
            React.createElement('h1', {
              className: 'text-2xl font-light mr-6 text-white flex-shrink-0 cursor-pointer hover:text-purple-300 transition-colors no-drag',
              style: {
                textShadow: '0 2px 10px rgba(0,0,0,0.5)',
                letterSpacing: '0.2em',
                textTransform: 'uppercase',
                maxWidth: '40%',
                lineHeight: '1.2'
              },
              onClick: () => setIsHeaderCollapsed(false),
              title: 'Click to expand'
            }, currentArtist.name),
            // Center: Navigation tabs
            React.createElement('div', {
              className: 'flex items-center gap-1',
              style: { textShadow: '0 1px 10px rgba(0,0,0,0.5)' }
            },
              ['music', 'biography', 'related'].map((tab, index) => [
                index > 0 && React.createElement('span', {
                  key: `sep-collapsed-${tab}`,
                  className: 'text-gray-400 mx-2'
                }, '|'),
                React.createElement('button', {
                  key: `collapsed-${tab}`,
                  onClick: async () => {
                    setArtistPageTab(tab);
                    if (tab === 'biography' && artistBio === null && !loadingBio && currentArtist) {
                      setLoadingBio(true); // Set loading immediately before async call
                      const bioData = await getArtistBio(currentArtist.name, currentArtist.mbid);
                      setArtistBio(bioData === null ? false : bioData); // Use false to indicate "fetched but no bio"
                    }
                    if (tab === 'related' && relatedArtists.length === 0 && currentArtist) {
                      const related = await getRelatedArtists(currentArtist.name, currentArtist.mbid);
                      if (related.length > 0) { setRelatedArtists(related); resolveRelatedArtistImages(related); }
                    }
                  },
                  className: `px-2 py-1 text-sm font-medium uppercase tracking-wider transition-colors no-drag ${
                    artistPageTab === tab
                      ? 'text-white'
                      : 'text-gray-400 hover:text-white'
                  }`
                }, tab === 'related' ? 'Related Artists' : tab.charAt(0).toUpperCase() + tab.slice(1))
              ]).flat().filter(Boolean)
            ),
            // Right side: Play Top Tracks button - responsive sizing
            React.createElement('button', {
              onClick: async () => {
                if (!currentArtist) return;
                setTrackLoading(true);
                const tracks = await getArtistTopTracks(currentArtist.name);
                if (tracks.length > 0) {
                  const context = { type: 'artist', name: currentArtist.name };
                  const [firstTrack, ...remainingTracks] = tracks;
                  const taggedFirstTrack = { ...firstTrack, _playbackContext: context };
                  setQueueWithContext(remainingTracks, context);
                  handlePlay(taggedFirstTrack);
                } else {
                  setTrackLoading(false);
                  showToast(`No top tracks found for ${currentArtist.name}`, 'error');
                }
              },
              className: `ml-auto rounded-full font-medium text-white no-drag transition-all hover:scale-105 ${isCompactHeader ? 'px-3 py-1.5 text-xs' : 'px-5 py-2 text-sm'}`,
              style: {
                backgroundColor: '#E91E63',
                boxShadow: '0 4px 15px rgba(233, 30, 99, 0.4)'
              }
            }, isCompactHeader ? 'Play' : 'Play Top Tracks')
          )
        ),
        
        // Loading state for release - show real header (already loaded), skeleton for content only
        loadingRelease && React.createElement('div', {
          className: 'flex-1 flex flex-col',
          style: { backgroundColor: 'white' }
        },
          // Real header with artist image (already loaded)
          React.createElement('div', {
            className: 'relative',
            style: { height: '80px', flexShrink: 0, overflow: 'hidden' }
          },
            // Background image
            artistImage && React.createElement('div', {
              className: 'absolute inset-0',
              style: {
                backgroundImage: `url(${artistImage})`,
                backgroundSize: 'cover',
                backgroundPosition: artistImagePosition
              }
            }),
            // Gradient overlay
            React.createElement('div', {
              className: 'absolute inset-0',
              style: {
                background: artistImage
                  ? 'linear-gradient(to bottom, rgba(0,0,0,0.5) 0%, rgba(17,17,17,0.95) 100%)'
                  : 'linear-gradient(to bottom, rgba(60,60,80,0.4) 0%, rgba(17,17,17,1) 100%)'
              }
            }),
            // Artist info overlay (matching collapsed artist header)
            React.createElement('div', {
              className: 'absolute inset-0 flex items-center px-16 z-10'
            },
              // Left side: Artist name
              React.createElement('h1', {
                className: 'text-2xl font-light mr-6 text-white flex-shrink-0',
                style: {
                  textShadow: '0 2px 10px rgba(0,0,0,0.5)',
                  letterSpacing: '0.2em',
                  textTransform: 'uppercase',
                  maxWidth: '40%',
                  lineHeight: '1.2'
                }
              }, currentArtist?.name || ''),
              // Center: Navigation tabs
              React.createElement('div', {
                className: 'flex items-center gap-1',
                style: { textShadow: '0 1px 10px rgba(0,0,0,0.5)' }
              },
                ['music', 'biography', 'related'].map((tab, index) => [
                  index > 0 && React.createElement('span', {
                    key: `sep-loading-${tab}`,
                    className: 'text-gray-400 mx-2'
                  }, '|'),
                  React.createElement('span', {
                    key: `loading-${tab}`,
                    className: `px-2 py-1 text-sm font-medium uppercase tracking-wider ${
                      tab === 'music' ? 'text-white' : 'text-gray-400'
                    }`
                  }, tab === 'related' ? 'Related Artists' : tab.charAt(0).toUpperCase() + tab.slice(1))
                ]).flat().filter(Boolean)
              ),
              // Right side: Start Album Station button - responsive sizing
              React.createElement('button', {
                className: `ml-auto rounded-full font-medium text-white no-drag transition-all hover:scale-105 ${isCompactHeader ? 'px-3 py-1.5 text-xs' : 'px-5 py-2 text-sm'}`,
                style: {
                  backgroundColor: '#E91E63',
                  boxShadow: '0 4px 15px rgba(233, 30, 99, 0.4)'
                }
              }, isCompactHeader ? 'Station' : 'Start Album Station')
            )
          ),
          // Skeleton content with white background (matching release page)
          React.createElement('div', { className: 'bg-white flex-1' },
            // ALBUM DETAILS header with breadcrumb (artist name known, album loading)
            React.createElement('div', {
              className: 'flex items-center justify-between px-6 py-4 border-b border-gray-200'
            },
              // Breadcrumb navigation: Artist Name > Loading...
              React.createElement('div', {
                className: 'flex items-center gap-2 text-xs font-medium tracking-widest uppercase'
              },
                React.createElement('button', {
                  onClick: () => {
                    setCurrentRelease(null);
                  },
                  className: 'text-gray-400 hover:text-gray-600 transition-colors uppercase'
                }, currentArtist?.name || 'Artist'),
                React.createElement('span', { className: 'text-gray-300' }, '/'),
React.createElement('div', {
                  className: 'h-3 w-24 rounded bg-gradient-to-r from-gray-300 via-gray-200 to-gray-300 animate-shimmer',
                  style: { backgroundSize: '200% 100%' }
                })
              ),
              React.createElement('div')
            ),
            // Two-column layout matching ReleasePage
            React.createElement('div', { className: 'flex gap-0 p-6' },
              // Left column - album art skeleton (matches ReleasePage: width 240px, pr-8)
              React.createElement('div', {
                className: 'flex-shrink-0 pr-8',
                style: { width: '240px' }
              },
                // Album art (w-48 h-48 = 192px)
                React.createElement('div', {
                  className: 'w-48 h-48 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                  style: { backgroundSize: '200% 100%' }
                }),
                // Metadata below art
                React.createElement('div', { className: 'mt-4 space-y-1' },
                  React.createElement('div', {
                    className: 'h-5 rounded w-3/4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                    style: { backgroundSize: '200% 100%' }
                  }),
                  React.createElement('div', {
                    className: 'h-4 rounded w-1/2 mt-1 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                    style: { backgroundSize: '200% 100%' }
                  }),
                  React.createElement('div', {
                    className: 'h-4 rounded w-1/3 mt-1 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                    style: { backgroundSize: '200% 100%' }
                  })
                )
              ),
              // Right column - track list skeleton
              React.createElement('div', { className: 'flex-1 min-w-0 space-y-0' },
                [75, 60, 85, 55, 70, 80, 50, 65, 90, 58].map((width, i) =>
                  React.createElement('div', {
                    key: `track-skeleton-${i}`,
                    className: 'flex items-center gap-4 py-3 px-2',
                    style: { backgroundColor: i % 2 === 0 ? '#fafafa' : 'transparent' }
                  },
                    // Track number
                    React.createElement('div', {
                      className: 'w-6 h-4 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                      style: { backgroundSize: '200% 100%' }
                    }),
                    // Track title
                    React.createElement('div', { className: 'flex-1' },
                      React.createElement('div', {
                        className: 'h-4 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                        style: { width: `${width}%`, backgroundSize: '200% 100%' }
                      })
                    ),
                    // Duration
                    React.createElement('div', {
                      className: 'w-10 h-4 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                      style: { backgroundSize: '200% 100%' }
                    })
                  )
                )
              )
            )
          )
        ),
        
        // Release page - artist header (shows artist image/name/tabs at top)
        !loadingRelease && currentRelease && React.createElement('div', {
          className: 'relative',
          style: {
            height: '80px',
            flexShrink: 0,
            overflow: 'hidden'
          }
        },
          // Background image with gradient overlay
          artistImage && React.createElement('div', {
            className: 'absolute inset-0',
            style: {
              backgroundImage: `url(${artistImage})`,
              backgroundSize: 'cover',
              backgroundPosition: artistImagePosition,
              filter: 'blur(0px)'
            }
          }),
          // Gradient overlay for readability
          React.createElement('div', {
            className: 'absolute inset-0',
            style: {
              background: artistImage
                ? 'linear-gradient(to bottom, rgba(0,0,0,0.5) 0%, rgba(17,17,17,0.95) 100%)'
                : 'linear-gradient(to bottom, rgba(60,60,80,0.4) 0%, rgba(17,17,17,1) 100%)'
            }
          }),
          // Artist info overlay (inline layout for release page - matches collapsed artist header)
          React.createElement('div', {
            className: 'absolute inset-0 flex items-center px-16 z-10'
          },
            // Left side: Artist name
            React.createElement('h1', {
              className: 'text-2xl font-light mr-6 text-white cursor-pointer hover:text-purple-300 transition-colors no-drag flex-shrink-0',
              style: {
                textShadow: '0 2px 10px rgba(0,0,0,0.5)',
                letterSpacing: '0.2em',
                textTransform: 'uppercase',
                maxWidth: '40%',
                lineHeight: '1.2'
              },
              onClick: () => {
                const artistName = currentRelease?.artist?.name || currentArtist?.name;
                setCurrentRelease(null);
                // Ensure full artist data is loaded
                if (artistName && artistReleases.length === 0) {
                  fetchArtistData(artistName);
                }
              },
              title: 'Back to artist'
            }, currentRelease.artist?.name || currentArtist?.name),
            // Center: Navigation tabs
            React.createElement('div', {
              className: 'flex items-center gap-1',
              style: { textShadow: '0 1px 10px rgba(0,0,0,0.5)' }
            },
              ['music', 'biography', 'related'].map((tab, index) => [
                index > 0 && React.createElement('span', {
                  key: `sep-release-${tab}`,
                  className: 'text-gray-400 mx-2'
                }, '|'),
                React.createElement('button', {
                  key: `release-${tab}`,
                  onClick: async () => {
                    // Go back to artist page and switch to the selected tab
                    const artistName = currentRelease?.artist?.name || currentArtist?.name;
                    setCurrentRelease(null);
                    setArtistPageTab(tab);
                    // Ensure full artist data is loaded if navigating to music tab
                    if (tab === 'music' && artistName && artistReleases.length === 0) {
                      fetchArtistData(artistName);
                    }
                    if (tab === 'biography' && artistBio === null && !loadingBio && artistName) {
                      // Ensure artist data is loaded first
                      if (artistReleases.length === 0) {
                        fetchArtistData(artistName);
                      }
                      setLoadingBio(true); // Set loading immediately before async call
                      const bioData = await getArtistBio(artistName, currentArtist?.mbid);
                      setArtistBio(bioData === null ? false : bioData); // Use false to indicate "fetched but no bio"
                    }
                    if (tab === 'related' && relatedArtists.length === 0 && artistName) {
                      // Ensure artist data is loaded first
                      if (artistReleases.length === 0) {
                        fetchArtistData(artistName);
                      }
                      const related = await getRelatedArtists(artistName, currentArtist?.mbid);
                      if (related.length > 0) { setRelatedArtists(related); resolveRelatedArtistImages(related); }
                    }
                  },
                  className: `px-2 py-1 text-sm font-medium uppercase tracking-wider transition-colors no-drag ${
                    tab === 'music'
                      ? 'text-white'
                      : 'text-gray-400 hover:text-white'
                  }`
                }, tab === 'related' ? 'Related Artists' : tab.charAt(0).toUpperCase() + tab.slice(1))
              ]).flat().filter(Boolean)
            ),
            // Right side: Start Album Station button - responsive sizing
            React.createElement('button', {
              onClick: () => console.log('Start Album Station - placeholder'),
              className: `ml-auto rounded-full font-medium text-white no-drag transition-all hover:scale-105 ${isCompactHeader ? 'px-3 py-1.5 text-xs' : 'px-5 py-2 text-sm'}`,
              style: {
                backgroundColor: '#E91E63',
                boxShadow: '0 4px 15px rgba(233, 30, 99, 0.4)'
              }
            }, isCompactHeader ? 'Station' : 'Start Album Station')
          )
        ),

        // Release page content (scrollable) - new layout with album details header
        !loadingRelease && currentRelease && React.createElement('div', {
          className: 'scrollable-content bg-white',
          style: {
            flex: 1,
            overflowY: 'scroll',
            pointerEvents: 'auto'
          }
        },
          // ALBUM DETAILS section header with breadcrumb
          React.createElement('div', {
            className: 'flex items-center justify-between px-6 py-4 border-b border-gray-200'
          },
            // Breadcrumb navigation: Artist Name > Album Name
            React.createElement('div', {
              className: 'flex items-center gap-2 text-xs font-medium tracking-widest uppercase'
            },
              React.createElement('button', {
                onClick: () => {
                  // Clear the release view to go back to artist
                  setCurrentRelease(null);
                  // If artist releases aren't loaded, fetch full artist data
                  const artistName = currentRelease?.artist?.name || currentArtist?.name;
                  if (artistName && artistReleases.length === 0) {
                    fetchArtistData(artistName);
                  }
                },
                className: 'text-gray-400 hover:text-gray-600 transition-colors uppercase'
              }, currentArtist?.name || currentRelease?.artist?.name || 'Artist'),
              React.createElement('span', { className: 'text-gray-300' }, '/'),
              React.createElement('span', { className: 'text-gray-600 uppercase' },
                currentRelease?.title || 'Album Details'
              )
            ),
            // Empty div to maintain layout (no close button needed with breadcrumb)
            React.createElement('div')
          ),
          // Two-column layout: album art + metadata on left, tracklist on right
          React.createElement(ReleasePage, {
            release: currentRelease,
            handleSearch: handleSearchInput,
            handlePlay: handlePlay,
            onTrackPlay: (track, tracksAfter) => {
              // Set queue with remaining tracks from the album, then play
              const context = { type: 'album', id: currentRelease?.id, name: currentRelease?.title, artist: currentRelease?.artist?.name };
              // Tag the current track with context too
              const taggedTrack = { ...track, _playbackContext: context };
              setQueueWithContext(tracksAfter, context);
              handlePlay(taggedTrack);
            },
            onTrackContextMenu: (track) => {
              if (window.electron?.contextMenu?.showTrackMenu) {
                window.electron.contextMenu.showTrackMenu({
                  type: 'track',
                  track: track
                });
              }
            },
            trackSources: trackSources,
            resolvers: resolvers,
            // Now playing props
            currentTrack: currentTrack,
            playbackContext: playbackContext,
            isPlaying: isPlaying,
            // Drag and drop handlers for adding tracks to playlists
            onDragStart: (track) => {
              setDraggingTrackForPlaylist(track);
            },
            onDragEnd: () => {
              setDraggingTrackForPlaylist(null);
              setDropTargetPlaylistId(null);
              setDropTargetNewPlaylist(false);
              // Close panel if it was opened by drag and nothing was dropped
              if (addToPlaylistPanel.open && selectedPlaylistsForAdd.length === 0) {
                setAddToPlaylistPanel(prev => ({ ...prev, open: false }));
              }
            },
            // Visibility tracking for resolution scheduler
            releaseTrackRowRefs: releaseTrackRowRefs,
            releaseObserverRef: releaseObserverRef,
            // Album action props (hover buttons on album art)
            onAlbumPlay: (rel) => {
              if (rel.tracks?.length > 0) {
                const context = { type: 'album', id: rel.id, name: rel.title, artist: rel.artist?.name };
                const tracks = rel.tracks.map(t => {
                  const trackId = `${rel.artist?.name || 'unknown'}-${t.title || 'untitled'}-${rel.title || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
                  return {
                    ...t,
                    id: trackId,
                    artist: rel.artist?.name,
                    album: rel.title,
                    albumArt: rel.albumArt,
                    sources: trackSources[trackId] || {}
                  };
                });
                const [firstTrack, ...remainingTracks] = tracks;
                const taggedFirstTrack = { ...firstTrack, _playbackContext: context };
                setQueueWithContext(remainingTracks, context);
                handlePlay(taggedFirstTrack);
              }
            },
            onAlbumAddToQueue: (rel) => {
              if (rel.tracks?.length > 0) {
                const tracks = rel.tracks.map(t => {
                  const trackId = `${rel.artist?.name || 'unknown'}-${t.title || 'untitled'}-${rel.title || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
                  return {
                    ...t,
                    id: trackId,
                    artist: rel.artist?.name,
                    album: rel.title,
                    albumArt: rel.albumArt,
                    sources: trackSources[trackId] || {}
                  };
                });
                addToQueue(tracks, { type: 'album', name: rel.title, id: rel.id });
                showToast(`Added ${tracks.length} tracks to queue`, 'success');
              }
            },
            onAlbumAddToPlaylist: (rel) => {
              if (rel.tracks?.length > 0) {
                const tracks = rel.tracks.map(t => {
                  const trackId = `${rel.artist?.name || 'unknown'}-${t.title || 'untitled'}-${rel.title || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
                  return {
                    ...t,
                    id: trackId,
                    artist: rel.artist?.name,
                    album: rel.title,
                    albumArt: rel.albumArt,
                    sources: trackSources[trackId] || {}
                  };
                });
                setAddToPlaylistPanel({
                  open: true,
                  tracks: tracks,
                  sourceName: rel.title,
                  sourceType: 'album'
                });
                setSelectedPlaylistsForAdd([]);
              }
            }
          })
        ),
        
        // Skeleton loading state for artist - only show before currentArtist is set
        !currentRelease && !loadingRelease && loadingArtist && !currentArtist && React.createElement('div', {
          className: 'flex-1'
        },
          // Skeleton header area with shimmer
          React.createElement('div', {
            className: 'relative h-48 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
            style: { backgroundSize: '200% 100%' }
          }),
          // Skeleton content
          React.createElement('div', { className: 'p-6' },
            // Skeleton filter buttons
            React.createElement('div', { className: 'flex gap-2 mb-4' },
              Array.from({ length: 4 }).map((_, i) =>
                React.createElement('div', {
                  key: `filter-skeleton-${i}`,
                  className: 'h-10 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded-full animate-shimmer',
                  style: { width: `${80 + i * 15}px`, backgroundSize: '200% 100%', animationDelay: `${i * 100}ms` }
                })
              )
            ),
            // Skeleton release count
            React.createElement('div', {
              className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-24 mb-6 animate-shimmer',
              style: { backgroundSize: '200% 100%' }
            }),
            // Skeleton album grid
            React.createElement('div', {
              className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4'
            },
              Array.from({ length: 10 }).map((_, i) =>
                React.createElement('div', { key: `album-skeleton-${i}` },
                  React.createElement('div', {
                    className: 'aspect-square bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded-lg mb-3 animate-shimmer',
                    style: { backgroundSize: '200% 100%', animationDelay: `${i * 50}ms` }
                  }),
                  React.createElement('div', {
                    className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-3/4 mb-2 animate-shimmer',
                    style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 25}ms` }
                  }),
                  React.createElement('div', {
                    className: 'h-3 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-1/2 animate-shimmer',
                    style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 50}ms` }
                  })
                )
              )
            )
          )
        ),
        
        // Artist content (scrollable) - show when we have artist data (even while releases are loading)
        !currentRelease && !loadingRelease && currentArtist && React.createElement('div', {
          ref: artistPageScrollRef,
          className: 'scrollable-content',
          style: {
            flex: 1,
            overflowY: 'scroll',
            pointerEvents: 'auto'
          },
          onScroll: handleArtistPageScroll
        },
          // Sticky filter bar (Music tab only) - refined styling
          artistPageTab === 'music' && React.createElement('div', {
            className: 'sticky top-0 z-10 flex items-center px-6 py-4',
            style: {
              backgroundColor: 'rgba(255, 255, 255, 0.95)',
              backdropFilter: 'blur(8px)',
              borderBottom: '1px solid rgba(0, 0, 0, 0.06)'
            }
          },
            // Release type filter pills
            React.createElement('div', { className: 'flex gap-2 flex-wrap' },
              [
                { value: 'album', label: 'Studio Albums' },
                { value: 'ep', label: 'EPs' },
                { value: 'single', label: 'Singles' },
                { value: 'live', label: 'Live' },
                { value: 'compilation', label: 'Compilations' },
                { value: 'all', label: 'All' }
              ].map(({ value, label }) => {
                const searchFiltered = filterArtistReleases(artistReleases);
                const count = value === 'all'
                  ? searchFiltered.length
                  : searchFiltered.filter(r => r.releaseType === value).length;

                // While loading, show all filter types; otherwise hide those with 0 count (except 'all')
                if (!loadingArtist && count === 0 && value !== 'all') return null;

                const isActive = releaseTypeFilter === value;
                return React.createElement('button', {
                  key: value,
                  onClick: () => setReleaseTypeFilter(value),
                  className: 'no-drag transition-all',
                  style: {
                    padding: '8px 16px',
                    borderRadius: '20px',
                    fontSize: '13px',
                    fontWeight: '500',
                    backgroundColor: isActive ? '#7c3aed' : 'rgba(0, 0, 0, 0.04)',
                    color: isActive ? '#ffffff' : '#4b5563',
                    border: 'none',
                    cursor: 'pointer',
                    boxShadow: isActive ? '0 2px 8px rgba(124, 58, 237, 0.3)' : 'none'
                  }
                }, loadingArtist ? label : `${label} (${count})`);
              })
            ),
            // Spacer
            React.createElement('div', { className: 'flex-1' }),
            // Sort dropdown
            React.createElement('div', { className: 'relative mr-3' },
              React.createElement('button', {
                onClick: (e) => { e.stopPropagation(); setArtistSortDropdownOpen(!artistSortDropdownOpen); },
                className: 'flex items-center gap-2 transition-colors',
                style: {
                  padding: '8px 12px',
                  fontSize: '13px',
                  fontWeight: '500',
                  color: '#6b7280',
                  cursor: 'pointer'
                }
              },
                React.createElement('span', null, artistSortOptions.find(o => o.value === artistSort)?.label || 'Sort'),
                React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                  React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M19 9l-7 7-7-7' })
                )
              ),
              // Dropdown menu
              artistSortDropdownOpen && React.createElement('div', {
                className: 'absolute right-0 top-full mt-1 bg-white rounded-lg shadow-lg py-1 min-w-[160px] z-30 border border-gray-200'
              },
                artistSortOptions.map(option =>
                  React.createElement('button', {
                    key: option.value,
                    onClick: (e) => {
                      e.stopPropagation();
                      setArtistSort(option.value);
                      setArtistSortDropdownOpen(false);
                    },
                    className: `w-full px-4 py-2 text-left text-sm hover:bg-gray-100 flex items-center justify-between ${
                      artistSort === option.value ? 'text-gray-900 font-medium' : 'text-gray-600'
                    }`
                  },
                    option.label,
                    artistSort === option.value && React.createElement('svg', {
                      className: 'w-4 h-4',
                      fill: 'none',
                      viewBox: '0 0 24 24',
                      stroke: 'currentColor'
                    },
                      React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M5 13l4 4L19 7' })
                    )
                  )
                )
              )
            ),
            // Search toggle/field
            React.createElement('div', { className: 'flex items-center' },
              artistSearchOpen ?
                React.createElement('div', {
                  className: 'flex items-center',
                  style: {
                    padding: '6px 14px',
                    borderRadius: '20px',
                    backgroundColor: 'rgba(0, 0, 0, 0.04)',
                    border: '1px solid rgba(0, 0, 0, 0.08)'
                  }
                },
                  React.createElement('input', {
                    type: 'text',
                    value: artistSearch,
                    onChange: (e) => setArtistSearch(e.target.value),
                    onBlur: () => {
                      if (!artistSearch.trim()) {
                        setArtistSearchOpen(false);
                      }
                    },
                    autoFocus: true,
                    placeholder: 'Filter...',
                    className: 'bg-transparent outline-none',
                    style: {
                      width: '150px',
                      fontSize: '13px',
                      color: '#374151'
                    }
                  }),
                  artistSearch && React.createElement('button', {
                    onClick: () => {
                      setArtistSearch('');
                      setArtistSearchOpen(false);
                    },
                    className: 'ml-2 text-gray-400 hover:text-gray-600'
                  },
                    React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                      React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M6 18L18 6M6 6l12 12' })
                    )
                  )
                )
              :
                React.createElement('button', {
                  onClick: () => setArtistSearchOpen(true),
                  className: 'transition-colors',
                  style: {
                    padding: '8px',
                    color: '#9ca3af',
                    cursor: 'pointer'
                  }
                },
                  React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' })
                  )
                )
            )
          ),
          // MUSIC TAB - Discography
          artistPageTab === 'music' && React.createElement('div', {
            className: 'space-y-6 p-6'
          },
            // Loading skeletons for discography
            loadingArtist && React.createElement('div', {
              className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4 pb-6'
            },
              Array.from({ length: 10 }).map((_, i) =>
                React.createElement('div', { key: `album-skeleton-${i}` },
                  React.createElement('div', {
                    className: 'aspect-square bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded-lg mb-3 animate-shimmer',
                    style: { backgroundSize: '200% 100%', animationDelay: `${i * 50}ms` }
                  }),
                  React.createElement('div', {
                    className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-3/4 mb-2 animate-shimmer',
                    style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 25}ms` }
                  }),
                  React.createElement('div', {
                    className: 'h-3 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-1/2 animate-shimmer',
                    style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 50}ms` }
                  })
                )
              )
            ),
            // Discography grid (when loaded) - refined spacing
            !loadingArtist && React.createElement('div', {
              className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-x-4 gap-y-5 pb-6',
              ref: (el) => {
                if (!el) {
                  // Cleanup observer when unmounting
                  if (albumArtObserver.current) {
                    albumArtObserver.current.disconnect();
                    albumArtObserver.current = null;
                  }
                  visibleAlbumIds.current.clear();
                  return;
                }

                // Set up IntersectionObserver if not already done
                if (!albumArtObserver.current) {
                  albumArtObserver.current = new IntersectionObserver(
                    (entries) => {
                      let changed = false;
                      for (const entry of entries) {
                        const releaseId = entry.target.getAttribute('data-release-id');
                        if (!releaseId) continue;

                        if (entry.isIntersecting) {
                          if (!visibleAlbumIds.current.has(releaseId)) {
                            visibleAlbumIds.current.add(releaseId);
                            changed = true;
                          }
                        } else {
                          if (visibleAlbumIds.current.has(releaseId)) {
                            visibleAlbumIds.current.delete(releaseId);
                            changed = true;
                          }
                        }
                      }

                      // Reprioritize queue when visibility changes
                      if (changed && albumArtQueue.current.length > 0) {
                        reprioritizeAlbumArtQueue();
                      }
                    },
                    { threshold: 0, rootMargin: '100px' } // Slightly expand viewport for smoother loading
                  );

                  // Observe all release cards
                  const cards = el.querySelectorAll('[data-release-id]');
                  cards.forEach(card => albumArtObserver.current.observe(card));
                }
              }
            },
              sortArtistReleases(filterArtistReleases(artistReleases)).map((release, index) =>
                React.createElement(ReleaseCard, {
                  key: release.id,
                  release: release,
                  onCardRef: (el) => {
                    // Observe new cards as they're added for viewport-prioritized loading
                    if (el && albumArtObserver.current) {
                      albumArtObserver.current.observe(el);
                    }
                  },
                  currentArtist: currentArtist,
                  fetchReleaseData: fetchReleaseData,
                  animationDelay: Math.min(index * 30, 300), // Staggered animation, cap at 300ms
                  onHoverFetch: (rel) => {
                    // Prefetch release tracks on hover for context menu
                    prefetchReleaseTracks(rel, currentArtist);
                  },
                  onContextMenu: async (rel) => {
                    // For releases, show context menu with tracks
                    if (window.electron?.contextMenu?.showTrackMenu) {
                      const albumData = {
                        title: rel.title,
                        artist: currentArtist?.name,
                        year: rel.date?.split('-')[0] ? parseInt(rel.date.split('-')[0]) : null,
                        art: rel.albumArt
                      };
                      // Check prefetched cache first (use ref to avoid stale closure)
                      const prefetched = prefetchedReleasesRef.current[rel.id];
                      if (prefetched?.tracks?.length > 0) {
                        window.electron.contextMenu.showTrackMenu({
                          type: 'release',
                          name: rel.title,
                          album: albumData,
                          tracks: prefetched.tracks
                        });
                      } else if (currentRelease?.id === rel.id && currentRelease?.tracks?.length > 0) {
                        // Use already loaded tracks from current release
                        const tracks = currentRelease.tracks.map(t => {
                          const trackId = `${currentArtist?.name || 'unknown'}-${t.title || 'untitled'}-${rel.title || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
                          return {
                            ...t,
                            id: trackId,
                            artist: currentArtist?.name,
                            album: rel.title,
                            albumArt: rel.albumArt,
                            sources: trackSources[`${t.position}-${t.title}`] || {}
                          };
                        });
                        window.electron.contextMenu.showTrackMenu({
                          type: 'release',
                          name: rel.title,
                          album: albumData,
                          tracks: tracks
                        });
                      } else {
                        // No tracks available yet - show with 0 tracks
                        window.electron.contextMenu.showTrackMenu({
                          type: 'release',
                          name: rel.title,
                          album: albumData,
                          releaseId: rel.id,
                          artist: currentArtist?.name,
                          albumArt: rel.albumArt,
                          tracks: []
                        });
                      }
                    }
                  },
                  prefetchedReleasesRef: prefetchedReleasesRef,
                  onPlay: async (rel) => {
                    setTrackLoading(true);
                    // Get tracks from prefetched cache or current release
                    const prefetched = prefetchedReleasesRef.current[rel.id];
                    let tracks = [];
                    if (prefetched?.tracks?.length > 0) {
                      tracks = prefetched.tracks;
                    } else if (currentRelease?.id === rel.id && currentRelease?.tracks?.length > 0) {
                      tracks = currentRelease.tracks.map(t => {
                        const trackId = `${currentArtist?.name || 'unknown'}-${t.title || 'untitled'}-${rel.title || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
                        return {
                          ...t,
                          id: trackId,
                          artist: currentArtist?.name,
                          album: rel.title,
                          albumArt: rel.albumArt,
                          sources: trackSources[`${t.position}-${t.title}`] || {}
                        };
                      });
                    }
                    if (tracks.length > 0) {
                      const context = { type: 'album', name: rel.title, id: rel.id };
                      const [firstTrack, ...remainingTracks] = tracks;
                      // Tag the first track with context so queue navigation works correctly
                      const taggedFirstTrack = { ...firstTrack, _playbackContext: context };
                      setQueueWithContext(remainingTracks, context);
                      handlePlay(taggedFirstTrack);
                    } else {
                      // Fetch and play if no tracks cached
                      await prefetchReleaseTracks(rel, currentArtist);
                      const newPrefetched = prefetchedReleasesRef.current[rel.id];
                      if (newPrefetched?.tracks?.length > 0) {
                        const context = { type: 'album', name: rel.title, id: rel.id };
                        const [firstTrack, ...remainingTracks] = newPrefetched.tracks;
                        // Tag the first track with context so queue navigation works correctly
                        const taggedFirstTrack = { ...firstTrack, _playbackContext: context };
                        setQueueWithContext(remainingTracks, context);
                        handlePlay(taggedFirstTrack);
                      }
                    }
                  },
                  onAddToQueue: async (rel) => {
                    const prefetched = prefetchedReleasesRef.current[rel.id];
                    let tracks = [];
                    if (prefetched?.tracks?.length > 0) {
                      tracks = prefetched.tracks;
                    } else if (currentRelease?.id === rel.id && currentRelease?.tracks?.length > 0) {
                      tracks = currentRelease.tracks.map(t => {
                        const trackId = `${currentArtist?.name || 'unknown'}-${t.title || 'untitled'}-${rel.title || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
                        return {
                          ...t,
                          id: trackId,
                          artist: currentArtist?.name,
                          album: rel.title,
                          albumArt: rel.albumArt,
                          sources: trackSources[`${t.position}-${t.title}`] || {}
                        };
                      });
                    }
                    if (tracks.length > 0) {
                      addToQueue(tracks, { type: 'album', name: rel.title, id: rel.id });
                    } else {
                      // Fetch and add if no tracks cached
                      await prefetchReleaseTracks(rel, currentArtist);
                      const newPrefetched = prefetchedReleasesRef.current[rel.id];
                      if (newPrefetched?.tracks?.length > 0) {
                        addToQueue(newPrefetched.tracks, { type: 'album', name: rel.title, id: rel.id });
                      }
                    }
                  },
                  onAddToPlaylist: async (rel) => {
                    const prefetched = prefetchedReleasesRef.current[rel.id];
                    let tracks = [];
                    if (prefetched?.tracks?.length > 0) {
                      tracks = prefetched.tracks;
                    } else if (currentRelease?.id === rel.id && currentRelease?.tracks?.length > 0) {
                      tracks = currentRelease.tracks.map(t => {
                        const trackId = `${currentArtist?.name || 'unknown'}-${t.title || 'untitled'}-${rel.title || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
                        return {
                          ...t,
                          id: trackId,
                          artist: currentArtist?.name,
                          album: rel.title,
                          albumArt: rel.albumArt,
                          sources: trackSources[`${t.position}-${t.title}`] || {}
                        };
                      });
                    }
                    if (tracks.length > 0) {
                      setAddToPlaylistPanel({
                        open: true,
                        tracks: tracks,
                        sourceName: rel.title,
                        sourceType: 'album'
                      });
                      setSelectedPlaylistsForAdd([]);
                    } else {
                      // Fetch and show panel if no tracks cached
                      await prefetchReleaseTracks(rel, currentArtist);
                      const newPrefetched = prefetchedReleasesRef.current[rel.id];
                      if (newPrefetched?.tracks?.length > 0) {
                        setAddToPlaylistPanel({
                          open: true,
                          tracks: newPrefetched.tracks,
                          sourceName: rel.title,
                          sourceType: 'album'
                        });
                        setSelectedPlaylistsForAdd([]);
                      }
                    }
                  },
                  isVisible: (releaseTypeFilter === 'all' || release.releaseType === releaseTypeFilter) &&
                    (!artistSearch.trim() || release.title.toLowerCase().includes(artistSearch.toLowerCase()))
                })
              )
            ),

            // Empty state (only show when not loading)
            !loadingArtist && (() => {
              const filtered = sortArtistReleases(filterArtistReleases(artistReleases));
              const typeFiltered = filtered.filter(r => releaseTypeFilter === 'all' || r.releaseType === releaseTypeFilter);
              if (typeFiltered.length === 0) {
                const typeLabels = {
                  all: '',
                  album: 'studio albums',
                  live: 'live albums',
                  compilation: 'compilations',
                  ep: 'EPs',
                  single: 'singles'
                };
                return React.createElement('div', { className: 'text-center py-12 text-gray-400' },
                  artistSearch.trim()
                    ? `No releases matching "${artistSearch}"`
                    : `No ${typeLabels[releaseTypeFilter] || releaseTypeFilter} found`
                );
              }
              return null;
            })()
          ),

          // BIOGRAPHY TAB - Two-column layout
          artistPageTab === 'biography' && React.createElement('div', {
            className: 'flex gap-0 p-6'
          },
            // LEFT COLUMN: Artist Info Card (same width as album art column)
            React.createElement('div', {
              className: 'flex-shrink-0 pr-8',
              style: { width: '240px' }
            },
              // Artist Info Card
              React.createElement('div', {
                style: {
                  width: '192px',
                  backgroundColor: '#ffffff',
                  borderRadius: '10px',
                  padding: '14px',
                  boxShadow: '0 1px 3px rgba(0, 0, 0, 0.05), 0 4px 12px rgba(0, 0, 0, 0.03)'
                }
              },
                // Loading skeleton for extended info
                loadingExtendedInfo && React.createElement('div', { className: 'space-y-4' },
                  // Section skeleton
                  React.createElement('div', { className: 'space-y-2' },
                    React.createElement('div', { className: 'h-3 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer w-16', style: { backgroundSize: '200% 100%' } }),
                    React.createElement('div', { className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer w-24', style: { backgroundSize: '200% 100%', animationDelay: '50ms' } })
                  ),
                  React.createElement('div', { className: 'space-y-2' },
                    React.createElement('div', { className: 'h-3 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer w-20', style: { backgroundSize: '200% 100%', animationDelay: '100ms' } }),
                    React.createElement('div', { className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer w-28', style: { backgroundSize: '200% 100%', animationDelay: '150ms' } })
                  ),
                  React.createElement('div', { className: 'space-y-2' },
                    React.createElement('div', { className: 'h-3 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer w-14', style: { backgroundSize: '200% 100%', animationDelay: '200ms' } }),
                    React.createElement('div', { className: 'flex gap-2' },
                      React.createElement('div', { className: 'h-6 w-6 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer', style: { backgroundSize: '200% 100%', animationDelay: '250ms' } }),
                      React.createElement('div', { className: 'h-6 w-6 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer', style: { backgroundSize: '200% 100%', animationDelay: '300ms' } }),
                      React.createElement('div', { className: 'h-6 w-6 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer', style: { backgroundSize: '200% 100%', animationDelay: '350ms' } })
                    )
                  )
                ),

                // Artist Info content
                !loadingExtendedInfo && artistExtendedInfo && artistExtendedInfo !== false && React.createElement('div', { className: 'space-y-3' },
                  // Founded date
                  artistExtendedInfo.foundedDate && React.createElement('div', null,
                    React.createElement('div', {
                      style: {
                        fontSize: '10px',
                        fontWeight: '600',
                        color: '#9ca3af',
                        textTransform: 'uppercase',
                        letterSpacing: '0.05em',
                        marginBottom: '2px'
                      }
                    }, artistExtendedInfo.type === 'Person' ? 'Born' : 'Founded'),
                    React.createElement('div', {
                      style: {
                        fontSize: '13px',
                        fontWeight: '500',
                        color: '#1f2937',
                        lineHeight: '1.35'
                      }
                    },
                      (() => {
                        const date = artistExtendedInfo.foundedDate;
                        if (date.length === 4) return date; // Just year
                        if (date.length === 7) {
                          const [year, month] = date.split('-');
                          const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                          return `${monthNames[parseInt(month) - 1]} ${year}`;
                        }
                        // Full date
                        const d = new Date(date);
                        return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                      })()
                    )
                  ),

                  // Founded In / Origin
                  artistExtendedInfo.foundedIn && React.createElement('div', null,
                    React.createElement('div', {
                      style: {
                        fontSize: '10px',
                        fontWeight: '600',
                        color: '#9ca3af',
                        textTransform: 'uppercase',
                        letterSpacing: '0.05em',
                        marginBottom: '2px'
                      }
                    }, artistExtendedInfo.type === 'Person' ? 'From' : 'Origin'),
                    React.createElement('div', {
                      style: {
                        fontSize: '13px',
                        fontWeight: '500',
                        color: '#1f2937',
                        lineHeight: '1.35'
                      }
                    }, artistExtendedInfo.foundedIn)
                  ),

                  // Status (active/disbanded)
                  artistExtendedInfo.type === 'Group' && React.createElement('div', null,
                    React.createElement('div', {
                      style: {
                        fontSize: '10px',
                        fontWeight: '600',
                        color: '#9ca3af',
                        textTransform: 'uppercase',
                        letterSpacing: '0.05em',
                        marginBottom: '2px'
                      }
                    }, 'Status'),
                    React.createElement('div', {
                      style: {
                        fontSize: '13px',
                        fontWeight: '500',
                        color: artistExtendedInfo.isActive ? '#16a34a' : '#6b7280',
                        lineHeight: '1.35'
                      }
                    }, artistExtendedInfo.isActive ? 'Active' : `Disbanded${artistExtendedInfo.endedDate ? ` (${artistExtendedInfo.endedDate.split('-')[0]})` : ''}`)
                  ),

                  // Official Homepage
                  artistExtendedInfo.urls.officialHomepage && React.createElement('div', null,
                    React.createElement('div', {
                      style: {
                        fontSize: '10px',
                        fontWeight: '600',
                        color: '#9ca3af',
                        textTransform: 'uppercase',
                        letterSpacing: '0.05em',
                        marginBottom: '2px'
                      }
                    }, 'Website'),
                    React.createElement('a', {
                      href: artistExtendedInfo.urls.officialHomepage,
                      target: '_blank',
                      rel: 'noopener noreferrer',
                      style: {
                        fontSize: '12px',
                        fontWeight: '500',
                        color: '#9333ea',
                        display: 'block',
                        overflow: 'hidden',
                        textOverflow: 'ellipsis',
                        whiteSpace: 'nowrap',
                        textDecoration: 'none'
                      },
                      title: artistExtendedInfo.urls.officialHomepage,
                      onMouseEnter: (e) => e.currentTarget.style.color = '#7e22ce',
                      onMouseLeave: (e) => e.currentTarget.style.color = '#9333ea'
                    }, new URL(artistExtendedInfo.urls.officialHomepage).hostname.replace(/^www\./, ''))
                  ),

                  // Social Media Links
                  (artistExtendedInfo.urls.twitter || artistExtendedInfo.urls.instagram || artistExtendedInfo.urls.facebook || artistExtendedInfo.urls.youtube) && React.createElement('div', { style: { paddingTop: '4px' } },
                    React.createElement('div', {
                      style: {
                        fontSize: '10px',
                        fontWeight: '600',
                        color: '#9ca3af',
                        textTransform: 'uppercase',
                        letterSpacing: '0.05em',
                        marginBottom: '6px'
                      }
                    }, 'Social'),
                    React.createElement('div', { style: { display: 'flex', flexWrap: 'wrap', gap: '6px' } },
                      // Twitter/X
                      artistExtendedInfo.urls.twitter && React.createElement('a', {
                        href: artistExtendedInfo.urls.twitter,
                        target: '_blank',
                        rel: 'noopener noreferrer',
                        style: {
                          width: '28px',
                          height: '28px',
                          borderRadius: '6px',
                          backgroundColor: '#f3f4f6',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          transition: 'background-color 150ms ease'
                        },
                        title: 'Twitter/X',
                        onMouseEnter: (e) => e.currentTarget.style.backgroundColor = '#e5e7eb',
                        onMouseLeave: (e) => e.currentTarget.style.backgroundColor = '#f3f4f6'
                      },
                        React.createElement('svg', { style: { width: '14px', height: '14px', color: '#4b5563' }, viewBox: '0 0 24 24', fill: 'currentColor' },
                          React.createElement('path', { d: 'M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z' })
                        )
                      ),
                      // Instagram
                      artistExtendedInfo.urls.instagram && React.createElement('a', {
                        href: artistExtendedInfo.urls.instagram,
                        target: '_blank',
                        rel: 'noopener noreferrer',
                        style: {
                          width: '28px',
                          height: '28px',
                          borderRadius: '6px',
                          backgroundColor: '#f3f4f6',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          transition: 'background-color 150ms ease'
                        },
                        title: 'Instagram',
                        onMouseEnter: (e) => e.currentTarget.style.backgroundColor = '#e5e7eb',
                        onMouseLeave: (e) => e.currentTarget.style.backgroundColor = '#f3f4f6'
                      },
                        React.createElement('svg', { style: { width: '14px', height: '14px', color: '#4b5563' }, viewBox: '0 0 24 24', fill: 'currentColor' },
                          React.createElement('path', { d: 'M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z' })
                        )
                      ),
                      // Facebook
                      artistExtendedInfo.urls.facebook && React.createElement('a', {
                        href: artistExtendedInfo.urls.facebook,
                        target: '_blank',
                        rel: 'noopener noreferrer',
                        style: {
                          width: '28px',
                          height: '28px',
                          borderRadius: '6px',
                          backgroundColor: '#f3f4f6',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          transition: 'background-color 150ms ease'
                        },
                        title: 'Facebook',
                        onMouseEnter: (e) => e.currentTarget.style.backgroundColor = '#e5e7eb',
                        onMouseLeave: (e) => e.currentTarget.style.backgroundColor = '#f3f4f6'
                      },
                        React.createElement('svg', { style: { width: '14px', height: '14px', color: '#4b5563' }, viewBox: '0 0 24 24', fill: 'currentColor' },
                          React.createElement('path', { d: 'M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z' })
                        )
                      ),
                      // YouTube
                      artistExtendedInfo.urls.youtube && React.createElement('a', {
                        href: artistExtendedInfo.urls.youtube,
                        target: '_blank',
                        rel: 'noopener noreferrer',
                        style: {
                          width: '28px',
                          height: '28px',
                          borderRadius: '6px',
                          backgroundColor: '#f3f4f6',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          transition: 'background-color 150ms ease'
                        },
                        title: 'YouTube',
                        onMouseEnter: (e) => e.currentTarget.style.backgroundColor = '#e5e7eb',
                        onMouseLeave: (e) => e.currentTarget.style.backgroundColor = '#f3f4f6'
                      },
                        React.createElement('svg', { style: { width: '14px', height: '14px', color: '#4b5563' }, viewBox: '0 0 24 24', fill: 'currentColor' },
                          React.createElement('path', { d: 'M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z' })
                        )
                      )
                    )
                  ),

                  // Members section (for Groups/Bands)
                  (artistExtendedInfo.members.current.length > 0 || artistExtendedInfo.members.former.length > 0) && React.createElement('div', {
                    style: {
                      paddingTop: '10px',
                      marginTop: '6px',
                      borderTop: '1px solid #f3f4f6'
                    }
                  },
                    // Current Members
                    artistExtendedInfo.members.current.length > 0 && React.createElement('div', { style: { marginBottom: '10px' } },
                      React.createElement('div', {
                        style: {
                          fontSize: '10px',
                          fontWeight: '600',
                          color: '#9ca3af',
                          textTransform: 'uppercase',
                          letterSpacing: '0.05em',
                          marginBottom: '6px'
                        }
                      }, 'Members'),
                      React.createElement('div', { style: { display: 'flex', flexDirection: 'column', gap: '3px' } },
                        artistExtendedInfo.members.current.map((member, idx) =>
                          React.createElement('div', {
                            key: member.mbid || idx,
                            style: {
                              fontSize: '12px',
                              fontWeight: '500',
                              color: '#374151',
                              lineHeight: '1.4'
                            }
                          },
                            member.name,
                            member.attributes.length > 0 && React.createElement('span', {
                              style: {
                                fontSize: '10px',
                                fontWeight: '400',
                                color: '#9ca3af',
                                marginLeft: '4px'
                              }
                            }, `(${member.attributes.join(', ')})`)
                          )
                        )
                      )
                    ),
                    // Former Members
                    artistExtendedInfo.members.former.length > 0 && React.createElement('div', null,
                      React.createElement('div', {
                        style: {
                          fontSize: '10px',
                          fontWeight: '600',
                          color: '#9ca3af',
                          textTransform: 'uppercase',
                          letterSpacing: '0.05em',
                          marginBottom: '6px'
                        }
                      }, 'Former'),
                      React.createElement('div', { style: { display: 'flex', flexDirection: 'column', gap: '3px' } },
                        artistExtendedInfo.members.former.map((member, idx) =>
                          React.createElement('div', {
                            key: member.mbid || idx,
                            style: {
                              fontSize: '12px',
                              fontWeight: '400',
                              color: '#6b7280',
                              lineHeight: '1.4'
                            }
                          },
                            member.name,
                            member.attributes.length > 0 && React.createElement('span', {
                              style: {
                                fontSize: '10px',
                                fontWeight: '400',
                                color: '#9ca3af',
                                marginLeft: '4px'
                              }
                            }, `(${member.attributes.join(', ')})`)
                          )
                        )
                      )
                    )
                  )
                ),

                // No extended info found
                !loadingExtendedInfo && artistExtendedInfo === false && React.createElement('div', {
                  style: {
                    fontSize: '11px',
                    color: '#9ca3af',
                    textAlign: 'center',
                    padding: '16px 0'
                  }
                }, 'No additional info available')
              )
            ),

            // RIGHT COLUMN: Biography
            React.createElement('div', { className: 'flex-1 min-w-0 max-w-2xl' },
              // Loading state - skeleton paragraphs
              loadingBio && React.createElement('div', { className: 'space-y-4' },
                // First paragraph skeleton (longer)
                React.createElement('div', { className: 'space-y-2' },
                  React.createElement('div', { className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer w-full', style: { backgroundSize: '200% 100%' } }),
                  React.createElement('div', { className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer w-full', style: { backgroundSize: '200% 100%', animationDelay: '50ms' } }),
                  React.createElement('div', { className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer w-11/12', style: { backgroundSize: '200% 100%', animationDelay: '100ms' } }),
                  React.createElement('div', { className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer w-4/5', style: { backgroundSize: '200% 100%', animationDelay: '150ms' } })
                ),
                // Second paragraph skeleton
                React.createElement('div', { className: 'space-y-2' },
                  React.createElement('div', { className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer w-full', style: { backgroundSize: '200% 100%', animationDelay: '200ms' } }),
                  React.createElement('div', { className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer w-full', style: { backgroundSize: '200% 100%', animationDelay: '250ms' } }),
                  React.createElement('div', { className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer w-3/4', style: { backgroundSize: '200% 100%', animationDelay: '300ms' } })
                ),
                // Third paragraph skeleton (shorter)
                React.createElement('div', { className: 'space-y-2' },
                  React.createElement('div', { className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer w-full', style: { backgroundSize: '200% 100%', animationDelay: '350ms' } }),
                  React.createElement('div', { className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer w-2/3', style: { backgroundSize: '200% 100%', animationDelay: '400ms' } })
                )
              ),
              // Bio content (artistBio is an object when bio exists)
              !loadingBio && artistBio && artistBio !== false && React.createElement('div', { className: 'space-y-4' },
                React.createElement('div', {
                  className: 'text-sm text-gray-700 leading-relaxed whitespace-pre-wrap'
                }, artistBio.bio),
                // Source attribution and link
                React.createElement('div', { className: 'flex items-center gap-2 mt-4' },
                  React.createElement('span', {
                    className: 'text-xs text-gray-400'
                  }, `From ${artistBio.source === 'wikipedia' ? 'Wikipedia' : artistBio.source === 'discogs' ? 'Discogs' : 'Last.fm'}`),
                  artistBio.url && React.createElement('a', {
                    href: artistBio.url,
                    target: '_blank',
                    rel: 'noopener noreferrer',
                    className: 'text-purple-600 hover:text-purple-700 text-sm'
                  }, 'Read more â†’')
                )
              ),
              // No bio found (artistBio === false means we fetched but found nothing)
              !loadingBio && artistBio === false && React.createElement('div', {
                className: 'text-center py-12 text-gray-400'
              }, 'No biography available for this artist.')
            )
          ),

          // RELATED ARTISTS TAB
          artistPageTab === 'related' && (() => {
            // Compute source counts for filter pills
            const listenbrainzCount = relatedArtists.filter(a => a.source === 'listenbrainz').length;
            const lastfmCount = relatedArtists.filter(a => a.source === 'lastfm').length;
            const bothCount = relatedArtists.filter(a => a.source === 'both').length;
            // Show filter bar when both services have data OR when configured (MBID available for ListenBrainz, API key for Last.fm)
            const hasBothServicesConfigured = !!currentArtist?.mbid && !!lastfmApiKey.current;

            // Filter artists based on source filter
            const filteredArtists = relatedArtistsSourceFilter === 'all'
              ? relatedArtists
              : relatedArtists.filter(a =>
                  relatedArtistsSourceFilter === 'both'
                    ? a.source === 'both'
                    : a.source === relatedArtistsSourceFilter || a.source === 'both'
                );

            return React.createElement('div', null,
              // Sticky filter bar - show when both services are configured
              hasBothServicesConfigured && React.createElement('div', {
                className: 'sticky top-0 z-10 flex items-center px-6 py-3 bg-white border-b border-gray-200'
              },
                React.createElement('div', { className: 'flex gap-2' },
                  [
                    { value: 'all', label: 'All', count: relatedArtists.length },
                    { value: 'listenbrainz', label: 'ListenBrainz', count: listenbrainzCount + bothCount },
                    { value: 'lastfm', label: 'Last.fm', count: lastfmCount + bothCount },
                    { value: 'both', label: 'Both', count: bothCount }
                  ].filter(({ value, count }) => value === 'all' || count > 0).map(({ value, label, count }) =>
                    React.createElement('button', {
                      key: value,
                      onClick: () => setRelatedArtistsSourceFilter(value),
                      className: `px-3 py-1.5 rounded-full text-sm transition-all no-drag ${
                        relatedArtistsSourceFilter === value
                          ? value === 'listenbrainz' ? 'bg-orange-500 text-white'
                            : value === 'lastfm' ? 'bg-red-600 text-white'
                            : value === 'both' ? 'bg-gradient-to-r from-orange-500 to-red-600 text-white'
                            : 'bg-purple-600 text-white'
                          : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                      }`
                    }, loadingRelated ? label : `${label} (${count})`)
                  )
                )
              ),
              // Content with padding
              React.createElement('div', { className: 'p-6' },
                // Loading state - skeleton grid with square card style
                loadingRelated && React.createElement('div', {
                  className: 'grid gap-4',
                  style: { gridTemplateColumns: 'repeat(auto-fill, minmax(160px, 1fr))' }
                },
                  Array.from({ length: 12 }).map((_, i) =>
                    React.createElement('div', { key: `skeleton-${i}`, className: 'bg-white rounded-lg overflow-hidden' },
                      React.createElement('div', {
                        className: 'aspect-square bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                        style: { backgroundSize: '200% 100%', animationDelay: `${i * 50}ms` }
                      }),
                      React.createElement('div', { className: 'p-3' },
                        React.createElement('div', {
                          className: 'w-3/4 h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer rounded',
                          style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 25}ms` }
                        })
                      )
                    )
                  )
                ),
                // Related artists grid (sorted by match, highest first) - Square card design
                !loadingRelated && filteredArtists.length > 0 && React.createElement('div', {
                  className: 'grid gap-4',
                  style: { gridTemplateColumns: 'repeat(auto-fill, minmax(160px, 1fr))' }
                },
                  [...filteredArtists].sort((a, b) => b.match - a.match).map((artist, index) => {
                    const relatedPattern = generateArtistPattern(artist.name);
                    return React.createElement('div', {
                      key: artist.name,
                      className: 'bg-white rounded-lg overflow-hidden hover:shadow-lg transition-shadow cursor-pointer group release-card card-fade-up',
                      style: { animationDelay: `${Math.min(index * 30, 300)}ms` },
                      draggable: true,
                      onDragStart: (e) => {
                        e.dataTransfer.effectAllowed = 'copy';
                        e.dataTransfer.setData('text/plain', JSON.stringify({
                          type: 'artist',
                          artist: {
                            id: artist.name.toLowerCase().replace(/[^a-z0-9]/g, '-'),
                            name: artist.name,
                            image: artist.image
                          }
                        }));
                      },
                      onClick: () => fetchArtistData(artist.name),
                      onContextMenu: (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        if (window.electron?.contextMenu?.showTrackMenu) {
                          window.electron.contextMenu.showTrackMenu({
                            type: 'artist',
                            artist: {
                              id: artist.name.toLowerCase().replace(/[^a-z0-9]/g, '-'),
                              name: artist.name,
                              image: artist.image
                            }
                          });
                        }
                      }
                    },
                      // Square image container - gray while loading, pattern only when imageLoaded && no image
                      React.createElement('div', {
                        className: 'aspect-square relative group/art',
                        style: { background: artist.imageLoaded && !artist.image ? relatedPattern.gradient : '#e5e7eb' }
                      },
                        // Shimmer while loading (imageLoaded not yet true)
                        !artist.imageLoaded && React.createElement('div', {
                          className: 'absolute inset-0 bg-gradient-to-r from-gray-300 via-gray-200 to-gray-300 animate-shimmer',
                          style: { backgroundSize: '200% 100%' }
                        }),
                        // Initials fallback (only show when imageLoaded && no image)
                        artist.imageLoaded && !artist.image && React.createElement('div', {
                          className: 'absolute inset-0 flex items-center justify-center',
                          style: { color: relatedPattern.textColor, opacity: 0.4 }
                        },
                          React.createElement('span', {
                            className: 'font-bold tracking-wider',
                            style: { fontSize: '2.5rem', textShadow: '0 2px 8px rgba(0,0,0,0.3)' }
                          }, relatedPattern.initials)
                        ),
                        // Image (fades in on load)
                        artist.image && React.createElement('img', {
                          src: artist.image,
                          alt: artist.name,
                          className: 'absolute inset-0 w-full h-full object-cover transition-all duration-300 group-hover/art:scale-105',
                          style: { opacity: 0 },
                          ref: (el) => { if (el && el.complete && el.naturalWidth > 0) el.style.opacity = '1'; },
                          onLoad: (e) => { e.target.style.opacity = '1'; },
                          onError: (e) => { e.target.style.display = 'none'; }
                        }),
                        // Hover overlay with action buttons (Play, Queue) - Top 10 icons
                        React.createElement('div', {
                          className: 'absolute inset-0 bg-black/50 opacity-0 group-hover/art:opacity-100 transition-opacity duration-200 flex items-center justify-center gap-3',
                          style: { pointerEvents: 'auto' }
                        },
                          // Play top 10 button (center, larger)
                          React.createElement('button', {
                            onClick: async (e) => {
                              e.stopPropagation();
                              setTrackLoading(true);
                              const tracks = await getArtistTopTracks(artist.name);
                              if (tracks.length > 0) {
                                const context = { type: 'artist', name: artist.name };
                                const [firstTrack, ...remainingTracks] = tracks;
                                // Tag the first track with context so queue navigation works correctly
                                const taggedFirstTrack = { ...firstTrack, _playbackContext: context };
                                setQueueWithContext(remainingTracks, context);
                                handlePlay(taggedFirstTrack);
                              } else {
                                setTrackLoading(false);
                                showToast(`No top tracks found for ${artist.name}`, 'error');
                              }
                            },
                            className: 'w-12 h-12 bg-white rounded-full flex items-center justify-center shadow-lg transition-all hover:scale-110',
                            style: { border: 'none', cursor: 'pointer' },
                            title: 'Play top 10 tracks'
                          },
                            React.createElement(PlayTop10Icon, { size: 26, className: 'text-gray-800' })
                          ),
                          // Add top 10 to Queue button
                          React.createElement('button', {
                            onClick: async (e) => {
                              e.stopPropagation();
                              const tracks = await getArtistTopTracks(artist.name);
                              if (tracks.length > 0) {
                                addToQueue(tracks, { type: 'artist', name: artist.name });
                                showToast(`Added ${tracks.length} tracks from ${artist.name}`, 'success');
                              } else {
                                showToast(`No top tracks found for ${artist.name}`, 'error');
                              }
                            },
                            className: 'w-10 h-10 rounded-full flex items-center justify-center transition-all hover:scale-110',
                            style: { backgroundColor: 'rgba(255, 255, 255, 0.15)', color: '#ffffff', border: 'none', cursor: 'pointer' },
                            onMouseEnter: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.25)',
                            onMouseLeave: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.15)',
                            title: 'Add top 10 to queue'
                          },
                            React.createElement(QueueTop10Icon, { size: 20 })
                          )
                        )
                      ),
                      // Artist name section
                      React.createElement('div', { className: 'p-3' },
                        React.createElement('p', {
                          className: 'font-medium text-gray-900 truncate text-sm transition-colors'
                        }, artist.name)
                      )
                    );
                  })
                ),
                // No related artists found (or filtered to none)
                !loadingRelated && filteredArtists.length === 0 && React.createElement('div', {
                  className: 'text-center py-12 text-gray-400'
                }, relatedArtists.length === 0
                  ? 'No related artists found.'
                  : `No artists from ${relatedArtistsSourceFilter === 'listenbrainz' ? 'ListenBrainz' : relatedArtistsSourceFilter === 'lastfm' ? 'Last.fm' : 'both sources'}.`
                )
              )
            );
          })()
        )
      )
      
      // Main content area - Playlist Page loading state (waiting for playlist to be resolved)
      : activeView === 'playlist-view' && !selectedPlaylist ? React.createElement('div', {
        className: 'flex-1 flex flex-col',
        style: { overflow: 'hidden' }
      },
        // Hero header with pending playlist title (real header, not skeleton)
        React.createElement('div', {
          className: 'relative',
          style: {
            height: '140px',
            flexShrink: 0,
            overflow: 'hidden'
          }
        },
          // Gradient background (same as loaded state)
          React.createElement('div', {
            className: 'absolute inset-0',
            style: {
              backgroundImage: 'linear-gradient(to bottom right, #f43f5e, #ec4899, #c026d3)',
              backgroundSize: 'cover',
              backgroundPosition: 'center',
              filter: 'blur(20px) brightness(0.7)',
              transform: 'scale(1.2)'
            }
          }),
          // Gradient overlay
          React.createElement('div', {
            className: 'absolute inset-0',
            style: {
              background: 'linear-gradient(to bottom, rgba(0,0,0,0.3) 0%, rgba(17,17,17,0.95) 100%)'
            }
          }),
          // Header content with title
          React.createElement('div', {
            className: 'absolute inset-0 flex items-center px-8 z-10'
          },
            // Playlist icon
            React.createElement('div', {
              className: 'w-6 h-6 rounded-full bg-white/20 flex items-center justify-center mr-3'
            },
              React.createElement('svg', { className: 'w-3 h-3 text-white', fill: 'currentColor', viewBox: '0 0 24 24' },
                React.createElement('circle', { cx: '12', cy: '12', r: '10' })
              )
            ),
            // Playlist name from pending load
            React.createElement('h1', {
              className: 'text-2xl font-bold text-white',
              style: {
                textShadow: '0 2px 10px rgba(0,0,0,0.5)',
                letterSpacing: '0.1em',
                textTransform: 'uppercase'
              }
            }, pendingPlaylistLoad?.title || 'Loading...')
          )
        ),
        // Content area with sticky bar and loading skeletons
        React.createElement('div', {
          className: 'scrollable-content bg-white',
          style: {
            flex: 1,
            overflowY: 'scroll',
            pointerEvents: 'auto'
          }
        },
          // PLAYLIST DETAILS sticky bar with breadcrumb (same as loaded state)
          React.createElement('div', {
            className: 'flex items-center justify-between px-6 py-4 border-b border-gray-200'
          },
            // Breadcrumb navigation: Playlists > Playlist Name
            React.createElement('div', {
              className: 'flex items-center gap-2 text-xs font-medium tracking-widest uppercase'
            },
              React.createElement('button', {
                onClick: () => {
                  setPendingPlaylistLoad(null);
                  setActiveView('playlists');
                  setViewHistory(['library', 'playlists']);
                },
                className: 'text-gray-400 hover:text-gray-600 transition-colors uppercase'
              }, 'Playlists'),
              React.createElement('span', { className: 'text-gray-300' }, '/'),
              React.createElement('span', { className: 'text-gray-600 uppercase' },
                pendingPlaylistLoad?.title || 'Loading'
              )
            ),
            // Close button
            React.createElement('button', {
              onClick: () => {
                setPendingPlaylistLoad(null);
                setActiveView('playlists');
                setViewHistory(['library', 'playlists']);
              },
              className: 'flex items-center gap-1 px-3 py-1 text-xs text-gray-500 hover:text-gray-700 border border-gray-300 rounded hover:bg-gray-50 transition-colors no-drag'
            },
              'CLOSE',
              React.createElement('span', { className: 'text-gray-400' }, 'Ã—')
            )
          ),
          // Loading content placeholder
          React.createElement('div', { className: 'flex gap-0 p-6' },
            // LEFT COLUMN: Skeleton album art and metadata
            React.createElement('div', {
              className: 'flex-shrink-0 pr-8',
              style: { width: '240px' }
            },
              // Skeleton 2x2 album art grid
              React.createElement('div', {
                className: 'grid grid-cols-2 gap-0.5 rounded-lg overflow-hidden mb-4',
                style: { width: '192px', height: '192px' }
              },
                Array.from({ length: 4 }).map((_, i) =>
                  React.createElement('div', {
                    key: `cover-skeleton-${i}`,
                    className: 'aspect-square bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                    style: { backgroundSize: '200% 100%', animationDelay: `${i * 50}ms` }
                  })
                )
              ),
              // Skeleton metadata
              React.createElement('div', { className: 'mt-4 space-y-2' },
                React.createElement('div', {
                  className: 'h-5 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-40 animate-shimmer',
                  style: { backgroundSize: '200% 100%' }
                }),
                React.createElement('div', {
                  className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-32 animate-shimmer',
                  style: { backgroundSize: '200% 100%', animationDelay: '100ms' }
                }),
                React.createElement('div', {
                  className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-24 animate-shimmer',
                  style: { backgroundSize: '200% 100%', animationDelay: '200ms' }
                })
              )
            ),
            // RIGHT COLUMN: Skeleton track list
            React.createElement('div', { className: 'flex-1 min-w-0 space-y-2' },
              Array.from({ length: 8 }).map((_, i) =>
                React.createElement('div', {
                  key: `track-skeleton-${i}`,
                  className: 'flex items-center gap-4 py-2 px-3'
                },
                  React.createElement('div', {
                    className: 'w-8 h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer',
                    style: { backgroundSize: '200% 100%', animationDelay: `${i * 30}ms` }
                  }),
                  React.createElement('div', {
                    className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer',
                    style: { width: '200px', backgroundSize: '200% 100%', animationDelay: `${i * 30 + 15}ms` }
                  }),
                  React.createElement('div', {
                    className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer',
                    style: { width: '120px', backgroundSize: '200% 100%', animationDelay: `${i * 30 + 30}ms` }
                  }),
                  React.createElement('div', { className: 'flex-1' }),
                  React.createElement('div', {
                    className: 'w-10 h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer',
                    style: { backgroundSize: '200% 100%', animationDelay: `${i * 30 + 45}ms` }
                  })
                )
              )
            )
          )
        )
      )

      // Main content area - Playlist Page (new design matching album page layout)
      : activeView === 'playlist-view' && selectedPlaylist ? React.createElement('div', {
        className: 'flex-1 flex flex-col',
        style: { overflow: 'hidden' }
      },
        // Playlist hero header (similar to Playlists main page)
        React.createElement('div', {
          className: 'relative',
          style: {
            height: '140px',
            flexShrink: 0,
            overflow: 'hidden'
          }
        },
          // Background with first album art or gradient
          React.createElement('div', {
            className: 'absolute inset-0',
            style: {
              backgroundImage: playlistCoverArt[0]
                ? `url(${playlistCoverArt[0]})`
                : 'linear-gradient(to bottom right, #f43f5e, #ec4899, #c026d3)',
              backgroundSize: 'cover',
              backgroundPosition: 'center',
              filter: 'blur(20px) brightness(0.7)',
              transform: 'scale(1.2)'
            }
          }),
          // Gradient overlay
          React.createElement('div', {
            className: 'absolute inset-0',
            style: {
              background: 'linear-gradient(to bottom, rgba(0,0,0,0.3) 0%, rgba(17,17,17,0.95) 100%)'
            }
          }),
          // Header content
          React.createElement('div', {
            className: 'absolute inset-0 flex items-center px-8 z-10'
          },
            // Playlist icon
            React.createElement('div', {
              className: 'w-6 h-6 rounded-full bg-white/20 flex items-center justify-center mr-3'
            },
              React.createElement('svg', { className: 'w-3 h-3 text-white', fill: 'currentColor', viewBox: '0 0 24 24' },
                React.createElement('circle', { cx: '12', cy: '12', r: '10' })
              )
            ),
            // Playlist name
            React.createElement('h1', {
              className: 'text-2xl font-bold text-white',
              style: {
                textShadow: '0 2px 10px rgba(0,0,0,0.5)',
                letterSpacing: '0.1em',
                textTransform: 'uppercase'
              }
            }, selectedPlaylist.title)
          )
        ),

        // Playlist content (scrollable) - white background with new layout
        React.createElement('div', {
          ref: (el) => {
            playlistScrollContainerRef.current = el;
            if (el && !playlistScrollContainerReady) {
              setPlaylistScrollContainerReady(true);
            }
          },
          className: 'scrollable-content bg-white',
          style: {
            flex: 1,
            overflowY: 'scroll',
            pointerEvents: 'auto'
          }
        },
          // PLAYLIST DETAILS section header with breadcrumb and Edit buttons
          React.createElement('div', {
            className: 'flex items-center justify-between px-6 py-4 border-b border-gray-200'
          },
            // Breadcrumb navigation: Playlists > Playlist Name
            React.createElement('div', {
              className: 'flex items-center gap-2 text-xs font-medium tracking-widest uppercase'
            },
              React.createElement('button', {
                onClick: () => {
                  if (playlistEditMode) {
                    setPlaylistEditMode(false);
                    setEditedPlaylistData(null);
                  }
                  setSelectedPlaylist(null);
                  setPlaylistTracks([]);
                  setPlaylistCoverArt([]);
                  navigateTo('playlists');
                },
                className: 'text-gray-400 hover:text-gray-600 transition-colors uppercase'
              }, 'Playlists'),
              React.createElement('span', { className: 'text-gray-300' }, '/'),
              React.createElement('span', { className: 'text-gray-600 uppercase' },
                playlistEditMode ? 'Editing' : (selectedPlaylist.title || 'Playlist Details')
              )
            ),
            React.createElement('div', { className: 'flex items-center gap-2' },
              // Edit / Cancel+Done buttons
              playlistEditMode ? React.createElement(React.Fragment, null,
                // Cancel button
                React.createElement('button', {
                  onClick: () => {
                    setPlaylistEditMode(false);
                    setEditedPlaylistData(null);
                  },
                  className: 'flex items-center gap-1 px-3 py-1 text-xs text-gray-500 hover:text-gray-700 border border-gray-300 rounded hover:bg-gray-50 transition-colors no-drag'
                }, 'CANCEL'),
                // Done button
                React.createElement('button', {
                  onClick: async () => {
                    if (editedPlaylistData) {
                      const updated = {
                        ...selectedPlaylist,
                        title: editedPlaylistData.title,
                        creator: editedPlaylistData.creator,
                        tracks: editedPlaylistData.tracks,
                        lastModified: Date.now()
                      };
                      setSelectedPlaylist(updated);
                      setPlaylistTracks(editedPlaylistData.tracks);
                      setPlaylists(prev => prev.map(p => p.id === updated.id ? updated : p));
                      await savePlaylistToStore(updated);
                      // Mark synced playlist as locally modified
                      markPlaylistAsLocallyModified(updated.id);
                    }
                    setPlaylistEditMode(false);
                    setEditedPlaylistData(null);
                  },
                  className: 'flex items-center gap-1 px-3 py-1 text-xs text-white bg-fuchsia-600 hover:bg-fuchsia-700 rounded transition-colors no-drag'
                }, 'DONE')
              ) : React.createElement('button', {
                onClick: () => {
                  setPlaylistEditMode(true);
                  setEditedPlaylistData({
                    title: selectedPlaylist.title,
                    creator: selectedPlaylist.creator || '',
                    tracks: [...playlistTracks]
                  });
                },
                className: 'flex items-center gap-1 px-3 py-1 text-xs text-gray-500 hover:text-gray-700 border border-gray-300 rounded hover:bg-gray-50 transition-colors no-drag'
              }, 'EDIT'),
              // Close button (hidden in edit mode since Cancel serves that purpose)
              !playlistEditMode && React.createElement('button', {
                onClick: () => {
                  setSelectedPlaylist(null);
                  setPlaylistTracks([]);
                  setPlaylistCoverArt([]);
                  navigateTo('playlists');
                },
                className: 'flex items-center gap-1 px-3 py-1 text-xs text-gray-500 hover:text-gray-700 border border-gray-300 rounded hover:bg-gray-50 transition-colors no-drag'
              },
                'CLOSE',
                React.createElement('span', { className: 'text-gray-400' }, 'Ã—')
              )
            )
          ),

          // Playlist update banner (shown when playlist has updates from sync source)
          selectedPlaylist?.hasUpdates && React.createElement('div', {
            className: 'mx-4 mb-4 overflow-hidden rounded-lg',
            style: {
              background: 'linear-gradient(135deg, rgba(147, 51, 234, 0.12) 0%, rgba(168, 85, 247, 0.08) 100%)',
              border: '1px solid rgba(147, 51, 234, 0.25)',
              boxShadow: '0 2px 8px rgba(147, 51, 234, 0.08)'
            }
          },
            React.createElement('div', {
              className: 'flex items-center justify-between px-4 py-3'
            },
              // Left side: icon + message
              React.createElement('div', { className: 'flex items-center gap-3' },
                // Animated sync icon
                React.createElement('div', {
                  className: 'flex items-center justify-center w-8 h-8 rounded-full',
                  style: {
                    background: 'linear-gradient(135deg, rgba(147, 51, 234, 0.2) 0%, rgba(168, 85, 247, 0.15) 100%)'
                  }
                },
                  React.createElement('svg', {
                    className: 'w-4 h-4 text-purple-600',
                    fill: 'none',
                    stroke: 'currentColor',
                    viewBox: '0 0 24 24',
                    style: { animation: 'spin 3s linear infinite' }
                  },
                    React.createElement('path', {
                      strokeLinecap: 'round',
                      strokeLinejoin: 'round',
                      strokeWidth: 2,
                      d: 'M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15'
                    })
                  )
                ),
                // Text content
                React.createElement('div', { className: 'flex flex-col' },
                  React.createElement('span', {
                    className: 'text-xs font-medium tracking-widest uppercase text-purple-500'
                  }, 'Sync Available'),
                  React.createElement('span', {
                    className: 'text-sm text-gray-600'
                  }, `Updated on ${selectedPlaylist.syncedFrom?.resolver || 'the source'}`)
                )
              ),
              // Right side: action buttons
              React.createElement('div', { className: 'flex items-center gap-2' },
                React.createElement('button', {
                  onClick: async () => {
                    const updatedPlaylist = { ...selectedPlaylist, hasUpdates: false };
                    setPlaylists(prev => prev.map(p =>
                      p.id === selectedPlaylist.id ? { ...p, hasUpdates: false } : p
                    ));
                    setSelectedPlaylist(prev => ({ ...prev, hasUpdates: false }));
                    await savePlaylistToStore(updatedPlaylist);
                  },
                  className: 'px-3 py-1.5 text-xs font-medium text-gray-500 hover:text-gray-700 transition-colors'
                }, 'Dismiss'),
                React.createElement('button', {
                  onClick: async () => {
                    // Fetch updated tracks from sync source
                    const provider = selectedPlaylist.syncedFrom?.resolver;
                    const externalId = selectedPlaylist.syncedFrom?.externalId;
                    if (provider && externalId) {
                      try {
                        const result = await window.electron.sync.fetchPlaylistTracks?.(provider, externalId);
                        if (result?.success && result.tracks) {
                          // Update playlist with new tracks and clear hasUpdates
                          const updatedPlaylist = {
                            ...selectedPlaylist,
                            tracks: result.tracks,
                            hasUpdates: false,
                            syncedFrom: {
                              ...selectedPlaylist.syncedFrom,
                              snapshotId: result.snapshotId
                            },
                            lastModified: Date.now()
                          };
                          setSelectedPlaylist(updatedPlaylist);
                          setPlaylistTracks(result.tracks);
                          setPlaylists(prev => prev.map(p =>
                            p.id === selectedPlaylist.id ? updatedPlaylist : p
                          ));
                          await savePlaylistToStore(updatedPlaylist);
                        }
                      } catch (err) {
                        console.error('Failed to fetch playlist updates:', err);
                      }
                    }
                  },
                  className: 'flex items-center gap-1.5 px-4 py-1.5 bg-purple-600 text-white text-xs font-medium rounded-full hover:bg-purple-700 transition-colors',
                  style: { boxShadow: '0 2px 8px rgba(147, 51, 234, 0.3)' }
                },
                  React.createElement('svg', {
                    className: 'w-3.5 h-3.5',
                    fill: 'none',
                    stroke: 'currentColor',
                    viewBox: '0 0 24 24'
                  },
                    React.createElement('path', {
                      strokeLinecap: 'round',
                      strokeLinejoin: 'round',
                      strokeWidth: 2,
                      d: 'M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4'
                    })
                  ),
                  'Sync Now'
                )
              )
            )
          ),

          // Two-column layout: playlist cover + metadata on left, tracklist on right
          React.createElement('div', { className: 'flex gap-0 p-6' },
            // LEFT COLUMN: 2x2 album art grid and metadata
            React.createElement('div', {
              className: 'flex-shrink-0 pr-8',
              style: { width: '240px' }
            },
              // Playlist card - matches playlist card style from grid view
              (() => {
                const covers = allPlaylistCovers[selectedPlaylist?.id] || playlistCoverArt || [];
                const hasCachedCovers = covers.length > 0;

                return React.createElement('div', {
                  style: {
                    padding: '10px',
                    borderRadius: '10px',
                    backgroundColor: '#ffffff',
                    boxShadow: '0 1px 3px rgba(0, 0, 0, 0.05), 0 4px 12px rgba(0, 0, 0, 0.03)',
                    width: 'fit-content'
                  }
                },
                  // Album art mosaic with hover overlay
                  React.createElement('div', {
                    className: 'rounded-lg overflow-hidden album-art-container group/art relative',
                    style: {
                      width: '192px',
                      height: '192px'
                    }
                  },
                    hasCachedCovers ?
                      React.createElement('div', { className: 'grid grid-cols-2 grid-rows-2 w-full h-full' },
                        [0, 1, 2, 3].map(idx => {
                          return React.createElement('div', {
                            key: idx,
                            className: 'relative w-full h-full flex items-center justify-center',
                            style: { background: 'linear-gradient(145deg, #1f1f1f 0%, #2d2d2d 50%, #1a1a1a 100%)' }
                          },
                            !covers[idx] && React.createElement(Music, { size: 20, className: 'text-gray-600' }),
                            covers[idx] && React.createElement('img', {
                              src: covers[idx],
                              alt: '',
                              className: 'absolute inset-0 w-full h-full object-cover transition-opacity duration-300',
                              style: { opacity: 0 },
                              ref: (el) => { if (el && el.complete && el.naturalWidth > 0) el.style.opacity = '1'; },
                              onLoad: (e) => { e.target.style.opacity = '1'; }
                            })
                          );
                        })
                      )
                    :
                      React.createElement('div', {
                        className: 'w-full h-full flex items-center justify-center',
                        style: { background: 'linear-gradient(145deg, #1f1f1f 0%, #2d2d2d 50%, #1a1a1a 100%)' }
                      },
                        // Playlist icon (three lines with play triangle)
                        React.createElement('svg', { className: 'w-12 h-12 text-gray-500', viewBox: '0 0 24 24', fill: 'currentColor' },
                          React.createElement('rect', { x: 3, y: 5, width: 18, height: 2, rx: 1 }),
                          React.createElement('rect', { x: 3, y: 11, width: 10, height: 2, rx: 1 }),
                          React.createElement('rect', { x: 3, y: 17, width: 7, height: 2, rx: 1 }),
                          React.createElement('path', { d: 'M15 13.5v6l5.5-3-5.5-3z' })
                        )
                      ),
                    // Hover overlay with action buttons
                    React.createElement('div', {
                      className: 'absolute inset-0 bg-black/50 opacity-0 group-hover/art:opacity-100 transition-opacity duration-200 flex items-center justify-center gap-3',
                      style: { pointerEvents: 'auto' }
                    },
                      // Add to Playlist button
                      React.createElement('button', {
                        onClick: (e) => {
                          e.stopPropagation();
                          const tracksWithIds = (playlistTracks || []).map(track => ({
                            ...track,
                            id: track.id || `${track.artist || 'unknown'}-${track.title || 'untitled'}`.toLowerCase().replace(/[^a-z0-9-]/g, ''),
                            sources: trackSources[track.id] || {}
                          }));
                          if (tracksWithIds.length > 0) {
                            setAddToPlaylistPanel({
                              open: true,
                              tracks: tracksWithIds,
                              sourceName: selectedPlaylist.title,
                              sourceType: 'playlist'
                            });
                            setSelectedPlaylistsForAdd([]);
                          }
                        },
                        className: 'w-10 h-10 rounded-full flex items-center justify-center transition-all hover:scale-110',
                        style: { backgroundColor: 'rgba(255, 255, 255, 0.15)', color: '#ffffff', border: 'none', cursor: 'pointer' },
                        onMouseEnter: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.25)',
                        onMouseLeave: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.15)',
                        title: 'Add to Playlist'
                      },
                        React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor', strokeWidth: 2 },
                          React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', d: 'M12 4v16m8-8H4' })
                        )
                      ),
                      // Play button (center, larger)
                      React.createElement('button', {
                        onClick: (e) => {
                          e.stopPropagation();
                          setTrackLoading(true);
                          const tracksWithIds = (playlistTracks || []).map(track => ({
                            ...track,
                            id: track.id || `${track.artist || 'unknown'}-${track.title || 'untitled'}`.toLowerCase().replace(/[^a-z0-9-]/g, ''),
                            sources: trackSources[track.id] || {}
                          }));
                          if (tracksWithIds.length > 0) {
                            const context = { type: 'playlist', id: selectedPlaylist.id, name: selectedPlaylist.title };
                            const [firstTrack, ...remainingTracks] = tracksWithIds;
                            const taggedFirstTrack = { ...firstTrack, _playbackContext: context };
                            setQueueWithContext(remainingTracks, context);
                            handlePlay(taggedFirstTrack);
                          } else {
                            setTrackLoading(false);
                          }
                        },
                        className: 'w-12 h-12 bg-white rounded-full flex items-center justify-center shadow-lg transition-all hover:scale-110',
                        style: { border: 'none', cursor: 'pointer' },
                        title: 'Play'
                      },
                        React.createElement(Play, { size: 22, className: 'text-gray-800 ml-0.5' })
                      ),
                      // Add to Queue button
                      React.createElement('button', {
                        onClick: (e) => {
                          e.stopPropagation();
                          const tracksWithIds = (playlistTracks || []).map(track => ({
                            ...track,
                            id: track.id || `${track.artist || 'unknown'}-${track.title || 'untitled'}`.toLowerCase().replace(/[^a-z0-9-]/g, ''),
                            sources: trackSources[track.id] || {}
                          }));
                          if (tracksWithIds.length > 0) {
                            const context = { type: 'playlist', id: selectedPlaylist.id, name: selectedPlaylist.title };
                            addToQueue(tracksWithIds, context);
                          }
                        },
                        className: 'w-10 h-10 rounded-full flex items-center justify-center transition-all hover:scale-110',
                        style: { backgroundColor: 'rgba(255, 255, 255, 0.15)', color: '#ffffff', border: 'none', cursor: 'pointer' },
                        onMouseEnter: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.25)',
                        onMouseLeave: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.15)',
                        title: 'Add to Queue'
                      },
                        React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor', strokeWidth: 2 },
                          React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', d: 'M4 6h16M4 12h16M4 18h7' })
                        )
                      )
                    )
                  ),
                  // Playlist title inside card - matching grid typography (13px/500)
                  React.createElement('div', {
                    className: 'truncate',
                    style: {
                      fontSize: '13px',
                      fontWeight: '500',
                      color: '#1f2937',
                      marginTop: '10px',
                      letterSpacing: '0.005em'
                    },
                    title: selectedPlaylist.title
                  }, selectedPlaylist.title),
                  // Track count - matching grid typography (11px)
                  React.createElement('div', {
                    className: 'truncate',
                    style: {
                      fontSize: '11px',
                      color: '#6b7280',
                      marginTop: '2px'
                    }
                  }, `${playlistTracks.length} Songs`)
                );
              })(),

              // Additional metadata below the card (author, edit mode inputs, dates, delete)
              React.createElement('div', { className: 'mt-3 space-y-1', style: { maxWidth: '212px' } },
                // Creator - editable for imported and hosted playlists in edit mode
                playlistEditMode && editedPlaylistData && (selectedPlaylist.id?.startsWith('imported-') || selectedPlaylist.sourceUrl)
                  ? React.createElement('input', {
                      type: 'text',
                      value: editedPlaylistData.creator,
                      onChange: (e) => setEditedPlaylistData(prev => ({ ...prev, creator: e.target.value })),
                      className: 'text-sm text-gray-500 bg-white border border-gray-300 rounded px-2 py-1 w-full focus:outline-none focus:ring-2 focus:ring-fuchsia-500 focus:border-transparent',
                      placeholder: 'Creator name'
                    })
                  : React.createElement('p', {
                      className: 'text-sm text-gray-500'
                    }, `Created by ${selectedPlaylist.creator || 'Unknown'}`),
                // Edit mode: Title input
                playlistEditMode && editedPlaylistData && React.createElement('input', {
                  type: 'text',
                  value: editedPlaylistData.title,
                  onChange: (e) => setEditedPlaylistData(prev => ({ ...prev, title: e.target.value })),
                  className: 'font-bold text-gray-900 text-sm leading-tight bg-white border border-gray-300 rounded px-2 py-1 w-full focus:outline-none focus:ring-2 focus:ring-fuchsia-500 focus:border-transparent',
                  placeholder: 'Playlist name'
                }),
                // Created date
                selectedPlaylist.createdAt && React.createElement('p', {
                  className: 'text-xs text-gray-400'
                }, `Created: ${new Date(selectedPlaylist.createdAt).toLocaleDateString()}`),
                // Last modified date
                selectedPlaylist.lastModified && React.createElement('p', {
                  className: 'text-xs text-gray-400'
                }, `Modified: ${new Date(selectedPlaylist.lastModified).toLocaleDateString()}`),
                // Delete Playlist button (only in edit mode)
                playlistEditMode && React.createElement('button', {
                  onClick: () => {
                    if (window.confirm(`Are you sure you want to delete "${selectedPlaylist.title}"? This cannot be undone.`)) {
                      // Delete the playlist
                      window.electron.playlists.delete(selectedPlaylist.id);
                      setPlaylists(prev => prev.filter(p => p.id !== selectedPlaylist.id));
                      // Clear cover cache for this playlist
                      delete playlistCoverCache.current[selectedPlaylist.id];
                      setAllPlaylistCovers(prev => {
                        const newCovers = { ...prev };
                        delete newCovers[selectedPlaylist.id];
                        return newCovers;
                      });
                      // Exit edit mode and navigate back
                      setPlaylistEditMode(false);
                      setEditedPlaylistData(null);
                      setSelectedPlaylist(null);
                      setPlaylistTracks([]);
                      setPlaylistCoverArt([]);
                      navigateTo('playlists');
                    }
                  },
                  className: 'mt-2 flex items-center gap-2 px-3 py-2 text-sm text-red-600 hover:text-red-700 border border-red-300 rounded hover:bg-red-50 transition-colors no-drag w-full justify-center'
                }, 'Delete Playlist')
              )
            ),

            // RIGHT COLUMN: Tracklist
            React.createElement('div', { className: 'flex-1 min-w-0' },
              // Use edited tracks when in edit mode, otherwise use playlistTracks
              (() => {
                const displayTracks = playlistEditMode && editedPlaylistData ? editedPlaylistData.tracks : playlistTracks;
                return displayTracks.length > 0 ?
                React.createElement('div', { className: 'space-y-0' },
                  displayTracks.map((track, index) => {
                    // Use track.id to look up resolved sources from trackSources state
                    const resolvedSources = trackSources[track.id] || track.sources || {};
                    const hasResolved = Object.keys(resolvedSources).length > 0;
                    const isResolving = Object.keys(resolvedSources).length === 0;
                    const isDraggedOver = playlistEditMode && playlistDropTarget === index;
                    const isDragging = playlistEditMode && draggedPlaylistTrack === index;
                    const isCurrentTrack = currentTrack?.id === track.id;
                    const isNowPlaying = isCurrentTrack && playbackContext?.type === 'playlist' && playbackContext?.id === selectedPlaylist?.id;

                    // Debug logging for first track only
                    if (index === 0) {
                      console.log('ðŸŽ¯ Playlist highlight check:', {
                        trackId: track.id,
                        currentTrackId: currentTrack?.id,
                        isCurrentTrack,
                        playbackContextType: playbackContext?.type,
                        playbackContextId: playbackContext?.id,
                        selectedPlaylistId: selectedPlaylist?.id,
                        isNowPlaying
                      });
                    }

                    return React.createElement('div', {
                      key: track.id || index,
                      'data-track-id': track.id,
                      ref: (el) => {
                        if (el && track.id) {
                          playlistTrackRowRefs.current.set(track.id, el);
                          if (playlistObserverRef.current) {
                            playlistObserverRef.current.observe(el);
                          }
                        } else if (track.id) {
                          playlistTrackRowRefs.current.delete(track.id);
                        }
                      },
                      draggable: true,
                      onDragStart: (e) => {
                        // Always allow dragging to other playlists
                        setDraggingTrackForPlaylist(track);
                        e.dataTransfer.effectAllowed = 'move';
                        e.dataTransfer.setData('text/plain', JSON.stringify({ type: 'track', track }));
                        // Only track index for reordering in edit mode
                        if (playlistEditMode) {
                          setDraggedPlaylistTrack(index);
                        }
                      },
                      onDragEnd: () => {
                        setDraggingTrackForPlaylist(null);
                        setDropTargetPlaylistId(null);
                        setDropTargetNewPlaylist(false);
                        if (playlistEditMode) {
                          setDraggedPlaylistTrack(null);
                          setPlaylistDropTarget(null);
                        }
                        // Close panel if it was opened by drag and nothing was dropped
                        if (addToPlaylistPanel.open && selectedPlaylistsForAdd.length === 0) {
                          setAddToPlaylistPanel(prev => ({ ...prev, open: false }));
                        }
                      },
                      onDragOver: playlistEditMode ? (e) => {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'move';
                        if (draggedPlaylistTrack !== null && draggedPlaylistTrack !== index) {
                          setPlaylistDropTarget(index);
                        }
                      } : undefined,
                      onDragLeave: playlistEditMode ? () => {
                        setPlaylistDropTarget(null);
                      } : undefined,
                      onDrop: playlistEditMode ? (e) => {
                        e.preventDefault();
                        if (draggedPlaylistTrack !== null && draggedPlaylistTrack !== index) {
                          moveInEditedPlaylist(draggedPlaylistTrack, index);
                        }
                        setDraggedPlaylistTrack(null);
                        setPlaylistDropTarget(null);
                      } : undefined,
                      className: `flex items-center gap-4 py-3 px-4 transition-all no-drag group ${
                        playlistEditMode ? 'cursor-grab active:cursor-grabbing' : 'cursor-pointer'
                      } ${isResolving ? 'opacity-60' : ''} ${isDragging ? 'opacity-50 bg-gray-100' : ''} ${isDraggedOver ? 'border-t-2 border-t-purple-500' : ''} ${isNowPlaying && isPlaying ? 'bg-purple-50' : 'hover:bg-gray-50/80'}`,
                      style: {
                        borderRadius: '8px',
                        marginBottom: '2px'
                      },
                      onClick: () => {
                        if (draggedPlaylistTrack !== null) return; // Don't play if dragging
                        const tracksAfter = playlistTracks.slice(index + 1);
                        const context = { type: 'playlist', id: selectedPlaylist?.id, name: selectedPlaylist?.title };
                        setQueueWithContext(tracksAfter, context);
                        handlePlay(track);
                      },
                      onContextMenu: (e) => {
                        e.preventDefault();
                        if (window.electron?.contextMenu?.showTrackMenu) {
                          window.electron.contextMenu.showTrackMenu({
                            type: 'track',
                            track: track,
                            // Pass playlist context for "Remove from Playlist" option
                            inPlaylist: true,
                            playlistId: selectedPlaylist.id,
                            trackIndex: index
                          });
                        }
                      }
                    },
                      // Track number or drag handle in edit mode
                      playlistEditMode
                        ? React.createElement('span', {
                            className: 'text-gray-400 flex-shrink-0 flex items-center justify-center',
                            style: { pointerEvents: 'none', width: '32px' },
                            title: 'Drag to reorder'
                          },
                          // Drag handle icon (hamburger/grip lines)
                          React.createElement('svg', {
                            className: 'w-4 h-4',
                            fill: 'none',
                            stroke: 'currentColor',
                            viewBox: '0 0 24 24'
                          },
                            React.createElement('path', {
                              strokeLinecap: 'round',
                              strokeLinejoin: 'round',
                              strokeWidth: 2,
                              d: 'M4 8h16M4 16h16'
                            })
                          )
                        )
                        : React.createElement('span', {
                            className: 'flex-shrink-0 text-right',
                            style: {
                              pointerEvents: 'none',
                              width: '32px',
                              fontSize: '12px',
                              fontWeight: '500',
                              color: isNowPlaying && isPlaying ? '#8b5cf6' : '#9ca3af'
                            }
                          }, isNowPlaying && isPlaying ? 'â–¶' : String(index + 1).padStart(2, '0')),

                      // Track title - fixed width column
                      React.createElement('span', {
                        className: 'truncate transition-colors',
                        style: {
                          pointerEvents: 'none',
                          width: '360px',
                          flexShrink: 0,
                          fontSize: '13px',
                          fontWeight: isNowPlaying && isPlaying ? '500' : '400',
                          color: isNowPlaying && isPlaying ? '#7c3aed' : hasResolved ? '#374151' : '#9ca3af'
                        }
                      }, track.title),

                      // Artist name - fixed width column, clickable
                      React.createElement('span', {
                        className: 'truncate hover:text-purple-600 hover:underline cursor-pointer transition-colors',
                        style: {
                          width: '240px',
                          flexShrink: 0,
                          fontSize: '12px',
                          color: '#6b7280'
                        },
                        onClick: (e) => {
                          e.stopPropagation();
                          fetchArtistData(track.artist);
                        }
                      }, track.artist),

                      // Duration - fixed width column (before resolver icons)
                      React.createElement('span', {
                        className: 'text-right tabular-nums',
                        style: {
                          pointerEvents: 'none',
                          width: '50px',
                          flexShrink: 0,
                          marginLeft: 'auto',
                          fontSize: '12px',
                          color: '#9ca3af'
                        }
                      }, formatTime(track.duration)),

                      // Resolver icons - fixed width column (last column)
                      React.createElement('div', {
                        className: 'flex items-center gap-1 justify-end',
                        style: { width: '100px', flexShrink: 0, minHeight: '24px' }
                      },
                        isResolving ?
                          React.createElement('div', {
                            className: 'flex items-center gap-1'
                          },
                            React.createElement('div', {
                              className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer',
                              title: 'Resolving track...'
                            }),
                            React.createElement('div', {
                              className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer',
                              style: { animationDelay: '0.1s' }
                            })
                          )
                        : hasResolved ?
                          Object.entries(resolvedSources)
                            .sort(([aId], [bId]) => {
                              const aIndex = resolverOrder.indexOf(aId);
                              const bIndex = resolverOrder.indexOf(bId);
                              return aIndex - bIndex;
                            })
                            .map(([resolverId, source]) => {
                              const resolver = allResolvers.find(r => r.id === resolverId);
                              if (!resolver || !resolver.play) return null;
                              return React.createElement('button', {
                                key: resolverId,
                                className: 'no-drag',
                                onClick: (e) => {
                                  e.stopPropagation();
                                  const tracksAfter = playlistTracks.slice(index + 1);
                                  const context = { type: 'playlist', id: selectedPlaylist?.id, name: selectedPlaylist?.title };
                                  setQueueWithContext(tracksAfter, context);
                                  handlePlay({ ...track, preferredResolver: resolverId });
                                },
                                style: {
                                  width: '20px',
                                  height: '20px',
                                  borderRadius: '4px',
                                  backgroundColor: resolver.color,
                                  border: 'none',
                                  cursor: 'pointer',
                                  display: 'flex',
                                  alignItems: 'center',
                                  justifyContent: 'center',
                                  pointerEvents: 'auto',
                                  opacity: (source.confidence || 0) > 0.8 ? 1 : 0.6,
                                  transition: 'transform 0.1s'
                                },
                                onMouseEnter: (e) => e.currentTarget.style.transform = 'scale(1.1)',
                                onMouseLeave: (e) => e.currentTarget.style.transform = 'scale(1)',
                                title: `Play from ${resolver.name}${source.confidence ? ` (${Math.round(source.confidence * 100)}% match)` : ''}`
                              }, React.createElement(ResolverIcon, { resolverId, size: 12 }));
                            })
                        :
                          // Show shimmer skeletons while resolving (match resolver icon size)
                          React.createElement('div', {
                            className: 'flex items-center gap-1'
                          },
                            React.createElement('div', {
                              className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer',
                              title: 'Resolving track...'
                            }),
                            React.createElement('div', {
                              className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer',
                              style: { animationDelay: '0.1s' }
                            })
                          )
                      )
                    );
                  })
                )
              :
                React.createElement('div', { className: 'text-center py-12 text-gray-400' },
                  'Loading tracks...'
                );
              })()
            )
          )
        )
      )

      // Main content area - Playlists Page (separate layout like Artist page)
      : activeView === 'playlists' ? React.createElement('div', {
        className: 'flex-1 flex flex-col h-full',
        style: { overflow: 'hidden', minHeight: 0 }
      },
        // Header section (outside scrollable area)
        React.createElement('div', {
          className: 'relative',
          style: {
            height: playlistsHeaderCollapsed ? '80px' : '320px',
            flexShrink: 0,
            transition: 'height 300ms ease-out',
            overflow: 'hidden'
          }
        },
          // Gradient background
          React.createElement('div', {
            className: 'absolute inset-0 bg-gradient-to-br from-rose-500 via-pink-500 to-fuchsia-600'
          }),
          // Background pattern
          React.createElement('div', {
            className: 'absolute inset-0',
            style: {
              opacity: 0.15,
              backgroundImage: 'url("data:image/svg+xml,%3Csvg width=\'60\' height=\'60\' viewBox=\'0 0 60 60\' xmlns=\'http://www.w3.org/2000/svg\'%3E%3Cg fill=\'none\' stroke=\'%23ffffff\' stroke-width=\'2\'%3E%3Cpath d=\'M5 15h50M5 30h35M5 45h45\'/%3E%3Ccircle cx=\'50\' cy=\'30\' r=\'5\' fill=\'%23ffffff\'/%3E%3C/g%3E%3C/svg%3E")'
            }
          }),
          // EXPANDED STATE - Centered content
          !playlistsHeaderCollapsed && React.createElement('div', {
            className: 'absolute inset-0 flex flex-col items-center justify-center text-center px-6 z-10',
            style: {
              opacity: playlistsHeaderCollapsed ? 0 : 1,
              transition: 'opacity 300ms ease-out'
            }
          },
            React.createElement('h1', {
              className: 'text-5xl font-light text-white',
              style: {
                textShadow: '0 2px 20px rgba(0,0,0,0.5)',
                letterSpacing: '0.3em',
                textTransform: 'uppercase'
              }
            }, 'PLAYLISTS'),
            React.createElement('div', {
              className: 'flex items-center gap-1 mt-6',
              style: { textShadow: '0 1px 10px rgba(0,0,0,0.5)' }
            },
              playlistsLoading && playlists.length === 0
                ? React.createElement('div', {
                    className: 'h-5 w-24 rounded bg-white/20 animate-pulse'
                  })
                : React.createElement('span', {
                    className: 'px-2 py-1 text-sm font-medium uppercase tracking-wider text-white'
                  }, `${playlists.length} Playlist${playlists.length !== 1 ? 's' : ''}`)
            ),
          ),
          // COLLAPSED STATE - Inline layout
          playlistsHeaderCollapsed && React.createElement('div', {
            className: 'absolute inset-0 flex items-center px-6 z-10',
            style: {
              opacity: playlistsHeaderCollapsed ? 1 : 0,
              transition: 'opacity 300ms ease-out'
            }
          },
            React.createElement('h1', {
              className: 'text-2xl font-light text-white',
              style: {
                textShadow: '0 2px 10px rgba(0,0,0,0.5)',
                letterSpacing: '0.2em',
                textTransform: 'uppercase'
              }
            }, 'PLAYLISTS')
          )
        ),
        // Filter bar (outside scrollable area)
        React.createElement('div', {
          className: 'flex items-center px-6 py-3 bg-white border-b border-gray-200',
          style: { flexShrink: 0 }
        },
          // Sort dropdown
          React.createElement('div', { className: 'relative' },
            React.createElement('button', {
              onClick: (e) => { e.stopPropagation(); setPlaylistsSortDropdownOpen(!playlistsSortDropdownOpen); },
              className: 'flex items-center gap-1 px-3 py-1.5 text-sm text-gray-500 hover:text-gray-700 transition-colors'
            },
              React.createElement('span', null, playlistsSortOptions.find(o => o.value === playlistsSort)?.label || 'Sort'),
              React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M19 9l-7 7-7-7' })
              )
            ),
            playlistsSortDropdownOpen && React.createElement('div', {
              className: 'absolute left-0 top-full mt-1 bg-white rounded-lg shadow-lg py-1 min-w-[160px] z-30 border border-gray-200'
            },
              playlistsSortOptions.map(option =>
                React.createElement('button', {
                  key: option.value,
                  onClick: (e) => {
                    e.stopPropagation();
                    setPlaylistsSort(option.value);
                    setPlaylistsSortDropdownOpen(false);
                  },
                  className: `w-full px-4 py-2 text-left text-sm hover:bg-gray-100 flex items-center justify-between ${
                    playlistsSort === option.value ? 'text-gray-900 font-medium' : 'text-gray-600'
                  }`
                },
                  option.label,
                  playlistsSort === option.value && React.createElement('svg', {
                    className: 'w-4 h-4',
                    fill: 'none',
                    viewBox: '0 0 24 24',
                    stroke: 'currentColor'
                  },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M5 13l4 4L19 7' })
                  )
                )
              )
            )
          ),
          React.createElement('div', { className: 'flex-1' }),
          // View mode toggle (grid/table)
          React.createElement('div', { className: 'flex items-center gap-1 mr-4' },
            React.createElement('button', {
              onClick: () => setPlaylistsViewMode('grid'),
              className: `p-1.5 rounded transition-colors ${playlistsViewMode === 'grid' ? 'bg-gray-200 text-gray-700' : 'text-gray-400 hover:text-gray-600'}`,
              title: 'Grid view'
            },
              React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor', strokeWidth: 2 },
                React.createElement('rect', { x: 3, y: 3, width: 7, height: 7, rx: 1 }),
                React.createElement('rect', { x: 14, y: 3, width: 7, height: 7, rx: 1 }),
                React.createElement('rect', { x: 3, y: 14, width: 7, height: 7, rx: 1 }),
                React.createElement('rect', { x: 14, y: 14, width: 7, height: 7, rx: 1 })
              )
            ),
            React.createElement('button', {
              onClick: () => setPlaylistsViewMode('table'),
              className: `p-1.5 rounded transition-colors ${playlistsViewMode === 'table' ? 'bg-gray-200 text-gray-700' : 'text-gray-400 hover:text-gray-600'}`,
              title: 'Table view'
            },
              React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor', strokeWidth: 2 },
                React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', d: 'M4 6h16M4 12h16M4 18h16' })
              )
            )
          ),
          // Search
          React.createElement('div', { className: 'flex items-center' },
            playlistsSearchOpen ?
              React.createElement('div', { className: 'flex items-center border border-gray-300 rounded-full px-3 py-1.5' },
                React.createElement('input', {
                  type: 'text',
                  value: playlistsSearch,
                  onChange: (e) => setPlaylistsSearch(e.target.value),
                  onBlur: () => { if (!playlistsSearch.trim()) setPlaylistsSearchOpen(false); },
                  autoFocus: true,
                  placeholder: 'Filter...',
                  className: 'bg-transparent text-gray-700 text-sm placeholder-gray-400 outline-none',
                  style: { width: '150px' }
                }),
                playlistsSearch && React.createElement('button', {
                  onClick: () => { setPlaylistsSearch(''); setPlaylistsSearchOpen(false); },
                  className: 'ml-2 text-gray-400 hover:text-gray-600'
                },
                  React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M6 18L18 6M6 6l12 12' })
                  )
                )
              )
            :
              React.createElement('button', {
                onClick: () => setPlaylistsSearchOpen(true),
                className: 'p-1.5 text-gray-400 hover:text-gray-600 transition-colors'
              },
                React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                  React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' })
                )
              )
          ),
          // Import Playlist button - styled like Add Friend button
          React.createElement('button', {
            onClick: () => setShowUrlImportDialog(true),
            className: 'ml-3 px-3 py-1.5 bg-pink-600 hover:bg-pink-700 text-white rounded-lg text-sm font-medium transition-colors flex items-center gap-1.5'
          },
            React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
              React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4 -4l-4 4m0 0l-4-4m4 4V4' })
            ),
            'Import'
          )
        ),
        // Content area (scrollable)
        React.createElement('div', {
          className: 'scrollable-content',
          style: {
            flex: 1,
            overflowY: 'scroll',
            pointerEvents: 'auto',
            padding: '24px'
          },
          onScroll: handlePlaylistsScroll
        },
          (() => {
            const filtered = filterPlaylists(playlists);
            const sorted = sortPlaylists(filtered);

            // Show loading skeletons while playlists are loading
            if (playlistsLoading && sorted.length === 0) {
              return React.createElement('div', { className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-6' },
                Array.from({ length: 10 }).map((_, i) =>
                  React.createElement('div', { key: `playlist-skeleton-${i}` },
                    // Skeleton 2x2 album art grid
                    React.createElement('div', {
                      className: 'aspect-square rounded-lg overflow-hidden mb-3 shadow-md'
                    },
                      React.createElement('div', { className: 'grid grid-cols-2 grid-rows-2 w-full h-full' },
                        [0, 1, 2, 3].map(idx =>
                          React.createElement('div', {
                            key: idx,
                            className: 'bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                            style: { backgroundSize: '200% 100%', animationDelay: `${(i * 4 + idx) * 30}ms` }
                          })
                        )
                      )
                    ),
                    // Skeleton title
                    React.createElement('div', {
                      className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-3/4 mb-2 animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 50}ms` }
                    }),
                    // Skeleton creator
                    React.createElement('div', {
                      className: 'h-3 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-1/2 animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 25}ms` }
                    })
                  )
                )
              );
            }

            if (sorted.length === 0 && playlistsSearch) {
              return React.createElement('div', { className: 'text-center py-12 text-gray-400' },
                React.createElement('svg', { className: 'w-12 h-12 mx-auto mb-4 text-gray-300', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                  React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 1.5, d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' })
                ),
                React.createElement('div', { className: 'text-sm' }, 'No playlists match your search')
              );
            }

            if (sorted.length === 0) {
              return React.createElement('div', {
                className: 'text-center py-12 text-gray-400'
              }, 'No playlists yet. Import a playlist to get started!');
            }

            // Grid view
            if (playlistsViewMode === 'grid') {
              return React.createElement('div', { className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-x-4 gap-y-5' },
                sorted.map((playlist, index) => {
                  const covers = allPlaylistCovers[playlist.id] || [];
                  const hasCachedCovers = covers.length > 0;
                  const animationDelay = Math.min(index * 30, 300);

                  return React.createElement('div', {
                    key: playlist.id,
                    onClick: (e) => {
                      e.preventDefault();
                      e.stopPropagation();
                      loadPlaylist(playlist);
                    },
                    onContextMenu: (e) => {
                      e.preventDefault();
                      if (window.electron?.contextMenu?.showTrackMenu) {
                        const tracksWithIds = (playlist.tracks || []).map((track, idx) => {
                          const trackId = `${track.artist || 'unknown'}-${track.title || 'untitled'}-${track.album || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
                          return { ...track, id: trackId, sources: {} };
                        });
                        window.electron.contextMenu.showTrackMenu({
                          type: 'playlist',
                          playlistId: playlist.id,
                          name: playlist.title,
                          tracks: tracksWithIds
                        });
                      }
                    },
                    className: 'group cursor-pointer release-card card-fade-up',
                    style: {
                      padding: '10px',
                      borderRadius: '10px',
                      backgroundColor: '#ffffff',
                      boxShadow: '0 1px 3px rgba(0, 0, 0, 0.05), 0 4px 12px rgba(0, 0, 0, 0.03)',
                      animationDelay: `${animationDelay}ms`
                    }
                  },
                    // Album art mosaic or placeholder (draggable)
                    React.createElement('div', {
                      className: 'relative aspect-square rounded-lg overflow-hidden mb-2 cursor-grab active:cursor-grabbing album-art-container',
                      draggable: true,
                      onDragStart: (e) => {
                        const tracksWithIds = (playlist.tracks || []).map(track => {
                          const trackId = `${track.artist || 'unknown'}-${track.title || 'untitled'}-${track.album || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
                          return { ...track, id: trackId, sources: {} };
                        });
                        e.dataTransfer.effectAllowed = 'copy';
                        e.dataTransfer.setData('text/plain', JSON.stringify({
                          type: 'playlist',
                          playlist: {
                            id: playlist.id,
                            title: playlist.title,
                            creator: playlist.creator,
                            tracks: tracksWithIds
                          }
                        }));
                      }
                    },
                      hasCachedCovers ?
                        React.createElement('div', { className: 'grid grid-cols-2 grid-rows-2 w-full h-full' },
                          [0, 1, 2, 3].map(idx => {
                            return React.createElement('div', {
                              key: idx,
                              className: 'relative w-full h-full flex items-center justify-center',
                              style: { background: 'linear-gradient(145deg, #1f1f1f 0%, #2d2d2d 50%, #1a1a1a 100%)' }
                            },
                              !covers[idx] && React.createElement(Music, { size: 20, className: 'text-gray-600' }),
                              covers[idx] && React.createElement('img', {
                                src: covers[idx],
                                alt: '',
                                className: 'absolute inset-0 w-full h-full object-cover transition-opacity duration-300',
                                style: { opacity: 0 },
                                ref: (el) => { if (el && el.complete && el.naturalWidth > 0) el.style.opacity = '1'; },
                                onLoad: (e) => { e.target.style.opacity = '1'; }
                              })
                            );
                          })
                        )
                      :
                        React.createElement('div', {
                          className: 'w-full h-full flex items-center justify-center',
                          style: { background: 'linear-gradient(145deg, #1f1f1f 0%, #2d2d2d 50%, #1a1a1a 100%)' }
                        },
                          // Playlist icon (three lines with play triangle)
                          React.createElement('svg', { className: 'w-12 h-12 text-gray-500', viewBox: '0 0 24 24', fill: 'currentColor' },
                            React.createElement('rect', { x: 3, y: 5, width: 18, height: 2, rx: 1 }),
                            React.createElement('rect', { x: 3, y: 11, width: 10, height: 2, rx: 1 }),
                            React.createElement('rect', { x: 3, y: 17, width: 7, height: 2, rx: 1 }),
                            React.createElement('path', { d: 'M15 13.5v6l5.5-3-5.5-3z' })
                          )
                        ),

                      // Hosted indicator
                      playlist.sourceUrl && React.createElement('div', {
                        className: 'absolute top-2 right-2 flex items-center gap-1'
                      },
                        React.createElement('span', {
                          className: 'bg-white/90 backdrop-blur-sm text-blue-500 text-xs px-2 py-0.5 rounded-full font-medium',
                          title: 'Hosted playlist'
                        }, 'ðŸŒ Hosted'),
                        React.createElement('button', {
                          onClick: async (e) => {
                            e.stopPropagation();
                            setRefreshingPlaylist(playlist.id);
                            await refreshHostedPlaylist(playlist.id);
                            setRefreshingPlaylist(null);
                          },
                          className: `p-1 bg-white/90 backdrop-blur-sm rounded-full hover:bg-white transition-colors ${refreshingPlaylist === playlist.id ? 'animate-spin' : ''}`,
                          title: 'Refresh playlist'
                        },
                          React.createElement('svg', { className: 'w-3 h-3 text-gray-600', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                            React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15' })
                          )
                        )
                      ),

                      // AI indicator
                      playlist.isAiPlaylist && !playlist.sourceUrl && React.createElement('div', {
                        className: 'absolute top-2 right-2'
                      },
                        React.createElement('span', {
                          className: 'bg-white/90 backdrop-blur-sm text-purple-600 text-xs px-2 py-0.5 rounded-full font-medium',
                          title: `Generated by ${playlist.creator || 'AI'}`
                        }, 'âœ¨ AI')
                      ),

                      // Hover overlay with action buttons (Add to Playlist, Play, Queue)
                      React.createElement('div', {
                        className: 'absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity duration-200 flex items-center justify-center gap-3'
                      },
                        // Add to Playlist button
                        React.createElement('button', {
                          onClick: (e) => {
                            e.stopPropagation();
                            const tracksWithIds = (playlist.tracks || []).map(track => ({
                              ...track,
                              id: `${track.artist || 'unknown'}-${track.title || 'untitled'}`.toLowerCase().replace(/[^a-z0-9-]/g, ''),
                              sources: {}
                            }));
                            if (tracksWithIds.length > 0) {
                              setAddToPlaylistPanel({
                                open: true,
                                tracks: tracksWithIds,
                                sourceName: playlist.title,
                                sourceType: 'playlist'
                              });
                            }
                          },
                          className: 'w-10 h-10 rounded-full flex items-center justify-center transition-all hover:scale-110',
                          style: { backgroundColor: 'rgba(255, 255, 255, 0.15)', color: '#ffffff' },
                          onMouseEnter: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.25)',
                          onMouseLeave: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.15)',
                          title: 'Add to Playlist'
                        },
                          React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor', strokeWidth: 2 },
                            React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', d: 'M12 4v16m8-8H4' })
                          )
                        ),
                        // Play button (center, larger)
                        React.createElement('button', {
                          onClick: (e) => {
                            e.stopPropagation();
                            setTrackLoading(true);
                            const tracksWithIds = (playlist.tracks || []).map(track => ({
                              ...track,
                              id: `${track.artist || 'unknown'}-${track.title || 'untitled'}`.toLowerCase().replace(/[^a-z0-9-]/g, ''),
                              sources: {}
                            }));
                            if (tracksWithIds.length > 0) {
                              const context = { type: 'playlist', id: playlist.id, name: playlist.title };
                              const [firstTrack, ...remainingTracks] = tracksWithIds;
                              // Tag the first track with context so queue navigation works correctly
                              const taggedFirstTrack = { ...firstTrack, _playbackContext: context };
                              setQueueWithContext(remainingTracks, context);
                              handlePlay(taggedFirstTrack);
                            } else {
                              setTrackLoading(false);
                            }
                          },
                          className: 'w-12 h-12 bg-white rounded-full flex items-center justify-center shadow-lg transition-all hover:scale-110',
                          title: 'Play'
                        },
                          React.createElement(Play, { size: 22, className: 'text-gray-800 ml-0.5' })
                        ),
                        // Add to Queue button
                        React.createElement('button', {
                          onClick: (e) => {
                            e.stopPropagation();
                            const tracksWithIds = (playlist.tracks || []).map(track => ({
                              ...track,
                              id: `${track.artist || 'unknown'}-${track.title || 'untitled'}`.toLowerCase().replace(/[^a-z0-9-]/g, ''),
                              sources: {}
                            }));
                            if (tracksWithIds.length > 0) {
                              const context = { type: 'playlist', id: playlist.id, name: playlist.title };
                              addToQueue(tracksWithIds, context);
                            }
                          },
                          className: 'w-10 h-10 rounded-full flex items-center justify-center transition-all hover:scale-110',
                          style: { backgroundColor: 'rgba(255, 255, 255, 0.15)', color: '#ffffff' },
                          onMouseEnter: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.25)',
                          onMouseLeave: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.15)',
                          title: 'Add to Queue'
                        },
                          React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor', strokeWidth: 2 },
                            React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', d: 'M4 6h16M4 12h16M4 18h7' })
                          )
                        )
                      )
                    ),
                    // Playlist info - refined typography
                    React.createElement('div', {
                      className: 'truncate transition-colors',
                      style: {
                        fontSize: '13px',
                        fontWeight: '500',
                        color: '#1f2937',
                        marginTop: '6px'
                      }
                    }, playlist.title),
                    React.createElement('div', {
                      className: 'truncate',
                      style: {
                        fontSize: '11px',
                        color: '#6b7280',
                        marginTop: '2px'
                      }
                    },
                      playlist.creator || `${playlist.tracks?.length || 0} Songs`
                    )
                  );
                }),
                // Trailing skeletons while hosted playlists are still loading
                ...(playlistsLoading ? Array.from({ length: 4 }).map((_, i) =>
                  React.createElement('div', { key: `trailing-skeleton-${i}` },
                    // Skeleton 2x2 album art grid
                    React.createElement('div', {
                      className: 'aspect-square rounded-lg overflow-hidden mb-3 shadow-md'
                    },
                      React.createElement('div', { className: 'grid grid-cols-2 grid-rows-2 w-full h-full' },
                        [0, 1, 2, 3].map(idx =>
                          React.createElement('div', {
                            key: idx,
                            className: 'bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                            style: { backgroundSize: '200% 100%', animationDelay: `${(i * 4 + idx) * 30}ms` }
                          })
                        )
                      )
                    ),
                    // Skeleton title
                    React.createElement('div', {
                      className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-3/4 mb-2 animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 50}ms` }
                    }),
                    // Skeleton creator
                    React.createElement('div', {
                      className: 'h-3 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-1/2 animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 25}ms` }
                    })
                  )
                ) : [])
              );
            }

            // Table view
            return React.createElement('div', { className: 'space-y-0' },
              sorted.map((playlist, index) => {
                const covers = allPlaylistCovers[playlist.id] || [];
                const hasCachedCovers = covers.length > 0;
                const trackCount = playlist.tracks?.length || 0;

                return React.createElement('div', {
                  key: playlist.id,
                  draggable: true,
                  onDragStart: (e) => {
                    const tracksWithIds = (playlist.tracks || []).map(track => {
                      const trackId = `${track.artist || 'unknown'}-${track.title || 'untitled'}-${track.album || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
                      return { ...track, id: trackId, sources: {} };
                    });
                    e.dataTransfer.effectAllowed = 'copy';
                    e.dataTransfer.setData('text/plain', JSON.stringify({
                      type: 'playlist',
                      playlist: {
                        id: playlist.id,
                        title: playlist.title,
                        creator: playlist.creator,
                        tracks: tracksWithIds
                      }
                    }));
                  },
                  onClick: (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    loadPlaylist(playlist);
                  },
                  onContextMenu: (e) => {
                    e.preventDefault();
                    if (window.electron?.contextMenu?.showTrackMenu) {
                      const tracksWithIds = (playlist.tracks || []).map((track, idx) => {
                        const trackId = `${track.artist || 'unknown'}-${track.title || 'untitled'}-${track.album || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
                        return { ...track, id: trackId, sources: {} };
                      });
                      window.electron.contextMenu.showTrackMenu({
                        type: 'playlist',
                        playlistId: playlist.id,
                        name: playlist.title,
                        tracks: tracksWithIds
                      });
                    }
                  },
                  className: `group flex items-center gap-4 py-3 px-4 cursor-pointer hover:bg-gray-50 transition-colors ${index > 0 ? 'border-t border-gray-100' : ''}`
                },
                  // Thumbnail (small mosaic or placeholder)
                  React.createElement('div', {
                    className: 'relative w-12 h-12 rounded overflow-hidden flex-shrink-0'
                  },
                    hasCachedCovers ?
                      React.createElement('div', { className: 'grid grid-cols-2 grid-rows-2 w-full h-full' },
                        [0, 1, 2, 3].map(idx => {
                          const gradients = [
                            'bg-gradient-to-br from-violet-400 to-purple-500',
                            'bg-gradient-to-br from-rose-400 to-pink-500',
                            'bg-gradient-to-br from-amber-400 to-orange-500',
                            'bg-gradient-to-br from-emerald-400 to-teal-500'
                          ];
                          return React.createElement('div', {
                            key: idx,
                            className: `relative w-full h-full ${gradients[idx]}`
                          },
                            covers[idx] && React.createElement('img', {
                              src: covers[idx],
                              alt: '',
                              className: 'absolute inset-0 w-full h-full object-cover transition-opacity duration-300',
                              style: { opacity: 0 },
                              ref: (el) => { if (el && el.complete && el.naturalWidth > 0) el.style.opacity = '1'; },
                              onLoad: (e) => { e.target.style.opacity = '1'; }
                            })
                          );
                        })
                      )
                    :
                      React.createElement('div', {
                        className: `w-full h-full flex items-center justify-center ${
                          playlist.sourceUrl
                            ? 'bg-gradient-to-br from-blue-400 to-cyan-400'
                            : playlist.isAiPlaylist
                              ? 'bg-gradient-to-br from-violet-500 to-fuchsia-500'
                              : 'bg-gradient-to-br from-purple-400 to-pink-400'
                        }`
                      },
                        // Playlist icon (three lines with play triangle)
                        React.createElement('svg', { className: 'w-5 h-5 text-white/80', viewBox: '0 0 24 24', fill: 'currentColor' },
                          React.createElement('rect', { x: 3, y: 5, width: 18, height: 2, rx: 1 }),
                          React.createElement('rect', { x: 3, y: 11, width: 10, height: 2, rx: 1 }),
                          React.createElement('rect', { x: 3, y: 17, width: 7, height: 2, rx: 1 }),
                          React.createElement('path', { d: 'M15 13.5v6l5.5-3-5.5-3z' })
                        )
                      )
                  ),
                  // Playlist name
                  React.createElement('div', { className: 'flex-1 min-w-0' },
                    React.createElement('div', { className: 'font-medium text-gray-900 truncate group-hover:text-green-600 transition-colors' }, playlist.title),
                    playlist.creator && React.createElement('div', { className: 'text-sm text-gray-500 truncate' }, playlist.creator)
                  ),
                  // Hosted badge
                  playlist.sourceUrl && React.createElement('span', {
                    className: 'text-xs text-blue-500 bg-blue-50 px-2 py-1 rounded-full font-medium flex-shrink-0',
                    title: 'Hosted playlist'
                  }, 'ðŸŒ Hosted'),
                  // AI badge
                  playlist.isAiPlaylist && !playlist.sourceUrl && React.createElement('span', {
                    className: 'text-xs text-purple-600 bg-purple-50 px-2 py-1 rounded-full font-medium flex-shrink-0',
                    title: `Generated by ${playlist.creator || 'AI'}`
                  }, 'âœ¨ AI'),
                  // Track count
                  React.createElement('div', { className: 'text-sm text-gray-500 flex-shrink-0 w-20 text-right' },
                    `${trackCount} song${trackCount !== 1 ? 's' : ''}`
                  ),
                  // Play icon on hover
                  React.createElement('div', {
                    className: 'w-8 h-8 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity flex-shrink-0 cursor-pointer hover:scale-110 transition-transform',
                    onClick: (e) => {
                      e.preventDefault();
                      e.stopPropagation();
                      // Play the playlist starting from first track
                      const tracks = playlist.tracks || [];
                      if (tracks.length > 0) {
                        // Create track objects with IDs matching the playlist view format
                        const tracksWithIds = tracks.map(track => {
                          const trackId = `${track.artist || 'unknown'}-${track.title || 'untitled'}-${track.album || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
                          return { ...track, id: trackId, sources: {} };
                        });
                        // Set all tracks after first as queue
                        setCurrentQueue(tracksWithIds.slice(1));
                        // Play first track
                        handlePlay(tracksWithIds[0]);
                      }
                    }
                  },
                    React.createElement(Play, { size: 20, className: 'text-purple-600 fill-purple-600' })
                  )
                );
              }),
              // Trailing skeletons while hosted playlists are still loading (table view)
              ...(playlistsLoading ? Array.from({ length: 4 }).map((_, i) =>
                React.createElement('div', {
                  key: `trailing-table-skeleton-${i}`,
                  className: `flex items-center gap-4 py-3 px-4 border-t border-gray-100`
                },
                  // Skeleton thumbnail
                  React.createElement('div', {
                    className: 'w-12 h-12 rounded overflow-hidden flex-shrink-0 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                    style: { backgroundSize: '200% 100%', animationDelay: `${i * 50}ms` }
                  }),
                  // Skeleton title/creator
                  React.createElement('div', { className: 'flex-1 min-w-0' },
                    React.createElement('div', {
                      className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-48 mb-2 animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 50}ms` }
                    }),
                    React.createElement('div', {
                      className: 'h-3 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-24 animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 25}ms` }
                    })
                  ),
                  // Skeleton track count
                  React.createElement('div', {
                    className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-16 flex-shrink-0 animate-shimmer',
                    style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 50}ms` }
                  })
                )
              ) : [])
            );
          })()
        )
      )

      // Main content area - Normal views (Library, Search, etc.)
      : React.createElement('div', {
        className: `flex-1 ${
          // Views with custom scroll handling should not have overflow on parent
          ['library', 'discover', 'critics-picks', 'recommendations', 'history', 'friendHistory'].includes(activeView)
            ? 'overflow-hidden'
            : 'overflow-y-auto scrollable-content'
        } ${
          // No padding for views with full-bleed heroes
          ['library', 'discover', 'new-releases', 'critics-picks', 'recommendations', 'history', 'friendHistory'].includes(activeView) ? '' : 'p-6'
        }`,
        style: {
          minHeight: 0,
          flexBasis: 0,
          pointerEvents: activeView === 'artist' || activeView === 'playlist-view' ? 'none' : 'auto'
        }
      },
        // Shared header - only show for views without custom heroes
        !['library', 'discover', 'new-releases', 'critics-picks', 'recommendations', 'history', 'friendHistory', 'settings', 'playlists', 'playlist-view'].includes(activeView) &&
        React.createElement('div', { className: 'flex items-center justify-between mb-4' },
          React.createElement('h2', { className: 'text-2xl font-bold' },
            activeView === 'friends' ? 'Friends' :
            'Discover'
          )
        ),

        // Library view with collapsible hero header (matching Recommendations pattern)
        activeView === 'library' && React.createElement('div', {
          className: 'flex-1 flex flex-col h-full',
          style: { overflow: 'hidden', minHeight: 0 }
        },
          // Header section (outside scrollable area)
          React.createElement('div', {
            className: 'relative',
            style: {
              height: collectionHeaderCollapsed ? '80px' : '320px',
              flexShrink: 0,
              transition: 'height 300ms cubic-bezier(0.4, 0, 0.2, 1)',
              overflow: 'hidden',
              willChange: 'height',
              contain: 'layout style'
            }
          },
              // Gradient background
              React.createElement('div', {
                className: 'absolute inset-0 bg-gradient-to-br from-violet-600 via-purple-600 to-indigo-700'
              }),
              // Vinyl pattern overlay
              React.createElement('div', {
                className: 'absolute inset-0',
                style: {
                  opacity: 0.08,
                  backgroundImage: 'url("data:image/svg+xml,%3Csvg width=\'60\' height=\'60\' viewBox=\'0 0 60 60\' xmlns=\'http://www.w3.org/2000/svg\'%3E%3Cg fill=\'%23ffffff\'%3E%3Ccircle cx=\'30\' cy=\'30\' r=\'20\' fill=\'none\' stroke=\'%23fff\' stroke-width=\'2\'/%3E%3Ccircle cx=\'30\' cy=\'30\' r=\'12\' fill=\'none\' stroke=\'%23fff\' stroke-width=\'1\'/%3E%3Ccircle cx=\'30\' cy=\'30\' r=\'4\'/%3E%3C/g%3E%3C/svg%3E")'
                }
              }),
              // EXPANDED STATE - Centered content
            !collectionHeaderCollapsed && React.createElement('div', {
              className: 'absolute inset-0 flex flex-col items-center justify-center text-center px-6 z-10',
              style: {
                opacity: collectionHeaderCollapsed ? 0 : 1,
                transition: 'opacity 300ms ease-out'
              }
            },
                // Title
                React.createElement('h1', {
                  className: 'text-5xl font-light text-white',
                  style: {
                    textShadow: '0 2px 20px rgba(0,0,0,0.5)',
                    letterSpacing: '0.3em',
                    textTransform: 'uppercase'
                  }
                }, 'COLLECTION'),
                // Stats row as tabs (matching Artist page styling)
                React.createElement('div', {
                  className: 'flex items-center gap-1 mt-6',
                  style: { textShadow: '0 1px 10px rgba(0,0,0,0.5)' }
                },
                  [
                    { key: 'artists', label: collectionLoading ? null : `${collectionData.artists.length} Artists`, staticLabel: 'Artists' },
                    { key: 'albums', label: collectionLoading ? null : `${collectionData.albums.length} Albums`, staticLabel: 'Albums' },
                    { key: 'tracks', label: collectionLoading ? null : `${library.length + collectionData.tracks.length} Songs`, staticLabel: 'Songs' },
                    { key: 'friends', label: `${friends.length} Friends`, staticLabel: 'Friends' }
                  ].map((tab, index) => [
                    index > 0 && React.createElement('span', {
                      key: `sep-expanded-${tab.key}`,
                      className: 'text-white/50 mx-2'
                    }, '|'),
                    React.createElement('button', {
                      key: `expanded-${tab.key}`,
                      onClick: () => setCollectionTab(tab.key),
                      className: `px-2 py-1 text-sm font-medium uppercase tracking-wider transition-colors no-drag ${
                        collectionTab === tab.key
                          ? 'text-white'
                          : 'text-white/60 hover:text-white'
                      }`
                    }, tab.label !== null ? tab.label : React.createElement('span', { className: 'flex items-center gap-1' },
                      React.createElement('span', { className: 'inline-block w-6 h-4 bg-white/30 rounded animate-pulse' }),
                      tab.staticLabel
                    ))
                  ]).flat().filter(Boolean)
                ),
                // Buttons row
                React.createElement('div', {
                  className: 'mt-6 flex items-center gap-3'
                },
                  // Start Collection Station button (pink, matching Artist page)
                  React.createElement('button', {
                    onClick: handleStartCollectionStation,
                    className: 'px-6 py-2 rounded-full font-medium text-white no-drag transition-all hover:scale-105',
                    style: {
                      backgroundColor: '#E91E63',
                      boxShadow: '0 4px 15px rgba(233, 30, 99, 0.4)'
                    }
                  }, 'Start Collection Station')
                )
              ),
            // COLLAPSED STATE - Inline layout matching Recommendations
            collectionHeaderCollapsed && React.createElement('div', {
              className: 'absolute inset-0 flex items-center px-6 z-10',
              style: {
                opacity: collectionHeaderCollapsed ? 1 : 0,
                transition: 'opacity 300ms ease-out'
              }
            },
                // Left: Title
                React.createElement('h1', {
                  className: 'text-2xl font-light text-white mr-6',
                  style: {
                    textShadow: '0 2px 10px rgba(0,0,0,0.5)',
                    letterSpacing: '0.2em',
                    textTransform: 'uppercase'
                  }
                }, 'COLLECTION'),
                // Tabs (next to title, like artist page)
                React.createElement('div', {
                  className: 'flex items-center gap-1',
                  style: { textShadow: '0 1px 10px rgba(0,0,0,0.5)' }
                },
                  [
                    { key: 'artists', label: collectionLoading ? null : `${collectionData.artists.length} Artists`, staticLabel: 'Artists' },
                    { key: 'albums', label: collectionLoading ? null : `${collectionData.albums.length} Albums`, staticLabel: 'Albums' },
                    { key: 'tracks', label: collectionLoading ? null : `${library.length + collectionData.tracks.length} Songs`, staticLabel: 'Songs' },
                    { key: 'friends', label: `${friends.length} Friends`, staticLabel: 'Friends' }
                  ].map((tab, index) => [
                    index > 0 && React.createElement('span', {
                      key: `sep-collapsed-${tab.key}`,
                      className: 'text-white/50 mx-2'
                    }, '|'),
                    React.createElement('button', {
                      key: `collapsed-${tab.key}`,
                      onClick: () => setCollectionTab(tab.key),
                      className: `px-2 py-1 text-sm font-medium uppercase tracking-wider transition-colors no-drag ${
                        collectionTab === tab.key
                          ? 'text-white'
                          : 'text-white/60 hover:text-white'
                      }`
                    }, tab.label !== null ? tab.label : React.createElement('span', { className: 'flex items-center gap-1' },
                      React.createElement('span', { className: 'inline-block w-6 h-4 bg-white/30 rounded animate-pulse' }),
                      tab.staticLabel
                    ))
                  ]).flat().filter(Boolean)
                ),
                // Right: Start Collection Station button
                React.createElement('button', {
                  onClick: handleStartCollectionStation,
                  className: 'ml-auto px-4 py-1.5 rounded-full text-sm font-medium text-white transition-colors hover:opacity-90 no-drag',
                  style: {
                    backgroundColor: '#E91E63'
                  }
                }, 'Start Station')
              )
          ),
          // Scrollable content area
          React.createElement('div', {
            ref: (el) => {
              collectionScrollContainerRef.current = el;
              if (el && !collectionScrollContainerReady) {
                setCollectionScrollContainerReady(true);
              }
            },
            className: 'flex-1 overflow-y-auto scrollable-content',
            style: { minHeight: 0, contain: 'strict' },
            onScroll: (e) => {
              const scrollTop = e.target.scrollTop;
              if (scrollTop > 50 && !collectionHeaderCollapsed) {
                setCollectionHeaderCollapsed(true);
              } else if (scrollTop <= 50 && collectionHeaderCollapsed) {
                setCollectionHeaderCollapsed(false);
              }
            }
          },
            // Sticky filter bar
            React.createElement('div', {
              className: 'sticky top-0 z-10 flex items-center px-6 py-3 bg-white border-b border-gray-200'
            },
              // Sort dropdown (moved to left)
              React.createElement('div', { className: 'relative' },
                React.createElement('button', {
                  onClick: (e) => { e.stopPropagation(); setCollectionSortDropdownOpen(!collectionSortDropdownOpen); },
                  className: 'flex items-center gap-1 px-3 py-1.5 text-sm text-gray-500 hover:text-gray-700 transition-colors'
                },
                  React.createElement('span', null, getCollectionSortOptions(collectionTab).find(o => o.value === collectionSort[collectionTab])?.label || 'Sort'),
                  React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M19 9l-7 7-7-7' })
                  )
                ),
                // Dropdown menu
                collectionSortDropdownOpen && React.createElement('div', {
                  className: 'absolute left-0 top-full mt-1 bg-white rounded-lg shadow-lg py-1 min-w-[160px] z-30 border border-gray-200'
                },
                  getCollectionSortOptions(collectionTab).map(option =>
                    React.createElement('button', {
                      key: option.value,
                      onClick: (e) => {
                        e.stopPropagation();
                        setCollectionSort(prev => ({ ...prev, [collectionTab]: option.value }));
                        setCollectionSortDropdownOpen(false);
                      },
                      className: `w-full px-4 py-2 text-left text-sm hover:bg-gray-100 flex items-center justify-between ${
                        collectionSort[collectionTab] === option.value ? 'text-gray-900 font-medium' : 'text-gray-600'
                      }`
                    },
                      option.label,
                      collectionSort[collectionTab] === option.value && React.createElement('svg', {
                        className: 'w-4 h-4',
                        fill: 'none',
                        viewBox: '0 0 24 24',
                        stroke: 'currentColor'
                      },
                        React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M5 13l4 4L19 7' })
                      )
                    )
                  )
                )
              ),
              // Spacer
              React.createElement('div', { className: 'flex-1' }),
              // Search toggle/field
              React.createElement('div', { className: 'flex items-center' },
                collectionSearchOpen ?
                  React.createElement('div', { className: 'flex items-center border border-gray-300 rounded-full px-3 py-1.5' },
                    React.createElement('input', {
                      type: 'text',
                      value: collectionSearch,
                      onChange: (e) => setCollectionSearch(e.target.value),
                      onBlur: () => {
                        if (!collectionSearch.trim()) {
                          setCollectionSearchOpen(false);
                        }
                      },
                      autoFocus: true,
                      placeholder: 'Filter...',
                      className: 'bg-transparent text-gray-700 text-sm placeholder-gray-400 outline-none',
                      style: { width: '150px' }
                    }),
                    collectionSearch && React.createElement('button', {
                      onClick: () => {
                        setCollectionSearch('');
                        setCollectionSearchOpen(false);
                      },
                      className: 'ml-2 text-gray-400 hover:text-gray-600'
                    },
                      React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                        React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M6 18L18 6M6 6l12 12' })
                      )
                    )
                  )
                :
                  React.createElement('button', {
                    onClick: () => setCollectionSearchOpen(true),
                    className: 'p-1.5 text-gray-400 hover:text-gray-600 transition-colors'
                  },
                    React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                      React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' })
                    )
                  )
              ),
              // Sync Collection button - styled like Add Friend button (hide on friends tab)
              collectionTab !== 'friends' && React.createElement('button', {
                onClick: () => openSyncSetupModal('spotify'),
                className: `ml-3 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors flex items-center gap-1.5 ${
                  resolverSyncSettings.spotify?.enabled
                    ? 'bg-green-600 hover:bg-green-700 text-white'
                    : 'bg-gray-600 hover:bg-gray-700 text-white'
                }`,
                title: 'Sync your Spotify library'
              },
                React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                  React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15' })
                ),
                resolverSyncSettings.spotify?.enabled ? 'Synced' : 'Sync'
              ),
              // Add Friend button in header (only on friends tab)
              collectionTab === 'friends' && React.createElement('button', {
                onClick: () => setAddFriendModalOpen(true),
                className: 'ml-3 px-3 py-1.5 bg-purple-600 hover:bg-purple-700 text-white rounded-lg text-sm font-medium transition-colors flex items-center gap-1.5'
              },
                React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                  React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M12 4v16m8-8H4' })
                ),
                'Add Friend'
              )
            ),
            // Content with padding
            React.createElement('div', { className: 'p-6' },
              // Artists tab
            collectionTab === 'artists' && (() => {
              // Show loading skeletons while collection is loading
              if (collectionLoading) {
                return React.createElement('div', {
                  className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-x-4 gap-y-5',
                  style: { minHeight: 'calc(100vh - 160px)' }
                },
                  Array.from({ length: 10 }).map((_, i) =>
                    React.createElement('div', { key: `artist-skeleton-${i}`, className: 'animate-pulse' },
                      React.createElement('div', { className: 'aspect-square bg-gray-200 rounded-lg mb-3' }),
                      React.createElement('div', { className: 'h-4 bg-gray-200 rounded w-3/4 mb-2' }),
                      React.createElement('div', { className: 'h-3 bg-gray-200 rounded w-1/2' })
                    )
                  )
                );
              }

              const filtered = filterCollectionItems(collectionData.artists, 'artists');
              const sorted = sortCollectionItems(filtered, 'artists');

              if (sorted.length === 0 && collectionSearch) {
                return React.createElement('div', { className: 'flex-1 flex flex-col items-center justify-center text-gray-400 py-20' },
                  React.createElement('p', { className: 'text-lg font-medium text-gray-500' }, 'No artists match your search')
                );
              }

              if (sorted.length === 0) {
                return React.createElement('div', { className: 'flex-1 flex flex-col items-center justify-center text-gray-400 py-20' },
                  React.createElement('svg', { className: 'w-16 h-16 mb-4 text-gray-300', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 1.5, d: 'M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z' })
                  ),
                  React.createElement('p', { className: 'text-lg font-medium text-gray-500 mb-2' }, 'No artists yet'),
                  React.createElement('p', { className: 'text-sm text-gray-400' }, 'Drag artists here to add them to your collection')
                );
              }

              return React.createElement('div', {
                className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-x-4 gap-y-5',
                style: { minHeight: 'calc(100vh - 160px)' }  // Ensure enough scroll area to prevent header bounce
              },
                sorted.map((artist, index) =>
                  React.createElement(CollectionArtistCard, {
                    key: artist.name,
                    artist: { ...artist, trackCount: 0 },
                    getArtistImage: getArtistImage,
                    onNavigate: () => fetchArtistData(artist.name),
                    onPlayTopTracks: async (artist) => {
                      setTrackLoading(true);
                      const tracks = await getArtistTopTracks(artist.name);
                      if (tracks.length > 0) {
                        const context = { type: 'artist', name: artist.name };
                        const [firstTrack, ...remainingTracks] = tracks;
                        // Tag the first track with context so queue navigation works correctly
                        const taggedFirstTrack = { ...firstTrack, _playbackContext: context };
                        setQueueWithContext(remainingTracks, context);
                        handlePlay(taggedFirstTrack);
                      } else {
                        setTrackLoading(false);
                        showToast(`No top tracks found for ${artist.name}`, 'error');
                      }
                    },
                    onAddToQueue: async (artist) => {
                      const tracks = await getArtistTopTracks(artist.name);
                      if (tracks.length > 0) {
                        addToQueue(tracks, { type: 'artist', name: artist.name });
                        showToast(`Added ${tracks.length} tracks from ${artist.name}`, 'success');
                      } else {
                        showToast(`No top tracks found for ${artist.name}`, 'error');
                      }
                    },
                    animationDelay: Math.min(index * 30, 300)
                  })
                )
              );
            })(),

            // Albums tab
            collectionTab === 'albums' && (() => {
              // Show loading skeletons while collection is loading
              if (collectionLoading) {
                return React.createElement('div', {
                  className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-x-4 gap-y-5',
                  style: { minHeight: 'calc(100vh - 160px)' }
                },
                  Array.from({ length: 10 }).map((_, i) =>
                    React.createElement('div', { key: `album-skeleton-${i}`, className: 'animate-pulse' },
                      React.createElement('div', { className: 'aspect-square bg-gray-200 rounded-lg mb-3' }),
                      React.createElement('div', { className: 'h-4 bg-gray-200 rounded w-3/4 mb-2' }),
                      React.createElement('div', { className: 'h-3 bg-gray-200 rounded w-1/2' })
                    )
                  )
                );
              }

              const filtered = filterCollectionItems(collectionData.albums, 'albums');
              const sorted = sortCollectionItems(filtered, 'albums');

              if (sorted.length === 0 && collectionSearch) {
                return React.createElement('div', { className: 'flex-1 flex flex-col items-center justify-center text-gray-400 py-20' },
                  React.createElement('p', { className: 'text-lg font-medium text-gray-500' }, 'No albums match your search')
                );
              }

              if (sorted.length === 0) {
                return React.createElement('div', { className: 'flex-1 flex flex-col items-center justify-center text-gray-400 py-20' },
                  React.createElement('svg', { className: 'w-16 h-16 mb-4 text-gray-300', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 1.5, d: 'M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3' })
                  ),
                  React.createElement('p', { className: 'text-lg font-medium text-gray-500 mb-2' }, 'No albums yet'),
                  React.createElement('p', { className: 'text-sm text-gray-400' }, 'Drag albums here to add them to your collection')
                );
              }

              return React.createElement('div', {
                className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-x-4 gap-y-5',
                style: { minHeight: 'calc(100vh - 160px)' }  // Ensure enough scroll area to prevent header bounce
              },
                sorted.map((album, index) =>
                  React.createElement(CollectionAlbumCard, {
                    key: `${album.title}-${album.artist}-${index}`,
                    album: { ...album, trackCount: collectionData.tracks.filter(t => t.artist === album.artist && t.album === album.title).length },
                    getAlbumArt: getAlbumArt,
                    onNavigate: () => handleCollectionAlbumClick(album),
                    animationDelay: Math.min(index * 30, 300)
                  })
                )
              );
            })(),

            // Tracks tab (existing implementation with filter/sort applied)
            collectionTab === 'tracks' && (() => {
              if (libraryLoading || collectionLoading) {
                // Skeleton loaders while loading - matches new rounded row style
                return React.createElement('div', { className: 'space-y-0' },
                  Array.from({ length: 8 }).map((_, index) =>
                    React.createElement('div', {
                      key: `skeleton-${index}`,
                      className: 'flex items-center gap-4 py-3 px-4',
                      style: { borderRadius: '8px', marginBottom: '2px' }
                    },
                      // Track number skeleton
                      React.createElement('div', {
                        className: 'h-3 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer',
                        style: { width: '24px', flexShrink: 0 }
                      }),
                      // Title skeleton
                      React.createElement('div', {
                        className: 'h-3.5 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer',
                        style: { width: '360px', flexShrink: 0, animationDelay: '0.1s' }
                      }),
                      // Artist skeleton
                      React.createElement('div', {
                        className: 'h-3.5 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer',
                        style: { width: '220px', flexShrink: 0, animationDelay: '0.2s' }
                      }),
                      // Album skeleton
                      React.createElement('div', {
                        className: 'h-3.5 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer',
                        style: { width: '150px', flexShrink: 0, animationDelay: '0.3s' }
                      }),
                      // Spacer
                      React.createElement('div', { className: 'flex-1' }),
                      // Duration skeleton
                      React.createElement('div', {
                        className: 'h-3 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer',
                        style: { width: '50px', flexShrink: 0, marginRight: '16px', animationDelay: '0.4s' }
                      }),
                      // Resolver icons skeleton
                      React.createElement('div', {
                        className: 'flex items-center gap-1 justify-end',
                        style: { width: '100px', flexShrink: 0 }
                      },
                        React.createElement('div', {
                          className: 'w-5 h-5 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer',
                          style: { animationDelay: '0.5s' }
                        }),
                        React.createElement('div', {
                          className: 'w-5 h-5 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded animate-shimmer',
                          style: { animationDelay: '0.6s' }
                        })
                      )
                    )
                  )
                );
              }

              // Merge local files with collection tracks
              const allTracks = [...library, ...collectionData.tracks];

              // Deduplicate by id
              const trackMap = new Map();
              allTracks.forEach(track => {
                const trackId = track.id || `${track.artist || 'unknown'}-${track.title || 'untitled'}-${track.album || 'noalbum'}`.toLowerCase().replace(/[^a-z0-9-]/g, '');
                if (!trackMap.has(trackId)) {
                  trackMap.set(trackId, { ...track, id: trackId });
                }
              });

              const mergedTracks = Array.from(trackMap.values());

              const filtered = filterCollectionItems(mergedTracks, 'tracks');
              const sorted = sortCollectionItems(filtered, 'tracks');

              if (sorted.length === 0 && collectionSearch) {
                return React.createElement('div', { className: 'text-center py-12 text-gray-400' },
                  React.createElement('svg', { className: 'w-12 h-12 mx-auto mb-4 text-gray-300', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 1.5, d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' })
                  ),
                  React.createElement('div', { className: 'text-sm' }, 'No tracks match your search')
                );
              }

              if (sorted.length === 0) {
                return React.createElement('div', { className: 'flex-1 flex flex-col items-center justify-center text-gray-400 py-20' },
                  React.createElement('svg', { className: 'w-16 h-16 mb-4 text-gray-300', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 1.5, d: 'M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3' })
                  ),
                  React.createElement('p', { className: 'text-lg font-medium text-gray-500 mb-2' }, 'No tracks yet'),
                  React.createElement('p', { className: 'text-sm text-gray-400' }, 'Drag tracks here or add local music folders in Settings')
                );
              }

              return React.createElement('div', {
                className: 'space-y-0',
                style: { minHeight: 'calc(100vh - 160px)' }  // Ensure enough scroll area to prevent header bounce
              },
                sorted.map((track, index) => {
                  // Use track's own sources (updated by resolution)
                  const effectiveSources = track.sources || {};
                  const hasResolved = Object.keys(effectiveSources).length > 0;
                  const isCurrentTrack = currentTrack?.id === track.id || (currentTrack?.filePath && track.filePath && currentTrack.filePath === track.filePath);
                  const isNowPlaying = isCurrentTrack && playbackContext?.type === 'library';
                  const isResolving = Object.keys(effectiveSources).length === 0;

                  return React.createElement('div', {
                    ref: (el) => {
                      if (el) {
                        collectionTrackRowRefs.current.set(track.id, el);
                        // Also observe if observer exists
                        if (collectionObserverRef.current) {
                          collectionObserverRef.current.observe(el);
                        }
                      } else {
                        collectionTrackRowRefs.current.delete(track.id);
                      }
                    },
                    'data-track-id': track.id,
                    key: track.id || track.filePath || index,
                    draggable: true,
                    onDragStart: (e) => {
                      setDraggingTrackForPlaylist(track);
                      e.dataTransfer.effectAllowed = 'copy';
                      e.dataTransfer.setData('text/plain', JSON.stringify({
                        type: 'track',
                        track: {
                          id: track.id,
                          title: track.title,
                          artist: track.artist,
                          album: track.album,
                          duration: track.duration,
                          albumArt: track.albumArt,
                          sources: track.sources || {}
                        }
                      }));
                    },
                    onDragEnd: () => {
                      setDraggingTrackForPlaylist(null);
                      setDropTargetPlaylistId(null);
                      setDropTargetNewPlaylist(false);
                      if (addToPlaylistPanel.open && selectedPlaylistsForAdd.length === 0) {
                        setAddToPlaylistPanel(prev => ({ ...prev, open: false }));
                      }
                    },
                    className: `flex items-center gap-4 py-3 px-4 cursor-grab active:cursor-grabbing transition-all no-drag group ${
                      isNowPlaying && isPlaying ? 'bg-purple-50' : 'hover:bg-gray-50/80'
                    }`,
                    style: {
                      borderRadius: '8px',
                      marginBottom: '2px'
                    },
                    onClick: () => {
                      const tracksAfter = sorted.slice(index + 1);
                      const context = { type: 'library', name: 'Collection' };
                      setQueueWithContext(tracksAfter, context);
                      handlePlay(track);
                    },
                    onContextMenu: (e) => {
                      e.preventDefault();
                      if (window.electron?.contextMenu?.showTrackMenu) {
                        window.electron.contextMenu.showTrackMenu({
                          type: 'track',
                          track: track,
                          isInCollection: true  // Collection tracks are always in collection
                        });
                      }
                    }
                  },
                    // Track number or playing indicator
                    React.createElement('span', {
                      className: 'w-6 flex-shrink-0 text-right',
                      style: {
                        pointerEvents: 'none',
                        fontSize: '12px',
                        fontWeight: '500',
                        color: isNowPlaying && isPlaying ? '#8b5cf6' : '#9ca3af'
                      }
                    }, isNowPlaying && isPlaying ? 'â–¶' : String(index + 1).padStart(2, '0')),

                    // Track title - fixed width column
                    React.createElement('span', {
                      className: 'truncate transition-colors',
                      style: {
                        pointerEvents: 'none',
                        width: '360px',
                        flexShrink: 0,
                        fontSize: '13px',
                        fontWeight: isNowPlaying && isPlaying ? '500' : '400',
                        color: isNowPlaying && isPlaying ? '#7c3aed' : '#374151'
                      }
                    }, track.title),

                    // Artist name - fixed width column, clickable
                    React.createElement('span', {
                      className: 'truncate hover:text-purple-600 hover:underline cursor-pointer transition-colors',
                      style: {
                        width: '220px',
                        flexShrink: 0,
                        fontSize: '13px',
                        color: '#6b7280'
                      },
                      onClick: (e) => {
                        e.stopPropagation();
                        fetchArtistData(track.artist);
                      }
                    }, track.artist || 'Unknown Artist'),

                    // Album name - fixed width column, clickable
                    track.album ? React.createElement('span', {
                      className: 'truncate hover:text-purple-600 hover:underline cursor-pointer transition-colors',
                      style: {
                        width: '150px',
                        flexShrink: 0,
                        fontSize: '13px',
                        color: '#6b7280'
                      },
                      onClick: (e) => {
                        e.stopPropagation();
                        openChartsAlbum({ artist: track.artist, title: track.album, albumArt: track.albumArt });
                      }
                    }, track.album) : React.createElement('span', {
                      className: 'truncate',
                      style: {
                        pointerEvents: 'none',
                        width: '150px',
                        flexShrink: 0,
                        fontSize: '13px',
                        color: '#6b7280'
                      }
                    }, ''),

                    // Spacer to push duration and resolvers to the right
                    React.createElement('div', { className: 'flex-1' }),

                    // Duration - right-justified before resolver icons
                    React.createElement('span', {
                      className: 'flex-shrink-0 tabular-nums',
                      style: {
                        pointerEvents: 'none',
                        width: '50px',
                        marginLeft: 'auto',
                        marginRight: '16px',
                        fontSize: '12px',
                        color: '#9ca3af',
                        textAlign: 'right'
                      }
                    }, formatTime(track.duration)),

                    // Resolver icons - fixed width column (last column)
                    React.createElement('div', {
                      className: 'flex items-center gap-1 flex-shrink-0',
                      style: { pointerEvents: 'none', minHeight: '20px', width: '100px', justifyContent: 'flex-end' }
                    },
                      (() => {
                        const sources = effectiveSources;
                        const sourceIds = Object.keys(sources);
                        const hasExternalSources = sourceIds.some(id => id !== 'localfiles');

                        if (hasExternalSources) {
                          // Show all resolver icons (including LO)
                          return Object.entries(sources)
                            .sort(([aId], [bId]) => {
                              const aIndex = resolverOrder.indexOf(aId);
                              const bIndex = resolverOrder.indexOf(bId);
                              return aIndex - bIndex;
                            })
                            .map(([resolverId, source]) => {
                              const resolver = allResolvers.find(r => r.id === resolverId);
                              if (!resolver) return null;
                              return React.createElement('button', {
                                key: resolverId,
                                className: 'no-drag',
                                onClick: (e) => {
                                  e.stopPropagation();
                                  const tracksAfter = sorted.slice(index + 1);
                                  const context = { type: 'library', name: 'Collection' };
                                  setQueueWithContext(tracksAfter, context);
                                  handlePlay({ ...track, preferredResolver: resolverId });
                                },
                                style: {
                                  width: '20px',
                                  height: '20px',
                                  borderRadius: '4px',
                                  backgroundColor: resolver.color,
                                  border: 'none',
                                  cursor: 'pointer',
                                  display: 'flex',
                                  alignItems: 'center',
                                  justifyContent: 'center',
                                  pointerEvents: 'auto',
                                  opacity: (source.confidence || 1) > 0.8 ? 1 : 0.6,
                                  transition: 'transform 0.1s'
                                },
                                onMouseEnter: (e) => e.currentTarget.style.transform = 'scale(1.1)',
                                onMouseLeave: (e) => e.currentTarget.style.transform = 'scale(1)',
                                title: `Play from ${resolver.name}${source.confidence ? ` (${Math.round(source.confidence * 100)}% match)` : ''}`
                              }, React.createElement(ResolverIcon, { resolverId, size: 12 }));
                            });
                        } else if (isResolving) {
                          // Show shimmer skeletons while resolving (for both local and collection tracks)
                          const localFilesResolver = allResolvers.find(r => r.id === 'localfiles');
                          return React.createElement('div', { className: 'flex items-center gap-1' },
                            // LO icon only for local files
                            track.filePath && localFilesResolver && React.createElement('button', {
                              key: 'localfiles',
                              className: 'no-drag',
                              onClick: (e) => {
                                e.stopPropagation();
                                const tracksAfter = sorted.slice(index + 1);
                                const context = { type: 'library', name: 'Collection' };
                                setQueueWithContext(tracksAfter, context);
                                handlePlay({ ...track, preferredResolver: 'localfiles' });
                              },
                              style: {
                                width: '20px',
                                height: '20px',
                                borderRadius: '4px',
                                backgroundColor: localFilesResolver.color,
                                border: 'none',
                                cursor: 'pointer',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                fontSize: '9px',
                                fontWeight: 'bold',
                                color: 'white',
                                pointerEvents: 'auto',
                                transition: 'transform 0.1s'
                              },
                              onMouseEnter: (e) => e.currentTarget.style.transform = 'scale(1.1)',
                              onMouseLeave: (e) => e.currentTarget.style.transform = 'scale(1)',
                              title: 'Play from Local Files'
                            }, 'LO'),
                            // Shimmer skeletons
                            React.createElement('div', {
                              className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer',
                              title: 'Resolving...'
                            }),
                            React.createElement('div', {
                              className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer',
                              style: { animationDelay: '0.1s' }
                            })
                          );
                        } else if (track.filePath) {
                          // Show just the LO icon for local tracks that finished resolving without finding external sources
                          const localFilesResolver = allResolvers.find(r => r.id === 'localfiles');
                          if (!localFilesResolver) return null;
                          return React.createElement('button', {
                            key: 'localfiles',
                            className: 'no-drag',
                            onClick: (e) => {
                              e.stopPropagation();
                              const tracksAfter = sorted.slice(index + 1);
                              const context = { type: 'library', name: 'Collection' };
                              setQueueWithContext(tracksAfter, context);
                              handlePlay({ ...track, preferredResolver: 'localfiles' });
                            },
                            style: {
                              width: '20px',
                              height: '20px',
                              borderRadius: '4px',
                              backgroundColor: localFilesResolver.color,
                              border: 'none',
                              cursor: 'pointer',
                              display: 'flex',
                              alignItems: 'center',
                              justifyContent: 'center',
                              fontSize: '9px',
                              fontWeight: 'bold',
                              color: 'white',
                              pointerEvents: 'auto',
                              transition: 'transform 0.1s'
                            },
                            onMouseEnter: (e) => e.currentTarget.style.transform = 'scale(1.1)',
                            onMouseLeave: (e) => e.currentTarget.style.transform = 'scale(1)',
                            title: 'Play from Local Files'
                          }, 'LO');
                        }
                        return null;
                      })()
                    )
                  );
                })
              );
            })(),

            // Friends tab
            collectionTab === 'friends' && (() => {
              // Only show friends saved to collection (savedToCollection !== false for backwards compatibility)
              const savedFriends = friends.filter(f => f.savedToCollection !== false);

              // Sort friends
              const sortedFriends = [...savedFriends].sort((a, b) => {
                const sort = collectionSort.friends;
                if (sort === 'alpha-asc') return a.displayName.localeCompare(b.displayName);
                if (sort === 'alpha-desc') return b.displayName.localeCompare(a.displayName);
                if (sort === 'recent') return b.addedAt - a.addedAt;
                if (sort === 'on-air') {
                  const aOnAir = isOnAir(a);
                  const bOnAir = isOnAir(b);
                  if (aOnAir && !bOnAir) return -1;
                  if (!aOnAir && bOnAir) return 1;
                  // Secondary sort by most recent activity
                  const aTime = a.cachedRecentTrack?.timestamp || 0;
                  const bTime = b.cachedRecentTrack?.timestamp || 0;
                  return bTime - aTime;
                }
                return 0;
              });

              // Filter by search
              const filtered = collectionSearch
                ? sortedFriends.filter(f =>
                    f.displayName.toLowerCase().includes(collectionSearch.toLowerCase()) ||
                    f.username.toLowerCase().includes(collectionSearch.toLowerCase())
                  )
                : sortedFriends;

              // Filter to only on-air if that sort is selected
              const displayFriends = collectionSort.friends === 'on-air'
                ? filtered.filter(f => isOnAir(f))
                : filtered;

              if (displayFriends.length === 0 && collectionSearch) {
                return React.createElement('div', { className: 'flex-1 flex flex-col items-center justify-center text-gray-400 py-20' },
                  React.createElement('p', { className: 'text-lg font-medium text-gray-500' }, 'No friends match your search')
                );
              }

              if (displayFriends.length === 0 && collectionSort.friends === 'on-air') {
                return React.createElement('div', { className: 'flex-1 flex flex-col items-center justify-center text-gray-400 py-20' },
                  React.createElement('svg', { className: 'w-16 h-16 mb-4 text-gray-300', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 1.5, d: 'M5.636 18.364a9 9 0 010-12.728m12.728 0a9 9 0 010 12.728m-9.9-2.829a5 5 0 010-7.07m7.072 0a5 5 0 010 7.07M13 12a1 1 0 11-2 0 1 1 0 012 0z' })
                  ),
                  React.createElement('p', { className: 'text-lg font-medium text-gray-500 mb-2' }, 'No friends on air right now'),
                  React.createElement('p', { className: 'text-sm text-gray-400' }, 'Check back later to see who\'s listening')
                );
              }

              if (savedFriends.length === 0) {
                return React.createElement('div', { className: 'flex-1 flex flex-col items-center justify-center text-gray-400 py-20' },
                  React.createElement('svg', { className: 'w-16 h-16 mb-4 text-gray-300', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 1.5, d: 'M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z' })
                  ),
                  React.createElement('p', { className: 'text-lg font-medium text-gray-500 mb-2' }, 'No friends in collection'),
                  React.createElement('p', { className: 'text-sm text-gray-400 mb-4' }, 'Add friends to your collection to see them here'),
                  React.createElement('button', {
                    onClick: () => setAddFriendModalOpen(true),
                    className: 'px-4 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded-lg text-sm font-medium transition-colors'
                  }, 'Add Friend')
                );
              }

              return React.createElement('div', {
                style: { minHeight: 'calc(100vh - 160px)' }  // Ensure enough scroll area to prevent header bounce
              },
                // Grid of friend cards - Cinematic Light design
                React.createElement('div', {
                  className: 'grid gap-x-4 gap-y-5',
                  style: { gridTemplateColumns: 'repeat(auto-fill, minmax(150px, 1fr))' }
                },
                  displayFriends.map((friend, index) => {
                    const onAir = isOnAir(friend);
                    const isPinned = pinnedFriendIds.includes(friend.id);

                    return React.createElement('div', {
                      key: friend.id,
                      className: 'flex flex-col items-center cursor-pointer group release-card card-fade-up',
                      style: {
                        padding: '14px 12px',
                        borderRadius: '10px',
                        backgroundColor: '#ffffff',
                        boxShadow: '0 1px 3px rgba(0, 0, 0, 0.05), 0 4px 12px rgba(0, 0, 0, 0.03)',
                        animationDelay: `${Math.min(index * 30, 300)}ms`
                      },
                      draggable: true,
                      onDragStart: (e) => {
                        e.dataTransfer.setData('friendId', friend.id);
                        e.dataTransfer.effectAllowed = 'copy';
                      },
                      onClick: () => navigateToFriend(friend),
                      onContextMenu: (e) => {
                        e.preventDefault();
                        if (window.electron?.contextMenu?.showTrackMenu) {
                          window.electron.contextMenu.showTrackMenu({
                            type: 'friend',
                            friend: friend,
                            isPinned: isPinned,
                            isSavedToCollection: friend.savedToCollection
                          });
                        }
                      }
                    },
                      // Hexagonal avatar with border ring and hover effects
                      React.createElement('div', {
                        className: 'relative',
                        style: { width: '100px', height: '100px' }
                      },
                        // Outer hexagon border/ring
                        React.createElement('div', {
                          style: {
                            position: 'absolute',
                            inset: 0,
                            clipPath: 'polygon(50% 0%, 93.3% 25%, 93.3% 75%, 50% 100%, 6.7% 75%, 6.7% 25%)',
                            background: onAir
                              ? 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)'
                              : 'linear-gradient(135deg, rgba(0,0,0,0.08) 0%, rgba(0,0,0,0.04) 100%)',
                            transition: 'all 0.3s ease'
                          },
                          className: 'group-hover:scale-105'
                        }),
                        // Inner hexagon with avatar
                        React.createElement('div', {
                          style: {
                            position: 'absolute',
                            inset: '3px',
                            clipPath: 'polygon(50% 0%, 93.3% 25%, 93.3% 75%, 50% 100%, 6.7% 75%, 6.7% 25%)',
                            overflow: 'hidden'
                          }
                        },
                          React.createElement('div', {
                            className: 'group-hover:scale-110 transition-transform duration-300',
                            style: {
                              width: '100%',
                              height: '100%',
                              ...(friend.avatarUrl ? {
                                backgroundImage: `url(${friend.avatarUrl})`,
                                backgroundSize: 'cover',
                                backgroundPosition: 'center'
                              } : {
                                background: 'linear-gradient(145deg, #18181b 0%, #27272a 50%, #18181b 100%)'
                              })
                            }
                          },
                            // Show initial if no avatar
                            !friend.avatarUrl && React.createElement('div', {
                              style: {
                                width: '100%',
                                height: '100%',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                fontSize: '28px',
                                fontWeight: '500',
                                color: 'rgba(255, 255, 255, 0.4)',
                                letterSpacing: '0.02em'
                              }
                            }, friend.displayName.charAt(0).toUpperCase())
                          )
                        ),
                        // On-air pulse indicator
                        onAir && React.createElement('div', {
                          className: 'on-air-indicator',
                          style: {
                            position: 'absolute',
                            bottom: '4px',
                            right: '8px',
                            width: '14px',
                            height: '14px',
                            backgroundColor: '#22c55e',
                            borderRadius: '9999px',
                            border: '2.5px solid #ffffff'
                          }
                        })
                      ),
                      // Name and pin icon
                      React.createElement('div', {
                        style: {
                          marginTop: '10px',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          gap: '4px',
                          width: '100%'
                        }
                      },
                        React.createElement('span', {
                          style: {
                            fontSize: '13px',
                            fontWeight: '500',
                            color: '#1f2937',
                            textAlign: 'center',
                            overflow: 'hidden',
                            textOverflow: 'ellipsis',
                            whiteSpace: 'nowrap',
                            transition: 'color 0.2s ease'
                          },
                          className: ''
                        }, friend.displayName),
                        // Pin icon for manually pinned friends (not auto-pinned)
                        isPinned && !autoPinnedFriendIds.includes(friend.id) && React.createElement('svg', {
                          style: { width: '12px', height: '12px', color: '#a78bfa', flexShrink: 0 },
                          fill: 'currentColor',
                          viewBox: '0 0 24 24',
                          title: 'Pinned to sidebar'
                        },
                          React.createElement('path', { d: 'M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z' })
                        )
                      ),
                      // Service badge - refined
                      React.createElement('div', {
                        className: 'release-badge',
                        style: {
                          marginTop: '4px',
                          backgroundColor: friend.service === 'lastfm' ? 'rgba(239, 68, 68, 0.08)' : 'rgba(249, 115, 22, 0.08)',
                          color: friend.service === 'lastfm' ? '#dc2626' : '#ea580c'
                        }
                      }, friend.service === 'lastfm' ? 'Last.fm' : 'ListenBrainz'),
                      // Current track if on-air
                      onAir && friend.cachedRecentTrack && React.createElement('div', {
                        style: {
                          marginTop: '6px',
                          fontSize: '11px',
                          color: '#6b7280',
                          overflow: 'hidden',
                          textOverflow: 'ellipsis',
                          whiteSpace: 'nowrap',
                          textAlign: 'center',
                          maxWidth: '100%'
                        }
                      },
                        React.createElement('span', { style: { color: '#22c55e' } }, '\u266A '),
                        `${friend.cachedRecentTrack.name}`
                      )
                    );
                  })
                )
              );
            })()
            )
          )
        ),

        activeView === 'friends' && React.createElement('div', {
          className: 'text-center py-12 text-gray-400'
        }, 'ðŸ‘¥ Connect with friends to see what they\'re listening to'),

        // Charts view with collapsible hero header (matching Artist page pattern)
        activeView === 'discover' && React.createElement('div', {
          className: 'flex-1 flex flex-col h-full',
          style: { overflow: 'hidden', minHeight: 0 }
        },
          // Header section (outside scrollable area)
          React.createElement('div', {
            className: 'relative',
            style: {
              height: chartsHeaderCollapsed ? '80px' : '320px',
              flexShrink: 0,
              transition: 'height 300ms ease-out',
              overflow: 'hidden'
            }
          },
              // Gradient background
              React.createElement('div', {
                className: 'absolute inset-0 bg-gradient-to-br from-orange-500 via-pink-500 to-purple-600'
              }),
              // Background pattern
              React.createElement('div', {
                className: 'absolute inset-0',
                style: {
                  opacity: 0.15,
                  backgroundImage: 'url("data:image/svg+xml,%3Csvg width=\'60\' height=\'60\' viewBox=\'0 0 60 60\' xmlns=\'http://www.w3.org/2000/svg\'%3E%3Cg fill=\'none\' fill-rule=\'evenodd\'%3E%3Cg fill=\'%23ffffff\' fill-opacity=\'0.4\'%3E%3Cpath d=\'M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z\'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E")'
                }
              }),
              // EXPANDED STATE - Centered content
              !chartsHeaderCollapsed && React.createElement('div', {
                className: 'absolute inset-0 flex flex-col items-center justify-center text-center px-6 z-10',
                style: {
                  opacity: chartsHeaderCollapsed ? 0 : 1,
                  transition: 'opacity 300ms ease-out'
                }
              },
                React.createElement('h1', {
                  className: 'text-5xl font-light text-white',
                  style: {
                    textShadow: '0 2px 20px rgba(0,0,0,0.5)',
                    letterSpacing: '0.3em',
                    textTransform: 'uppercase'
                  }
                }, 'POP OF THE TOPS'),
                React.createElement('div', {
                  className: 'flex items-center gap-1 mt-6',
                  style: { textShadow: '0 1px 10px rgba(0,0,0,0.5)' }
                },
                  React.createElement('span', {
                    className: 'px-2 py-1 text-sm font-medium uppercase tracking-wider text-white'
                  }, `${charts.length} Albums`)
                ),
                React.createElement('p', {
                  className: 'mt-2 text-white/80 text-sm'
                }, 'Top 50 most played albums on Apple Music')
              ),
              // COLLAPSED STATE - Inline layout
              chartsHeaderCollapsed && React.createElement('div', {
                className: 'absolute inset-0 flex items-center px-6 z-10',
                style: {
                  opacity: chartsHeaderCollapsed ? 1 : 0,
                  transition: 'opacity 300ms ease-out'
                }
              },
                React.createElement('h1', {
                  className: 'text-2xl font-light text-white',
                  style: {
                    textShadow: '0 2px 10px rgba(0,0,0,0.5)',
                    letterSpacing: '0.2em',
                    textTransform: 'uppercase'
                  }
                }, 'POP OF THE TOPS'),
                React.createElement('div', { className: 'flex-1' }),
                React.createElement('span', {
                  className: 'text-sm font-medium uppercase tracking-wider text-white/80'
                }, `${charts.length} Albums`)
              )
          ),
          // Filter bar (outside scrollable area)
          React.createElement('div', {
            className: 'flex items-center px-6 py-3 bg-white border-b border-gray-200',
            style: { flexShrink: 0 }
          },
            // Sort dropdown
              React.createElement('div', { className: 'relative' },
                React.createElement('button', {
                  onClick: (e) => { e.stopPropagation(); setChartsSortDropdownOpen(!chartsSortDropdownOpen); },
                  className: 'flex items-center gap-1 px-3 py-1.5 text-sm text-gray-500 hover:text-gray-700 transition-colors'
                },
                  React.createElement('span', null, chartsSortOptions.find(o => o.value === chartsSort)?.label || 'Sort'),
                  React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M19 9l-7 7-7-7' })
                  )
                ),
                chartsSortDropdownOpen && React.createElement('div', {
                  className: 'absolute left-0 top-full mt-1 bg-white rounded-lg shadow-lg py-1 min-w-[160px] z-30 border border-gray-200'
                },
                  chartsSortOptions.map(option =>
                    React.createElement('button', {
                      key: option.value,
                      onClick: (e) => {
                        e.stopPropagation();
                        setChartsSort(option.value);
                        setChartsSortDropdownOpen(false);
                      },
                      className: `w-full px-4 py-2 text-left text-sm hover:bg-gray-100 flex items-center justify-between ${
                        chartsSort === option.value ? 'text-gray-900 font-medium' : 'text-gray-600'
                      }`
                    },
                      option.label,
                      chartsSort === option.value && React.createElement('svg', {
                        className: 'w-4 h-4',
                        fill: 'none',
                        viewBox: '0 0 24 24',
                        stroke: 'currentColor'
                      },
                        React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M5 13l4 4L19 7' })
                      )
                    )
                  )
                )
              ),
              React.createElement('div', { className: 'flex-1' }),
              // Search
              React.createElement('div', { className: 'flex items-center' },
                chartsSearchOpen ?
                  React.createElement('div', { className: 'flex items-center border border-gray-300 rounded-full px-3 py-1.5' },
                    React.createElement('input', {
                      type: 'text',
                      value: chartsSearch,
                      onChange: (e) => setChartsSearch(e.target.value),
                      onBlur: () => { if (!chartsSearch.trim()) setChartsSearchOpen(false); },
                      autoFocus: true,
                      placeholder: 'Filter...',
                      className: 'bg-transparent text-gray-700 text-sm placeholder-gray-400 outline-none',
                      style: { width: '150px' }
                    }),
                    chartsSearch && React.createElement('button', {
                      onClick: () => { setChartsSearch(''); setChartsSearchOpen(false); },
                      className: 'ml-2 text-gray-400 hover:text-gray-600'
                    },
                      React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                        React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M6 18L18 6M6 6l12 12' })
                      )
                    )
                  )
                :
                  React.createElement('button', {
                    onClick: () => setChartsSearchOpen(true),
                    className: 'p-1.5 text-gray-400 hover:text-gray-600 transition-colors'
                  },
                    React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                      React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' })
                    )
                  )
              )
          ),
          // Content area (scrollable)
          React.createElement('div', {
            className: 'scrollable-content',
            style: {
              flex: 1,
              overflowY: 'scroll',
              pointerEvents: 'auto',
              padding: '24px'
            },
            onScroll: handleChartsScroll
          },
            // Skeleton loading state - show when loading OR when charts haven't been loaded yet
            (chartsLoading || !chartsLoaded) && React.createElement('div', {
              className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4 pb-6'
            },
              Array.from({ length: 15 }).map((_, i) =>
                React.createElement('div', { key: `skeleton-${i}` },
                  // Skeleton album art
                  React.createElement('div', {
                    className: 'aspect-square rounded-lg mb-3 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                    style: { backgroundSize: '200% 100%', animationDelay: `${i * 50}ms` }
                  }),
                  // Skeleton title
                  React.createElement('div', { className: 'space-y-2' },
                    React.createElement('div', {
                      className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-3/4 animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 25}ms` }
                    }),
                    React.createElement('div', {
                      className: 'h-3 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-1/2 animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 50}ms` }
                    })
                  )
                )
              )
            ),

            // Albums grid with filter/sort - only show when loaded and not loading
            chartsLoaded && !chartsLoading && (() => {
              const filtered = filterCharts(charts);
              const sorted = sortCharts(filtered);

              if (sorted.length === 0 && chartsSearch) {
                return React.createElement('div', { className: 'text-center py-12 text-gray-400' },
                  React.createElement('svg', { className: 'w-12 h-12 mx-auto mb-4 text-gray-300', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 1.5, d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' })
                  ),
                  React.createElement('div', { className: 'text-sm' }, 'No albums match your search')
                );
              }

              if (sorted.length === 0) {
                return React.createElement('div', { className: 'text-center py-12 text-gray-400' },
                  React.createElement('div', { className: 'text-sm' }, 'No chart data available')
                );
              }

              return React.createElement('div', {
                className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-x-4 gap-y-5 pb-6'
              },
                sorted.map((album, index) =>
                React.createElement('div', {
                  key: album.id,
                  className: 'group cursor-pointer release-card card-fade-up',
                  style: {
                    padding: '10px',
                    borderRadius: '10px',
                    backgroundColor: '#ffffff',
                    border: 'none',
                    boxShadow: '0 1px 3px rgba(0, 0, 0, 0.05), 0 4px 12px rgba(0, 0, 0, 0.03)',
                    animationDelay: `${Math.min(index * 30, 300)}ms`
                  },
                  onMouseEnter: () => prefetchChartsTracks(album),
                  onClick: () => openChartsAlbum(album)
                },
                  // Album art with hover overlay - Cinematic Light design
                  React.createElement('div', {
                    className: `album-art-container ${album.albumArt === null ? '' : album.albumArt === undefined ? 'animate-shimmer' : ''}`,
                    style: {
                      aspectRatio: '1',
                      borderRadius: '6px',
                      overflow: 'hidden',
                      marginBottom: '10px',
                      position: 'relative',
                      background: album.albumArt === null
                        ? 'linear-gradient(145deg, #1f1f1f 0%, #2d2d2d 50%, #1a1a1a 100%)'
                        : album.albumArt === undefined
                          ? 'linear-gradient(to right, #f3f4f6, #e5e7eb, #f3f4f6)'
                          : '#f3f4f6',
                      backgroundSize: album.albumArt === undefined ? '200% 100%' : undefined
                    }
                  },
                    // Placeholder - only show when no art (null or missing)
                    !album.albumArt && album.albumArt !== undefined && React.createElement('div', {
                      style: { position: 'absolute', inset: 0, display: 'flex', alignItems: 'center', justifyContent: 'center' }
                    },
                      React.createElement('svg', {
                        style: { width: '40px', height: '40px', color: 'rgba(255, 255, 255, 0.2)' },
                        fill: 'none',
                        viewBox: '0 0 24 24',
                        stroke: 'currentColor',
                        strokeWidth: 1
                      },
                        React.createElement('circle', { cx: 12, cy: 12, r: 10 }),
                        React.createElement('circle', { cx: 12, cy: 12, r: 3 }),
                        React.createElement('circle', { cx: 12, cy: 12, r: 6, strokeDasharray: '2 2' })
                      )
                    ),
                    album.albumArt && typeof album.albumArt === 'string' && React.createElement('img', {
                      src: album.albumArt,
                      alt: album.title,
                      style: {
                        position: 'absolute',
                        inset: 0,
                        width: '100%',
                        height: '100%',
                        objectFit: 'cover',
                        opacity: 0,
                        transition: 'opacity 0.35s ease-out, transform 0.3s ease'
                      },
                      className: 'group-hover:scale-105',
                      ref: (el) => { if (el && el.complete && el.naturalWidth > 0) el.style.opacity = '1'; },
                      onLoad: (e) => { e.target.style.opacity = '1'; },
                      onError: (e) => { e.target.style.display = 'none'; }
                    }),
                    // Rank badge - refined
                    React.createElement('div', {
                      style: {
                        position: 'absolute',
                        top: '8px',
                        right: '8px',
                        padding: '3px 8px',
                        borderRadius: '4px',
                        backgroundColor: 'rgba(0, 0, 0, 0.75)',
                        color: '#ffffff',
                        fontSize: '11px',
                        fontWeight: '600',
                        letterSpacing: '0.02em'
                      }
                    }, `#${album.rank}`),
                    // Hover overlay with action buttons (Add to Playlist, Play, Queue)
                    React.createElement('div', {
                      className: 'opacity-0 group-hover:opacity-100',
                      style: {
                        position: 'absolute',
                        inset: 0,
                        backgroundColor: 'rgba(0, 0, 0, 0.5)',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        gap: '12px',
                        transition: 'opacity 0.2s ease'
                      }
                    },
                      // Add to Playlist button
                      React.createElement('button', {
                        onClick: async (e) => {
                          e.stopPropagation();
                          const prefetched = prefetchedReleases[album.id];
                          if (prefetched?.tracks?.length > 0) {
                            setAddToPlaylistPanel({
                              open: true,
                              tracks: prefetched.tracks,
                              sourceName: album.title,
                              sourceType: 'album'
                            });
                          }
                        },
                        className: 'w-10 h-10 rounded-full flex items-center justify-center transition-all hover:scale-110',
                        style: { backgroundColor: 'rgba(255, 255, 255, 0.15)', color: '#ffffff', border: 'none', cursor: 'pointer' },
                        onMouseEnter: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.25)',
                        onMouseLeave: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.15)',
                        title: 'Add to Playlist'
                      },
                        React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor', strokeWidth: 2 },
                          React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', d: 'M12 4v16m8-8H4' })
                        )
                      ),
                      // Play button (center, larger)
                      React.createElement('button', {
                        onClick: async (e) => {
                          e.stopPropagation();
                          setTrackLoading(true);
                          let tracks = prefetchedReleases[album.id]?.tracks;
                          if (!tracks?.length) {
                            // If not prefetched yet, fetch and play
                            await prefetchChartsTracks(album);
                            tracks = prefetchedReleases[album.id]?.tracks;
                          }
                          if (tracks?.length > 0) {
                            const context = { type: 'album', id: album.id, name: album.title, artist: album.artist };
                            const [firstTrack, ...remainingTracks] = tracks;
                            // Tag the first track with context so queue navigation works correctly
                            const taggedFirstTrack = { ...firstTrack, _playbackContext: context };
                            setQueueWithContext(remainingTracks, context);
                            handlePlay(taggedFirstTrack);
                          } else {
                            setTrackLoading(false);
                          }
                        },
                        className: 'w-12 h-12 bg-white rounded-full flex items-center justify-center shadow-lg transition-all hover:scale-110',
                        style: { border: 'none', cursor: 'pointer' },
                        title: 'Play'
                      },
                        React.createElement(Play, { size: 22, className: 'text-gray-800 ml-0.5' })
                      ),
                      // Add to Queue button
                      React.createElement('button', {
                        onClick: (e) => {
                          e.stopPropagation();
                          addChartsToQueue(album);
                        },
                        className: 'w-10 h-10 rounded-full flex items-center justify-center transition-all hover:scale-110',
                        style: { backgroundColor: 'rgba(255, 255, 255, 0.15)', color: '#ffffff', border: 'none', cursor: 'pointer' },
                        onMouseEnter: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.25)',
                        onMouseLeave: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.15)',
                        title: 'Add to Queue'
                      },
                        React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor', strokeWidth: 2 },
                          React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', d: 'M4 6h16M4 12h16M4 18h7' })
                        )
                      )
                    )
                  ),
                  // Album info - refined typography
                  React.createElement('div', null,
                    React.createElement('div', {
                      style: {
                        fontWeight: '500',
                        fontSize: '13px',
                        color: '#1f2937',
                        overflow: 'hidden',
                        textOverflow: 'ellipsis',
                        whiteSpace: 'nowrap',
                        marginBottom: '2px',
                        transition: 'color 0.2s ease'
                      },
                      className: ''
                    }, album.title),
                    React.createElement('div', {
                      style: {
                        fontSize: '12px',
                        color: '#6b7280',
                        overflow: 'hidden',
                        textOverflow: 'ellipsis',
                        whiteSpace: 'nowrap',
                        cursor: 'pointer',
                        transition: 'color 0.2s ease'
                      },
                      className: 'hover:text-purple-600',
                      onClick: (e) => {
                        e.stopPropagation();
                        fetchArtistData(album.artist);
                      }
                    }, album.artist)
                  )
                )
              )
              );
            })()
          )
        ),

        // New Releases view with hero
        activeView === 'new-releases' && React.createElement('div', {
          className: 'h-full overflow-y-auto scrollable-content'
        },
          // Hero section
          React.createElement('div', {
            className: 'relative h-64 bg-gradient-to-br from-emerald-500 via-teal-500 to-cyan-600 overflow-hidden'
          },
            // Background pattern - sparkles
            React.createElement('div', {
              className: 'absolute inset-0 opacity-30',
              style: {
                backgroundImage: 'url("data:image/svg+xml,%3Csvg width=\'100\' height=\'100\' viewBox=\'0 0 100 100\' xmlns=\'http://www.w3.org/2000/svg\'%3E%3Cg fill=\'%23ffffff\'%3E%3Ccircle cx=\'25\' cy=\'25\' r=\'2\'/%3E%3Ccircle cx=\'75\' cy=\'25\' r=\'1.5\'/%3E%3Ccircle cx=\'50\' cy=\'50\' r=\'2.5\'/%3E%3Ccircle cx=\'25\' cy=\'75\' r=\'1.5\'/%3E%3Ccircle cx=\'75\' cy=\'75\' r=\'2\'/%3E%3Ccircle cx=\'10\' cy=\'50\' r=\'1\'/%3E%3Ccircle cx=\'90\' cy=\'50\' r=\'1\'/%3E%3C/g%3E%3C/svg%3E")'
              }
            }),
            // Hero content
            React.createElement('div', {
              className: 'absolute inset-0 flex items-end p-8'
            },
              React.createElement('div', null,
                React.createElement('div', {
                  className: 'inline-flex items-center gap-2 px-3 py-1 bg-white/20 backdrop-blur-sm rounded-full text-white/90 text-sm mb-3'
                },
                  React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z' })
                  ),
                  'Fresh Music'
                ),
                React.createElement('h1', { className: 'text-4xl font-light text-white mb-2', style: { letterSpacing: '0.2em', textTransform: 'uppercase' } }, 'NEW RELEASES'),
                React.createElement('p', { className: 'text-white/80 text-lg' }, 'The latest albums and singles, just dropped')
              )
            )
          ),
          // Placeholder content
          React.createElement('div', { className: 'p-6' },
            React.createElement('div', { className: 'text-center py-12 text-gray-400' },
              React.createElement('div', { className: 'text-5xl mb-4' }, 'âœ¨'),
              React.createElement('div', { className: 'text-lg font-medium text-gray-600 mb-2' }, 'New Releases Coming Soon'),
              React.createElement('div', { className: 'text-sm' }, 'Stay tuned for the freshest music')
            )
          )
        ),

        // Critic's Picks view with collapsible hero header (matching Artist page pattern)
        activeView === 'critics-picks' && React.createElement('div', {
          className: 'flex-1 flex flex-col h-full',
          style: { overflow: 'hidden', minHeight: 0 }
        },
          // Header section (outside scrollable area)
          React.createElement('div', {
            className: 'relative',
            style: {
              height: criticsHeaderCollapsed ? '80px' : '320px',
              flexShrink: 0,
              transition: 'height 300ms ease-out',
              overflow: 'hidden'
            }
          },
              // Gradient background
              React.createElement('div', {
                className: 'absolute inset-0 bg-gradient-to-br from-amber-500 via-orange-500 to-red-500'
              }),
              // Background pattern
              React.createElement('div', {
                className: 'absolute inset-0',
                style: {
                  opacity: 0.15,
                  backgroundImage: 'url("data:image/svg+xml,%3Csvg width=\'80\' height=\'80\' viewBox=\'0 0 80 80\' xmlns=\'http://www.w3.org/2000/svg\'%3E%3Cg fill=\'%23ffffff\'%3E%3Cpath d=\'M40 5l4.5 13.8h14.5l-11.7 8.5 4.5 13.8L40 32.6l-11.8 8.5 4.5-13.8-11.7-8.5h14.5z\'/%3E%3C/g%3E%3C/svg%3E")'
                }
              }),
              // EXPANDED STATE - Centered content
              !criticsHeaderCollapsed && React.createElement('div', {
                className: 'absolute inset-0 flex flex-col items-center justify-center text-center px-6 z-10',
                style: {
                  opacity: criticsHeaderCollapsed ? 0 : 1,
                  transition: 'opacity 300ms ease-out'
                }
              },
                React.createElement('h1', {
                  className: 'text-5xl font-light text-white',
                  style: {
                    textShadow: '0 2px 20px rgba(0,0,0,0.5)',
                    letterSpacing: '0.3em',
                    textTransform: 'uppercase'
                  }
                }, 'CRITICAL DARLINGS'),
                React.createElement('div', {
                  className: 'flex items-center gap-1 mt-6',
                  style: { textShadow: '0 1px 10px rgba(0,0,0,0.5)' }
                },
                  React.createElement('span', {
                    className: 'px-2 py-1 text-sm font-medium uppercase tracking-wider text-white'
                  }, `${criticsPicks.length} Albums`)
                ),
                React.createElement('p', {
                  className: 'mt-2 text-white/80 text-sm'
                }, 'Top-rated albums from leading music publications')
              ),
              // COLLAPSED STATE - Inline layout
              criticsHeaderCollapsed && React.createElement('div', {
                className: 'absolute inset-0 flex items-center px-6 z-10',
                style: {
                  opacity: criticsHeaderCollapsed ? 1 : 0,
                  transition: 'opacity 300ms ease-out'
                }
              },
                React.createElement('h1', {
                  className: 'text-2xl font-light text-white',
                  style: {
                    textShadow: '0 2px 10px rgba(0,0,0,0.5)',
                    letterSpacing: '0.2em',
                    textTransform: 'uppercase'
                  }
                }, 'CRITICAL DARLINGS'),
                React.createElement('div', { className: 'flex-1' }),
                React.createElement('span', {
                  className: 'text-sm font-medium uppercase tracking-wider text-white/80'
                }, `${criticsPicks.length} Albums`)
              )
          ),
          // Filter bar (outside scrollable area)
          React.createElement('div', {
            className: 'flex items-center px-6 py-3 bg-white border-b border-gray-200',
            style: { flexShrink: 0 }
          },
            // Sort dropdown
              React.createElement('div', { className: 'relative' },
                React.createElement('button', {
                  onClick: (e) => { e.stopPropagation(); setCriticsSortDropdownOpen(!criticsSortDropdownOpen); },
                  className: 'flex items-center gap-1 px-3 py-1.5 text-sm text-gray-500 hover:text-gray-700 transition-colors'
                },
                  React.createElement('span', null, criticsSortOptions.find(o => o.value === criticsSort)?.label || 'Sort'),
                  React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M19 9l-7 7-7-7' })
                  )
                ),
                criticsSortDropdownOpen && React.createElement('div', {
                  className: 'absolute left-0 top-full mt-1 bg-white rounded-lg shadow-lg py-1 min-w-[160px] z-30 border border-gray-200'
                },
                  criticsSortOptions.map(option =>
                    React.createElement('button', {
                      key: option.value,
                      onClick: (e) => {
                        e.stopPropagation();
                        setCriticsSort(option.value);
                        setCriticsSortDropdownOpen(false);
                      },
                      className: `w-full px-4 py-2 text-left text-sm hover:bg-gray-100 flex items-center justify-between ${
                        criticsSort === option.value ? 'text-gray-900 font-medium' : 'text-gray-600'
                      }`
                    },
                      option.label,
                      criticsSort === option.value && React.createElement('svg', {
                        className: 'w-4 h-4',
                        fill: 'none',
                        viewBox: '0 0 24 24',
                        stroke: 'currentColor'
                      },
                        React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M5 13l4 4L19 7' })
                      )
                    )
                  )
                )
              ),
              React.createElement('div', { className: 'flex-1' }),
              // Search
              React.createElement('div', { className: 'flex items-center' },
                criticsSearchOpen ?
                  React.createElement('div', { className: 'flex items-center border border-gray-300 rounded-full px-3 py-1.5' },
                    React.createElement('input', {
                      type: 'text',
                      value: criticsSearch,
                      onChange: (e) => setCriticsSearch(e.target.value),
                      onBlur: () => { if (!criticsSearch.trim()) setCriticsSearchOpen(false); },
                      autoFocus: true,
                      placeholder: 'Filter...',
                      className: 'bg-transparent text-gray-700 text-sm placeholder-gray-400 outline-none',
                      style: { width: '150px' }
                    }),
                    criticsSearch && React.createElement('button', {
                      onClick: () => { setCriticsSearch(''); setCriticsSearchOpen(false); },
                      className: 'ml-2 text-gray-400 hover:text-gray-600'
                    },
                      React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                        React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M6 18L18 6M6 6l12 12' })
                      )
                    )
                  )
                :
                  React.createElement('button', {
                    onClick: () => setCriticsSearchOpen(true),
                    className: 'p-1.5 text-gray-400 hover:text-gray-600 transition-colors'
                  },
                    React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                      React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' })
                    )
                  )
              )
          ),
          // Content area (scrollable)
          React.createElement('div', {
            className: 'scrollable-content',
            style: {
              flex: 1,
              overflowY: 'scroll',
              pointerEvents: 'auto',
              padding: '24px'
            },
            onScroll: handleCriticsScroll
          },
            // Skeleton loading state - show when loading OR when critics picks haven't been loaded yet
            (criticsPicksLoading || !criticsPicksLoaded) && React.createElement('div', {
              className: 'space-y-4 pb-6'
            },
            Array.from({ length: 8 }).map((_, i) =>
              React.createElement('div', {
                key: `skeleton-${i}`,
                className: 'flex gap-5 p-4 bg-white rounded-xl border border-gray-100'
              },
                // Skeleton album art
                React.createElement('div', {
                  className: 'w-28 h-28 flex-shrink-0 rounded-lg bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                  style: { backgroundSize: '200% 100%', animationDelay: `${i * 50}ms` }
                }),
                // Skeleton content
                React.createElement('div', { className: 'flex-1 space-y-3 py-1' },
                  React.createElement('div', {
                    className: 'h-5 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-2/5 animate-shimmer',
                    style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 25}ms` }
                  }),
                  React.createElement('div', {
                    className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-1/4 animate-shimmer',
                    style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 50}ms` }
                  }),
                  React.createElement('div', { className: 'space-y-2 pt-2' },
                    React.createElement('div', {
                      className: 'h-3 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-full animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 75}ms` }
                    }),
                    React.createElement('div', {
                      className: 'h-3 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 rounded w-4/5 animate-shimmer',
                      style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 100}ms` }
                    })
                  )
                )
              )
            )
          ),

          // Albums grid with filter/sort - only show when loaded and not loading
          criticsPicksLoaded && !criticsPicksLoading && (() => {
            const filtered = filterCriticsPicks(criticsPicks);
            const sorted = sortCriticsPicks(filtered);

            if (sorted.length === 0 && criticsSearch) {
              return React.createElement('div', { className: 'text-center py-12 text-gray-400' },
                React.createElement('svg', { className: 'w-12 h-12 mx-auto mb-4 text-gray-300', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                  React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 1.5, d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' })
                ),
                React.createElement('div', { className: 'text-sm' }, 'No albums match your search')
              );
            }

            if (sorted.length === 0) {
              return React.createElement('div', { className: 'text-center py-12 text-gray-400' },
                React.createElement('div', { className: 'text-sm' }, 'No critic picks available')
              );
            }

            return React.createElement('div', {
              className: 'space-y-3 pb-6'
            },
              sorted.map((album, index) =>
              React.createElement('div', {
                key: album.id,
                className: 'group flex gap-4 cursor-grab active:cursor-grabbing release-card card-fade-up',
                style: {
                  padding: '12px',
                  borderRadius: '10px',
                  backgroundColor: '#ffffff',
                  border: 'none',
                  boxShadow: '0 1px 3px rgba(0, 0, 0, 0.05), 0 4px 12px rgba(0, 0, 0, 0.03)',
                  animationDelay: `${Math.min(index * 40, 400)}ms`
                },
                draggable: true,
                onDragStart: (e) => {
                  e.dataTransfer.effectAllowed = 'copy';
                  const albumData = {
                    type: 'album',
                    album: {
                      id: album.id,
                      title: album.title,
                      artist: album.artist,
                      year: album.pubDate ? album.pubDate.getFullYear() : null,
                      art: album.albumArt || null
                    }
                  };
                  e.dataTransfer.setData('text/plain', JSON.stringify(albumData));
                },
                onMouseEnter: () => prefetchCriticsPicksTracks(album),
                onClick: () => openCriticsPicksAlbum(album)
              },
                // Album art - left column - Cinematic Light design
                React.createElement('div', {
                  className: `album-art-container ${album.albumArt === undefined ? 'animate-shimmer' : ''}`,
                  style: {
                    width: '180px',
                    height: '180px',
                    flexShrink: 0,
                    borderRadius: '8px',
                    overflow: 'hidden',
                    position: 'relative',
                    background: album.albumArt === null
                      ? 'linear-gradient(145deg, #1f1f1f 0%, #2d2d2d 50%, #1a1a1a 100%)'
                      : album.albumArt === undefined
                        ? 'linear-gradient(to right, #f3f4f6, #e5e7eb, #f3f4f6)'
                        : '#f3f4f6',
                    backgroundSize: album.albumArt === undefined ? '200% 100%' : undefined
                  }
                },
                  // Placeholder icon - only show when art fetch completed with no result (null)
                  album.albumArt === null && React.createElement('div', {
                    style: { position: 'absolute', inset: 0, display: 'flex', alignItems: 'center', justifyContent: 'center' }
                  },
                    React.createElement('svg', {
                      style: { width: '32px', height: '32px', color: 'rgba(255, 255, 255, 0.2)' },
                      fill: 'none',
                      viewBox: '0 0 24 24',
                      stroke: 'currentColor',
                      strokeWidth: 1
                    },
                      React.createElement('circle', { cx: 12, cy: 12, r: 10 }),
                      React.createElement('circle', { cx: 12, cy: 12, r: 3 }),
                      React.createElement('circle', { cx: 12, cy: 12, r: 6, strokeDasharray: '2 2' })
                    )
                  ),
                  // Image - show when we have a URL string
                  typeof album.albumArt === 'string' && React.createElement('img', {
                    src: album.albumArt,
                    alt: album.title,
                    style: {
                      position: 'absolute',
                      inset: 0,
                      width: '100%',
                      height: '100%',
                      objectFit: 'cover',
                      opacity: 0,
                      transition: 'opacity 0.35s ease-out, transform 0.3s ease'
                    },
                    className: 'group-hover:scale-105',
                    ref: (el) => { if (el && el.complete && el.naturalWidth > 0) el.style.opacity = '1'; },
                    onLoad: (e) => { e.target.style.opacity = '1'; },
                    onError: (e) => { e.target.style.display = 'none'; }
                  }),
                  // Hover overlay with action buttons (Add to Playlist, Play, Queue)
                  React.createElement('div', {
                    className: 'opacity-0 group-hover:opacity-100',
                    style: {
                      position: 'absolute',
                      inset: 0,
                      backgroundColor: 'rgba(0, 0, 0, 0.5)',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      gap: '12px',
                      transition: 'opacity 0.2s ease'
                    }
                  },
                    // Add to Playlist button
                    React.createElement('button', {
                      onClick: async (e) => {
                        e.stopPropagation();
                        const prefetched = prefetchedReleases[album.id];
                        if (prefetched?.tracks?.length > 0) {
                          setAddToPlaylistPanel({
                            open: true,
                            tracks: prefetched.tracks,
                            sourceName: album.title,
                            sourceType: 'album'
                          });
                        }
                      },
                      className: 'w-10 h-10 rounded-full flex items-center justify-center transition-all hover:scale-110',
                      style: { backgroundColor: 'rgba(255, 255, 255, 0.15)', color: '#ffffff', border: 'none', cursor: 'pointer' },
                      onMouseEnter: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.25)',
                      onMouseLeave: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.15)',
                      title: 'Add to Playlist'
                    },
                      React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor', strokeWidth: 2 },
                        React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', d: 'M12 4v16m8-8H4' })
                      )
                    ),
                    // Play button (center, larger)
                    React.createElement('button', {
                      onClick: async (e) => {
                        e.stopPropagation();
                        setTrackLoading(true);
                        let tracks = prefetchedReleases[album.id]?.tracks;
                        if (!tracks?.length) {
                          await prefetchCriticsPicksTracks(album);
                          tracks = prefetchedReleases[album.id]?.tracks;
                        }
                        if (tracks?.length > 0) {
                          const context = { type: 'album', id: album.id, name: album.title, artist: album.artist };
                          const [firstTrack, ...remainingTracks] = tracks;
                          // Tag the first track with context so queue navigation works correctly
                          const taggedFirstTrack = { ...firstTrack, _playbackContext: context };
                          setQueueWithContext(remainingTracks, context);
                          handlePlay(taggedFirstTrack);
                        } else {
                          setTrackLoading(false);
                        }
                      },
                      className: 'w-12 h-12 bg-white rounded-full flex items-center justify-center shadow-lg transition-all hover:scale-110',
                      style: { border: 'none', cursor: 'pointer' },
                      title: 'Play'
                    },
                      React.createElement(Play, { size: 22, className: 'text-gray-800 ml-0.5' })
                    ),
                    // Add to Queue button
                    React.createElement('button', {
                      onClick: (e) => {
                        e.stopPropagation();
                        addCriticsPicksToQueue(album);
                      },
                      className: 'w-10 h-10 rounded-full flex items-center justify-center transition-all hover:scale-110',
                      style: { backgroundColor: 'rgba(255, 255, 255, 0.15)', color: '#ffffff', border: 'none', cursor: 'pointer' },
                      onMouseEnter: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.25)',
                      onMouseLeave: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.15)',
                      title: 'Add to Queue'
                    },
                      React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor', strokeWidth: 2 },
                        React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', d: 'M4 6h16M4 12h16M4 18h7' })
                      )
                    )
                  )
                ),
                // Album info - right column - refined typography
                React.createElement('div', {
                  style: { flex: 1, minWidth: 0, display: 'flex', flexDirection: 'column', justifyContent: 'center' }
                },
                  React.createElement('div', {
                    style: {
                      fontWeight: '500',
                      fontSize: '15px',
                      color: '#1f2937',
                      overflow: 'hidden',
                      textOverflow: 'ellipsis',
                      whiteSpace: 'nowrap',
                      transition: 'color 0.2s ease'
                    },
                    className: ''
                  }, album.title),
                  React.createElement('div', {
                    style: {
                      fontSize: '13px',
                      color: '#6b7280',
                      overflow: 'hidden',
                      textOverflow: 'ellipsis',
                      whiteSpace: 'nowrap',
                      marginTop: '2px',
                      cursor: 'pointer',
                      transition: 'color 0.2s ease'
                    },
                    className: 'hover:text-purple-600',
                    onClick: (e) => {
                      e.stopPropagation();
                      fetchArtistData(album.artist);
                    }
                  }, album.artist),
                  // Synopsis
                  album.description && React.createElement('p', {
                    style: {
                      fontSize: '12px',
                      color: '#9ca3af',
                      marginTop: '8px',
                      lineHeight: '1.5',
                      maxWidth: '400px',
                      display: '-webkit-box',
                      WebkitLineClamp: 2,
                      WebkitBoxOrient: 'vertical',
                      overflow: 'hidden'
                    }
                  }, album.description)
                )
              )
            )
            );
          })()
          )
        ),

        // Recommendations view with collapsible hero header
        activeView === 'recommendations' && React.createElement('div', {
          className: 'flex-1 flex flex-col h-full',
          style: { overflow: 'hidden', minHeight: 0 }
        },
          // Header section (outside scrollable area)
          React.createElement('div', {
            className: 'relative',
            style: {
              height: recommendationsHeaderCollapsed ? '80px' : '320px',
              flexShrink: 0,
              transition: 'height 300ms ease-out',
              overflow: 'hidden'
            }
          },
            // Gradient background - purple/indigo theme for recommendations
            React.createElement('div', {
              className: 'absolute inset-0 bg-gradient-to-br from-indigo-500 via-purple-500 to-pink-500'
            }),
            // Background pattern - stars for recommendations
            React.createElement('div', {
              className: 'absolute inset-0',
              style: {
                opacity: 0.15,
                backgroundImage: 'url("data:image/svg+xml,%3Csvg width=\'80\' height=\'80\' viewBox=\'0 0 80 80\' xmlns=\'http://www.w3.org/2000/svg\'%3E%3Cg fill=\'%23ffffff\'%3E%3Cpath d=\'M40 5l4.5 13.8h14.5l-11.7 8.5 4.5 13.8L40 32.6l-11.8 8.5 4.5-13.8-11.7-8.5h14.5z\'/%3E%3C/g%3E%3C/svg%3E")'
              }
            }),
            // EXPANDED STATE - Centered content
            !recommendationsHeaderCollapsed && React.createElement('div', {
              className: 'absolute inset-0 flex flex-col items-center justify-center text-center px-6 z-10',
              style: {
                opacity: recommendationsHeaderCollapsed ? 0 : 1,
                transition: 'opacity 300ms ease-out'
              }
            },
              React.createElement('h1', {
                className: 'text-5xl font-light text-white',
                style: {
                  textShadow: '0 2px 20px rgba(0,0,0,0.5)',
                  letterSpacing: '0.3em',
                  textTransform: 'uppercase'
                }
              }, 'RECOMMENDATIONS'),
              // Tabs in expanded state
              React.createElement('div', {
                className: 'flex items-center gap-1 mt-6',
                style: { textShadow: '0 1px 10px rgba(0,0,0,0.5)' }
              },
                [
                  { key: 'artists', label: `${recommendations.artists.length} Artists` },
                  { key: 'songs', label: `${recommendations.tracks.length} Songs` }
                ].map((tab, index) => [
                  index > 0 && React.createElement('span', {
                    key: `sep-expanded-${tab.key}`,
                    className: 'text-white/50 mx-2'
                  }, '|'),
                  React.createElement('button', {
                    key: `expanded-${tab.key}`,
                    onClick: () => setRecommendationsTab(tab.key),
                    className: `px-2 py-1 text-sm font-medium uppercase tracking-wider transition-colors no-drag ${
                      recommendationsTab === tab.key
                        ? 'text-white'
                        : 'text-white/60 hover:text-white'
                    }`
                  }, tab.label)
                ]).flat().filter(Boolean)
              ),
              React.createElement('p', {
                className: 'mt-2 text-white/70 text-sm'
              }, metaServiceConfigs.listenbrainz?.username
                ? `Personalized picks for ${metaServiceConfigs.listenbrainz.username}`
                : metaServiceConfigs.lastfm?.username
                  ? `Personalized picks for ${metaServiceConfigs.lastfm.username}`
                  : 'Connect your Last.fm or ListenBrainz account to get started'
              )
            ),
            // COLLAPSED STATE - Inline layout matching artist page
            recommendationsHeaderCollapsed && React.createElement('div', {
              className: 'absolute inset-0 flex items-center px-6 z-10',
              style: {
                opacity: recommendationsHeaderCollapsed ? 1 : 0,
                transition: 'opacity 300ms ease-out'
              }
            },
              // Left: Title
              React.createElement('h1', {
                className: 'text-2xl font-light text-white mr-6',
                style: {
                  textShadow: '0 2px 10px rgba(0,0,0,0.5)',
                  letterSpacing: '0.2em',
                  textTransform: 'uppercase'
                }
              }, 'RECOMMENDATIONS'),
              // Tabs (next to title, like artist page)
              React.createElement('div', {
                className: 'flex items-center gap-1',
                style: { textShadow: '0 1px 10px rgba(0,0,0,0.5)' }
              },
                [
                  { key: 'artists', label: `${recommendations.artists.length} Artists` },
                  { key: 'songs', label: `${recommendations.tracks.length} Songs` }
                ].map((tab, index) => [
                  index > 0 && React.createElement('span', {
                    key: `sep-collapsed-${tab.key}`,
                    className: 'text-white/50 mx-2'
                  }, '|'),
                  React.createElement('button', {
                    key: `collapsed-${tab.key}`,
                    onClick: () => setRecommendationsTab(tab.key),
                    className: `px-2 py-1 text-sm font-medium uppercase tracking-wider transition-colors no-drag ${
                      recommendationsTab === tab.key
                        ? 'text-white'
                        : 'text-white/60 hover:text-white'
                    }`
                  }, tab.label)
                ]).flat().filter(Boolean)
              )
            )
          ),
          // Scrollable content area
          (() => {
            // Check if both services are configured (show filter bar even while loading)
            const hasBothServicesConfigured = metaServiceConfigs.listenbrainz?.username && metaServiceConfigs.lastfm?.username;

            // Compute filtered recommendations data
            const listenbrainzTrackCount = recommendations.tracks.filter(t => t.source === 'listenbrainz').length;
            const lastfmTrackCount = recommendations.tracks.filter(t => t.source === 'lastfm').length;
            const hasBothSourcesWithData = listenbrainzTrackCount > 0 && lastfmTrackCount > 0;

            // Filter tracks based on source filter
            const filteredTracks = recommendationsSourceFilter === 'all'
              ? recommendations.tracks
              : recommendations.tracks.filter(t => t.source === recommendationsSourceFilter);

            // Get unique artists from filtered tracks
            const filteredArtistNames = new Set(filteredTracks.map(t => t.artist));
            const filteredArtists = recommendations.artists.filter(a => filteredArtistNames.has(a.name));

            return React.createElement('div', {
              ref: (el) => {
                recommendationsScrollContainerRef.current = el;
                if (el && !recommendationsScrollContainerReady) {
                  setRecommendationsScrollContainerReady(true);
                }
              },
              className: 'flex-1 overflow-y-auto scrollable-content',
              onScroll: (e) => {
                const scrollTop = e.target.scrollTop;
                if (scrollTop > 50 && !recommendationsHeaderCollapsed) {
                  setRecommendationsHeaderCollapsed(true);
                } else if (scrollTop <= 50 && recommendationsHeaderCollapsed) {
                  setRecommendationsHeaderCollapsed(false);
                }
              }
            },
              // Sticky filter bar - show when both services are configured (even during loading)
              hasBothServicesConfigured && React.createElement('div', {
                className: 'sticky top-0 z-10 flex items-center px-6 py-3 bg-white border-b border-gray-200'
              },
                // Source filter pills
                React.createElement('div', { className: 'flex gap-2' },
                  [
                    { value: 'all', label: 'All', count: recommendations.tracks.length },
                    { value: 'listenbrainz', label: 'ListenBrainz', count: listenbrainzTrackCount },
                    { value: 'lastfm', label: 'Last.fm', count: lastfmTrackCount }
                  ].map(({ value, label, count }) =>
                    React.createElement('button', {
                      key: value,
                      onClick: () => setRecommendationsSourceFilter(value),
                      className: `px-3 py-1.5 rounded-full text-sm transition-all no-drag ${
                        recommendationsSourceFilter === value
                          ? value === 'listenbrainz' ? 'bg-indigo-600 text-white'
                            : value === 'lastfm' ? 'bg-red-600 text-white'
                            : 'bg-purple-600 text-white'
                          : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                      }`
                    }, recommendations.loading ? label : `${label} (${count})`)
                  )
                )
              ),
              // Content with padding
              React.createElement('div', { className: 'p-6' },
                // Loading state - show skeleton for active tab
                recommendations.loading ?
              React.createElement('div', null,
                // Artists skeleton (when artists tab active) - square card design
                recommendationsTab === 'artists' && React.createElement('div', {
                  className: 'grid gap-4',
                  style: { gridTemplateColumns: 'repeat(auto-fill, minmax(160px, 1fr))' }
                },
                  ...Array(12).fill(null).map((_, i) =>
                    React.createElement('div', { key: `rec-artist-skeleton-${i}`, className: 'bg-white rounded-lg overflow-hidden' },
                      React.createElement('div', { className: 'aspect-square bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer', style: { backgroundSize: '200% 100%' } }),
                      React.createElement('div', { className: 'p-3' },
                        React.createElement('div', { className: 'w-3/4 h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer rounded', style: { backgroundSize: '200% 100%' } })
                      )
                    )
                  )
                ),
                // Songs skeleton (when songs tab active)
                recommendationsTab === 'songs' && React.createElement('div', { className: 'space-y-0' },
                  ...Array(15).fill(null).map((_, i) =>
                    React.createElement('div', {
                      key: `rec-track-skeleton-${i}`,
                      className: 'flex items-center gap-4 py-2 px-3 border-b border-gray-100'
                    },
                      React.createElement('div', {
                        className: 'w-8 h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                        style: { backgroundSize: '200% 100%', animationDelay: `${i * 50}ms` }
                      }),
                      React.createElement('div', {
                        className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                        style: { width: '360px', backgroundSize: '200% 100%', animationDelay: `${i * 50 + 25}ms` }
                      }),
                      React.createElement('div', {
                        className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                        style: { width: '240px', backgroundSize: '200% 100%', animationDelay: `${i * 50 + 50}ms` }
                      }),
                      React.createElement('div', {
                        className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                        style: { width: '50px', backgroundSize: '200% 100%', animationDelay: `${i * 50 + 75}ms` }
                      }),
                      React.createElement('div', {
                        className: 'flex gap-1 ml-auto',
                        style: { width: '100px' }
                      },
                        React.createElement('div', {
                          className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                          style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 100}ms` }
                        }),
                        React.createElement('div', {
                          className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                          style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 125}ms` }
                        })
                      )
                    )
                  )
                )
              )
            // Not configured state
            : recommendations.error === 'not_configured' ?
              React.createElement('div', { className: 'text-center py-16' },
                React.createElement('div', {
                  className: 'w-20 h-20 mx-auto mb-6 rounded-full bg-gray-100 flex items-center justify-center'
                },
                  React.createElement('svg', { className: 'w-10 h-10 text-gray-400', fill: 'currentColor', viewBox: '0 0 24 24' },
                    React.createElement('path', { d: 'M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z' })
                  )
                ),
                React.createElement('h3', {
                  className: 'text-xl font-medium text-gray-900 mb-2'
                }, 'Connect a music service'),
                React.createElement('p', { className: 'text-gray-500 mb-6 max-w-md mx-auto' },
                  'Get personalized music recommendations based on your listening history. Connect your Last.fm or ListenBrainz account to get started.'
                ),
                React.createElement('div', { className: 'flex gap-3 justify-center' },
                  React.createElement('button', {
                    onClick: () => {
                      setActiveView('settings');
                      setSettingsTab('installed');
                      // Find and select the ListenBrainz service
                      const listenbrainzService = metaServices.find(s => s.id === 'listenbrainz');
                      if (listenbrainzService) {
                        setSelectedResolver(listenbrainzService);
                      }
                    },
                    className: 'px-6 py-3 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors font-medium'
                  }, 'Connect ListenBrainz'),
                  React.createElement('button', {
                    onClick: () => {
                      setActiveView('settings');
                      setSettingsTab('installed');
                      // Find and select the Last.fm service
                      const lastfmService = metaServices.find(s => s.id === 'lastfm');
                      if (lastfmService) {
                        setSelectedResolver(lastfmService);
                      }
                    },
                    className: 'px-6 py-3 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors font-medium'
                  }, 'Connect Last.fm')
                )
              )
            // Other error state
            : recommendations.error ?
              React.createElement('div', { className: 'text-center py-12' },
                React.createElement('div', { className: 'text-gray-400 mb-4' }, recommendations.error),
                React.createElement('button', {
                  onClick: loadRecommendations,
                  className: 'px-4 py-2 bg-gray-900 text-white rounded-lg hover:bg-gray-800 transition-colors'
                }, 'Try Again')
              )
            // Results - show content based on active tab
            : React.createElement('div', null,
                // Artists tab content - Square card design with Play/Queue hover
                recommendationsTab === 'artists' && filteredArtists.length > 0 && React.createElement('div', {
                  className: 'grid gap-4',
                  style: { gridTemplateColumns: 'repeat(auto-fill, minmax(160px, 1fr))' }
                },
                  ...filteredArtists.map((artist, index) => {
                    const recsArtistPattern = generateArtistPattern(artist.name);
                    return React.createElement('div', {
                      key: artist.id,
                      className: 'bg-white rounded-lg overflow-hidden hover:shadow-lg transition-shadow cursor-pointer group release-card card-fade-up',
                      style: { animationDelay: `${Math.min(index * 30, 300)}ms` },
                      draggable: true,
                      onDragStart: (e) => {
                        e.dataTransfer.effectAllowed = 'copy';
                        e.dataTransfer.setData('text/plain', JSON.stringify({
                          type: 'artist',
                          artist: {
                            id: artist.id,
                            name: artist.name,
                            image: artist.image
                          }
                        }));
                      },
                      onClick: () => fetchArtistData(artist.name),
                      onContextMenu: (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        if (window.electron?.contextMenu?.showTrackMenu) {
                          window.electron.contextMenu.showTrackMenu({
                            type: 'artist',
                            artist: {
                              id: artist.id,
                              name: artist.name,
                              image: artist.image
                            }
                          });
                        }
                      }
                    },
                      // Square image container - gray while loading, pattern only when imageLoaded && no image
                      React.createElement('div', {
                        className: 'aspect-square relative group/art',
                        style: { background: artist.imageLoaded && !artist.image ? recsArtistPattern.gradient : '#e5e7eb' }
                      },
                        // Shimmer while loading (imageLoaded not yet true)
                        !artist.imageLoaded && React.createElement('div', {
                          className: 'absolute inset-0 bg-gradient-to-r from-gray-300 via-gray-200 to-gray-300 animate-shimmer',
                          style: { backgroundSize: '200% 100%' }
                        }),
                        // Initials fallback (only show when imageLoaded && no image)
                        artist.imageLoaded && !artist.image && React.createElement('div', {
                          className: 'absolute inset-0 flex items-center justify-center',
                          style: { color: recsArtistPattern.textColor, opacity: 0.4 }
                        },
                          React.createElement('span', {
                            className: 'font-bold tracking-wider',
                            style: { fontSize: '2.5rem', textShadow: '0 2px 8px rgba(0,0,0,0.3)' }
                          }, recsArtistPattern.initials)
                        ),
                        // Artist image
                        artist.image && React.createElement('img', {
                          src: artist.image,
                          alt: artist.name,
                          className: 'absolute inset-0 w-full h-full object-cover'
                        }),
                        // Hover overlay with Play and Queue buttons - Top 10 icons
                        React.createElement('div', {
                          className: 'absolute inset-0 bg-black/50 opacity-0 group-hover/art:opacity-100 transition-opacity duration-200 flex items-center justify-center gap-3',
                          style: { pointerEvents: 'auto' }
                        },
                          // Play top 10 button
                          React.createElement('button', {
                            onClick: async (e) => {
                              e.stopPropagation();
                              setTrackLoading(true);
                              const tracks = await getArtistTopTracks(artist.name);
                              if (tracks.length > 0) {
                                const context = { type: 'artist', name: artist.name };
                                const [firstTrack, ...remainingTracks] = tracks;
                                // Tag the first track with context so queue navigation works correctly
                                const taggedFirstTrack = { ...firstTrack, _playbackContext: context };
                                setQueueWithContext(remainingTracks, context);
                                handlePlay(taggedFirstTrack);
                              } else {
                                setTrackLoading(false);
                                showToast(`No top tracks found for ${artist.name}`, 'error');
                              }
                            },
                            className: 'w-12 h-12 bg-white rounded-full flex items-center justify-center shadow-lg transition-all hover:scale-110',
                            style: { border: 'none', cursor: 'pointer' },
                            title: 'Play top 10 tracks'
                          },
                            React.createElement(PlayTop10Icon, { size: 26, className: 'text-gray-800' })
                          ),
                          // Add top 10 to Queue button
                          React.createElement('button', {
                            onClick: async (e) => {
                              e.stopPropagation();
                              const tracks = await getArtistTopTracks(artist.name);
                              if (tracks.length > 0) {
                                addToQueue(tracks, { type: 'artist', name: artist.name });
                                showToast(`Added ${tracks.length} top tracks from ${artist.name} to queue`);
                              } else {
                                showToast(`No top tracks found for ${artist.name}`, 'error');
                              }
                            },
                            className: 'w-10 h-10 rounded-full flex items-center justify-center transition-all hover:scale-110',
                            style: { backgroundColor: 'rgba(255, 255, 255, 0.15)', color: '#ffffff', border: 'none', cursor: 'pointer' },
                            title: 'Add top 10 to queue'
                          },
                            React.createElement(QueueTop10Icon, { size: 20 })
                          )
                        )
                      ),
                      // Artist name
                      React.createElement('div', { className: 'p-3' },
                        React.createElement('p', {
                          className: 'font-medium text-gray-900 truncate text-sm transition-colors'
                        }, artist.name)
                      )
                    );
                  })
                ),

                // Artists tab empty state
                recommendationsTab === 'artists' && filteredArtists.length === 0 && React.createElement('div', {
                  className: 'text-center py-12 text-gray-400'
                }, recommendationsSourceFilter !== 'all' ? `No artists from ${recommendationsSourceFilter === 'listenbrainz' ? 'ListenBrainz' : 'Last.fm'}.` : 'No recommended artists found.'),

                // Songs tab content - track list table
                recommendationsTab === 'songs' && filteredTracks.length > 0 && React.createElement('div', { className: 'space-y-0' },
                  ...filteredTracks.map((track, index) => {
                      // Use track.id to look up resolved sources from trackSources state
                      const resolvedSources = trackSources[track.id] || track.sources || {};
                      const hasResolved = Object.keys(resolvedSources).length > 0;
                      const isResolving = Object.keys(resolvedSources).length === 0;

                      return React.createElement('div', {
                        key: track.id,
                        'data-track-id': track.id,
                        ref: (el) => {
                          if (el) {
                            recommendationsTrackRowRefs.current.set(track.id, el);
                            if (recommendationsObserverRef.current) {
                              recommendationsObserverRef.current.observe(el);
                            }
                          } else {
                            recommendationsTrackRowRefs.current.delete(track.id);
                          }
                        },
                        draggable: true,
                        onDragStart: (e) => {
                          setDraggingTrackForPlaylist(track); // Enable playlist drop target
                          e.dataTransfer.effectAllowed = 'copy';
                          e.dataTransfer.setData('text/plain', JSON.stringify({
                            type: 'track',
                            track: {
                              id: track.id,
                              title: track.title,
                              artist: track.artist,
                              duration: track.duration,
                              sources: track.sources || {}
                            }
                          }));
                        },
                        onDragEnd: () => {
                          setDraggingTrackForPlaylist(null);
                          setDropTargetPlaylistId(null);
                          setDropTargetNewPlaylist(false);
                          // Close panel if it was opened by drag and nothing was dropped
                          if (addToPlaylistPanel.open && selectedPlaylistsForAdd.length === 0) {
                            setAddToPlaylistPanel(prev => ({ ...prev, open: false }));
                          }
                        },
                        className: `flex items-center gap-4 py-3 px-4 cursor-grab active:cursor-grabbing transition-all group ${
                          isResolving ? 'opacity-60' : 'hover:bg-gray-50/80'
                        }`,
                        style: { borderRadius: '8px', marginBottom: '2px' },
                        onClick: () => {
                          // Set remaining tracks as queue and play this track
                          const tracksAfter = filteredTracks.slice(index + 1);
                          const context = { type: 'recommendations', name: 'Recommendations' };
                          setQueueWithContext(tracksAfter, context);
                          handlePlay(track);
                        },
                        onContextMenu: (e) => {
                          e.preventDefault();
                          if (window.electron?.contextMenu?.showTrackMenu) {
                            window.electron.contextMenu.showTrackMenu({
                              type: 'track',
                              track: track,
                              sourceType: 'recommendations',
                              sourceName: 'Recommendations'
                            });
                          }
                        }
                      },
                        // Track number
                        React.createElement('span', {
                          className: 'flex-shrink-0 text-right',
                          style: { pointerEvents: 'none', width: '32px', fontSize: '12px', fontWeight: '500', color: '#9ca3af' }
                        }, String(index + 1).padStart(2, '0')),

                        // Track title - fixed width column
                        React.createElement('span', {
                          className: 'truncate transition-colors',
                          style: { pointerEvents: 'none', width: '360px', flexShrink: 0, fontSize: '13px', fontWeight: '400', color: hasResolved ? '#374151' : '#9ca3af' }
                        }, track.title),

                        // Artist name - fixed width column, clickable
                        React.createElement('span', {
                          className: 'truncate hover:text-purple-600 hover:underline cursor-pointer transition-colors',
                          style: { width: '240px', flexShrink: 0, fontSize: '12px', color: '#6b7280' },
                          onClick: (e) => {
                            e.stopPropagation();
                            fetchArtistData(track.artist);
                          }
                        }, track.artist),

                        // Duration - fixed width column
                        React.createElement('span', {
                          className: 'text-right tabular-nums',
                          style: { pointerEvents: 'none', width: '50px', flexShrink: 0, marginLeft: 'auto', fontSize: '12px', color: '#9ca3af' }
                        }, formatTime(track.duration)),

                        // Resolver icons - fixed width column
                        React.createElement('div', {
                          className: 'flex items-center gap-1 justify-end',
                          style: { width: '100px', flexShrink: 0, minHeight: '24px' }
                        },
                          isResolving ?
                            React.createElement('div', {
                              className: 'flex items-center gap-1'
                            },
                              React.createElement('div', {
                                className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer',
                                title: 'Resolving track...'
                              }),
                              React.createElement('div', {
                                className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer',
                                style: { animationDelay: '0.1s' }
                              })
                            )
                          : hasResolved ?
                            Object.entries(resolvedSources)
                              .sort(([aId], [bId]) => {
                                const aIndex = resolverOrder.indexOf(aId);
                                const bIndex = resolverOrder.indexOf(bId);
                                return aIndex - bIndex;
                              })
                              .map(([resolverId, source]) => {
                                const resolver = allResolvers.find(r => r.id === resolverId);
                                if (!resolver || !resolver.play) return null;
                                return React.createElement('button', {
                                  key: resolverId,
                                  className: 'no-drag',
                                  onClick: (e) => {
                                    e.stopPropagation();
                                    const tracksAfter = recommendations.tracks.slice(index + 1);
                                    const context = { type: 'recommendations', name: 'Recommendations' };
                                    setQueueWithContext(tracksAfter, context);
                                    handlePlay({ ...track, preferredResolver: resolverId });
                                  },
                                  style: {
                                    width: '20px',
                                    height: '20px',
                                    borderRadius: '4px',
                                    backgroundColor: resolver.color,
                                    border: 'none',
                                    cursor: 'pointer',
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    pointerEvents: 'auto',
                                    opacity: (source.confidence || 0) > 0.8 ? 1 : 0.6,
                                    transition: 'transform 0.1s'
                                  },
                                  onMouseEnter: (e) => e.currentTarget.style.transform = 'scale(1.1)',
                                  onMouseLeave: (e) => e.currentTarget.style.transform = 'scale(1)',
                                  title: `Play from ${resolver.name}${source.confidence ? ` (${Math.round(source.confidence * 100)}% match)` : ''}`
                                }, React.createElement(ResolverIcon, { resolverId, size: 12 }));
                              })
                          :
                            // Show shimmer skeletons while resolving
                            React.createElement('div', {
                              className: 'flex items-center gap-1'
                            },
                              React.createElement('div', {
                                className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer',
                                title: 'Resolving track...'
                              }),
                              React.createElement('div', {
                                className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer',
                                style: { animationDelay: '0.1s' }
                              })
                            )
                        )
                      );
                    })
                ),

                // Songs tab empty state
                recommendationsTab === 'songs' && filteredTracks.length === 0 && React.createElement('div', {
                  className: 'text-center py-12 text-gray-400'
                }, recommendationsSourceFilter !== 'all' ? `No songs from ${recommendationsSourceFilter === 'listenbrainz' ? 'ListenBrainz' : 'Last.fm'}.` : 'No recommended songs found.')
              )
            )
          );
          })()
        ),

        // History view with collapsible hero header and tabs
        activeView === 'history' && React.createElement('div', {
          className: 'flex-1 flex flex-col h-full',
          style: { overflow: 'hidden', minHeight: 0 }
        },
          // Header section (outside scrollable area)
          React.createElement('div', {
            className: 'relative',
            style: {
              height: historyHeaderCollapsed ? '80px' : '320px',
              flexShrink: 0,
              transition: 'height 300ms ease-out',
              overflow: 'hidden'
            }
          },
            // Gradient background - blue/cyan theme for history
            React.createElement('div', {
              className: 'absolute inset-0 bg-gradient-to-br from-cyan-500 via-blue-500 to-indigo-600'
            }),
            // Background pattern - clock/time icons
            React.createElement('div', {
              className: 'absolute inset-0',
              style: {
                opacity: 0.15,
                backgroundImage: 'url("data:image/svg+xml,%3Csvg width=\'60\' height=\'60\' viewBox=\'0 0 60 60\' xmlns=\'http://www.w3.org/2000/svg\'%3E%3Cg fill=\'none\' stroke=\'%23ffffff\' stroke-width=\'1.5\'%3E%3Ccircle cx=\'30\' cy=\'30\' r=\'12\'/%3E%3Cpath d=\'M30 22v8l5 5\'/%3E%3C/g%3E%3C/svg%3E")'
              }
            }),
            // EXPANDED STATE - Centered content with tabs
            !historyHeaderCollapsed && React.createElement('div', {
              className: 'absolute inset-0 flex flex-col items-center justify-center text-center px-6 z-10',
              style: {
                opacity: historyHeaderCollapsed ? 0 : 1,
                transition: 'opacity 300ms ease-out'
              }
            },
              React.createElement('h1', {
                className: 'text-5xl font-light text-white',
                style: {
                  textShadow: '0 2px 20px rgba(0,0,0,0.5)',
                  letterSpacing: '0.3em',
                  textTransform: 'uppercase'
                }
              }, 'HISTORY'),
              // Tabs in expanded state
              React.createElement('div', {
                className: 'flex items-center gap-1 mt-6',
                style: { textShadow: '0 1px 10px rgba(0,0,0,0.5)' }
              },
                [
                  { key: 'topTracks', label: 'Top Songs' },
                  { key: 'topAlbums', label: 'Top Albums' },
                  { key: 'topArtists', label: 'Top Artists' },
                  { key: 'recent', label: 'Recently Played' }
                ].map((tab, i, arr) => React.createElement(React.Fragment, { key: tab.key },
                  i > 0 && React.createElement('span', {
                    className: 'text-white/50 mx-2'
                  }, '|'),
                  React.createElement('button', {
                    onClick: () => {
                      setHistoryTab(tab.key);
                      if (tab.key === 'recent') loadListeningHistory();
                      else if (tab.key === 'topTracks') loadTopTracks();
                      else if (tab.key === 'topArtists') loadTopArtists();
                      else if (tab.key === 'topAlbums') loadTopAlbums();
                    },
                    className: `px-2 py-1 text-sm font-medium uppercase tracking-wider transition-colors no-drag ${
                      historyTab === tab.key ? 'text-white' : 'text-white/60 hover:text-white'
                    }`
                  }, tab.label)
                ))
              ),
              React.createElement('p', {
                className: 'mt-2 text-white/80 text-sm'
              }, metaServiceConfigs.listenbrainz?.username && metaServiceConfigs.lastfm?.username
                ? 'Your listening activity from ListenBrainz & Last.fm'
                : metaServiceConfigs.listenbrainz?.username
                  ? 'Your listening activity from ListenBrainz'
                  : 'Your listening activity from Last.fm'
              )
            ),
            // COLLAPSED STATE - Inline layout with tabs
            historyHeaderCollapsed && React.createElement('div', {
              className: 'absolute inset-0 flex items-center px-6 z-10',
              style: {
                opacity: historyHeaderCollapsed ? 1 : 0,
                transition: 'opacity 300ms ease-out'
              }
            },
              React.createElement('h1', {
                className: 'text-2xl font-light text-white mr-6',
                style: {
                  textShadow: '0 2px 10px rgba(0,0,0,0.5)',
                  letterSpacing: '0.2em',
                  textTransform: 'uppercase'
                }
              }, 'HISTORY'),
              React.createElement('div', {
                className: 'flex items-center gap-1',
                style: { textShadow: '0 1px 10px rgba(0,0,0,0.5)' }
              },
                [
                  { key: 'topTracks', label: 'Top Songs' },
                  { key: 'topAlbums', label: 'Top Albums' },
                  { key: 'topArtists', label: 'Top Artists' },
                  { key: 'recent', label: 'Recent' }
                ].map((tab, i) => React.createElement(React.Fragment, { key: tab.key },
                  i > 0 && React.createElement('span', {
                    className: 'text-white/50 mx-2'
                  }, '|'),
                  React.createElement('button', {
                    onClick: () => {
                      setHistoryTab(tab.key);
                      if (tab.key === 'recent') loadListeningHistory();
                      else if (tab.key === 'topTracks') loadTopTracks();
                      else if (tab.key === 'topArtists') loadTopArtists();
                      else if (tab.key === 'topAlbums') loadTopAlbums();
                    },
                    className: `px-2 py-1 text-sm font-medium uppercase tracking-wider transition-colors no-drag ${
                      historyTab === tab.key ? 'text-white' : 'text-white/60 hover:text-white'
                    }`
                  }, tab.label)
                ))
              )
            )
          ),
          // Filter bar (outside scrollable area)
          React.createElement('div', {
            className: 'flex items-center px-6 py-3 bg-white border-b border-gray-200',
            style: { flexShrink: 0 }
          },
            // Period dropdown for top charts OR sort dropdown for recent
            historyTab === 'recent' ?
              React.createElement('div', { className: 'relative' },
                React.createElement('button', {
                  onClick: (e) => { e.stopPropagation(); setHistorySortDropdownOpen(!historySortDropdownOpen); },
                  className: 'flex items-center gap-1 px-3 py-1.5 text-sm text-gray-500 hover:text-gray-700 transition-colors'
                },
                  React.createElement('span', null, historySortOptions.find(o => o.value === historySort)?.label || 'Sort'),
                  React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M19 9l-7 7-7-7' })
                  )
                ),
                historySortDropdownOpen && React.createElement('div', {
                  className: 'absolute left-0 top-full mt-1 bg-white rounded-lg shadow-lg py-1 min-w-[160px] z-30 border border-gray-200'
                },
                  historySortOptions.map(option =>
                    React.createElement('button', {
                      key: option.value,
                      onClick: (e) => {
                        e.stopPropagation();
                        setHistorySort(option.value);
                        setHistorySortDropdownOpen(false);
                      },
                      className: `w-full px-4 py-2 text-left text-sm hover:bg-gray-100 flex items-center justify-between ${
                        historySort === option.value ? 'text-gray-900 font-medium' : 'text-gray-600'
                      }`
                    },
                      option.label,
                      historySort === option.value && React.createElement('svg', {
                        className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor'
                      },
                        React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M5 13l4 4L19 7' })
                      )
                    )
                  )
                )
              )
            :
              // Period dropdown for top charts
              React.createElement('div', { className: 'relative' },
                React.createElement('button', {
                  onClick: (e) => { e.stopPropagation(); setHistoryPeriodDropdownOpen(!historyPeriodDropdownOpen); },
                  className: 'flex items-center gap-1 px-3 py-1.5 text-sm text-gray-500 hover:text-gray-700 transition-colors'
                },
                  React.createElement('span', null, historyPeriodOptions.find(o => o.value === historyPeriod)?.label || 'Period'),
                  React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M19 9l-7 7-7-7' })
                  )
                ),
                historyPeriodDropdownOpen && React.createElement('div', {
                  className: 'absolute left-0 top-full mt-1 bg-white rounded-lg shadow-lg py-1 min-w-[160px] z-30 border border-gray-200'
                },
                  historyPeriodOptions.map(option =>
                    React.createElement('button', {
                      key: option.value,
                      onClick: (e) => {
                        e.stopPropagation();
                        setHistoryPeriod(option.value);
                        setHistoryPeriodDropdownOpen(false);
                        // Reload current tab with new period
                        if (historyTab === 'topTracks') loadTopTracks(option.value);
                        else if (historyTab === 'topArtists') loadTopArtists(option.value);
                        else if (historyTab === 'topAlbums') loadTopAlbums(option.value);
                      },
                      className: `w-full px-4 py-2 text-left text-sm hover:bg-gray-100 flex items-center justify-between ${
                        historyPeriod === option.value ? 'text-gray-900 font-medium' : 'text-gray-600'
                      }`
                    },
                      option.label,
                      historyPeriod === option.value && React.createElement('svg', {
                        className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor'
                      },
                        React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M5 13l4 4L19 7' })
                      )
                    )
                  )
                )
              ),
            React.createElement('div', { className: 'flex-1' }),
            // Search (only for recent and top tracks)
            (historyTab === 'recent' || historyTab === 'topTracks') && React.createElement('div', { className: 'flex items-center' },
              historySearchOpen ?
                React.createElement('div', { className: 'flex items-center border border-gray-300 rounded-full px-3 py-1.5' },
                  React.createElement('input', {
                    type: 'text',
                    value: historySearch,
                    onChange: (e) => setHistorySearch(e.target.value),
                    onBlur: () => { if (!historySearch.trim()) setHistorySearchOpen(false); },
                    autoFocus: true,
                    placeholder: 'Filter...',
                    className: 'bg-transparent text-gray-700 text-sm placeholder-gray-400 outline-none',
                    style: { width: '150px' }
                  }),
                  historySearch && React.createElement('button', {
                    onClick: () => { setHistorySearch(''); setHistorySearchOpen(false); },
                    className: 'ml-2 text-gray-400 hover:text-gray-600'
                  },
                    React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                      React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M6 18L18 6M6 6l12 12' })
                    )
                  )
                )
              :
                React.createElement('button', {
                  onClick: () => setHistorySearchOpen(true),
                  className: 'p-1.5 text-gray-400 hover:text-gray-600 transition-colors'
                },
                  React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' })
                  )
                )
            )
          ),
          // Scrollable content area (shared by recent and topTracks tabs)
          React.createElement('div', {
            ref: (el) => {
              historyScrollContainerRef.current = el;
              topTracksScrollContainerRef.current = el; // Same container for top tracks tab
              if (el) {
                if (!historyScrollContainerReady) setHistoryScrollContainerReady(true);
                if (!topTracksScrollContainerReady) setTopTracksScrollContainerReady(true);
              }
            },
            className: 'flex-1 overflow-y-auto scrollable-content p-6',
            onScroll: handleHistoryScroll
          },
            // RECENTLY PLAYED TAB
            historyTab === 'recent' && (
              listeningHistory.loading ?
                React.createElement('div', { className: 'space-y-0' },
                  ...Array(15).fill(null).map((_, i) =>
                    React.createElement('div', {
                      key: `history-skeleton-${i}`,
                      className: 'flex items-center gap-4 py-2 px-3 border-b border-gray-100'
                    },
                      React.createElement('div', {
                        className: 'w-8 h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                        style: { backgroundSize: '200% 100%', animationDelay: `${i * 50}ms` }
                      }),
                      React.createElement('div', {
                        className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                        style: { width: '360px', backgroundSize: '200% 100%', animationDelay: `${i * 50 + 25}ms` }
                      }),
                      React.createElement('div', {
                        className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                        style: { width: '240px', backgroundSize: '200% 100%', animationDelay: `${i * 50 + 50}ms` }
                      }),
                      React.createElement('div', {
                        className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                        style: { width: '50px', marginLeft: 'auto', backgroundSize: '200% 100%', animationDelay: `${i * 50 + 75}ms` }
                      }),
                      React.createElement('div', {
                        className: 'flex gap-1',
                        style: { width: '100px' }
                      },
                        React.createElement('div', {
                          className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                          style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 100}ms` }
                        }),
                        React.createElement('div', {
                          className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer',
                          style: { backgroundSize: '200% 100%', animationDelay: `${i * 50 + 125}ms` }
                        })
                      )
                    )
                  )
                )
              : listeningHistory.error ?
                React.createElement('div', { className: 'text-center py-12' },
                  React.createElement('div', { className: 'text-gray-400 mb-4' }, listeningHistory.error),
                  React.createElement('button', {
                    onClick: loadListeningHistory,
                    className: 'px-4 py-2 bg-gray-900 text-white rounded-lg hover:bg-gray-800 transition-colors'
                  }, 'Try Again')
                )
              : (() => {
                  const filtered = filterHistory(listeningHistory.tracks);
                  const sorted = sortHistory(filtered);

                  if (sorted.length === 0) {
                    return React.createElement('div', {
                      className: 'text-center py-12 text-gray-400'
                    }, historySearch ? 'No tracks match your search.' : 'No recent tracks found.');
                  }

                  return React.createElement('div', { className: 'space-y-0' },
                    ...sorted.map((track, index) => {
                      // Use track.id to look up resolved sources from trackSources state
                      const resolvedSources = trackSources[track.id] || track.sources || {};
                      const hasResolved = Object.keys(resolvedSources).length > 0;
                      const isResolving = Object.keys(resolvedSources).length === 0;

                      return React.createElement('div', {
                        key: track.id,
                        'data-track-id': track.id,
                        ref: (el) => {
                          if (el) {
                            historyTrackRowRefs.current.set(track.id, el);
                            if (historyObserverRef.current) {
                              historyObserverRef.current.observe(el);
                            }
                          } else {
                            historyTrackRowRefs.current.delete(track.id);
                          }
                        },
                        draggable: true,
                        onDragStart: (e) => {
                          setDraggingTrackForPlaylist(track);
                          e.dataTransfer.effectAllowed = 'copy';
                          e.dataTransfer.setData('text/plain', JSON.stringify({
                            type: 'track',
                            track: { id: track.id, title: track.title, artist: track.artist, album: track.album, duration: track.duration, sources: track.sources || {} }
                          }));
                        },
                        onDragEnd: () => {
                          setDraggingTrackForPlaylist(null);
                          setDropTargetPlaylistId(null);
                          setDropTargetNewPlaylist(false);
                          if (addToPlaylistPanel.open && selectedPlaylistsForAdd.length === 0) {
                            setAddToPlaylistPanel(prev => ({ ...prev, open: false }));
                          }
                        },
                        className: `flex items-center gap-4 py-3 px-4 cursor-grab active:cursor-grabbing transition-all group ${isResolving ? 'opacity-60' : 'hover:bg-gray-50/80'}`,
                        style: {
                          borderRadius: '8px',
                          marginBottom: '2px'
                        },
                        onClick: () => {
                          const tracksAfter = sorted.slice(index + 1);
                          const context = { type: 'history', name: 'History' };
                          setQueueWithContext(tracksAfter, context);
                          handlePlay(track);
                        },
                        onContextMenu: (e) => {
                          e.preventDefault();
                          if (window.electron?.contextMenu?.showTrackMenu) {
                            window.electron.contextMenu.showTrackMenu({ type: 'track', track: track });
                          }
                        }
                      },
                        React.createElement('span', {
                          className: 'flex-shrink-0 text-right',
                          style: { pointerEvents: 'none', width: '32px', fontSize: '12px', fontWeight: '500', color: track.nowPlaying ? '#8b5cf6' : '#9ca3af' }
                        }, track.nowPlaying ? 'â–¶' : String(index + 1).padStart(2, '0')),
                        React.createElement('span', {
                          className: 'truncate transition-colors',
                          style: { pointerEvents: 'none', width: '360px', flexShrink: 0, fontSize: '13px', fontWeight: track.nowPlaying ? '500' : '400', color: track.nowPlaying ? '#7c3aed' : hasResolved ? '#374151' : '#9ca3af' }
                        }, track.title),
                        React.createElement('span', {
                          className: 'truncate hover:text-purple-600 hover:underline cursor-pointer transition-colors',
                          style: { width: '240px', flexShrink: 0, fontSize: '12px', color: '#6b7280' },
                          onClick: (e) => { e.stopPropagation(); fetchArtistData(track.artist); }
                        }, track.artist),
                        React.createElement('span', {
                          className: 'text-right tabular-nums',
                          style: { pointerEvents: 'none', width: '50px', flexShrink: 0, marginLeft: 'auto', fontSize: '12px', color: '#9ca3af' }
                        }, track.duration ? formatTime(track.duration) : '--:--'),
                        React.createElement('div', {
                          className: 'flex items-center gap-1 justify-end',
                          style: { width: '100px', flexShrink: 0, minHeight: '24px' }
                        },
                          isResolving ?
                            React.createElement('div', { className: 'flex items-center gap-1' },
                              React.createElement('div', { className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer', title: 'Resolving track...' }),
                              React.createElement('div', { className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer', style: { animationDelay: '0.1s' } })
                            )
                          : hasResolved ?
                            Object.entries(resolvedSources).sort(([aId], [bId]) => resolverOrder.indexOf(aId) - resolverOrder.indexOf(bId)).map(([resolverId, source]) => {
                              const resolver = allResolvers.find(r => r.id === resolverId);
                              if (!resolver || !resolver.play) return null;
                              return React.createElement('button', {
                                key: resolverId,
                                className: 'no-drag',
                                onClick: (e) => { e.stopPropagation(); const tracksAfter = sorted.slice(index + 1); const context = { type: 'history', name: 'History' }; setQueueWithContext(tracksAfter, context); handlePlay({ ...track, preferredResolver: resolverId }); },
                                style: { width: '20px', height: '20px', borderRadius: '4px', backgroundColor: resolver.color, border: 'none', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center', pointerEvents: 'auto', opacity: (source.confidence || 0) > 0.8 ? 1 : 0.6, transition: 'transform 0.1s' },
                                onMouseEnter: (e) => e.currentTarget.style.transform = 'scale(1.1)',
                                onMouseLeave: (e) => e.currentTarget.style.transform = 'scale(1)',
                                title: `Play from ${resolver.name}${source.confidence ? ` (${Math.round(source.confidence * 100)}% match)` : ''}`
                              }, React.createElement(ResolverIcon, { resolverId, size: 12 }));
                            })
                          :
                            React.createElement('div', { className: 'flex items-center gap-1' },
                              React.createElement('div', { className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer', title: 'Resolving track...' }),
                              React.createElement('div', { className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer', style: { animationDelay: '0.1s' } })
                            )
                        )
                      );
                    })
                  );
                })()
            ),

            // TOP TRACKS TAB
            historyTab === 'topTracks' && (
              topTracks.loading ?
                React.createElement('div', { className: 'space-y-0' },
                  ...Array(15).fill(null).map((_, i) =>
                    React.createElement('div', {
                      key: `top-track-skeleton-${i}`,
                      className: 'flex items-center gap-4 py-2 px-3 border-b border-gray-100'
                    },
                      React.createElement('div', { className: 'w-8 h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer', style: { backgroundSize: '200% 100%' } }),
                      React.createElement('div', { className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer', style: { width: '360px', backgroundSize: '200% 100%' } }),
                      React.createElement('div', { className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer', style: { width: '240px', backgroundSize: '200% 100%' } }),
                      React.createElement('div', { className: 'h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer', style: { width: '80px', marginLeft: 'auto', backgroundSize: '200% 100%' } })
                    )
                  )
                )
              : topTracks.error ?
                React.createElement('div', { className: 'text-center py-12' },
                  React.createElement('div', { className: 'text-gray-400 mb-4' }, topTracks.error),
                  React.createElement('button', {
                    onClick: () => loadTopTracks(),
                    className: 'px-4 py-2 bg-gray-900 text-white rounded-lg hover:bg-gray-800 transition-colors'
                  }, 'Try Again')
                )
              : (() => {
                  const filtered = historySearch ? topTracks.tracks.filter(t =>
                    t.title.toLowerCase().includes(historySearch.toLowerCase()) ||
                    t.artist.toLowerCase().includes(historySearch.toLowerCase())
                  ) : topTracks.tracks;

                  if (filtered.length === 0) {
                    return React.createElement('div', { className: 'text-center py-12 text-gray-400' },
                      historySearch ? 'No tracks match your search.' : 'No top tracks found for this period.');
                  }

                  return React.createElement('div', { className: 'space-y-0' },
                    ...filtered.map((track, index) => {
                      // Use track.id to look up resolved sources from trackSources state
                      const resolvedSources = trackSources[track.id] || track.sources || {};
                      const hasResolved = Object.keys(resolvedSources).length > 0;
                      return React.createElement('div', {
                        key: track.id,
                        'data-track-id': track.id,
                        ref: (el) => {
                          if (el) {
                            topTracksRowRefs.current.set(track.id, el);
                            if (topTracksObserverRef.current) {
                              topTracksObserverRef.current.observe(el);
                            }
                          } else {
                            topTracksRowRefs.current.delete(track.id);
                          }
                        },
                        draggable: true,
                        onDragStart: (e) => {
                          setDraggingTrackForPlaylist(track);
                          e.dataTransfer.effectAllowed = 'copy';
                          e.dataTransfer.setData('text/plain', JSON.stringify({ type: 'track', track }));
                        },
                        onDragEnd: () => { setDraggingTrackForPlaylist(null); setDropTargetPlaylistId(null); setDropTargetNewPlaylist(false); },
                        className: `flex items-center gap-4 py-3 px-4 cursor-grab active:cursor-grabbing transition-all group ${!hasResolved ? 'opacity-60' : 'hover:bg-gray-50/80'}`,
                        style: { borderRadius: '8px', marginBottom: '2px' },
                        onClick: () => { const tracksAfter = filtered.slice(index + 1); const context = { type: 'history', name: 'Top Tracks' }; setQueueWithContext(tracksAfter, context); handlePlay(track); },
                        onContextMenu: (e) => { e.preventDefault(); if (window.electron?.contextMenu?.showTrackMenu) window.electron.contextMenu.showTrackMenu({ type: 'track', track }); }
                      },
                        React.createElement('span', { className: 'flex-shrink-0 text-right', style: { width: '32px', fontSize: '12px', fontWeight: '500', color: '#9ca3af' } }, `#${track.rank}`),
                        React.createElement('span', { className: 'truncate transition-colors', style: { width: '360px', flexShrink: 0, fontSize: '13px', fontWeight: '400', color: hasResolved ? '#374151' : '#9ca3af' } }, track.title),
                        React.createElement('span', {
                          className: 'truncate hover:text-purple-600 hover:underline cursor-pointer transition-colors',
                          style: { width: '240px', flexShrink: 0, fontSize: '12px', color: '#6b7280' },
                          onClick: (e) => { e.stopPropagation(); fetchArtistData(track.artist); }
                        }, track.artist),
                        React.createElement('span', { className: 'text-right tabular-nums', style: { width: '80px', flexShrink: 0, marginLeft: 'auto', fontSize: '12px', color: '#9ca3af' } }, `${track.playCount} plays`),
                        React.createElement('div', { className: 'flex items-center gap-1 justify-end', style: { width: '100px', flexShrink: 0, minHeight: '24px' } },
                          hasResolved ?
                            Object.entries(resolvedSources).sort(([aId], [bId]) => resolverOrder.indexOf(aId) - resolverOrder.indexOf(bId)).map(([resolverId, source]) => {
                              const resolver = allResolvers.find(r => r.id === resolverId);
                              if (!resolver || !resolver.play) return null;
                              return React.createElement('button', {
                                key: resolverId,
                                className: 'no-drag',
                                onClick: (e) => { e.stopPropagation(); const tracksAfter = filtered.slice(index + 1); const context = { type: 'history', name: 'Top Tracks' }; setQueueWithContext(tracksAfter, context); handlePlay({ ...track, preferredResolver: resolverId }); },
                                style: { width: '20px', height: '20px', borderRadius: '4px', backgroundColor: resolver.color, border: 'none', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center', opacity: (source.confidence || 0) > 0.8 ? 1 : 0.6, transition: 'transform 0.1s' },
                                onMouseEnter: (e) => e.currentTarget.style.transform = 'scale(1.1)',
                                onMouseLeave: (e) => e.currentTarget.style.transform = 'scale(1)',
                                title: `Play from ${resolver.name}`
                              }, React.createElement(ResolverIcon, { resolverId, size: 12 }));
                            })
                          :
                            React.createElement('div', { className: 'flex items-center gap-1' },
                              React.createElement('div', { className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer' }),
                              React.createElement('div', { className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer', style: { animationDelay: '0.1s' } })
                            )
                        )
                      );
                    })
                  );
                })()
            ),

            // TOP ARTISTS TAB
            historyTab === 'topArtists' && (
              topArtists.loading ?
                // Skeleton - square card style
                React.createElement('div', {
                  className: 'grid gap-4',
                  style: { gridTemplateColumns: 'repeat(auto-fill, minmax(160px, 1fr))' }
                },
                  ...Array(12).fill(null).map((_, i) =>
                    React.createElement('div', { key: `artist-skeleton-${i}`, className: 'bg-white rounded-lg overflow-hidden' },
                      React.createElement('div', { className: 'aspect-square bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer', style: { backgroundSize: '200% 100%' } }),
                      React.createElement('div', { className: 'p-3' },
                        React.createElement('div', { className: 'w-3/4 h-4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer rounded', style: { backgroundSize: '200% 100%' } })
                      )
                    )
                  )
                )
              : topArtists.error ?
                React.createElement('div', { className: 'text-center py-12' },
                  React.createElement('div', { className: 'text-gray-400 mb-4' }, topArtists.error),
                  React.createElement('button', {
                    onClick: () => loadTopArtists(),
                    className: 'px-4 py-2 bg-gray-900 text-white rounded-lg hover:bg-gray-800 transition-colors'
                  }, 'Try Again')
                )
              : topArtists.artists.length === 0 ?
                React.createElement('div', { className: 'text-center py-12 text-gray-400' }, 'No top artists found for this period.')
              :
                // Top Artists grid - Square card design
                React.createElement('div', {
                  className: 'grid gap-4',
                  style: { gridTemplateColumns: 'repeat(auto-fill, minmax(160px, 1fr))' }
                },
                  ...topArtists.artists.map((artist, index) => {
                    const topArtistPattern = generateArtistPattern(artist.name);
                    return React.createElement('div', {
                      key: artist.id,
                      className: 'bg-white rounded-lg overflow-hidden hover:shadow-lg transition-shadow cursor-pointer group release-card card-fade-up',
                      style: { animationDelay: `${Math.min(index * 30, 300)}ms` },
                      draggable: true,
                      onDragStart: (e) => {
                        e.dataTransfer.effectAllowed = 'copy';
                        e.dataTransfer.setData('text/plain', JSON.stringify({
                          type: 'artist',
                          artist: {
                            id: artist.id,
                            name: artist.name,
                            image: artist.image
                          }
                        }));
                      },
                      onClick: () => fetchArtistData(artist.name),
                      onContextMenu: (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        if (window.electron?.contextMenu?.showTrackMenu) {
                          window.electron.contextMenu.showTrackMenu({
                            type: 'artist',
                            artist: {
                              id: artist.id,
                              name: artist.name,
                              image: artist.image
                            }
                          });
                        }
                      }
                    },
                      // Square image container - gray while loading, pattern only when imageLoaded && no image
                      React.createElement('div', {
                        className: 'aspect-square relative group/art',
                        style: { background: artist.imageLoaded && !artist.image ? topArtistPattern.gradient : '#e5e7eb' }
                      },
                        // Shimmer while loading (imageLoaded not yet true)
                        !artist.imageLoaded && React.createElement('div', {
                          className: 'absolute inset-0 bg-gradient-to-r from-gray-300 via-gray-200 to-gray-300 animate-shimmer',
                          style: { backgroundSize: '200% 100%' }
                        }),
                        // Initials fallback (only show when imageLoaded && no image)
                        artist.imageLoaded && !artist.image && React.createElement('div', {
                          className: 'absolute inset-0 flex items-center justify-center',
                          style: { color: topArtistPattern.textColor, opacity: 0.4 }
                        },
                          React.createElement('span', {
                            className: 'font-bold tracking-wider',
                            style: { fontSize: '2.5rem', textShadow: '0 2px 8px rgba(0,0,0,0.3)' }
                          }, topArtistPattern.initials)
                        ),
                        // Image (fades in on load)
                        artist.image && React.createElement('img', {
                          src: artist.image,
                          alt: artist.name,
                          className: 'absolute inset-0 w-full h-full object-cover transition-all duration-300 group-hover/art:scale-105',
                          style: { opacity: 0 },
                          ref: (el) => { if (el && el.complete && el.naturalWidth > 0) el.style.opacity = '1'; },
                          onLoad: (e) => { e.target.style.opacity = '1'; },
                          onError: (e) => { e.target.style.display = 'none'; }
                        }),
                        // Rank badge
                        React.createElement('div', {
                          className: 'absolute top-2 left-2 px-2 py-0.5 bg-black/60 rounded text-xs text-white font-medium'
                        }, `#${artist.rank}`),
                        // Hover overlay with action buttons (Play, Queue) - Top 10 icons
                        React.createElement('div', {
                          className: 'absolute inset-0 bg-black/50 opacity-0 group-hover/art:opacity-100 transition-opacity duration-200 flex items-center justify-center gap-3',
                          style: { pointerEvents: 'auto' }
                        },
                          // Play top 10 button (center, larger)
                          React.createElement('button', {
                            onClick: async (e) => {
                              e.stopPropagation();
                              setTrackLoading(true);
                              const tracks = await getArtistTopTracks(artist.name);
                              if (tracks.length > 0) {
                                const context = { type: 'artist', name: artist.name };
                                const [firstTrack, ...remainingTracks] = tracks;
                                // Tag the first track with context so queue navigation works correctly
                                const taggedFirstTrack = { ...firstTrack, _playbackContext: context };
                                setQueueWithContext(remainingTracks, context);
                                handlePlay(taggedFirstTrack);
                              } else {
                                setTrackLoading(false);
                                showToast(`No top tracks found for ${artist.name}`, 'error');
                              }
                            },
                            className: 'w-12 h-12 bg-white rounded-full flex items-center justify-center shadow-lg transition-all hover:scale-110',
                            style: { border: 'none', cursor: 'pointer' },
                            title: 'Play top 10 tracks'
                          },
                            React.createElement(PlayTop10Icon, { size: 26, className: 'text-gray-800' })
                          ),
                          // Add top 10 to Queue button
                          React.createElement('button', {
                            onClick: async (e) => {
                              e.stopPropagation();
                              const tracks = await getArtistTopTracks(artist.name);
                              if (tracks.length > 0) {
                                addToQueue(tracks, { type: 'artist', name: artist.name });
                                showToast(`Added ${tracks.length} tracks from ${artist.name}`, 'success');
                              } else {
                                showToast(`No top tracks found for ${artist.name}`, 'error');
                              }
                            },
                            className: 'w-10 h-10 rounded-full flex items-center justify-center transition-all hover:scale-110',
                            style: { backgroundColor: 'rgba(255, 255, 255, 0.15)', color: '#ffffff', border: 'none', cursor: 'pointer' },
                            onMouseEnter: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.25)',
                            onMouseLeave: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.15)',
                            title: 'Add top 10 to queue'
                          },
                            React.createElement(QueueTop10Icon, { size: 20 })
                          )
                        )
                      ),
                      // Artist name and play count section
                      React.createElement('div', { className: 'p-3' },
                        React.createElement('p', {
                          className: 'font-medium text-gray-900 truncate text-sm transition-colors'
                        }, artist.name),
                        React.createElement('p', {
                          className: 'text-xs text-gray-400 mt-1'
                        }, `${artist.playCount} plays`)
                      )
                    );
                  })
                )
            ),

            // TOP ALBUMS TAB
            historyTab === 'topAlbums' && (
              topAlbums.loading ?
                React.createElement('div', {
                  className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-x-4 gap-y-8 pb-6'
                },
                  ...Array(12).fill(null).map((_, i) =>
                    React.createElement('div', { key: `album-skeleton-${i}` },
                      React.createElement('div', { className: 'aspect-square rounded-lg mb-3 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer', style: { backgroundSize: '200% 100%' } }),
                      React.createElement('div', { className: 'space-y-1' },
                        React.createElement('div', { className: 'h-4 w-3/4 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer rounded', style: { backgroundSize: '200% 100%' } }),
                        React.createElement('div', { className: 'h-3 w-1/2 bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 animate-shimmer rounded', style: { backgroundSize: '200% 100%' } })
                      )
                    )
                  )
                )
              : topAlbums.error ?
                React.createElement('div', { className: 'text-center py-12' },
                  React.createElement('div', { className: 'text-gray-400 mb-4' }, topAlbums.error),
                  React.createElement('button', {
                    onClick: () => loadTopAlbums(),
                    className: 'px-4 py-2 bg-gray-900 text-white rounded-lg hover:bg-gray-800 transition-colors'
                  }, 'Try Again')
                )
              : topAlbums.albums.length === 0 ?
                React.createElement('div', { className: 'text-center py-12 text-gray-400' }, 'No top albums found for this period.')
              :
                // Top Albums grid - Cinematic Light design
                React.createElement('div', {
                  className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-x-4 gap-y-5 pb-6'
                },
                  ...topAlbums.albums.map((album, index) =>
                    React.createElement('div', {
                      key: album.id,
                      className: 'group cursor-pointer release-card card-fade-up',
                      style: {
                        padding: '10px',
                        borderRadius: '10px',
                        backgroundColor: '#ffffff',
                        boxShadow: '0 1px 3px rgba(0, 0, 0, 0.05), 0 4px 12px rgba(0, 0, 0, 0.03)',
                        animationDelay: `${Math.min(index * 30, 300)}ms`
                      },
                      onClick: () => openTopAlbum(album)
                    },
                      // Album art - Cinematic Light design
                      React.createElement('div', {
                        className: `album-art-container ${album.image === null || album.image === '' ? '' : !album.image ? 'animate-shimmer' : ''}`,
                        style: {
                          aspectRatio: '1',
                          borderRadius: '6px',
                          overflow: 'hidden',
                          marginBottom: '10px',
                          position: 'relative',
                          background: album.image === null || album.image === ''
                            ? 'linear-gradient(145deg, #1f1f1f 0%, #2d2d2d 50%, #1a1a1a 100%)'
                            : !album.image
                              ? 'linear-gradient(to right, #f3f4f6, #e5e7eb, #f3f4f6)'
                              : '#f3f4f6',
                          backgroundSize: !album.image && album.image !== null && album.image !== '' ? '200% 100%' : undefined
                        }
                      },
                        // Placeholder - only show when no art
                        (album.image === null || album.image === '') && React.createElement('div', {
                          style: { position: 'absolute', inset: 0, display: 'flex', alignItems: 'center', justifyContent: 'center' }
                        },
                          React.createElement('svg', {
                            style: { width: '36px', height: '36px', color: 'rgba(255, 255, 255, 0.2)' },
                            fill: 'none',
                            viewBox: '0 0 24 24',
                            stroke: 'currentColor',
                            strokeWidth: 1
                          },
                            React.createElement('circle', { cx: 12, cy: 12, r: 10 }),
                            React.createElement('circle', { cx: 12, cy: 12, r: 3 }),
                            React.createElement('circle', { cx: 12, cy: 12, r: 6, strokeDasharray: '2 2' })
                          )
                        ),
                        album.image && typeof album.image === 'string' && React.createElement('img', {
                          src: album.image,
                          alt: album.name,
                          className: 'group-hover:scale-105',
                          style: {
                            position: 'absolute',
                            inset: 0,
                            width: '100%',
                            height: '100%',
                            objectFit: 'cover',
                            opacity: 0,
                            transition: 'opacity 0.35s ease-out, transform 0.3s ease'
                          },
                          ref: (el) => { if (el && el.complete && el.naturalWidth > 0) el.style.opacity = '1'; },
                          onLoad: (e) => { e.target.style.opacity = '1'; },
                          onError: (e) => { e.target.style.display = 'none'; }
                        }),
                        // Rank badge - refined
                        React.createElement('div', {
                          style: {
                            position: 'absolute',
                            top: '8px',
                            right: '8px',
                            padding: '3px 8px',
                            borderRadius: '4px',
                            backgroundColor: 'rgba(0, 0, 0, 0.75)',
                            color: '#ffffff',
                            fontSize: '11px',
                            fontWeight: '600',
                            letterSpacing: '0.02em'
                          }
                        }, `#${album.rank}`)
                      ),
                      // Album info - refined typography
                      React.createElement('div', null,
                        React.createElement('div', {
                          style: {
                            fontWeight: '500',
                            fontSize: '13px',
                            color: '#1f2937',
                            overflow: 'hidden',
                            textOverflow: 'ellipsis',
                            whiteSpace: 'nowrap',
                            marginBottom: '2px',
                            transition: 'color 0.2s ease'
                          },
                          className: ''
                        }, album.name),
                        React.createElement('div', {
                          style: {
                            fontSize: '12px',
                            color: '#6b7280',
                            overflow: 'hidden',
                            textOverflow: 'ellipsis',
                            whiteSpace: 'nowrap',
                            cursor: 'pointer',
                            transition: 'color 0.2s ease'
                          },
                          className: 'hover:text-purple-600',
                          onClick: (e) => {
                            e.stopPropagation();
                            fetchArtistData(album.artist);
                          }
                        }, album.artist),
                        React.createElement('div', {
                          style: { fontSize: '11px', color: '#9ca3af', marginTop: '3px' }
                        }, `${album.playCount} plays`)
                      )
                    )
                  )
                )
            )
          )
        ),

        // Friend History View - matching History page structure exactly
        activeView === 'friendHistory' && currentFriend && (() => {
          return React.createElement('div', {
            className: 'flex-1 flex flex-col h-full',
            style: { overflow: 'hidden', minHeight: 0 }
          },
            // Header section (outside scrollable area) - matching History pattern
            React.createElement('div', {
              className: 'relative',
              style: {
                height: historyHeaderCollapsed ? '80px' : '320px',
                flexShrink: 0,
                transition: 'height 300ms ease-out',
                overflow: 'hidden'
              }
            },
              // Gradient background - purple/magenta theme for friends
              React.createElement('div', {
                className: 'absolute inset-0',
                style: {
                  background: 'linear-gradient(135deg, #9333ea 0%, #c026d3 50%, #e11d48 100%)'
                }
              }),
              // Background pattern - hexagon pattern for friends
              React.createElement('div', {
                className: 'absolute inset-0',
                style: {
                  opacity: 0.1,
                  backgroundImage: 'url("data:image/svg+xml,%3Csvg width=\'60\' height=\'60\' viewBox=\'0 0 60 60\' xmlns=\'http://www.w3.org/2000/svg\'%3E%3Cpolygon fill=\'none\' stroke=\'%23ffffff\' stroke-width=\'1.5\' points=\'30,5 55,20 55,50 30,65 5,50 5,20\'/%3E%3C/svg%3E")'
                }
              }),
              // EXPANDED STATE - Centered content with tabs (matching History exactly)
              !historyHeaderCollapsed && React.createElement('div', {
                className: 'absolute inset-0 flex flex-col items-center justify-center text-center px-6 z-10',
                style: {
                  opacity: historyHeaderCollapsed ? 0 : 1,
                  transition: 'opacity 300ms ease-out'
                }
              },
                // Hexagonal avatar centered
                React.createElement('div', {
                  className: 'w-24 h-24 mb-4 overflow-hidden',
                  style: {
                    clipPath: 'polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%)'
                  }
                },
                  currentFriend.avatarUrl
                    ? React.createElement('img', {
                        src: currentFriend.avatarUrl,
                        alt: currentFriend.displayName,
                        className: 'w-full h-full object-cover'
                      })
                    : React.createElement('div', {
                        className: 'w-full h-full flex items-center justify-center text-3xl font-medium bg-white/20 text-white'
                      }, currentFriend.displayName.charAt(0).toUpperCase())
                ),
                // Name with badges
                React.createElement('div', { className: 'flex items-center gap-3 mb-2' },
                  React.createElement('h1', {
                    className: 'text-4xl font-light text-white',
                    style: {
                      textShadow: '0 2px 20px rgba(0,0,0,0.5)',
                      letterSpacing: '0.2em',
                      textTransform: 'uppercase'
                    }
                  }, currentFriend.displayName),
                  // On-air badge
                  isOnAir(currentFriend) && React.createElement('span', {
                    className: 'px-2 py-1 bg-green-500 text-white text-xs font-medium rounded-full flex items-center gap-1'
                  },
                    React.createElement('span', { className: 'w-2 h-2 bg-white rounded-full animate-pulse' }),
                    'On Air'
                  )
                ),
                // Tabs in expanded state (matching History)
                React.createElement('div', {
                  className: 'flex items-center gap-1 mt-4',
                  style: { textShadow: '0 1px 10px rgba(0,0,0,0.5)' }
                },
                  [
                    { key: 'recent', label: 'Recently Played' },
                    { key: 'topTracks', label: 'Top Tracks' },
                    { key: 'topAlbums', label: 'Top Albums' },
                    { key: 'topArtists', label: 'Top Artists' }
                  ].map((tab, i) => React.createElement(React.Fragment, { key: tab.key },
                    i > 0 && React.createElement('span', {
                      className: 'text-white/50 mx-2'
                    }, '|'),
                    React.createElement('button', {
                      onClick: () => {
                        setFriendHistoryTab(tab.key);
                        if (tab.key === 'recent') loadFriendRecentTracks(currentFriend);
                        else if (tab.key === 'topTracks') loadFriendTopTracks(currentFriend);
                        else if (tab.key === 'topAlbums') loadFriendTopAlbums(currentFriend);
                        else if (tab.key === 'topArtists') loadFriendTopArtists(currentFriend);
                      },
                      className: `px-2 py-1 text-sm font-medium uppercase tracking-wider transition-colors no-drag ${
                        friendHistoryTab === tab.key ? 'text-white' : 'text-white/60 hover:text-white'
                      }`
                    }, tab.label)
                  ))
                ),
                // Service subtitle
                React.createElement('p', {
                  className: 'mt-2 text-white/80 text-sm'
                }, `Listening activity from ${currentFriend.service === 'lastfm' ? 'Last.fm' : 'ListenBrainz'}`)
              ),
              // COLLAPSED STATE - Inline layout with tabs (matching History)
              historyHeaderCollapsed && React.createElement('div', {
                className: 'absolute inset-0 flex items-center px-6 z-10',
                style: {
                  opacity: historyHeaderCollapsed ? 1 : 0,
                  transition: 'opacity 300ms ease-out'
                }
              },
                // Small avatar
                React.createElement('div', {
                  className: 'w-10 h-10 mr-4 overflow-hidden flex-shrink-0',
                  style: {
                    clipPath: 'polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%)'
                  }
                },
                  currentFriend.avatarUrl
                    ? React.createElement('img', {
                        src: currentFriend.avatarUrl,
                        alt: currentFriend.displayName,
                        className: 'w-full h-full object-cover'
                      })
                    : React.createElement('div', {
                        className: 'w-full h-full flex items-center justify-center text-sm font-medium bg-white/20 text-white'
                      }, currentFriend.displayName.charAt(0).toUpperCase())
                ),
                React.createElement('h1', {
                  className: 'text-2xl font-light text-white mr-6',
                  style: {
                    textShadow: '0 2px 10px rgba(0,0,0,0.5)',
                    letterSpacing: '0.2em',
                    textTransform: 'uppercase'
                  }
                }, currentFriend.displayName),
                // On-air dot
                isOnAir(currentFriend) && React.createElement('span', {
                  className: 'w-2.5 h-2.5 bg-green-400 rounded-full mr-4'
                }),
                // Tabs in collapsed mode
                React.createElement('div', {
                  className: 'flex items-center gap-1',
                  style: { textShadow: '0 1px 10px rgba(0,0,0,0.5)' }
                },
                  [
                    { key: 'recent', label: 'Recent' },
                    { key: 'topTracks', label: 'Top Tracks' },
                    { key: 'topAlbums', label: 'Top Albums' },
                    { key: 'topArtists', label: 'Top Artists' }
                  ].map((tab, i) => React.createElement(React.Fragment, { key: `c-${tab.key}` },
                    i > 0 && React.createElement('span', {
                      className: 'text-white/50 mx-2'
                    }, '|'),
                    React.createElement('button', {
                      onClick: () => {
                        setFriendHistoryTab(tab.key);
                        if (tab.key === 'recent') loadFriendRecentTracks(currentFriend);
                        else if (tab.key === 'topTracks') loadFriendTopTracks(currentFriend);
                        else if (tab.key === 'topAlbums') loadFriendTopAlbums(currentFriend);
                        else if (tab.key === 'topArtists') loadFriendTopArtists(currentFriend);
                      },
                      className: `px-2 py-1 text-sm font-medium uppercase tracking-wider transition-colors no-drag ${
                        friendHistoryTab === tab.key ? 'text-white' : 'text-white/60 hover:text-white'
                      }`
                    }, tab.label)
                  ))
                )
              )
            ),
            // Filter bar (outside scrollable area - matching History exactly)
            React.createElement('div', {
              className: 'flex items-center px-6 py-3 bg-white border-b border-gray-200',
              style: { flexShrink: 0 }
            },
              // Sort dropdown for recent, period dropdown for top charts
              friendHistoryTab === 'recent' ?
                React.createElement('div', { className: 'relative' },
                  React.createElement('button', {
                    onClick: (e) => { e.stopPropagation(); setFriendHistorySortDropdownOpen(!friendHistorySortDropdownOpen); },
                    className: 'flex items-center gap-1 px-3 py-1.5 text-sm text-gray-500 hover:text-gray-700 transition-colors'
                  },
                    React.createElement('span', null, historySortOptions.find(o => o.value === friendHistorySort)?.label || 'Sort'),
                    React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                      React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M19 9l-7 7-7-7' })
                    )
                  ),
                  friendHistorySortDropdownOpen && React.createElement('div', {
                    className: 'absolute left-0 top-full mt-1 bg-white rounded-lg shadow-lg py-1 min-w-[160px] z-30 border border-gray-200'
                  },
                    historySortOptions.map(option =>
                      React.createElement('button', {
                        key: option.value,
                        onClick: (e) => {
                          e.stopPropagation();
                          setFriendHistorySort(option.value);
                          setFriendHistorySortDropdownOpen(false);
                        },
                        className: `w-full px-4 py-2 text-left text-sm hover:bg-gray-100 flex items-center justify-between ${
                          friendHistorySort === option.value ? 'text-gray-900 font-medium' : 'text-gray-600'
                        }`
                      },
                        option.label,
                        friendHistorySort === option.value && React.createElement('svg', {
                          className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor'
                        },
                          React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M5 13l4 4L19 7' })
                        )
                      )
                    )
                  )
                )
              :
                React.createElement('div', { className: 'relative' },
                  React.createElement('button', {
                    onClick: (e) => { e.stopPropagation(); setHistoryPeriodDropdownOpen(!historyPeriodDropdownOpen); },
                    className: 'flex items-center gap-1 px-3 py-1.5 text-sm text-gray-500 hover:text-gray-700 transition-colors'
                  },
                    React.createElement('span', null, historyPeriodOptions.find(o => o.value === friendHistoryPeriod)?.label || 'Period'),
                    React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                      React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M19 9l-7 7-7-7' })
                    )
                  ),
                  historyPeriodDropdownOpen && React.createElement('div', {
                    className: 'absolute left-0 top-full mt-1 bg-white rounded-lg shadow-lg py-1 min-w-[160px] z-30 border border-gray-200'
                  },
                    historyPeriodOptions.map(option =>
                      React.createElement('button', {
                        key: option.value,
                        onClick: (e) => {
                          e.stopPropagation();
                          setFriendHistoryPeriod(option.value);
                          setHistoryPeriodDropdownOpen(false);
                          if (friendHistoryTab === 'topTracks') loadFriendTopTracks(currentFriend, option.value);
                          else if (friendHistoryTab === 'topAlbums') loadFriendTopAlbums(currentFriend, option.value);
                          else if (friendHistoryTab === 'topArtists') loadFriendTopArtists(currentFriend, option.value);
                        },
                        className: `w-full px-4 py-2 text-left text-sm hover:bg-gray-100 flex items-center justify-between ${
                          friendHistoryPeriod === option.value ? 'text-gray-900 font-medium' : 'text-gray-600'
                        }`
                      },
                        option.label,
                        friendHistoryPeriod === option.value && React.createElement('svg', {
                          className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor'
                        },
                          React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M5 13l4 4L19 7' })
                        )
                      )
                    )
                  )
                ),
              React.createElement('div', { className: 'flex-1' }),
              // Pin/Unpin button on right side of filter bar
              React.createElement('button', {
                onClick: () => pinnedFriendIds.includes(currentFriend.id) ? unpinFriend(currentFriend.id) : pinFriend(currentFriend.id),
                className: `flex items-center gap-2 px-3 py-1.5 text-sm rounded-full transition-colors ${
                  pinnedFriendIds.includes(currentFriend.id)
                    ? 'bg-purple-100 text-purple-700'
                    : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                }`
              },
                React.createElement('svg', {
                  className: 'w-4 h-4',
                  fill: pinnedFriendIds.includes(currentFriend.id) ? 'currentColor' : 'none',
                  viewBox: '0 0 24 24',
                  stroke: 'currentColor'
                },
                  React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z' })
                ),
                pinnedFriendIds.includes(currentFriend.id) ? 'Pinned' : 'Pin to Sidebar'
              )
            ),
            // Scrollable content area
            React.createElement('div', {
              ref: (el) => {
                friendHistoryScrollContainerRef.current = el;
                if (el && !friendHistoryScrollContainerReady) {
                  setFriendHistoryScrollContainerReady(true);
                }
              },
              className: 'flex-1 overflow-y-auto scrollable-content p-6',
              onScroll: (e) => {
                const scrollTop = e.target.scrollTop;
                if (scrollTop > 50 && !historyHeaderCollapsed) {
                  setHistoryHeaderCollapsed(true);
                } else if (scrollTop <= 50 && historyHeaderCollapsed) {
                  setHistoryHeaderCollapsed(false);
                }
              }
            },
                // Loading state
                friendHistoryLoading && React.createElement('div', { className: 'flex items-center justify-center py-12' },
                  React.createElement('div', { className: 'w-8 h-8 border-2 border-purple-500 border-t-transparent rounded-full animate-spin' })
                ),
                // Recent tab content - matching History page layout
                !friendHistoryLoading && friendHistoryTab === 'recent' && (() => {
                  const sorted = sortFriendHistory(friendHistoryData.recent);
                  if (sorted.length === 0) {
                    return React.createElement('p', { className: 'text-center text-gray-400 py-8' }, 'No recent listens');
                  }
                  return React.createElement('div', { className: 'space-y-0' },
                    ...sorted.map((track, index) => {
                      // Use track.id to look up resolved sources from trackSources state
                      const resolvedSources = trackSources[track.id] || track.sources || {};
                      const hasResolved = Object.keys(resolvedSources).length > 0;
                      const isResolving = Object.keys(resolvedSources).length === 0;
                      const tracksAfterRecent = sorted.slice(index + 1);

                      return React.createElement('div', {
                        key: track.id || index,
                        'data-track-id': track.id,
                        ref: (el) => {
                          if (el && track.id) {
                            friendHistoryTrackRowRefs.current.set(track.id, el);
                            if (friendHistoryObserverRef.current) {
                              friendHistoryObserverRef.current.observe(el);
                            }
                          } else if (track.id) {
                            friendHistoryTrackRowRefs.current.delete(track.id);
                          }
                        },
                        draggable: true,
                        onDragStart: (e) => {
                          setDraggingTrackForPlaylist(track);
                          e.dataTransfer.effectAllowed = 'copy';
                          e.dataTransfer.setData('text/plain', JSON.stringify({ type: 'track', track }));
                        },
                        onDragEnd: () => {
                          setDraggingTrackForPlaylist(null);
                          setDropTargetPlaylistId(null);
                          setDropTargetNewPlaylist(false);
                        },
                        className: `flex items-center gap-4 py-3 px-4 cursor-grab active:cursor-grabbing transition-all group ${isResolving ? 'opacity-60' : 'hover:bg-gray-50/80'}`,
                        style: { borderRadius: '8px', marginBottom: '2px' },
                        onClick: () => {
                          const tracksAfter = sorted.slice(index + 1);
                          const context = { type: 'friend', name: currentFriend?.name || 'Friend', tab: 'recent' };
                          setQueueWithContext(tracksAfter, context);
                          handlePlay(track);
                        },
                          onContextMenu: (e) => {
                            e.preventDefault();
                            if (window.electron?.contextMenu?.showTrackMenu) {
                              window.electron.contextMenu.showTrackMenu({ type: 'track', track });
                            }
                          }
                        },
                          React.createElement('span', {
                            className: 'flex-shrink-0 text-right',
                            style: { pointerEvents: 'none', width: '32px', fontSize: '12px', fontWeight: '500', color: track.nowPlaying ? '#8b5cf6' : '#9ca3af' }
                          }, track.nowPlaying ? 'â–¶' : String(index + 1).padStart(2, '0')),
                          React.createElement('span', {
                            className: 'truncate transition-colors',
                            style: { pointerEvents: 'none', width: '360px', flexShrink: 0, fontSize: '13px', fontWeight: track.nowPlaying ? '500' : '400', color: track.nowPlaying ? '#7c3aed' : hasResolved ? '#374151' : '#9ca3af' }
                          }, track.title),
                          React.createElement('span', {
                            className: 'truncate hover:text-purple-600 hover:underline cursor-pointer transition-colors',
                            style: { width: '240px', flexShrink: 0, fontSize: '12px', color: '#6b7280' },
                            onClick: (e) => { e.stopPropagation(); fetchArtistData(track.artist); }
                          }, track.artist),
                          React.createElement('span', {
                            className: 'truncate',
                            style: { pointerEvents: 'none', width: '150px', flexShrink: 0, fontSize: '12px', color: '#9ca3af' }
                          }, track.album || ''),
                          React.createElement('span', {
                            className: 'text-right tabular-nums',
                            style: { pointerEvents: 'none', width: '80px', flexShrink: 0, marginLeft: 'auto', fontSize: '12px', color: '#9ca3af' }
                          }, track.timestamp ? formatTimeAgo(track.timestamp) : ''),
                          React.createElement('div', {
                            className: 'flex items-center gap-1 justify-end',
                            style: { width: '100px', flexShrink: 0, minHeight: '24px' }
                          },
                            isResolving ?
                              React.createElement('div', { className: 'flex items-center gap-1' },
                                React.createElement('div', { className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer', title: 'Resolving track...' }),
                                React.createElement('div', { className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer', style: { animationDelay: '0.1s' } })
                              )
                            : hasResolved ?
                              Object.entries(resolvedSources).sort(([aId], [bId]) => resolverOrder.indexOf(aId) - resolverOrder.indexOf(bId)).map(([resolverId, source]) => {
                                const resolver = allResolvers.find(r => r.id === resolverId);
                                if (!resolver || !resolver.play) return null;
                                return React.createElement('button', {
                                  key: resolverId,
                                  className: 'no-drag',
                                  onClick: (e) => { e.stopPropagation(); const context = { type: 'friend', name: currentFriend?.name || 'Friend', tab: 'recent' }; setQueueWithContext(tracksAfterRecent, context); handlePlay({ ...track, preferredResolver: resolverId }); },
                                  style: { width: '20px', height: '20px', borderRadius: '4px', backgroundColor: resolver.color, border: 'none', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center', pointerEvents: 'auto', opacity: (source.confidence || 0) > 0.8 ? 1 : 0.6, transition: 'transform 0.1s' },
                                  onMouseEnter: (e) => e.currentTarget.style.transform = 'scale(1.1)',
                                  onMouseLeave: (e) => e.currentTarget.style.transform = 'scale(1)',
                                  title: `Play from ${resolver.name}`
                                }, React.createElement(ResolverIcon, { resolverId, size: 12 }));
                              })
                            :
                              React.createElement('div', { className: 'flex items-center gap-1' },
                                React.createElement('div', { className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer', title: 'Resolving track...' }),
                                React.createElement('div', { className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer', style: { animationDelay: '0.1s' } })
                              )
                          )
                      );
                    })
                  );
                })(),
                // Top tracks tab content - matching History page layout
                !friendHistoryLoading && friendHistoryTab === 'topTracks' && React.createElement('div', { className: 'space-y-0' },
                  friendHistoryData.topTracks.length === 0
                    ? React.createElement('p', { className: 'text-center text-gray-400 py-8' }, 'No top tracks data')
                    : friendHistoryData.topTracks.map((track, index) => {
                        // Use track.id to look up resolved sources from trackSources state
                        const resolvedSources = trackSources[track.id] || track.sources || {};
                        const hasResolved = Object.keys(resolvedSources).length > 0;
                        const isResolving = Object.keys(resolvedSources).length === 0;

                        return React.createElement('div', {
                          key: track.id || index,
                          'data-track-id': track.id,
                          ref: (el) => {
                            if (el && track.id) {
                              friendHistoryTrackRowRefs.current.set(track.id, el);
                              if (friendHistoryObserverRef.current) {
                                friendHistoryObserverRef.current.observe(el);
                              }
                            } else if (track.id) {
                              friendHistoryTrackRowRefs.current.delete(track.id);
                            }
                          },
                          draggable: true,
                          onDragStart: (e) => {
                            setDraggingTrackForPlaylist(track);
                            e.dataTransfer.effectAllowed = 'copy';
                            e.dataTransfer.setData('text/plain', JSON.stringify({ type: 'track', track }));
                          },
                          onDragEnd: () => {
                            setDraggingTrackForPlaylist(null);
                            setDropTargetPlaylistId(null);
                            setDropTargetNewPlaylist(false);
                          },
                          className: `flex items-center gap-4 py-3 px-4 cursor-grab active:cursor-grabbing transition-all group ${isResolving ? 'opacity-60' : 'hover:bg-gray-50/80'}`,
                          style: { borderRadius: '8px', marginBottom: '2px' },
                          onClick: () => {
                            const tracksAfter = friendHistoryData.topTracks.slice(index + 1);
                            const context = { type: 'friend', name: currentFriend?.name || 'Friend', tab: 'topTracks' };
                            setQueueWithContext(tracksAfter, context);
                            handlePlay(track);
                          },
                          onContextMenu: (e) => {
                            e.preventDefault();
                            if (window.electron?.contextMenu?.showTrackMenu) {
                              window.electron.contextMenu.showTrackMenu({ type: 'track', track });
                            }
                          }
                        },
                          React.createElement('span', {
                            className: 'flex-shrink-0 text-right',
                            style: { width: '32px', fontSize: '12px', fontWeight: '500', color: '#9ca3af' }
                          }, `#${track.rank || index + 1}`),
                          React.createElement('span', {
                            className: 'truncate transition-colors',
                            style: { width: '360px', flexShrink: 0, fontSize: '13px', fontWeight: '400', color: hasResolved ? '#374151' : '#9ca3af' }
                          }, track.title),
                          React.createElement('span', {
                            className: 'truncate hover:text-purple-600 hover:underline cursor-pointer transition-colors',
                            style: { width: '240px', flexShrink: 0, fontSize: '12px', color: '#6b7280' },
                            onClick: (e) => { e.stopPropagation(); fetchArtistData(track.artist); }
                          }, track.artist),
                          React.createElement('span', {
                            className: 'text-right tabular-nums',
                            style: { width: '80px', flexShrink: 0, marginLeft: 'auto', fontSize: '12px', color: '#9ca3af' }
                          }, `${track.playCount} plays`),
                          React.createElement('div', {
                            className: 'flex items-center gap-1 justify-end',
                            style: { width: '100px', flexShrink: 0, minHeight: '24px' }
                          },
                            isResolving ?
                              React.createElement('div', { className: 'flex items-center gap-1' },
                                React.createElement('div', { className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer', title: 'Resolving track...' }),
                                React.createElement('div', { className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer', style: { animationDelay: '0.1s' } })
                              )
                            : hasResolved ?
                              Object.entries(resolvedSources).sort(([aId], [bId]) => resolverOrder.indexOf(aId) - resolverOrder.indexOf(bId)).map(([resolverId, source]) => {
                                const resolver = allResolvers.find(r => r.id === resolverId);
                                if (!resolver || !resolver.play) return null;
                                return React.createElement('button', {
                                  key: resolverId,
                                  className: 'no-drag',
                                  onClick: (e) => { e.stopPropagation(); const context = { type: 'friend', name: currentFriend?.name || 'Friend', tab: 'topTracks' }; setQueueWithContext(friendHistoryData.topTracks.slice(index + 1), context); handlePlay({ ...track, preferredResolver: resolverId }); },
                                  style: { width: '20px', height: '20px', borderRadius: '4px', backgroundColor: resolver.color, border: 'none', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center', pointerEvents: 'auto', opacity: (source.confidence || 0) > 0.8 ? 1 : 0.6, transition: 'transform 0.1s' },
                                  onMouseEnter: (e) => e.currentTarget.style.transform = 'scale(1.1)',
                                  onMouseLeave: (e) => e.currentTarget.style.transform = 'scale(1)',
                                  title: `Play from ${resolver.name}`
                                }, React.createElement(ResolverIcon, { resolverId, size: 12 }));
                              })
                            :
                              React.createElement('div', { className: 'flex items-center gap-1' },
                                React.createElement('div', { className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer', title: 'Resolving track...' }),
                                React.createElement('div', { className: 'w-5 h-5 rounded bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%] animate-shimmer', style: { animationDelay: '0.1s' } })
                              )
                          )
                        );
                      })
                ),
                // Top albums tab content
                !friendHistoryLoading && friendHistoryTab === 'topAlbums' && React.createElement('div', {
                  className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4'
                },
                  friendHistoryData.topAlbums.length === 0
                    ? React.createElement('p', { className: 'col-span-full text-center text-gray-400 py-8' }, 'No top albums data')
                    : friendHistoryData.topAlbums.map((album, index) => {
                        const albumPattern = generateArtistPattern(`${album.artist} ${album.name}`);
                        return React.createElement('div', {
                          key: album.id || index,
                          className: 'bg-white rounded-lg overflow-hidden hover:shadow-lg transition-shadow cursor-pointer group',
                          onClick: () => fetchArtistData(album.artist)
                        },
                          React.createElement('div', {
                            className: 'aspect-square relative',
                            style: { background: album.imageLoaded && !album.image ? albumPattern.gradient : '#e5e7eb' }
                          },
                            // Shimmer while loading (imageLoaded not yet true)
                            !album.imageLoaded && React.createElement('div', {
                              className: 'absolute inset-0 bg-gradient-to-r from-gray-300 via-gray-200 to-gray-300 animate-shimmer',
                              style: { backgroundSize: '200% 100%' }
                            }),
                            // Initials fallback (only show when imageLoaded && no image)
                            album.imageLoaded && !album.image && React.createElement('div', {
                              className: 'absolute inset-0 flex items-center justify-center',
                              style: { color: albumPattern.textColor, opacity: 0.4 }
                            },
                              React.createElement('span', {
                                className: 'font-bold tracking-wider',
                                style: { fontSize: '2.5rem', textShadow: '0 2px 8px rgba(0,0,0,0.3)' }
                              }, albumPattern.initials)
                            ),
                            album.image && React.createElement('img', {
                              src: album.image,
                              alt: album.name,
                              className: 'absolute inset-0 w-full h-full object-cover transition-opacity duration-300',
                              style: { opacity: 0 },
                              ref: (el) => { if (el && el.complete && el.naturalWidth > 0) el.style.opacity = '1'; },
                              onLoad: (e) => { e.target.style.opacity = '1'; },
                              onError: (e) => { e.target.style.display = 'none'; }
                            }),
                            React.createElement('div', {
                              className: 'absolute top-2 left-2 px-2 py-0.5 bg-black/60 rounded text-xs text-white font-medium'
                            }, `#${album.rank}`)
                          ),
                          React.createElement('div', { className: 'p-3' },
                            React.createElement('p', { className: 'font-medium text-gray-900 truncate text-sm' }, album.name),
                            React.createElement('p', { className: 'text-xs text-gray-500 truncate' }, album.artist),
                            React.createElement('p', { className: 'text-xs text-gray-400 mt-1' }, `${album.playCount} plays`)
                          )
                        );
                      })
                ),
                // Top artists tab content
                !friendHistoryLoading && friendHistoryTab === 'topArtists' && React.createElement('div', {
                  className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4'
                },
                  friendHistoryData.topArtists.length === 0
                    ? React.createElement('p', { className: 'col-span-full text-center text-gray-400 py-8' }, 'No top artists data')
                    : friendHistoryData.topArtists.map((artist, index) => {
                        const artistPattern = generateArtistPattern(artist.name);
                        return React.createElement('div', {
                          key: artist.id || index,
                          className: 'bg-white rounded-lg overflow-hidden hover:shadow-lg transition-shadow cursor-pointer group',
                          onClick: () => fetchArtistData(artist.name)
                        },
                          React.createElement('div', {
                            className: 'aspect-square relative',
                            style: { background: artist.imageLoaded && !artist.image ? artistPattern.gradient : '#e5e7eb' }
                          },
                            // Shimmer while loading (imageLoaded not yet true)
                            !artist.imageLoaded && React.createElement('div', {
                              className: 'absolute inset-0 bg-gradient-to-r from-gray-300 via-gray-200 to-gray-300 animate-shimmer',
                              style: { backgroundSize: '200% 100%' }
                            }),
                            // Initials fallback (only show when imageLoaded && no image)
                            artist.imageLoaded && !artist.image && React.createElement('div', {
                              className: 'absolute inset-0 flex items-center justify-center',
                              style: { color: artistPattern.textColor, opacity: 0.4 }
                            },
                              React.createElement('span', {
                                className: 'font-bold tracking-wider',
                                style: { fontSize: '2.5rem', textShadow: '0 2px 8px rgba(0,0,0,0.3)' }
                              }, artistPattern.initials)
                            ),
                            artist.image && React.createElement('img', {
                              src: artist.image,
                              alt: artist.name,
                              ref: (el) => { if (el && el.complete && el.naturalWidth > 0) el.style.opacity = '1'; },
                              className: 'absolute inset-0 w-full h-full object-cover transition-opacity duration-300',
                              style: { opacity: 0 },
                              onLoad: (e) => { e.target.style.opacity = '1'; },
                              onError: (e) => { e.target.style.display = 'none'; }
                            }),
                            React.createElement('div', {
                              className: 'absolute top-2 left-2 px-2 py-0.5 bg-black/60 rounded text-xs text-white font-medium'
                            }, `#${artist.rank}`)
                          ),
                          React.createElement('div', { className: 'p-3' },
                            React.createElement('p', { className: 'font-medium text-gray-900 truncate text-sm' }, artist.name),
                            React.createElement('p', { className: 'text-xs text-gray-400 mt-1' }, `${artist.playCount} plays`)
                          )
                        );
                      })
                )
            )
          );
        })(),

        activeView === 'settings' && React.createElement('div', {
          className: 'flex flex-col h-full'
        },
          // Header bar with SETTINGS title and CLOSE button - refined styling
          React.createElement('div', {
            className: 'flex items-center justify-between px-8 py-4 flex-shrink-0',
            style: {
              borderBottom: '1px solid rgba(0, 0, 0, 0.06)',
              backgroundColor: 'rgba(255, 255, 255, 0.8)'
            }
          },
            React.createElement('span', {
              style: {
                fontSize: '11px',
                fontWeight: '600',
                letterSpacing: '0.1em',
                color: '#9ca3af',
                textTransform: 'uppercase'
              }
            }, 'Settings'),
            React.createElement('button', {
              onClick: () => navigateBack(),
              className: 'flex items-center gap-2 no-drag transition-all',
              style: {
                padding: '6px 12px',
                fontSize: '12px',
                fontWeight: '500',
                color: '#6b7280',
                border: '1px solid rgba(0, 0, 0, 0.1)',
                borderRadius: '6px',
                backgroundColor: 'transparent',
                cursor: 'pointer'
              }
            },
              'Close',
              React.createElement('span', { style: { color: '#9ca3af' } }, 'Ã—')
            )
          ),
          // Wrapper for sidebar and content
          React.createElement('div', { className: 'flex flex-1 overflow-hidden' },
            // Settings vertical tabs (left side) - refined styling
            React.createElement('div', {
              className: 'flex-shrink-0',
              style: {
                width: '200px',
                borderRight: '1px solid rgba(0, 0, 0, 0.06)',
                padding: '24px 0',
                backgroundColor: 'rgba(249, 250, 251, 0.5)'
              }
            },
              React.createElement('nav', { style: { padding: '0 12px' } },
              // Marketplace tab
              React.createElement('button', {
                onClick: () => setSettingsTab('marketplace'),
                className: 'w-full text-left transition-all',
                style: {
                  padding: '12px 16px',
                  marginBottom: '4px',
                  fontSize: '13px',
                  fontWeight: settingsTab === 'marketplace' ? '500' : '400',
                  color: settingsTab === 'marketplace' ? '#1f2937' : '#6b7280',
                  backgroundColor: settingsTab === 'marketplace' ? 'rgba(124, 58, 237, 0.08)' : 'transparent',
                  borderRadius: '8px',
                  border: 'none',
                  cursor: 'pointer',
                  borderLeft: settingsTab === 'marketplace' ? '3px solid #7c3aed' : '3px solid transparent'
                }
              }, 'Marketplace'),
              // Installed Plug-Ins tab
              React.createElement('button', {
                onClick: () => setSettingsTab('installed'),
                className: 'w-full text-left transition-all',
                style: {
                  padding: '12px 16px',
                  marginBottom: '4px',
                  fontSize: '13px',
                  fontWeight: settingsTab === 'installed' ? '500' : '400',
                  color: settingsTab === 'installed' ? '#1f2937' : '#6b7280',
                  backgroundColor: settingsTab === 'installed' ? 'rgba(124, 58, 237, 0.08)' : 'transparent',
                  borderRadius: '8px',
                  border: 'none',
                  cursor: 'pointer',
                  borderLeft: settingsTab === 'installed' ? '3px solid #7c3aed' : '3px solid transparent'
                }
              }, 'Installed Plug-Ins'),
              // General tab
              React.createElement('button', {
                onClick: () => setSettingsTab('general'),
                className: 'w-full text-left transition-all',
                style: {
                  padding: '12px 16px',
                  marginBottom: '4px',
                  fontSize: '13px',
                  fontWeight: settingsTab === 'general' ? '500' : '400',
                  color: settingsTab === 'general' ? '#1f2937' : '#6b7280',
                  backgroundColor: settingsTab === 'general' ? 'rgba(124, 58, 237, 0.08)' : 'transparent',
                  borderRadius: '8px',
                  border: 'none',
                  cursor: 'pointer',
                  borderLeft: settingsTab === 'general' ? '3px solid #7c3aed' : '3px solid transparent'
                }
              }, 'General'),
              // About tab
              React.createElement('button', {
                onClick: () => setSettingsTab('about'),
                className: 'w-full text-left transition-all',
                style: {
                  padding: '12px 16px',
                  marginBottom: '4px',
                  fontSize: '13px',
                  fontWeight: settingsTab === 'about' ? '500' : '400',
                  color: settingsTab === 'about' ? '#1f2937' : '#6b7280',
                  backgroundColor: settingsTab === 'about' ? 'rgba(124, 58, 237, 0.08)' : 'transparent',
                  borderRadius: '8px',
                  border: 'none',
                  cursor: 'pointer',
                  borderLeft: settingsTab === 'about' ? '3px solid #7c3aed' : '3px solid transparent'
                }
              }, 'About')
            )
          ),
          // Settings content area (right side) - refined styling
          React.createElement('div', {
            className: 'flex-1 overflow-y-auto scrollable-content',
            style: { padding: '32px 40px' }
          },
            // Installed Plug-Ins Tab
            settingsTab === 'installed' && React.createElement('div', null,
              // Page Header with Add button - refined styling
              React.createElement('div', {
                className: 'flex items-center justify-between',
                style: { marginBottom: '32px' }
              },
                React.createElement('div', null,
                  React.createElement('h2', {
                    style: {
                      fontSize: '20px',
                      fontWeight: '600',
                      color: '#1f2937',
                      marginBottom: '6px'
                    }
                  }, 'Installed Plug-Ins'),
                  React.createElement('p', {
                    style: {
                      fontSize: '13px',
                      color: '#6b7280'
                    }
                  },
                    'Manage your installed plug-ins for playback and services.'
                  )
                ),
                // Add from file button - refined styling
                React.createElement('button', {
                  onClick: handleInstallResolver,
                  className: 'flex items-center gap-2 transition-all',
                  style: {
                    padding: '10px 16px',
                    fontSize: '13px',
                    fontWeight: '500',
                    color: '#374151',
                    backgroundColor: '#ffffff',
                    border: '1px solid rgba(0, 0, 0, 0.1)',
                    borderRadius: '8px',
                    cursor: 'pointer',
                    boxShadow: '0 1px 2px rgba(0, 0, 0, 0.05)'
                  }
                },
                  React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M9 13h6m-3-3v6m5 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z' })
                  ),
                  'Add from file'
                )
              ),

              // Content Resolvers Section - refined styling
              React.createElement('div', { style: { marginBottom: '40px' } },
                React.createElement('div', { style: { marginBottom: '16px' } },
                  React.createElement('h3', {
                    style: {
                      fontSize: '11px',
                      fontWeight: '600',
                      color: '#9ca3af',
                      textTransform: 'uppercase',
                      letterSpacing: '0.08em'
                    }
                  }, 'Content Resolvers'),
                  React.createElement('p', {
                    style: {
                      fontSize: '12px',
                      color: '#9ca3af',
                      marginTop: '4px'
                    }
                  },
                    'Drag to reorder playback priority'
                  )
                ),
                // Resolver grid
                React.createElement('div', {
                  className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-6'
                },
                  resolverOrder
                    .filter(resolverId => allResolvers.some(r => r.id === resolverId))
                    .map((resolverId, index) => {
                    const resolver = allResolvers.find(r => r.id === resolverId);

                    const isActive = activeResolvers.includes(resolver.id);

                    // Check if marketplace has a newer version
                    const marketplaceResolver = marketplaceManifest?.resolvers?.find(r => r.id === resolver.id);
                    const hasUpdate = marketplaceResolver &&
                      marketplaceResolver.version !== resolver.version &&
                      marketplaceResolver.version > resolver.version;

                    // Determine if resolver needs configuration
                    let needsConfiguration = false;
                    if (resolver.id === 'spotify' && !spotifyConnected) {
                      needsConfiguration = true;
                    } else if (resolver.id === 'localfiles' && watchFolders.length === 0) {
                      needsConfiguration = true;
                    } else if (resolver.id === 'qobuz' && !qobuzConnected) {
                      // Qobuz works with previews but full playback needs login
                      needsConfiguration = false; // Optional, so don't mark as needed
                    }

                    return React.createElement(ResolverCard, {
                      key: resolver.id,
                      resolver: resolver,
                      isActive: isActive,
                      hasUpdate: hasUpdate,
                      needsConfiguration: needsConfiguration,
                      priorityNumber: index + 1,
                      draggable: true,
                      isDragging: draggedResolver === resolver.id,
                      isDragOver: dragOverResolver === resolver.id,
                      onClick: () => setSelectedResolver(resolver),
                      onDragStart: (e) => handleResolverDragStart(e, resolver.id),
                      onDragOver: handleResolverDragOver,
                      onDragEnter: (e) => handleResolverDragEnter(e, resolver.id),
                      onDragLeave: handleResolverDragLeave,
                      onDrop: (e) => handleResolverDrop(e, resolver.id),
                      onDragEnd: handleResolverDragEnd,
                      onContextMenu: (e) => {
                        e.preventDefault();
                        if (window.electron?.resolvers?.showContextMenu) {
                          window.electron.resolvers.showContextMenu(resolver.id);
                        }
                      }
                    });
                  })
                )
              ),

              // Meta Services Section - refined styling
              metaServices.length > 0 && React.createElement('div', null,
                React.createElement('div', { style: { marginBottom: '16px' } },
                  React.createElement('h3', {
                    style: {
                      fontSize: '11px',
                      fontWeight: '600',
                      color: '#9ca3af',
                      textTransform: 'uppercase',
                      letterSpacing: '0.08em'
                    }
                  }, 'Meta Services'),
                  React.createElement('p', {
                    style: {
                      fontSize: '12px',
                      color: '#9ca3af',
                      marginTop: '4px'
                    }
                  },
                    'Connected services for recommendations and metadata'
                  )
                ),
                // Meta services grid - refined card layout
                React.createElement('div', {
                  className: 'flex flex-wrap gap-6'
                },
                  metaServices.map(service => {
                    const config = metaServiceConfigs[service.id];
                    const requiresAuth = service.settings?.requiresAuth !== false;
                    // All installed meta services show a checkmark
                    const isConnected = true;

                    return React.createElement('div', {
                      key: service.id,
                      className: 'flex flex-col items-center'
                    },
                      // Card with colored background - refined styling
                      React.createElement('div', {
                        className: 'relative flex items-center justify-center cursor-pointer transition-all',
                        style: {
                          width: '120px',
                          height: '120px',
                          borderRadius: '16px',
                          backgroundColor: service.color || '#6B7280',
                          boxShadow: '0 2px 8px rgba(0, 0, 0, 0.1), 0 4px 16px rgba(0, 0, 0, 0.05)'
                        },
                        onClick: () => setSelectedResolver(service)
                      },
                        // Centered logo or emoji fallback
                        SERVICE_LOGOS[service.id] ? SERVICE_LOGOS[service.id] : React.createElement('span', {
                          className: 'text-5xl text-white drop-shadow-md'
                        }, service.icon),
                        // Connected indicator (top-right checkmark) - refined
                        isConnected && React.createElement('div', {
                          className: 'absolute flex items-center justify-center',
                          style: {
                            top: '8px',
                            right: '8px',
                            width: '22px',
                            height: '22px',
                            backgroundColor: 'rgba(255, 255, 255, 0.95)',
                            borderRadius: '6px',
                            fontSize: '11px',
                            fontWeight: '600',
                            color: '#22c55e'
                          }
                        }, 'âœ“')
                      ),
                      // Name below card - refined typography
                      React.createElement('span', {
                        style: {
                          marginTop: '10px',
                          fontSize: '13px',
                          fontWeight: '500',
                          color: '#1f2937',
                          textAlign: 'center',
                          width: '120px',
                          overflow: 'hidden',
                          textOverflow: 'ellipsis',
                          whiteSpace: 'nowrap'
                        }
                      }, service.name)
                    );
                  })
                )
              )
            ),

            // Marketplace Tab
            settingsTab === 'marketplace' && React.createElement('div', null,
              // Header - refined styling
              React.createElement('div', { style: { marginBottom: '24px' } },
                React.createElement('h2', {
                  style: {
                    fontSize: '20px',
                    fontWeight: '600',
                    color: '#1f2937',
                    marginBottom: '6px'
                  }
                }, 'Marketplace'),
                React.createElement('p', {
                  style: {
                    fontSize: '13px',
                    color: '#6b7280'
                  }
                },
                  'Discover and install plug-ins to extend Parachord.'
                )
              ),

              // Plug-in architecture description - refined styling
              React.createElement('div', {
                style: {
                  background: 'linear-gradient(135deg, rgba(124, 58, 237, 0.06) 0%, rgba(99, 102, 241, 0.06) 100%)',
                  border: '1px solid rgba(124, 58, 237, 0.12)',
                  borderRadius: '12px',
                  padding: '20px',
                  marginBottom: '32px'
                }
              },
                React.createElement('div', { className: 'flex gap-4' },
                  // Icon
                  React.createElement('div', { className: 'flex-shrink-0 w-10 h-10 bg-purple-100 rounded-lg flex items-center justify-center' },
                    React.createElement('svg', { className: 'w-5 h-5 text-purple-600', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                      React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M11 4a2 2 0 114 0v1a1 1 0 001 1h3a1 1 0 011 1v3a1 1 0 01-1 1h-1a2 2 0 100 4h1a1 1 0 011 1v3a1 1 0 01-1 1h-3a1 1 0 01-1-1v-1a2 2 0 10-4 0v1a1 1 0 01-1 1H7a1 1 0 01-1-1v-3a1 1 0 00-1-1H4a2 2 0 110-4h1a1 1 0 001-1V7a1 1 0 011-1h3a1 1 0 001-1V4z' })
                    )
                  ),
                  // Content
                  React.createElement('div', { className: 'flex-1' },
                    React.createElement('h3', { className: 'text-sm font-semibold text-gray-900 mb-2' }, 'Extensible Plug-in Architecture'),
                    React.createElement('p', { className: 'text-sm text-gray-600 leading-relaxed mb-3' },
                      'Parachord\'s plug-in system lets you connect to your favorite music services and customize your listening experience. Each plug-in runs in a secure sandbox, ensuring your data stays safe while enabling powerful integrations.'
                    ),
                    React.createElement('div', { className: 'grid grid-cols-1 sm:grid-cols-3 gap-3' },
                      // Feature 1
                      React.createElement('div', { className: 'flex items-start gap-2' },
                        React.createElement('svg', { className: 'w-4 h-4 text-purple-500 mt-0.5 flex-shrink-0', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                          React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3' })
                        ),
                        React.createElement('span', { className: 'text-xs text-gray-600' }, 'Stream from multiple services in one unified library')
                      ),
                      // Feature 2
                      React.createElement('div', { className: 'flex items-start gap-2' },
                        React.createElement('svg', { className: 'w-4 h-4 text-purple-500 mt-0.5 flex-shrink-0', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                          React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M4 7v10c0 2.21 3.582 4 8 4s8-1.79 8-4V7M4 7c0 2.21 3.582 4 8 4s8-1.79 8-4M4 7c0-2.21 3.582-4 8-4s8 1.79 8 4' })
                        ),
                        React.createElement('span', { className: 'text-xs text-gray-600' }, 'Enrich metadata with artist bios, lyrics, and recommendations')
                      ),
                      // Feature 3
                      React.createElement('div', { className: 'flex items-start gap-2' },
                        React.createElement('svg', { className: 'w-4 h-4 text-purple-500 mt-0.5 flex-shrink-0', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                          React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z' })
                        ),
                        React.createElement('span', { className: 'text-xs text-gray-600' }, 'Sandboxed execution keeps your credentials secure')
                      )
                    )
                  )
                )
              ),

              // Search and filter bar
              React.createElement('div', { className: 'flex items-center gap-4 mb-8' },
                // Search input
                React.createElement('div', { className: 'relative' },
                  React.createElement('svg', {
                    className: 'absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-gray-400',
                    fill: 'none',
                    viewBox: '0 0 24 24',
                    stroke: 'currentColor'
                  },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' })
                  ),
                  React.createElement('input', {
                    type: 'text',
                    placeholder: 'Search plug-ins...',
                    value: marketplaceSearchQuery,
                    onChange: (e) => setMarketplaceSearchQuery(e.target.value),
                    className: 'w-64 pl-9 pr-4 py-2 bg-gray-50 border border-gray-200 rounded-full text-sm text-gray-900 placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent'
                  })
                ),
                // Category filter pills
                React.createElement('div', { className: 'flex gap-2 flex-wrap' },
                  [
                    { value: 'all', label: 'All' },
                    { value: 'streaming', label: 'Streaming' },
                    { value: 'purchase', label: 'Purchase' },
                    { value: 'social', label: 'Social' },
                    { value: 'metadata', label: 'Metadata' },
                    { value: 'ai', label: 'AI' },
                    { value: 'local', label: 'Local' }
                  ].map(({ value, label }) =>
                    React.createElement('button', {
                      key: value,
                      onClick: () => setMarketplaceCategory(value),
                      className: `px-3 py-1.5 rounded-full text-sm transition-all ${
                        marketplaceCategory === value
                          ? 'bg-purple-600 text-white'
                          : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                      }`
                    }, label)
                  )
                )
              ),
              // Loading state
              marketplaceLoading && React.createElement('div', {
                className: 'text-center py-12 text-gray-500'
              }, 'Loading marketplace...'),
              // Empty state
              !marketplaceLoading && marketplaceManifest && marketplaceManifest.resolvers && marketplaceManifest.resolvers.length === 0 &&
                React.createElement('div', {
                  className: 'text-center py-12 text-gray-400'
                }, 'No plug-ins available in marketplace yet.'),
              // Resolver grid
              !marketplaceLoading && marketplaceManifest && marketplaceManifest.resolvers && marketplaceManifest.resolvers.length > 0 &&
                React.createElement('div', {
                  className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-6'
                },
                  marketplaceManifest.resolvers
                    .filter(resolver => {
                      if (marketplaceSearchQuery) {
                        const query = marketplaceSearchQuery.toLowerCase();
                        const matchesName = resolver.name.toLowerCase().includes(query);
                        const matchesDesc = resolver.description.toLowerCase().includes(query);
                        const matchesAuthor = resolver.author.toLowerCase().includes(query);
                        if (!matchesName && !matchesDesc && !matchesAuthor) return false;
                      }
                      if (marketplaceCategory !== 'all') {
                        const matchesCategory = resolver.category === marketplaceCategory;
                        const matchesTag = resolver.tags && resolver.tags.includes(marketplaceCategory);
                        if (!matchesCategory && !matchesTag) return false;
                      }
                      return true;
                    })
                    .map(resolver => {
                      const installedResolver = allResolvers.find(r => r.id === resolver.id);
                      const isInstalled = !!installedResolver;
                      const isInstalling = installingResolvers.has(resolver.id);

                      return React.createElement(ResolverCard, {
                        key: resolver.id,
                        resolver: resolver,
                        isInstalled: isInstalled,
                        isInstalling: isInstalling,
                        onClick: () => setSelectedMarketplaceItem({ ...resolver, isInstalled, installedResolver })
                      });
                    })
                )
            ),

            // General Tab - refined styling
            settingsTab === 'general' && React.createElement('div', null,
              // Page Header - refined
              React.createElement('div', { style: { marginBottom: '32px' } },
                React.createElement('h2', {
                  style: {
                    fontSize: '20px',
                    fontWeight: '600',
                    color: '#1f2937',
                    marginBottom: '6px'
                  }
                }, 'General'),
                React.createElement('p', {
                  style: {
                    fontSize: '13px',
                    color: '#6b7280'
                  }
                },
                  'Configure application settings and preferences.'
                )
              ),

              // Settings sections - refined
              React.createElement('div', { style: { display: 'flex', flexDirection: 'column', gap: '24px' } },
                // Cache Management Section - refined card
                React.createElement('div', {
                  style: {
                    backgroundColor: '#ffffff',
                    border: '1px solid rgba(0, 0, 0, 0.06)',
                    borderRadius: '12px',
                    padding: '24px',
                    boxShadow: '0 1px 3px rgba(0, 0, 0, 0.04)'
                  }
                },
                  React.createElement('div', { style: { marginBottom: '16px' } },
                    React.createElement('h3', {
                      style: {
                        fontSize: '11px',
                        fontWeight: '600',
                        color: '#9ca3af',
                        textTransform: 'uppercase',
                        letterSpacing: '0.08em'
                      }
                    }, 'Cache Management'),
                    React.createElement('p', {
                      style: {
                        fontSize: '12px',
                        color: '#9ca3af',
                        marginTop: '4px'
                      }
                    }, 'Clear cached data to free up space or fix display issues')
                  ),
                  React.createElement('p', {
                    style: {
                      fontSize: '13px',
                      color: '#6b7280',
                      marginBottom: '20px',
                      lineHeight: '1.6'
                    }
                  }, 'This will remove cached artist images, album art, and API responses. Loading may be slower temporarily while data is re-fetched.'),
                  React.createElement('button', {
                    onClick: async () => {
                      // Clear all caches
                      artistImageCache.current = {};
                      albumArtCache.current = {};
                      artistDataCache.current = {};
                      albumToReleaseIdCache.current = {};

                      // Clear persisted caches
                      if (window.electron?.store) {
                        await window.electron.store.set('cache_artist_images', {});
                        await window.electron.store.set('cache_album_art', {});
                        await window.electron.store.set('cache_artist_data', {});
                        await window.electron.store.set('cache_album_release_ids', {});
                      }

                      // Show confirmation (using a simple alert for now)
                      alert('Cache cleared successfully!');
                    },
                    className: 'inline-flex items-center gap-2 transition-all',
                    style: {
                      padding: '10px 16px',
                      backgroundColor: '#ef4444',
                      color: '#ffffff',
                      fontSize: '13px',
                      fontWeight: '500',
                      borderRadius: '8px',
                      border: 'none',
                      cursor: 'pointer'
                    }
                  },
                    React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                      React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16' })
                    ),
                    'Clear Cache'
                  )
                ),

                // Volume Normalization Section - refined card
                React.createElement('div', {
                  style: {
                    backgroundColor: '#ffffff',
                    border: '1px solid rgba(0, 0, 0, 0.06)',
                    borderRadius: '12px',
                    padding: '24px',
                    boxShadow: '0 1px 3px rgba(0, 0, 0, 0.04)'
                  }
                },
                  React.createElement('div', { style: { marginBottom: '16px' } },
                    React.createElement('h3', {
                      style: {
                        fontSize: '11px',
                        fontWeight: '600',
                        color: '#9ca3af',
                        textTransform: 'uppercase',
                        letterSpacing: '0.08em'
                      }
                    }, 'Volume Normalization'),
                    React.createElement('p', {
                      style: {
                        fontSize: '12px',
                        color: '#9ca3af',
                        marginTop: '4px'
                      }
                    }, 'Balance loudness between different sources')
                  ),
                  React.createElement('p', {
                    style: {
                      fontSize: '13px',
                      color: '#6b7280',
                      marginBottom: '24px',
                      lineHeight: '1.6'
                    }
                  }, 'Adjust volume offsets per resolver to balance loudness. Negative values reduce volume for louder sources.'),

                  // Resolver volume offset sliders - only show enabled content resolvers
                  React.createElement('div', { style: { display: 'flex', flexDirection: 'column', gap: '8px' } },
                    // Filter to only show content resolvers (have resolve capability) that are enabled
                    loadedResolvers
                      .filter(r => r.capabilities?.resolve && activeResolvers.includes(r.id))
                      .map(resolver => {
                        // Browser-based resolvers can't have volume controlled
                        const isBrowserBased = !resolver.capabilities?.stream;
                        const offset = resolverVolumeOffsets[resolver.id] || 0;

                        return React.createElement('div', {
                          key: resolver.id,
                          className: 'flex items-center gap-4 transition-colors',
                          style: {
                            padding: '10px 12px',
                            borderRadius: '8px',
                            backgroundColor: 'rgba(0, 0, 0, 0.02)',
                            opacity: isBrowserBased ? 0.5 : 1
                          }
                        },
                          React.createElement('span', {
                            style: {
                              width: '100px',
                              fontSize: '13px',
                              fontWeight: '500',
                              color: isBrowserBased ? '#9ca3af' : '#374151'
                            }
                          }, resolver.name),
                          React.createElement('input', {
                            type: 'range',
                            min: '-12',
                            max: '6',
                            step: '1',
                            value: offset,
                            onChange: (e) => setResolverVolumeOffsets(prev => ({ ...prev, [resolver.id]: Number(e.target.value) })),
                            className: `flex-1 h-2 bg-gray-200 rounded-full appearance-none ${isBrowserBased ? 'cursor-not-allowed' : 'cursor-pointer accent-purple-600'}`,
                            disabled: isBrowserBased,
                            title: isBrowserBased ? 'Browser playback - volume control not available' : undefined
                          }),
                          React.createElement('span', {
                            style: {
                              width: '56px',
                              fontSize: isBrowserBased ? '11px' : '12px',
                              color: isBrowserBased ? '#9ca3af' : '#6b7280',
                              textAlign: 'right',
                              fontFamily: isBrowserBased ? 'inherit' : 'monospace',
                              fontStyle: isBrowserBased ? 'italic' : 'normal'
                            }
                          }, isBrowserBased ? 'Browser' : `${offset > 0 ? '+' : ''}${offset} dB`)
                        );
                      })
                  ),
                  // Show message if no content resolvers are enabled
                  loadedResolvers.filter(r => r.capabilities?.resolve && activeResolvers.includes(r.id)).length === 0 &&
                    React.createElement('p', {
                      style: { fontSize: '13px', color: '#9ca3af', fontStyle: 'italic', padding: '12px 0' }
                    }, 'No content resolvers enabled. Enable resolvers in Settings â†’ Resolvers.'),

                  // Reset button - refined
                  React.createElement('div', { style: { marginTop: '24px', paddingTop: '20px', borderTop: '1px solid rgba(0, 0, 0, 0.06)' } },
                    React.createElement('button', {
                      onClick: () => setResolverVolumeOffsets({
                        spotify: 0,
                        localfiles: 0,
                        bandcamp: -3,
                        youtube: -6,
                        qobuz: 0
                      }),
                      className: 'inline-flex items-center gap-2 transition-all',
                      style: {
                        padding: '10px 16px',
                        fontSize: '13px',
                        fontWeight: '500',
                        color: '#374151',
                        backgroundColor: '#ffffff',
                        border: '1px solid rgba(0, 0, 0, 0.1)',
                        borderRadius: '8px',
                        cursor: 'pointer'
                      }
                    },
                      React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                        React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15' })
                      ),
                      'Reset to Defaults'
                    )
                  )
                ),

                // Playback Behavior Section - refined card
                React.createElement('div', {
                  style: {
                    backgroundColor: '#ffffff',
                    border: '1px solid rgba(0, 0, 0, 0.06)',
                    borderRadius: '12px',
                    padding: '24px',
                    boxShadow: '0 1px 3px rgba(0, 0, 0, 0.04)'
                  }
                },
                  React.createElement('div', { style: { marginBottom: '16px' } },
                    React.createElement('h3', {
                      style: {
                        fontSize: '11px',
                        fontWeight: '600',
                        color: '#9ca3af',
                        textTransform: 'uppercase',
                        letterSpacing: '0.08em'
                      }
                    }, 'Playback Behavior'),
                    React.createElement('p', {
                      style: {
                        fontSize: '12px',
                        color: '#9ca3af',
                        marginTop: '4px'
                      }
                    }, 'Configure how external tracks are handled')
                  ),
                  // Skip external prompt toggle - refined
                  React.createElement('div', { className: 'flex items-center justify-between', style: { padding: '12px 0' } },
                    React.createElement('div', null,
                      React.createElement('p', { style: { fontSize: '13px', fontWeight: '500', color: '#374151' } },
                        'Auto-open external tracks'
                      ),
                      React.createElement('p', { style: { fontSize: '12px', color: '#9ca3af', marginTop: '2px' } },
                        'Skip the confirmation prompt for Bandcamp, YouTube, etc.'
                      )
                    ),
                    React.createElement('button', {
                      onClick: async () => {
                        const newValue = !skipExternalPrompt;
                        setSkipExternalPrompt(newValue);
                        if (window.electron?.store) {
                          await window.electron.store.set('skip_external_prompt', newValue);
                        }
                      },
                      className: `relative w-11 h-6 rounded-full transition-colors ${skipExternalPrompt ? 'bg-purple-600' : 'bg-gray-300'}`
                    },
                      React.createElement('span', {
                        className: `absolute top-0.5 left-0.5 w-5 h-5 bg-white rounded-full shadow transition-transform ${skipExternalPrompt ? 'translate-x-5' : 'translate-x-0'}`
                      })
                    )
                  ),
                ),

                // Dialogs Section - Reset "Don't show again" preferences
                React.createElement('div', {
                  className: 'bg-white border border-gray-200 rounded-xl p-6 hover:shadow-sm hover:border-gray-300 transition-all'
                },
                  React.createElement('div', { className: 'mb-5' },
                    React.createElement('h3', {
                      className: 'text-sm font-semibold text-gray-700 uppercase tracking-wider'
                    }, 'Dialogs'),
                    React.createElement('p', {
                      className: 'text-xs text-gray-500 mt-1'
                    }, 'Manage confirmation dialogs and prompts')
                  ),
                  // List of dismissed dialogs
                  React.createElement('div', { className: 'space-y-3 mb-5' },
                    // External track prompt
                    React.createElement('div', { className: 'flex items-center justify-between py-2 px-3 rounded-lg bg-gray-50' },
                      React.createElement('div', null,
                        React.createElement('p', { className: 'text-sm text-gray-900' }, 'Open in Browser prompt'),
                        React.createElement('p', { className: 'text-xs text-gray-500' }, 'Confirmation before opening external tracks')
                      ),
                      React.createElement('div', {
                        className: `px-2 py-0.5 rounded text-xs font-medium ${skipExternalPrompt ? 'bg-amber-100 text-amber-700' : 'bg-green-100 text-green-700'}`
                      }, skipExternalPrompt ? 'Hidden' : 'Showing')
                    ),
                    // Unsaved friend unpin warning
                    React.createElement('div', { className: 'flex items-center justify-between py-2 px-3 rounded-lg bg-gray-50' },
                      React.createElement('div', null,
                        React.createElement('p', { className: 'text-sm text-gray-900' }, 'Unsaved friend warning'),
                        React.createElement('p', { className: 'text-xs text-gray-500' }, 'Warning when unpinning friends not saved to collection')
                      ),
                      React.createElement('div', {
                        className: `px-2 py-0.5 rounded text-xs font-medium ${skipUnsavedFriendWarning ? 'bg-amber-100 text-amber-700' : 'bg-green-100 text-green-700'}`
                      }, skipUnsavedFriendWarning ? 'Hidden' : 'Showing')
                    )
                  ),
                  // Reset all button
                  (skipExternalPrompt || skipUnsavedFriendWarning) && React.createElement('button', {
                    onClick: async () => {
                      setSkipExternalPrompt(false);
                      setSkipUnsavedFriendWarning(false);
                      if (window.electron?.store) {
                        await window.electron.store.set('skip_external_prompt', false);
                        await window.electron.store.set('skip_unsaved_friend_warning', false);
                      }
                      showToast('All dialog preferences reset');
                    },
                    className: 'inline-flex items-center gap-2 px-4 py-2 bg-purple-600 text-white text-sm font-medium rounded-lg hover:bg-purple-700 transition-colors'
                  },
                    React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                      React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15' })
                    ),
                    'Reset All Dialogs'
                  ),
                  // All dialogs showing message
                  (!skipExternalPrompt && !skipUnsavedFriendWarning) && React.createElement('p', {
                    className: 'text-sm text-gray-500 italic'
                  }, 'All confirmation dialogs are currently enabled.')
                ),

                // Queue Settings Section
                React.createElement('div', {
                  className: 'bg-white border border-gray-200 rounded-xl p-6 hover:shadow-sm hover:border-gray-300 transition-all'
                },
                  React.createElement('div', { className: 'mb-5' },
                    React.createElement('h3', {
                      className: 'text-sm font-semibold text-gray-700 uppercase tracking-wider'
                    }, 'Queue Settings'),
                    React.createElement('p', {
                      className: 'text-xs text-gray-500 mt-1'
                    }, 'Configure queue persistence')
                  ),
                  // Remember queue toggle
                  React.createElement('div', { className: 'flex items-center justify-between py-3' },
                    React.createElement('div', null,
                      React.createElement('p', { className: 'text-sm text-gray-900 font-medium' },
                        'Remember queue'
                      ),
                      React.createElement('p', { className: 'text-xs text-gray-500 mt-0.5' },
                        'Restore your queue when you reopen the app'
                      )
                    ),
                    React.createElement('button', {
                      onClick: async () => {
                        const newValue = !rememberQueue;
                        setRememberQueue(newValue);
                        if (window.electron?.store) {
                          await window.electron.store.set('remember_queue', newValue);
                          // If turning off, clear the saved queue and context
                          if (!newValue) {
                            await window.electron.store.set('saved_queue', []);
                            await window.electron.store.set('saved_playback_context', null);
                          }
                        }
                      },
                      className: `relative w-11 h-6 rounded-full transition-colors ${rememberQueue ? 'bg-purple-600' : 'bg-gray-300'}`
                    },
                      React.createElement('span', {
                        className: `absolute top-0.5 left-0.5 w-5 h-5 bg-white rounded-full shadow transition-transform ${rememberQueue ? 'translate-x-5' : 'translate-x-0'}`
                      })
                    )
                  )
                ),

                // Scrobbling Section
                React.createElement('div', {
                  className: 'bg-white border border-gray-200 rounded-xl p-6 hover:shadow-sm hover:border-gray-300 transition-all'
                },
                  React.createElement('div', { className: 'mb-5' },
                    React.createElement('h3', {
                      className: 'text-sm font-semibold text-gray-700 uppercase tracking-wider flex items-center gap-2'
                    },
                      // Music note icon
                      React.createElement('svg', {
                        className: 'w-4 h-4',
                        fill: 'none',
                        stroke: 'currentColor',
                        viewBox: '0 0 24 24'
                      },
                        React.createElement('path', {
                          strokeLinecap: 'round',
                          strokeLinejoin: 'round',
                          strokeWidth: 2,
                          d: 'M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3'
                        })
                      ),
                      'Scrobbling'
                    ),
                    React.createElement('p', {
                      className: 'text-xs text-gray-500 mt-1'
                    }, 'Report your listening history to scrobbling services')
                  ),

                  // Global enable/disable toggle
                  React.createElement('div', { className: 'flex items-center justify-between py-3 px-3 bg-gray-50 rounded-lg' },
                    React.createElement('div', null,
                      React.createElement('p', { className: 'text-sm text-gray-900 font-medium' },
                        'Enable Scrobbling'
                      ),
                      React.createElement('p', { className: 'text-xs text-gray-500 mt-0.5' },
                        'Send your listening activity to connected services'
                      )
                    ),
                    React.createElement('button', {
                      onClick: async () => {
                        const newValue = !scrobblingEnabled;
                        setScrobblingEnabled(newValue);
                        if (window.electron?.store) {
                          await window.electron.store.set('scrobbling-enabled', newValue);
                        }
                      },
                      className: `relative w-11 h-6 rounded-full transition-colors ${scrobblingEnabled ? 'bg-purple-600' : 'bg-gray-300'}`
                    },
                      React.createElement('span', {
                        className: `absolute top-0.5 left-0.5 w-5 h-5 bg-white rounded-full shadow transition-transform ${scrobblingEnabled ? 'translate-x-5' : 'translate-x-0'}`
                      })
                    )
                  ),

                  // Note about configuring scrobblers
                  React.createElement('p', {
                    className: 'text-xs text-gray-500 mt-4 text-center'
                  }, 'Configure scrobbling services in their respective settings: Last.fm, ListenBrainz, and Libre.fm.')
                ),

                // Developer Settings Section
                React.createElement('div', {
                  className: 'bg-white border border-gray-200 rounded-xl p-6 hover:shadow-sm hover:border-gray-300 transition-all'
                },
                  React.createElement('div', { className: 'mb-5' },
                    React.createElement('h3', {
                      className: 'text-sm font-semibold text-gray-700 uppercase tracking-wider'
                    }, 'Developer Settings'),
                    React.createElement('p', {
                      className: 'text-xs text-gray-500 mt-1'
                    }, 'Options for testing and development')
                  ),
                  // Reset Tutorial button
                  React.createElement('div', {
                    className: 'flex items-center justify-between py-3 border-b border-gray-100'
                  },
                    React.createElement('div', null,
                      React.createElement('div', {
                        className: 'text-sm font-medium text-gray-900'
                      }, 'Reset Tutorial'),
                      React.createElement('div', {
                        className: 'text-xs text-gray-500 mt-0.5'
                      }, 'Show the first-run tutorial again on next app launch')
                    ),
                    React.createElement('button', {
                      onClick: async () => {
                        await window.electron.store.delete('tutorial_completed');
                        alert('Tutorial reset! The welcome tutorial will appear the next time you open Parachord.');
                      },
                      className: 'px-3 py-1.5 text-xs font-medium text-indigo-600 bg-indigo-50 rounded-lg hover:bg-indigo-100 transition-colors'
                    }, 'Reset')
                  ),
                  // Show Tutorial Now button
                  React.createElement('div', {
                    className: 'flex items-center justify-between py-3'
                  },
                    React.createElement('div', null,
                      React.createElement('div', {
                        className: 'text-sm font-medium text-gray-900'
                      }, 'Show Tutorial Now'),
                      React.createElement('div', {
                        className: 'text-xs text-gray-500 mt-0.5'
                      }, 'Open the first-run tutorial immediately')
                    ),
                    React.createElement('button', {
                      onClick: () => {
                        setFirstRunTutorial(prev => ({ ...prev, open: true, step: 'welcome' }));
                      },
                      className: 'px-3 py-1.5 text-xs font-medium text-indigo-600 bg-indigo-50 rounded-lg hover:bg-indigo-100 transition-colors'
                    }, 'Show')
                  )
                ),

                // Reset Application Section
                React.createElement('div', {
                  className: 'bg-white border border-red-200 rounded-xl p-6 hover:shadow-sm hover:border-red-300 transition-all'
                },
                  React.createElement('div', { className: 'mb-5' },
                    React.createElement('h3', {
                      className: 'text-sm font-semibold text-red-700 uppercase tracking-wider'
                    }, 'Reset Application'),
                    React.createElement('p', {
                      className: 'text-xs text-gray-500 mt-1'
                    }, 'Clear all data and start fresh')
                  ),
                  React.createElement('p', {
                    className: 'text-sm text-gray-600 mb-5 leading-relaxed'
                  }, 'This will permanently delete all your data including your collection, playlists, friends, listening history, connected accounts, and all settings. The app will restart as if it was freshly installed.'),
                  React.createElement('button', {
                    onClick: async () => {
                      // Show confirmation dialog
                      const confirmed = window.confirm(
                        'Are you sure you want to reset the application?\n\n' +
                        'This will permanently delete:\n' +
                        'â€¢ Your music collection\n' +
                        'â€¢ All playlists\n' +
                        'â€¢ Friends list\n' +
                        'â€¢ Connected accounts (Spotify, Last.fm, etc.)\n' +
                        'â€¢ All settings and preferences\n' +
                        'â€¢ Cached data\n\n' +
                        'This action cannot be undone.'
                      );

                      if (confirmed) {
                        try {
                          // Clear electron store (all persisted data)
                          if (window.electron?.store?.clear) {
                            await window.electron.store.clear();
                          }

                          // Clear in-memory caches
                          artistImageCache.current = {};
                          albumArtCache.current = {};
                          artistDataCache.current = {};
                          albumToReleaseIdCache.current = {};

                          // Reload the app
                          window.location.reload();
                        } catch (error) {
                          console.error('Failed to reset application:', error);
                          alert('Failed to reset application. Please try again.');
                        }
                      }
                    },
                    className: 'inline-flex items-center gap-2 px-4 py-2 bg-red-600 text-white text-sm font-medium rounded-lg hover:bg-red-700 transition-colors'
                  },
                    React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                      React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z' })
                    ),
                    'Reset Application'
                  )
                )
              ) // Close space-y-8 wrapper
            ),

            // About Tab
            settingsTab === 'about' && React.createElement('div', {
              className: 'flex flex-col items-center justify-center',
              style: { paddingTop: '48px', paddingBottom: '48px' }
            },
              // Centered card container
              React.createElement('div', {
                style: {
                  backgroundColor: '#ffffff',
                  border: '1px solid rgba(0, 0, 0, 0.06)',
                  borderRadius: '16px',
                  padding: '48px 56px',
                  boxShadow: '0 1px 3px rgba(0, 0, 0, 0.04), 0 8px 24px rgba(0, 0, 0, 0.06)',
                  textAlign: 'center',
                  maxWidth: '420px'
                }
              },
                // Parachord Logo
                React.createElement('div', { style: { marginBottom: '20px', display: 'flex', justifyContent: 'center' } },
                  React.createElement(ParachordWordmark, { fill: '#333', height: 56 })
                ),

                // Version
                React.createElement('p', {
                  style: {
                    fontSize: '14px',
                    fontWeight: '500',
                    color: '#374151',
                    marginBottom: '8px'
                  }
                }, 'Version 1.0.0'),

                // Tagline
                React.createElement('p', {
                  style: {
                    fontSize: '13px',
                    color: '#6b7280',
                    marginBottom: '32px',
                    lineHeight: '1.6',
                    maxWidth: '320px'
                  }
                },
                  'A modern multi-source music player inspired by ',
                  React.createElement('a', {
                    href: '#',
                    onClick: (e) => {
                      e.preventDefault();
                      if (window.electron?.shell?.openExternal) {
                        window.electron.shell.openExternal('https://github.com/tomahawk-player/tomahawk');
                      }
                    },
                    style: {
                      color: '#7c3aed',
                      textDecoration: 'none',
                      fontWeight: '500'
                    }
                  }, 'Tomahawk'),
                  '.'
                ),

                // Divider
                React.createElement('div', {
                  style: {
                    width: '64px',
                    height: '1px',
                    backgroundColor: 'rgba(0, 0, 0, 0.08)',
                    margin: '0 auto 32px'
                  }
                }),

                // Open Source info
                React.createElement('div', { style: { marginBottom: '24px' } },
                  React.createElement('p', {
                    style: {
                      fontSize: '11px',
                      fontWeight: '600',
                      color: '#9ca3af',
                      textTransform: 'uppercase',
                      letterSpacing: '0.08em',
                      marginBottom: '8px'
                    }
                  }, 'Open Source Software'),
                  React.createElement('p', {
                    style: {
                      fontSize: '12px',
                      color: '#6b7280',
                      marginBottom: '12px'
                    }
                  },
                    'Built with Electron, React, and Tailwind CSS'
                  ),
                  React.createElement('a', {
                    href: '#',
                    onClick: (e) => {
                      e.preventDefault();
                      if (window.electron?.shell?.openExternal) {
                        window.electron.shell.openExternal('https://github.com/jherskowitz/parachord');
                      }
                    },
                    style: {
                      fontSize: '12px',
                      color: '#7c3aed',
                      fontWeight: '500',
                      textDecoration: 'none'
                    }
                  }, 'View on GitHub â†’')
                ),

                // Copyright
                React.createElement('p', {
                  style: {
                    fontSize: '11px',
                    color: '#9ca3af'
                  }
                },
                  'Â© ', new Date().getFullYear(), ' Parachord. All rights reserved.'
                ),

                // License
                React.createElement('p', {
                  style: {
                    fontSize: '11px',
                    color: '#9ca3af',
                    marginTop: '4px'
                  }
                },
                  'Licensed under the MIT License'
                )
              )
            )
          )
        ) // Close content area
      ) // Close wrapper (sidebar + content)
    ) // Close settings container
    )
    ), // Close outer wrappers

    // Player bar (always visible) - New Tomahawk-inspired layout
    // Layout: [Left: transport + queue] [Center: track info] [Right: progress + shuffle + repeat + volume]
    // z-50 to stay above queue drawer
    React.createElement('div', {
      className: 'bg-gray-800/95 backdrop-blur-xl border-t border-gray-700 py-3 no-drag flex-shrink-0 relative z-50',
      style: { minHeight: '85px', paddingLeft: '26px', paddingRight: '26px' }
    },
      React.createElement('div', { className: 'flex items-center justify-between gap-4' },
        // LEFT: Transport controls + Queue button
        React.createElement('div', { className: 'flex items-center gap-2' },
          React.createElement(Tooltip, { content: 'Previous', position: 'top', variant: 'dark' },
            React.createElement('button', {
              onClick: handlePrevious,
              disabled: !currentTrack,
              className: `p-2 rounded hover:bg-white/10 transition-colors ${!currentTrack ? 'text-gray-600 cursor-not-allowed' : 'text-white'}`,
              style: { display: 'flex', alignItems: 'center', justifyContent: 'center' }
            }, React.createElement(SkipBack, { size: 18 }))
          ),
          React.createElement(Tooltip, { content: isPlaying ? 'Pause' : 'Play', position: 'top', variant: 'dark' },
            React.createElement('button', {
              onClick: handlePlayPause,
              disabled: !currentTrack,
              className: `p-2 rounded hover:bg-white/10 transition-colors ${!currentTrack ? 'text-gray-600 cursor-not-allowed' : 'text-white'}`,
              style: { width: '38px', height: '38px', display: 'flex', alignItems: 'center', justifyContent: 'center' }
            }, isPlaying ? React.createElement(Pause, { size: 22 }) : React.createElement(Play, { size: 22 }))
          ),
          React.createElement(Tooltip, { content: 'Next', position: 'top', variant: 'dark' },
            React.createElement('button', {
              onClick: () => handleNext(true),
              disabled: !currentTrack,
              className: `p-2 rounded hover:bg-white/10 transition-colors ${!currentTrack ? 'text-gray-600 cursor-not-allowed' : 'text-white'}`,
              style: { display: 'flex', alignItems: 'center', justifyContent: 'center' }
            }, React.createElement(SkipForward, { size: 18 }))
          ),
          // Queue button (hamburger style)
          React.createElement(Tooltip, { content: 'Queue', position: 'top', variant: 'dark' },
            React.createElement('button', {
              onClick: () => setQueueDrawerOpen(!queueDrawerOpen),
              className: `relative p-2 ml-1 rounded hover:bg-white/10 transition-colors ${queueDrawerOpen ? 'bg-white/20 text-white' : 'text-gray-400'} ${queueAnimating ? 'queue-pulse' : ''}`,
              style: { display: 'flex', alignItems: 'center', justifyContent: 'center' }
            },
              React.createElement(List, { size: 15 }),
              // Show queue badge (gray when in spinoff or listen-along mode)
              currentQueue.length > 0 && React.createElement('span', {
                className: `absolute -top-1 -right-1 text-white rounded-full min-w-[16px] h-[16px] flex items-center justify-center px-1 font-medium ${queueAnimating ? 'badge-flash' : ''}`,
                style: { fontSize: '10px', backgroundColor: (spinoffMode || listenAlongFriend) ? '#6b7280' : '#059669' }
              }, currentQueue.length > 99 ? '99+' : currentQueue.length)
            )
          ),
          // AI Playlist Generation button (sparkle icon) - with tooltip
          (() => {
            const aiResolvers = getAiServices();
            const hasEnabledAi = aiResolvers.some(s => {
              const config = metaServiceConfigs[s.id] || {};
              return config.enabled && config.apiKey;
            });
            return React.createElement(Tooltip, {
              content: hasEnabledAi
                ? 'AI Playlist'
                : 'Enable AI in Settings',
              position: 'top',
              variant: 'dark'
            },
              React.createElement('button', {
                onClick: () => setAiPromptOpen(!aiPromptOpen),
                disabled: !hasEnabledAi,
                className: `p-2 ml-1 rounded transition-colors ${
                  aiPromptOpen
                    ? 'bg-purple-500/30 text-purple-300'
                    : hasEnabledAi
                      ? 'text-gray-400 hover:bg-white/10 hover:text-white'
                      : 'text-gray-600 cursor-not-allowed'
                }`
              },
                React.createElement('svg', {
                  className: 'w-4 h-4',
                  viewBox: '0 0 56 56',
                  fill: 'currentColor'
                },
                  // Sparkle icon
                  React.createElement('path', {
                    d: 'M 26.6875 12.6602 C 26.9687 12.6602 27.1094 12.4961 27.1797 12.2383 C 27.9062 8.3242 27.8594 8.2305 31.9375 7.4570 C 32.2187 7.4102 32.3828 7.2461 32.3828 6.9648 C 32.3828 6.6836 32.2187 6.5195 31.9375 6.4726 C 27.8828 5.6524 28.0000 5.5586 27.1797 1.6914 C 27.1094 1.4336 26.9687 1.2695 26.6875 1.2695 C 26.4062 1.2695 26.2656 1.4336 26.1953 1.6914 C 25.3750 5.5586 25.5156 5.6524 21.4375 6.4726 C 21.1797 6.5195 20.9922 6.6836 20.9922 6.9648 C 20.9922 7.2461 21.1797 7.4102 21.4375 7.4570 C 25.5156 8.2774 25.4687 8.3242 26.1953 12.2383 C 26.2656 12.4961 26.4062 12.6602 26.6875 12.6602 Z M 15.3438 28.7852 C 15.7891 28.7852 16.0938 28.5039 16.1406 28.0821 C 16.9844 21.8242 17.1953 21.8242 23.6641 20.5821 C 24.0860 20.5117 24.3906 20.2305 24.3906 19.7852 C 24.3906 19.3633 24.0860 19.0586 23.6641 18.9883 C 17.1953 18.0977 16.9609 17.8867 16.1406 11.5117 C 16.0938 11.0899 15.7891 10.7852 15.3438 10.7852 C 14.9219 10.7852 14.6172 11.0899 14.5703 11.5352 C 13.7969 17.8164 13.4687 17.7930 7.0469 18.9883 C 6.6250 19.0821 6.3203 19.3633 6.3203 19.7852 C 6.3203 20.2539 6.6250 20.5117 7.1406 20.5821 C 13.5156 21.6133 13.7969 21.7774 14.5703 28.0352 C 14.6172 28.5039 14.9219 28.7852 15.3438 28.7852 Z M 31.2344 54.7305 C 31.8438 54.7305 32.2891 54.2852 32.4062 53.6524 C 34.0703 40.8086 35.8750 38.8633 48.5781 37.4570 C 49.2344 37.3867 49.6797 36.8945 49.6797 36.2852 C 49.6797 35.6758 49.2344 35.2070 48.5781 35.1133 C 35.8750 33.7070 34.0703 31.7617 32.4062 18.9180 C 32.2891 18.2852 31.8438 17.8633 31.2344 17.8633 C 30.6250 17.8633 30.1797 18.2852 30.0860 18.9180 C 28.4219 31.7617 26.5938 33.7070 13.9140 35.1133 C 13.2344 35.2070 12.7891 35.6758 12.7891 36.2852 C 12.7891 36.8945 13.2344 37.3867 13.9140 37.4570 C 26.5703 39.1211 28.3281 40.8321 30.0860 53.6524 C 30.1797 54.2852 30.6250 54.7305 31.2344 54.7305 Z'
                  })
                )
              )
            );
          })()
        ),

        // CENTER: Track info (album art + metadata)
        React.createElement('div', {
          className: 'flex items-center gap-3 relative',
          style: { width: '340px', flexShrink: 0 },
          onDragEnter: (e) => handleDragEnter(e, 'now-playing'),
          onDragOver: (e) => handleDragOver(e, 'now-playing'),
          onDragLeave: handleDragLeave,
          onDrop: (e) => handleDrop(e, 'now-playing')
        },
          React.createElement(DropZoneOverlay, {
            zone: 'now-playing',
            isActive: isDraggingUrl && dropZoneTarget === 'now-playing'
          }),
          currentTrack && !trackLoading ? [
            React.createElement('div', {
              key: 'album-art-button',
              draggable: true,
              onDragStart: (e) => {
                // Set track data for playlists
                const trackData = {
                  type: 'track',
                  track: {
                    title: currentTrack.title,
                    artist: currentTrack.artist,
                    album: currentTrack.album,
                    duration: currentTrack.duration,
                    id: `${currentTrack.artist}-${currentTrack.title}`.toLowerCase().replace(/[^a-z0-9-]/g, '')
                  }
                };
                e.dataTransfer.effectAllowed = 'copy';
                e.dataTransfer.setData('text/plain', JSON.stringify(trackData));
                // Also set state for immediate access
                setDraggingTrackForPlaylist(trackData.track);
              },
              onDragEnd: () => {
                setDraggingTrackForPlaylist(null);
                setDropTargetPlaylistId(null);
                setDropTargetNewPlaylist(false);
              },
              onContextMenu: (e) => {
                e.preventDefault();
                if (window.electron?.contextMenu?.showTrackMenu) {
                  window.electron.contextMenu.showTrackMenu({
                    type: 'track',
                    track: currentTrack,
                    isNowPlaying: true
                  });
                }
              },
              onClick: async (e) => {
                // Prevent click if we just finished a drag operation
                if (e.defaultPrevented) return;
                // Search for the album and open its page
                if (currentTrack.album && currentTrack.artist) {
                  try {
                    // Search MusicBrainz for the release
                    const query = encodeURIComponent(`"${currentTrack.album}" AND artist:"${currentTrack.artist}"`);
                    const response = await fetch(
                      `https://musicbrainz.org/ws/2/release-group?query=${query}&fmt=json&limit=1`,
                      { headers: { 'User-Agent': 'Parachord/1.0.0 (https://github.com/harmonix)' }}
                    );
                    if (response.ok) {
                      const data = await response.json();
                      if (data['release-groups']?.length > 0) {
                        const album = data['release-groups'][0];
                        handleAlbumClick(album);
                      }
                    }
                  } catch (error) {
                    console.error('Error searching for album:', error);
                  }
                }
              },
              className: 'flex-shrink-0 hover:opacity-80 transition-opacity cursor-pointer no-drag',
              title: currentTrack.album ? `Click to open "${currentTrack.album}" â€¢ Drag to add to playlist` : 'Drag to add to playlist'
            },
              React.createElement('div', {
                className: 'bg-gray-700 rounded flex items-center justify-center overflow-hidden relative',
                style: { width: '61px', height: '61px' }
              },
                // Previous album art (fading out)
                playbarAlbumArt.previous && React.createElement('img', {
                  key: 'prev-art-' + playbarAlbumArt.previous,
                  src: playbarAlbumArt.previous,
                  alt: '',
                  className: 'absolute inset-0 w-full h-full object-cover',
                  style: {
                    opacity: playbarAlbumArt.isLoaded ? 0 : 1,
                    transition: 'opacity 0.3s ease-out'
                  }
                }),
                // Current album art (fading in)
                playbarAlbumArt.current && React.createElement('img', {
                  key: 'curr-art-' + playbarAlbumArt.current,
                  src: playbarAlbumArt.current,
                  alt: currentTrack.album,
                  className: 'absolute inset-0 w-full h-full object-cover',
                  style: {
                    opacity: playbarAlbumArt.isLoaded ? 1 : 0,
                    transition: 'opacity 0.3s ease-in'
                  },
                  onLoad: () => setPlaybarAlbumArt(prev => ({ ...prev, isLoaded: true })),
                  onError: (e) => { e.target.style.display = 'none'; }
                }),
                React.createElement(Music, { size: 20, className: 'text-gray-500' })
              )
            ),
            React.createElement('div', {
              key: 'track-info',
              className: 'min-w-0',
              onContextMenu: (e) => {
                e.preventDefault();
                if (window.electron?.contextMenu?.showTrackMenu) {
                  const trackId = generateTrackId(currentTrack.artist, currentTrack.title, currentTrack.album);
                  const isInCollection = collectionData.tracks.some(t => t.id === trackId);
                  window.electron.contextMenu.showTrackMenu({
                    type: 'track',
                    track: currentTrack,
                    isNowPlaying: true,
                    isInCollection: isInCollection
                  });
                }
              }
            },
              // Line 1: Track title
              React.createElement('div', { className: 'text-sm font-medium text-white truncate' }, currentTrack.title),
              // Line 2: Artist name
              React.createElement('div', { className: 'text-xs text-gray-400 truncate' },
                React.createElement('button', {
                  onClick: () => fetchArtistData(currentTrack.artist),
                  className: 'hover:text-white hover:underline transition-colors cursor-pointer no-drag'
                }, currentTrack.artist)
              ),
              // Line 3: Resolver dropdown + browser indicator
              (() => {
                const currentResolverId = determineResolverIdFromTrack(currentTrack);
                const resolver = allResolvers.find(r => r.id === currentResolverId);
                const resolverColors = {
                  spotify: { color: 'text-green-400', bg: 'bg-green-400' },
                  bandcamp: { color: 'text-cyan-400', bg: 'bg-cyan-400' },
                  qobuz: { color: 'text-blue-400', bg: 'bg-blue-400' },
                  youtube: { color: 'text-red-400', bg: 'bg-red-400' },
                  localfiles: { color: 'text-purple-400', bg: 'bg-purple-400' }
                };

                // Get available sources for this track
                const availableSources = currentTrack.sources && typeof currentTrack.sources === 'object' && !Array.isArray(currentTrack.sources)
                  ? Object.keys(currentTrack.sources).filter(resId => activeResolvers.includes(resId))
                  : [];

                const meta = resolverColors[currentResolverId] || { color: 'text-purple-400', bg: 'bg-purple-400' };
                const hasMultipleSources = availableSources.length > 1;

                if (resolver) {
                  // Color mapping for resolver icons
                  const resolverIconColors = {
                    spotify: '#1DB954',
                    bandcamp: '#1DA0C3',
                    qobuz: '#4285F4',
                    youtube: '#FF0000',
                    localfiles: '#A855F7',
                    soundcloud: '#FF5500',
                    applemusic: '#FA2D48'
                  };
                  const currentIconColor = resolverIconColors[currentResolverId] || '#A855F7';

                  return React.createElement('div', { className: 'flex items-center gap-1.5 mt-0.5' },
                    // Custom resolver selector with icon
                    React.createElement('div', { className: 'relative no-drag' },
                      // Current resolver button (icon + dropdown chevron if multiple sources)
                      React.createElement('button', {
                        onClick: (e) => {
                          e.stopPropagation();
                          if (hasMultipleSources) {
                            setPlaybarSourceDropdownOpen(!playbarSourceDropdownOpen);
                          }
                        },
                        className: `flex items-center gap-1.5 px-2 py-1 rounded transition-all ${
                          hasMultipleSources
                            ? 'hover:bg-white/10 cursor-pointer'
                            : 'cursor-default'
                        }`,
                        style: {
                          background: playbarSourceDropdownOpen ? 'rgba(255,255,255,0.1)' : 'transparent'
                        },
                        title: hasMultipleSources ? 'Switch playback source' : resolver.name
                      },
                        // Resolver icon
                        React.createElement(ResolverIcon, {
                          resolverId: currentResolverId,
                          size: 14,
                          fill: currentIconColor
                        }),
                        // Resolver name
                        React.createElement('span', {
                          className: 'text-xs font-medium',
                          style: { color: currentIconColor }
                        }, resolver.name),
                        // Dropdown chevron (only if multiple sources)
                        hasMultipleSources && React.createElement('svg', {
                          className: `w-3 h-3 transition-transform ${playbarSourceDropdownOpen ? 'rotate-180' : ''}`,
                          fill: 'none',
                          viewBox: '0 0 24 24',
                          stroke: 'currentColor',
                          strokeWidth: 2,
                          style: { color: '#9ca3af' }
                        },
                          React.createElement('path', {
                            strokeLinecap: 'round',
                            strokeLinejoin: 'round',
                            d: 'M19 9l-7 7-7-7'
                          })
                        )
                      ),
                      // Dropdown menu
                      playbarSourceDropdownOpen && hasMultipleSources && React.createElement('div', {
                        className: 'absolute left-0 bottom-full mb-1 rounded-lg overflow-hidden z-50',
                        style: {
                          background: 'linear-gradient(180deg, rgba(30, 30, 35, 0.98) 0%, rgba(20, 20, 25, 0.98) 100%)',
                          border: '1px solid rgba(255,255,255,0.1)',
                          boxShadow: '0 -4px 20px rgba(0,0,0,0.4), 0 0 1px rgba(255,255,255,0.1)',
                          backdropFilter: 'blur(12px)',
                          minWidth: '160px'
                        }
                      },
                        // Header
                        React.createElement('div', {
                          className: 'px-3 py-2 text-[10px] font-semibold uppercase tracking-wider',
                          style: {
                            color: 'rgba(255,255,255,0.4)',
                            borderBottom: '1px solid rgba(255,255,255,0.06)'
                          }
                        }, 'Play from'),
                        // Source options
                        availableSources.map(resId => {
                          const r = allResolvers.find(res => res.id === resId);
                          const iconColor = resolverIconColors[resId] || '#A855F7';
                          const isActive = resId === currentResolverId;
                          return React.createElement('button', {
                            key: resId,
                            onClick: (e) => {
                              e.stopPropagation();
                              if (resId !== currentResolverId && currentTrack.sources[resId]) {
                                handlePlay({ ...currentTrack, preferredResolver: resId });
                              }
                              setPlaybarSourceDropdownOpen(false);
                            },
                            className: 'w-full flex items-center gap-2.5 px-3 py-2 transition-colors hover:bg-white/5',
                            style: {
                              background: isActive ? 'rgba(255,255,255,0.08)' : 'transparent'
                            }
                          },
                            // Resolver icon
                            React.createElement(ResolverIcon, {
                              resolverId: resId,
                              size: 16,
                              fill: iconColor
                            }),
                            // Resolver name
                            React.createElement('span', {
                              className: 'text-xs',
                              style: {
                                color: isActive ? '#fff' : 'rgba(255,255,255,0.7)',
                                fontWeight: isActive ? '500' : '400'
                              }
                            }, r ? r.name : resId),
                            // Active indicator
                            isActive && React.createElement('svg', {
                              className: 'w-3.5 h-3.5 ml-auto',
                              fill: 'none',
                              viewBox: '0 0 24 24',
                              stroke: iconColor,
                              strokeWidth: 2.5
                            },
                              React.createElement('path', {
                                strokeLinecap: 'round',
                                strokeLinejoin: 'round',
                                d: 'M5 13l4 4L19 7'
                              })
                            )
                          );
                        })
                      )
                    ),
                    // Browser indicator pill for external playback
                    isExternalPlayback && React.createElement('span', {
                      className: 'inline-flex items-center gap-1 px-2 py-0.5 rounded text-[10px] font-medium tracking-wide uppercase',
                      style: {
                        background: 'linear-gradient(135deg, rgba(99, 102, 241, 0.15) 0%, rgba(139, 92, 246, 0.15) 100%)',
                        color: '#a5b4fc',
                        border: '1px solid rgba(139, 92, 246, 0.3)',
                        boxShadow: '0 0 8px rgba(139, 92, 246, 0.15), inset 0 1px 0 rgba(255,255,255,0.05)'
                      },
                      title: 'Playing in browser'
                    },
                      // External link / window icon
                      React.createElement('svg', {
                        className: 'w-2.5 h-2.5',
                        fill: 'none',
                        viewBox: '0 0 24 24',
                        stroke: 'currentColor',
                        strokeWidth: 2,
                        style: { opacity: 0.9 }
                      },
                        React.createElement('path', {
                          strokeLinecap: 'round',
                          strokeLinejoin: 'round',
                          d: 'M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14'
                        })
                      ),
                      'external'
                    )
                  );
                }
                return null;
              })()
            )
          ] : React.createElement(React.Fragment, null,
            // Skeleton album art
            React.createElement('div', {
              className: `flex-shrink-0 rounded ${trackLoading ? 'bg-gradient-to-r from-gray-700 via-gray-600 to-gray-700 animate-shimmer' : 'bg-gray-700'}`,
              style: { width: '61px', height: '61px', ...(trackLoading ? { backgroundSize: '200% 100%' } : {}) }
            }),
            // Skeleton track info - matches actual track info layout
            React.createElement('div', { className: 'min-w-0' },
              // Track title skeleton (text-sm = 14px, but skeleton slightly smaller)
              React.createElement('div', {
                className: `h-3.5 rounded ${trackLoading ? 'bg-gradient-to-r from-gray-700 via-gray-600 to-gray-700 animate-shimmer' : 'bg-gray-700'}`,
                style: { width: '200px', ...(trackLoading ? { backgroundSize: '200% 100%' } : {}) }
              }),
              // Artist skeleton (text-xs = 12px)
              React.createElement('div', {
                className: `h-3 rounded mt-1 ${trackLoading ? 'bg-gradient-to-r from-gray-700 via-gray-600 to-gray-700 animate-shimmer' : 'bg-gray-700'}`,
                style: { width: '140px', ...(trackLoading ? { backgroundSize: '200% 100%' } : {}) }
              }),
              // Source skeleton (text-xs with mt-0.5)
              React.createElement('div', {
                className: `h-3 rounded mt-1 ${trackLoading ? 'bg-gradient-to-r from-gray-700 via-gray-600 to-gray-700 animate-shimmer' : 'bg-gray-700'}`,
                style: { width: '80px', ...(trackLoading ? { backgroundSize: '200% 100%' } : {}) }
              })
            )
          )
        ),

        // RIGHT: Spinoff + Heart + Progress bar + Shuffle + Repeat + Volume
        React.createElement('div', { className: 'flex items-center gap-3' },
          // Spinoff button - radio-like playback of similar tracks (with tooltip)
          React.createElement(Tooltip, {
            content: spinoffMode ? 'Exit spinoff mode' :
              spinoffAvailable === false ? 'No related songs available' :
              spinoffAvailable === null ? 'Checking for related songs...' : 'Spinoff',
            position: 'top',
            variant: 'dark'
          },
            React.createElement('button', {
              onClick: () => {
                if (spinoffMode) {
                  exitSpinoff();
                } else if (currentTrack && spinoffAvailable) {
                  startSpinoff(currentTrack);
                }
              },
              disabled: !currentTrack || spinoffLoading || spinoffAvailable === false || spinoffAvailable === null,
              className: `p-1.5 rounded-full transition-colors ${
                !currentTrack || spinoffAvailable === false ? 'text-gray-600 cursor-not-allowed' :
                spinoffLoading || spinoffAvailable === null ? 'text-gray-400' :
                spinoffMode ? 'text-purple-400 hover:text-purple-300' :
                'text-gray-400 hover:text-white'
              }`
            },
              spinoffLoading
                ? React.createElement('span', { className: 'animate-spin inline-block w-5 h-5' }, 'â—Œ')
                : React.createElement('svg', {
                    className: 'w-5 h-5',
                    viewBox: '0 0 32 32',
                    fill: 'currentColor'
                  },
                    // Fork/branch icon (IBM Carbon style)
                    React.createElement('path', {
                      d: 'M26,18a3.9955,3.9955,0,0,0-3.858,3H18a3.0033,3.0033,0,0,1-3-3V14a4.9514,4.9514,0,0,0-1.0256-3H22.142a4,4,0,1,0,0-2H9.858a4,4,0,1,0,0,2H10a3.0033,3.0033,0,0,1,3,3v4a5.0059,5.0059,0,0,0,5,5h4.142A3.9935,3.9935,0,1,0,26,18ZM26,8a2,2,0,1,1-2,2A2.0023,2.0023,0,0,1,26,8ZM6,12a2,2,0,1,1,2-2A2.002,2.002,0,0,1,6,12ZM26,24a2,2,0,1,1,2-2A2.0027,2.0027,0,0,1,26,24Z'
                    })
                  )
            )
          ),
          // Heart/favorite button
          (() => {
            if (!currentTrack) return null;
            const trackId = generateTrackId(currentTrack.artist, currentTrack.title, currentTrack.album);
            const isInCollection = collectionData.tracks.some(t => t.id === trackId);
            return React.createElement(Tooltip, {
              content: isInCollection ? 'Remove from collection' : 'Save to collection',
              position: 'top',
              variant: 'dark'
            },
              React.createElement('button', {
                onClick: () => {
                  if (!isInCollection) {
                    // Get sources from trackSources state as fallback (keyed by position-title)
                    const trackSourceKey = `${currentTrack.position || 0}-${currentTrack.title}`;
                    const stateSources = trackSources[trackSourceKey];
                    // Also check cache
                    const cacheKey = `${(currentTrack.artist || '').toLowerCase()}|${(currentTrack.title || '').toLowerCase()}|${currentTrack.position || 0}`;
                    const cachedSources = trackSourcesCache.current[cacheKey]?.sources;
                    // Merge sources: currentTrack.sources > cached > state
                    const effectiveSources = {
                      ...(stateSources || {}),
                      ...(cachedSources || {}),
                      ...(currentTrack.sources || {})
                    };
                    addTrackToCollection({ ...currentTrack, sources: effectiveSources });
                  } else {
                    // Remove from collection (unheart)
                    removeTrackFromCollection(currentTrack);
                  }
                },
                className: `p-1.5 rounded-full transition-colors ${isInCollection ? 'text-red-500 hover:text-red-400' : 'text-gray-400 hover:text-white'}`
              },
                React.createElement('svg', {
                  className: 'w-5 h-5',
                  viewBox: '0 0 24 24',
                  fill: isInCollection ? 'currentColor' : 'none',
                  stroke: 'currentColor',
                  strokeWidth: isInCollection ? 0 : 2
                },
                  React.createElement('path', {
                    strokeLinecap: 'round',
                    strokeLinejoin: 'round',
                    d: 'M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z'
                  })
                )
              )
            );
          })(),
          // Progress section
          React.createElement('div', { className: 'flex items-center gap-2 min-w-[200px]' },
            React.createElement('span', {
              className: 'text-xs text-gray-400 tabular-nums',
              style: { width: '36px', textAlign: 'right', fontVariantNumeric: 'tabular-nums', lineHeight: '1' }
            },
              currentTrack && !browserPlaybackActive ? formatTime(progress) : '0:00'
            ),
            React.createElement('div', { className: 'flex-1 w-24 flex items-center' },
              (() => {
                // Check if current track is Spotify (seeking not supported)
                const isSpotifyTrack = currentTrack && (currentTrack.sources?.spotify || currentTrack.spotifyUri || currentTrack.resolver === 'spotify');
                const isSeekDisabled = !currentTrack || browserPlaybackActive || isSpotifyTrack;

                return React.createElement('input', {
                  type: 'range',
                  min: '0',
                  max: currentTrack?.duration || 100,
                  value: currentTrack && !browserPlaybackActive ? progress : 0,
                  disabled: isSeekDisabled,
                  onChange: async (e) => {
                    if (browserPlaybackActive || !currentTrack || isSpotifyTrack) return;
                    const newPosition = Number(e.target.value);
                    setProgress(newPosition);
                    if (currentTrack?.sources?.localfiles && audioRef.current) {
                      audioRef.current.currentTime = newPosition;
                    }
                  },
                  className: `progress-slider w-full h-1 rounded-full ${isSeekDisabled ? 'bg-gray-600 opacity-50' : 'bg-gray-600'}`,
                  title: isSpotifyTrack ? 'Seeking not available for Spotify tracks' : undefined
                });
              })()
            ),
            React.createElement('span', {
              className: 'text-xs text-gray-400 tabular-nums',
              style: { width: '36px', textAlign: 'left', fontVariantNumeric: 'tabular-nums', lineHeight: '1' }
            },
              currentTrack ? formatTime(currentTrack.duration) : '0:00'
            )
          ),
          // Shuffle button (disabled in spinoff/listen-along modes)
          (() => {
            const shuffleDisabled = spinoffMode || listenAlongFriend;
            const tooltipContent = shuffleDisabled
              ? (spinoffMode ? 'Shuffle unavailable in Spinoff mode' : 'Shuffle unavailable while listening along')
              : (shuffleMode ? 'Shuffle on (click to restore order)' : 'Shuffle queue');
            return React.createElement(Tooltip, {
              content: tooltipContent,
              position: 'top',
              variant: 'dark'
            },
              React.createElement('button', {
                onClick: shuffleDisabled ? undefined : toggleShuffle,
                disabled: shuffleDisabled,
                className: `p-2 rounded transition-colors ${
                  shuffleDisabled ? 'text-gray-600 cursor-not-allowed' :
                  shuffleMode ? 'text-purple-400 hover:text-purple-300' : 'text-gray-400 hover:text-white'
                }`
              },
                React.createElement('svg', { className: 'w-4 h-4', viewBox: '0 0 24 24', fill: 'currentColor' },
                  React.createElement('path', { d: 'M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zm.33 9.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04-3.13-3.13z' })
                )
              )
            );
          })(),
          // Repeat button (placeholder) - disabled for now
          // React.createElement('button', {
          //   disabled: true,
          //   className: 'p-2 rounded text-gray-600 cursor-not-allowed',
          //   title: 'Repeat (coming soon)'
          // },
          //   React.createElement('svg', { className: 'w-4 h-4', viewBox: '0 0 16 16', fill: 'currentColor' },
          //     React.createElement('path', { d: 'M8,16c-1.3,0-2.7-0.3-3.8-1c-0.8-0.4-1.4-0.9-2-1.6c-0.5-0.5-0.9-1.1-1.3-1.8C0.3,10.5,0,9.3,0,8c0-4.4,3.6-8,8-8c1.1,0,2.1,0.2,3,0.6l-0.4,0.9C9.8,1.2,8.9,1,8,1C4.1,1,1,4.1,1,8c0,1.1,0.3,2.2,0.8,3.2c0.3,0.6,0.7,1.1,1.1,1.6c0.5,0.5,1.1,1,1.8,1.4C5.7,14.7,6.8,15,8,15c3.9,0,7-3.1,7-7c0-1-0.2-2-0.6-2.9l0.9-0.4C15.8,5.7,16,6.8,16,8C16,12.4,12.4,16,8,16z' })
          //   )
          // ),
          // Volume - only enabled for local files and Spotify on Computer devices
          (() => {
            const currentResolverId = determineResolverIdFromTrack(currentTrack);
            const isSpotify = currentResolverId === 'spotify';
            // For Spotify, only enable volume on Computer devices (desktop app)
            // TVs, speakers, and other devices don't respond to remote volume commands reliably
            const spotifyVolumeSupported = !isSpotify || spotifyDevice?.type === 'Computer';
            const volumeSupported = !currentTrack || currentResolverId === 'localfiles' || (isSpotify && spotifyVolumeSupported);
            const isDisabled = !volumeSupported || browserPlaybackActive || isExternalPlayback;
            const resolverOffset = currentResolverId ? (resolverVolumeOffsets[currentResolverId] || 0) : 0;
            const hasOffset = resolverOffset !== 0;
            const effectiveVolume = isMuted ? 0 : volume;

            // Toggle mute handler
            const handleMuteToggle = () => {
              if (isDisabled) return;
              const activeResolverId = determineResolverIdFromTrack(currentTrackRef.current);
              if (isMuted) {
                // Unmute: restore previous volume
                const restoredVolume = preMuteVolumeRef.current || 70;
                setIsMuted(false);
                setVolume(restoredVolume);
                if (activeResolverId === 'localfiles' && audioRef.current) {
                  applyLocalFileVolume(restoredVolume, currentTrackRef.current?.id);
                }
                if (activeResolverId === 'spotify') {
                  setSpotifyVolume(restoredVolume, true);
                }
              } else {
                // Mute: save current volume and set to 0
                preMuteVolumeRef.current = volume;
                setIsMuted(true);
                if (activeResolverId === 'localfiles' && audioRef.current) {
                  audioRef.current.volume = 0;
                }
                if (activeResolverId === 'spotify') {
                  setSpotifyVolume(0, false);
                }
              }
            };

            // Determine appropriate tooltip
            const getTooltip = () => {
              if (isDisabled) {
                if (browserPlaybackActive || isExternalPlayback) {
                  return 'Volume control not available for browser playback';
                }
                if (isSpotify && spotifyDevice && spotifyDevice.type !== 'Computer') {
                  return `Volume control not available on ${spotifyDevice.name || spotifyDevice.type}`;
                }
                return 'Volume control not available';
              }
              if (isMuted) return 'Click to unmute';
              if (hasOffset) return `Volume (${resolverOffset > 0 ? '+' : ''}${resolverOffset}dB normalization applied) - Click to mute`;
              return 'Click to mute';
            };

            return React.createElement('div', {
              className: 'flex items-center gap-1'
            },
              React.createElement(Tooltip, {
                content: isMuted ? 'Unmute' : 'Mute',
                position: 'top',
                variant: 'dark'
              },
                React.createElement('button', {
                  className: `${isDisabled ? 'text-gray-600 cursor-not-allowed' : 'text-gray-400 hover:text-white cursor-pointer'} transition-colors`,
                  onClick: handleMuteToggle,
                  disabled: isDisabled
                },
                  React.createElement('svg', { width: 16, height: 16, viewBox: '0 0 18 18', fill: 'currentColor' },
                    isMuted || effectiveVolume === 0
                      // Muted icon (speaker with diagonal slash)
                      ? React.createElement('g', null,
                          React.createElement('path', { d: 'M16,17.4l-6.1-3.8H2V5.1h6.9L16,0.6V17.4z M3,12.6h7.2l4.8,3V2.4L9.1,6.1H3V12.6z' }),
                          React.createElement('line', { x1: '1', y1: '17', x2: '17', y2: '1', stroke: 'currentColor', strokeWidth: '2', strokeLinecap: 'round' })
                        )
                      // Normal volume icon
                      : React.createElement('path', { d: 'M16,17.4l-6.1-3.8H2V5.1h6.9L16,0.6V17.4z M3,12.6h7.2l4.8,3V2.4L9.1,6.1H3V12.6z' })
                  )
                )
              ),
              React.createElement('input', {
                type: 'range',
                min: '0',
                max: '100',
                value: effectiveVolume,
                disabled: isDisabled,
                onChange: (e) => {
                    const newVolume = Number(e.target.value);
                    // If user moves slider while muted, unmute
                    if (isMuted && newVolume > 0) {
                      setIsMuted(false);
                    }
                    setVolume(newVolume);
                    // Re-determine resolver from current track ref to avoid stale closure
                    const activeResolverId = determineResolverIdFromTrack(currentTrackRef.current);
                    // Local files: apply normalized volume immediately
                    if (activeResolverId === 'localfiles' && audioRef.current) {
                      applyLocalFileVolume(newVolume, currentTrackRef.current?.id);
                    }
                    // Spotify: debounced API call to prevent rate limiting
                    if (activeResolverId === 'spotify') {
                      setSpotifyVolumeDebounced(newVolume, true);
                    }
                  },
                className: `volume-slider w-20 h-1 rounded-full ${isDisabled ? 'disabled cursor-not-allowed opacity-50' : 'cursor-pointer'}`
              })
            );
          })()
        )
      )
    ),

    // AI Prompt Input Panel (floating above playbar, aligned with AI button on left) - Refined dark theme
    aiPromptOpen && React.createElement('div', {
      className: 'fixed bottom-24 left-4 z-50',
      style: {
        width: '380px',
        backgroundColor: 'rgba(17, 24, 39, 0.95)',
        backdropFilter: 'blur(20px)',
        border: '1px solid rgba(255, 255, 255, 0.08)',
        borderRadius: '14px',
        boxShadow: '0 25px 50px -12px rgba(0, 0, 0, 0.5)',
        padding: '16px'
      }
    },
      // Header
      React.createElement('div', { className: 'flex items-center justify-between mb-3' },
        React.createElement('div', { className: 'flex items-center gap-2' },
          React.createElement('span', { style: { color: '#c4b5fd' } }, 'âœ¨'),
          React.createElement('span', { style: { fontSize: '14px', fontWeight: '500', color: '#f3f4f6' } }, 'Generate Playlist')
        ),
        React.createElement('button', {
          onClick: () => {
            setAiPromptOpen(false);
            setAiPrompt('');
            setAiError(null);
          },
          className: 'transition-colors',
          style: { padding: '6px', color: '#6b7280', borderRadius: '8px' },
          onMouseEnter: (e) => { e.currentTarget.style.color = '#d1d5db'; e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.08)'; },
          onMouseLeave: (e) => { e.currentTarget.style.color = '#6b7280'; e.currentTarget.style.backgroundColor = 'transparent'; }
        },
          React.createElement('svg', { className: 'w-4 h-4', viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2 },
            React.createElement('path', { d: 'M6 18L18 6M6 6l12 12' })
          )
        )
      ),

      // Input
      React.createElement('div', { className: 'relative' },
        React.createElement('input', {
          type: 'text',
          value: aiPrompt,
          onChange: (e) => setAiPrompt(e.target.value),
          onKeyDown: (e) => {
            if (e.key === 'Enter' && aiPrompt.trim() && !aiLoading) {
              handleAiGenerate(aiPrompt.trim());
            }
            if (e.key === 'Escape') {
              setAiPromptOpen(false);
              setAiPrompt('');
              setAiError(null);
            }
          },
          placeholder: 'What do you want to listen to?',
          disabled: aiLoading,
          autoFocus: true,
          style: {
            width: '100%',
            backgroundColor: 'rgba(255, 255, 255, 0.05)',
            border: '1px solid rgba(255, 255, 255, 0.1)',
            borderRadius: '10px',
            padding: '12px 48px 12px 16px',
            fontSize: '14px',
            color: '#f3f4f6',
            outline: 'none',
            opacity: aiLoading ? '0.5' : '1'
          },
          onFocus: (e) => { e.target.style.borderColor = 'rgba(167, 139, 250, 0.5)'; e.target.style.boxShadow = '0 0 0 3px rgba(167, 139, 250, 0.1)'; },
          onBlur: (e) => { e.target.style.borderColor = 'rgba(255, 255, 255, 0.1)'; e.target.style.boxShadow = 'none'; }
        }),
        React.createElement('button', {
          onClick: () => aiPrompt.trim() && !aiLoading && handleAiGenerate(aiPrompt.trim()),
          disabled: !aiPrompt.trim() || aiLoading,
          className: 'absolute right-2 top-1/2 -translate-y-1/2 transition-colors',
          style: {
            padding: '8px',
            borderRadius: '8px',
            backgroundColor: !aiPrompt.trim() || aiLoading ? 'rgba(124, 58, 237, 0.3)' : '#7c3aed',
            color: '#ffffff',
            cursor: !aiPrompt.trim() || aiLoading ? 'not-allowed' : 'pointer',
            opacity: !aiPrompt.trim() || aiLoading ? '0.5' : '1'
          },
          onMouseEnter: (e) => { if (aiPrompt.trim() && !aiLoading) e.currentTarget.style.backgroundColor = '#6d28d9'; },
          onMouseLeave: (e) => { if (aiPrompt.trim() && !aiLoading) e.currentTarget.style.backgroundColor = '#7c3aed'; }
        },
          aiLoading
            ? React.createElement('svg', { className: 'w-4 h-4 animate-spin', viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2 },
                React.createElement('circle', { cx: 12, cy: 12, r: 10, strokeOpacity: 0.25 }),
                React.createElement('path', { d: 'M12 2a10 10 0 0 1 10 10', strokeLinecap: 'round' })
              )
            : React.createElement('svg', { className: 'w-4 h-4', viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2 },
                React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', d: 'M14 5l7 7m0 0l-7 7m7-7H3' })
              )
        )
      ),

      // Provider selector row (right-aligned)
      (() => {
        const aiResolvers = getAiServices();
        if (aiResolvers.length <= 1) return null;
        return React.createElement('div', { className: 'mt-3 flex items-center justify-end gap-2' },
          React.createElement('span', { style: { fontSize: '12px', color: '#6b7280' } }, 'Provider:'),
          React.createElement('select', {
            value: selectedAiResolver || aiResolvers[0]?.id || '',
            onChange: (e) => setSelectedAiResolver(e.target.value),
            style: {
              backgroundColor: 'rgba(255, 255, 255, 0.05)',
              border: '1px solid rgba(255, 255, 255, 0.1)',
              borderRadius: '6px',
              padding: '4px 8px',
              fontSize: '12px',
              color: '#d1d5db',
              outline: 'none'
            }
          },
            aiResolvers.map(r =>
              React.createElement('option', { key: r.id, value: r.id }, r.name)
            )
          )
        );
      })(),

      // Listening history toggle (if scrobbler connected)
      hasScrobblerConnected() && React.createElement('div', {
        className: 'mt-3 flex items-center justify-between'
      },
        React.createElement('label', {
          htmlFor: 'ai-include-history',
          style: { fontSize: '12px', color: '#9ca3af', cursor: 'pointer', userSelect: 'none' }
        }, 'Use my listening history'),
        React.createElement('label', { className: 'relative inline-block w-10 h-5 cursor-pointer' },
          React.createElement('input', {
            type: 'checkbox',
            id: 'ai-include-history',
            checked: aiIncludeHistory,
            onChange: (e) => setAiIncludeHistory(e.target.checked),
            className: 'sr-only peer'
          }),
          React.createElement('div', {
            className: 'w-full h-full rounded-full peer-checked:bg-violet-600 transition-colors',
            style: { backgroundColor: aiIncludeHistory ? '#7c3aed' : 'rgba(255, 255, 255, 0.15)' }
          }),
          React.createElement('div', {
            className: 'absolute left-0.5 top-0.5 w-4 h-4 bg-white rounded-full shadow transition-transform peer-checked:translate-x-5'
          })
        )
      ),

      // Surprise Me button (own row, only when listening history is enabled) - Muted gradient
      hasScrobblerConnected() && aiIncludeHistory && React.createElement('div', {
        className: 'mt-3'
      },
        React.createElement('button', {
          onClick: () => !aiLoading && handleAiGenerate('Surprise me! Based on my listening history, create a playlist of songs I might love but haven\'t discovered yet. Mix familiar vibes with fresh discoveries.'),
          disabled: aiLoading,
          className: 'w-full transition-all',
          style: {
            padding: '10px 12px',
            borderRadius: '10px',
            fontSize: '14px',
            fontWeight: '500',
            background: aiLoading ? 'rgba(255, 255, 255, 0.05)' : 'linear-gradient(135deg, #7c3aed 0%, #a855f7 50%, #c026d3 100%)',
            color: aiLoading ? '#6b7280' : '#ffffff',
            cursor: aiLoading ? 'not-allowed' : 'pointer',
            opacity: aiLoading ? '0.6' : '1'
          },
          onMouseEnter: (e) => { if (!aiLoading) e.currentTarget.style.opacity = '0.9'; },
          onMouseLeave: (e) => { if (!aiLoading) e.currentTarget.style.opacity = '1'; }
        },
          React.createElement('span', { className: 'flex items-center justify-center gap-2' },
            React.createElement('svg', {
              className: 'w-4 h-4',
              viewBox: '0 0 482 511.93',
              fill: 'currentColor',
              xmlns: 'http://www.w3.org/2000/svg'
            },
              React.createElement('path', {
                fillRule: 'nonzero',
                d: 'm277.15 355.47-129.39-67.81L115.79 327c47.18 24.94 89.8 47.83 137 72.79l24.36-44.32zM191.5 208.38c4.84 0 8.77 3.92 8.77 8.76s-3.93 8.77-8.77 8.77-8.76-3.93-8.76-8.77 3.92-8.76 8.76-8.76zm185.52 9.13c4.84 0 8.76 3.92 8.76 8.76s-3.92 8.77-8.76 8.77c-4.85 0-8.77-3.93-8.77-8.77s3.92-8.76 8.77-8.76zm74.65-148.53c5.38 0 9.74 4.36 9.74 9.75 0 5.38-4.36 9.74-9.74 9.74s-9.74-4.36-9.74-9.74c0-5.39 4.36-9.75 9.74-9.75zm-274.01 9.88c6.35 0 11.49 5.15 11.49 11.5s-5.14 11.49-11.49 11.49c-6.35 0-11.5-5.14-11.5-11.49 0-6.35 5.15-11.5 11.5-11.5zm-34.45 89.91c7.17 0 12.98 5.81 12.98 12.98 0 7.16-5.81 12.97-12.98 12.97-7.16 0-12.97-5.81-12.97-12.97 0-7.17 5.81-12.98 12.97-12.98zM231.86 0l17.02 29.17 32.89-2.76-21 24.78 12.54 30.75-30.13-12.48-24.72 21.12 2.21-32.72-28.62-17.44 33.19-7.38L231.86 0zm118.07 161.29c4.84 0 8.77 3.92 8.77 8.77 0 4.84-3.93 8.76-8.77 8.76s-8.77-3.92-8.77-8.76c0-4.85 3.93-8.77 8.77-8.77zm82.72 38.11-1.25-.35c2.88-10.22 1.58-20.22-3.91-30-5.48-9.79-13.33-16.12-23.54-19l.35-1.25c10.22 2.88 20.21 1.58 30-3.93 9.79-5.5 16.13-13.34 18.99-23.52l1.26.35c-2.88 10.22-1.58 20.21 3.9 30 5.49 9.79 13.34 16.12 23.55 19l-.35 1.25c-10.22-2.88-20.22-1.58-30 3.9-9.79 5.49-16.12 13.34-19 23.55zm-61.45-98.38h-1.62c0-13.19-4.93-24.73-14.8-34.59-9.86-9.87-21.4-14.8-34.6-14.8v-1.62c13.2 0 24.74-4.93 34.6-14.82 9.87-9.89 14.8-21.42 14.8-34.58h1.62c0 13.2 4.93 24.73 14.8 34.6 9.87 9.87 21.4 14.8 34.6 14.8v1.62c-13.2 0-24.73 4.93-34.6 14.8-9.87 9.86-14.8 21.4-14.8 34.59zM68.87 128.06l-1.44.75c-6.12-11.69-15.84-19.62-29.16-23.78s-25.82-3.18-37.52 2.94L0 106.54c11.7-6.13 19.62-15.85 23.77-29.18 4.15-13.34 3.17-25.85-2.93-37.5l1.43-.75C28.4 50.8 38.12 58.73 51.44 62.89c13.31 4.16 25.82 3.18 37.51-2.94l.75 1.43C78.01 67.5 70.08 77.23 65.92 90.54c-4.16 13.32-3.18 25.83 2.95 37.52zM291.4 287.62a6.511 6.511 0 0 1-5.98 3.69c-1.08.75-2.4 1.17-3.81 1.14-.48-.01-.94-.07-1.39-.18a6.5 6.5 0 0 1-8.2-3.94c-14.91-41.24-38.21-76.53-67.05-105.6-31.26-31.53-69.05-55.8-109.73-72.53-3.32-1.36-4.9-5.16-3.54-8.48 1.37-3.32 5.17-4.90 8.48-3.54 42.24 17.37 81.5 42.6 114.01 75.38 20.91 21.08 39.03 45.29 53.37 72.53L244.59 98.46c-.55-3.55 1.88-6.87 5.42-7.41a6.495 6.495 0 0 1 7.41 5.42l22.67 145.62c2.81-14.15 6.76-28.09 11.66-41.7 10.98-30.51 26.68-59.38 44.9-85.52a6.495 6.495 0 0 1 9.06-1.63c2.96 2.05 3.68 6.11 1.63 9.06-17.66 25.35-32.83 53.21-43.36 82.47-7.01 19.47-11.99 39.6-14.31 60.05 10.23-15.34 25.53-33.46 45.01-50.01 20.18-17.15 44.95-32.73 73.34-41.94 3.42-1.11 7.09.76 8.2 4.18a6.507 6.507 0 0 1-4.18 8.2c-26.61 8.64-49.91 23.31-68.95 39.49-26 22.09-43.97 46.81-51.69 62.88zM187.97 261.3l-30.77 14.87 126.99 66.84 127.01-66.97-27.9-13.98c4.13-3.04 8.31-5.97 12.49-8.8l23.44 10.08 37.73-35.71-12.34-6.54c3.18-2.29 6.18-4.55 8.94-6.82l19.76 10.44c.44.24.85.54 1.22.92a4.982 4.982 0 0 1-.06 7.06l-44.81 44.02 43.4 51.94a5.015 5.015 0 0 1-.63 7.04c-.32.26-.66.49-1.02.66l-38.96 20.6v77.21a5.01 5.01 0 0 1-3.09 4.62l-140.86 71.5a4.97 4.97 0 0 1-3.7 1.65c-1.96 0-3.65-1.12-4.47-2.76l-141.13-70.55a4.984 4.984 0 0 1-2.76-4.46l-.02-76.83-39.69-20.98c-.36-.17-.69-.4-1.01-.66a4.997 4.997 0 0 1-.63-7.04l42.28-50.59-49.05-46.48c-1.82-2.07-1.6-5.22.47-7.04.31-.26.62-.49.96-.66l22.88-12.95c3.05 2.91 5.97 5.39 8.53 7.34l-15.75 8.8 41.39 37.97 36.57-17.7c1.5 4.72 3.04 9.43 4.59 13.96zm232.81 27.53-126.5 63.38 27.88 48.05 133.28-69.41-34.66-42.02z'
              })
            ),
            'Surprise Me'
          )
        )
      ),

      // Scrobbler not connected - show link to marketplace
      !hasScrobblerConnected() && React.createElement('div', {
        className: 'mt-3 flex items-center justify-between'
      },
        React.createElement('span', { style: { fontSize: '12px', color: '#6b7280' } },
          'Connect a scrobbler for personalized recommendations'
        ),
        React.createElement('button', {
          onClick: () => {
            setAiPromptOpen(false);
            setActiveView('marketplace');
            setMarketplaceCategory('scrobblers');
          },
          className: 'transition-colors',
          style: { fontSize: '12px', color: '#a78bfa' },
          onMouseEnter: (e) => e.currentTarget.style.color = '#c4b5fd',
          onMouseLeave: (e) => e.currentTarget.style.color = '#a78bfa'
        }, 'Browse â†’')
      ),

      // Error message
      aiError && React.createElement('div', {
        style: {
          marginTop: '12px',
          padding: '10px 12px',
          backgroundColor: 'rgba(239, 68, 68, 0.1)',
          border: '1px solid rgba(239, 68, 68, 0.2)',
          borderRadius: '8px'
        }
      },
        React.createElement('p', { style: { fontSize: '12px', color: '#fca5a5' } }, aiError)
      ),

      // Hint
      !aiError && React.createElement('p', { style: { marginTop: '12px', fontSize: '12px', color: '#6b7280' } },
        'Try: "upbeat 90s hip hop" or "relaxing jazz for studying"'
      )
    ),

    // Results Sidebar (slides in from right, above playbar) - Refined dark theme
    resultsSidebar && React.createElement('div', {
      className: 'fixed top-0 right-0 z-40 flex',
      style: { bottom: '80px' } // Leave room for playbar
    },
      // Backdrop (click to close)
      React.createElement('div', {
        className: 'flex-1',
        style: { backgroundColor: 'rgba(0, 0, 0, 0.3)', backdropFilter: 'blur(4px)' },
        onClick: () => setResultsSidebar(null)
      }),

      // Sidebar panel
      React.createElement('div', {
        className: 'w-80 flex flex-col',
        style: {
          backgroundColor: 'rgba(17, 24, 39, 0.98)',
          borderLeft: '1px solid rgba(255, 255, 255, 0.08)',
          boxShadow: '-10px 0 40px rgba(0, 0, 0, 0.3)',
          animation: 'slideInRight 0.2s ease-out'
        }
      },
        // Header
        React.createElement('div', {
          style: { padding: '16px', borderBottom: '1px solid rgba(255, 255, 255, 0.08)' }
        },
          React.createElement('div', { className: 'flex items-center justify-between' },
            React.createElement('div', { className: 'flex items-center gap-2' },
              React.createElement('span', { style: { color: '#c4b5fd' } }, 'âœ¨'),
              React.createElement('h3', { style: { fontSize: '16px', fontWeight: '600', color: '#f3f4f6' } }, resultsSidebar.title)
            ),
            React.createElement('button', {
              onClick: () => setResultsSidebar(null),
              className: 'transition-colors',
              style: { padding: '6px', color: '#6b7280', borderRadius: '8px' },
              onMouseEnter: (e) => { e.currentTarget.style.color = '#d1d5db'; e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.08)'; },
              onMouseLeave: (e) => { e.currentTarget.style.color = '#6b7280'; e.currentTarget.style.backgroundColor = 'transparent'; }
            },
              React.createElement('svg', { className: 'w-5 h-5', viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2 },
                React.createElement('path', { d: 'M6 18L18 6M6 6l12 12' })
              )
            )
          ),
          resultsSidebar.subtitle && React.createElement('p', {
            style: { fontSize: '13px', color: '#9ca3af', marginTop: '4px', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }
          }, resultsSidebar.subtitle)
        ),

        // Track list or loading skeletons
        React.createElement('div', { className: 'flex-1 overflow-y-auto', style: { padding: '8px' } },
          // Loading skeletons
          resultsSidebar.loading
            ? Array.from({ length: 12 }).map((_, index) =>
                React.createElement('div', {
                  key: `skeleton-${index}`,
                  className: 'flex items-center gap-3',
                  style: { padding: '8px' }
                },
                  // Skeleton track number
                  React.createElement('div', {
                    className: 'animate-pulse',
                    style: { width: '24px', height: '16px', backgroundColor: 'rgba(255, 255, 255, 0.08)', borderRadius: '4px' }
                  }),
                  // Skeleton track info
                  React.createElement('div', { className: 'flex-1 min-w-0 space-y-2' },
                    React.createElement('div', {
                      className: 'animate-pulse',
                      style: { height: '16px', backgroundColor: 'rgba(255, 255, 255, 0.08)', borderRadius: '4px', width: `${60 + Math.random() * 30}%`, animationDelay: `${index * 0.05}s` }
                    }),
                    React.createElement('div', {
                      className: 'animate-pulse',
                      style: { height: '12px', backgroundColor: 'rgba(255, 255, 255, 0.05)', borderRadius: '4px', width: `${40 + Math.random() * 25}%`, animationDelay: `${index * 0.05 + 0.1}s` }
                    })
                  )
                )
              )
            : resultsSidebar.tracks.map((track, index) =>
                React.createElement('div', {
                  key: track.id || index,
                  className: 'group flex items-center gap-3 transition-colors',
                  style: { padding: '8px', borderRadius: '8px' },
                  onMouseEnter: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.05)',
                  onMouseLeave: (e) => e.currentTarget.style.backgroundColor = 'transparent'
                },
                  // Track number
                  React.createElement('span', { style: { width: '24px', textAlign: 'center', fontSize: '12px', color: '#6b7280' } }, index + 1),

                  // Track info
                  React.createElement('div', { className: 'flex-1 min-w-0' },
                    React.createElement('div', { style: { fontSize: '14px', color: '#f3f4f6', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' } }, track.title),
                    React.createElement('div', { style: { fontSize: '12px', color: '#9ca3af', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' } }, track.artist)
                  ),

                  // Remove button
                  React.createElement('button', {
                    onClick: () => {
                      setResultsSidebar(prev => ({
                        ...prev,
                        tracks: prev.tracks.filter((_, i) => i !== index)
                      }));
                    },
                    className: 'opacity-0 group-hover:opacity-100 transition-all',
                    style: { padding: '4px', borderRadius: '6px', color: '#6b7280' },
                    onMouseEnter: (e) => { e.currentTarget.style.backgroundColor = 'rgba(239, 68, 68, 0.15)'; e.currentTarget.style.color = '#f87171'; },
                    onMouseLeave: (e) => { e.currentTarget.style.backgroundColor = 'transparent'; e.currentTarget.style.color = '#6b7280'; }
                  },
                    React.createElement('svg', { className: 'w-4 h-4', viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2 },
                      React.createElement('path', { d: 'M6 18L18 6M6 6l12 12' })
                    )
                  )
                )
              )
        ),

        // Empty state (only show when not loading and no tracks)
        !resultsSidebar.loading && resultsSidebar.tracks.length === 0 && React.createElement('div', {
          className: 'flex-1 flex items-center justify-center',
          style: { padding: '16px' }
        },
          React.createElement('p', { style: { fontSize: '14px', color: '#6b7280' } }, 'No tracks remaining')
        ),

        // Actions
        React.createElement('div', {
          style: { padding: '16px', borderTop: '1px solid rgba(255, 255, 255, 0.08)' }
        },
          React.createElement('button', {
            onClick: handleAiAddToQueue,
            disabled: resultsSidebar.loading || resultsSidebar.tracks.length === 0,
            className: 'w-full transition-colors',
            style: {
              padding: '12px 16px',
              fontSize: '14px',
              fontWeight: '500',
              color: '#ffffff',
              backgroundColor: resultsSidebar.loading || resultsSidebar.tracks.length === 0 ? 'rgba(255, 255, 255, 0.05)' : '#7c3aed',
              borderRadius: '10px',
              cursor: resultsSidebar.loading || resultsSidebar.tracks.length === 0 ? 'not-allowed' : 'pointer',
              opacity: resultsSidebar.loading || resultsSidebar.tracks.length === 0 ? '0.5' : '1',
              marginBottom: '8px'
            },
            onMouseEnter: (e) => { if (!resultsSidebar.loading && resultsSidebar.tracks.length > 0) e.currentTarget.style.backgroundColor = '#6d28d9'; },
            onMouseLeave: (e) => { if (!resultsSidebar.loading && resultsSidebar.tracks.length > 0) e.currentTarget.style.backgroundColor = '#7c3aed'; }
          }, resultsSidebar.loading ? 'Generating...' : `Add ${resultsSidebar.tracks.length} to Queue`),
          React.createElement('button', {
            onClick: handleAiSavePlaylist,
            disabled: resultsSidebar.loading || resultsSidebar.tracks.length === 0,
            className: 'w-full transition-colors',
            style: {
              padding: '12px 16px',
              fontSize: '14px',
              fontWeight: '500',
              color: resultsSidebar.loading || resultsSidebar.tracks.length === 0 ? '#6b7280' : '#d1d5db',
              backgroundColor: 'rgba(255, 255, 255, 0.05)',
              borderRadius: '10px',
              cursor: resultsSidebar.loading || resultsSidebar.tracks.length === 0 ? 'not-allowed' : 'pointer',
              opacity: resultsSidebar.loading || resultsSidebar.tracks.length === 0 ? '0.5' : '1'
            },
            onMouseEnter: (e) => { if (!resultsSidebar.loading && resultsSidebar.tracks.length > 0) e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.08)'; },
            onMouseLeave: (e) => { if (!resultsSidebar.loading && resultsSidebar.tracks.length > 0) e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.05)'; }
          }, 'Save as Playlist')
        )
      )
    ),

    // AI Save Playlist Dialog - Refined dark theme
    aiSaveDialogOpen && React.createElement('div', {
      className: 'fixed inset-0 flex items-center justify-center z-50',
      style: { backgroundColor: 'rgba(0, 0, 0, 0.5)', backdropFilter: 'blur(8px)' },
      onClick: (e) => {
        if (e.target === e.currentTarget) {
          setAiSaveDialogOpen(false);
        }
      }
    },
      React.createElement('div', {
        className: 'max-w-md w-full mx-4',
        style: {
          backgroundColor: 'rgba(17, 24, 39, 0.98)',
          borderRadius: '16px',
          padding: '24px',
          boxShadow: '0 25px 50px -12px rgba(0, 0, 0, 0.5)',
          border: '1px solid rgba(255, 255, 255, 0.08)'
        }
      },
        // Header
        React.createElement('div', { className: 'flex items-center justify-between', style: { marginBottom: '16px' } },
          React.createElement('h2', { style: { fontSize: '17px', fontWeight: '600', color: '#f3f4f6' } }, 'Save Playlist'),
          React.createElement('button', {
            onClick: () => setAiSaveDialogOpen(false),
            className: 'transition-colors',
            style: { padding: '6px', color: '#6b7280', borderRadius: '8px' },
            onMouseEnter: (e) => { e.currentTarget.style.color = '#d1d5db'; e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.08)'; },
            onMouseLeave: (e) => { e.currentTarget.style.color = '#6b7280'; e.currentTarget.style.backgroundColor = 'transparent'; }
          },
            React.createElement('svg', { className: 'w-5 h-5', viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2 },
              React.createElement('path', { d: 'M6 18L18 6M6 6l12 12' })
            )
          )
        ),

        // Provider info
        resultsSidebar?.provider && React.createElement('p', {
          style: { fontSize: '12px', color: '#6b7280', marginBottom: '16px' }
        }, `Generated by ${resultsSidebar.provider.name}`),

        // Name input
        React.createElement('div', { style: { marginBottom: '20px' } },
          React.createElement('label', {
            htmlFor: 'playlist-name',
            style: { display: 'block', fontSize: '13px', color: '#9ca3af', marginBottom: '8px' }
          }, 'Playlist Name'),
          React.createElement('input', {
            id: 'playlist-name',
            type: 'text',
            value: aiSavePlaylistName,
            onChange: (e) => setAiSavePlaylistName(e.target.value),
            onKeyDown: (e) => {
              if (e.key === 'Enter' && aiSavePlaylistName.trim()) {
                handleAiSavePlaylistConfirm();
              }
            },
            autoFocus: true,
            style: {
              width: '100%',
              backgroundColor: 'rgba(255, 255, 255, 0.05)',
              border: '1px solid rgba(255, 255, 255, 0.1)',
              borderRadius: '10px',
              padding: '12px 16px',
              fontSize: '14px',
              color: '#f3f4f6',
              outline: 'none'
            },
            onFocus: (e) => { e.target.style.borderColor = 'rgba(167, 139, 250, 0.5)'; e.target.style.boxShadow = '0 0 0 3px rgba(167, 139, 250, 0.1)'; },
            onBlur: (e) => { e.target.style.borderColor = 'rgba(255, 255, 255, 0.1)'; e.target.style.boxShadow = 'none'; }
          })
        ),

        // Actions
        React.createElement('div', { className: 'flex gap-3' },
          React.createElement('button', {
            onClick: () => setAiSaveDialogOpen(false),
            className: 'flex-1 transition-colors',
            style: {
              padding: '12px 16px',
              fontSize: '14px',
              fontWeight: '500',
              color: '#d1d5db',
              backgroundColor: 'rgba(255, 255, 255, 0.05)',
              borderRadius: '10px'
            },
            onMouseEnter: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.08)',
            onMouseLeave: (e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.05)'
          }, 'Cancel'),
          React.createElement('button', {
            onClick: handleAiSavePlaylistConfirm,
            disabled: !aiSavePlaylistName.trim(),
            className: 'flex-1 transition-colors',
            style: {
              padding: '12px 16px',
              fontSize: '14px',
              fontWeight: '500',
              color: '#ffffff',
              backgroundColor: !aiSavePlaylistName.trim() ? 'rgba(124, 58, 237, 0.3)' : '#7c3aed',
              borderRadius: '10px',
              cursor: !aiSavePlaylistName.trim() ? 'not-allowed' : 'pointer',
              opacity: !aiSavePlaylistName.trim() ? '0.5' : '1'
            },
            onMouseEnter: (e) => { if (aiSavePlaylistName.trim()) e.currentTarget.style.backgroundColor = '#6d28d9'; },
            onMouseLeave: (e) => { if (aiSavePlaylistName.trim()) e.currentTarget.style.backgroundColor = '#7c3aed'; }
          }, 'Save')
        )
      )
    ),

    // Queue Save Playlist Dialog
    queueSaveDialogOpen && React.createElement('div', {
      className: 'fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50',
      onClick: (e) => {
        if (e.target === e.currentTarget) {
          setQueueSaveDialogOpen(false);
        }
      }
    },
      React.createElement('div', {
        className: 'bg-gray-900 rounded-xl p-6 max-w-md w-full mx-4 shadow-xl border border-gray-700'
      },
        // Header
        React.createElement('div', { className: 'flex items-center justify-between mb-4' },
          React.createElement('h2', { className: 'text-lg font-semibold text-white' }, 'Save Queue as Playlist'),
          React.createElement('button', {
            onClick: () => setQueueSaveDialogOpen(false),
            className: 'p-1 rounded hover:bg-white/10 text-gray-400 hover:text-white transition-colors'
          },
            React.createElement('svg', { className: 'w-5 h-5', viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2 },
              React.createElement('path', { d: 'M6 18L18 6M6 6l12 12' })
            )
          )
        ),

        // Track count info
        React.createElement('p', {
          className: 'text-xs text-gray-500 mb-4'
        }, `${(currentTrack ? 1 : 0) + currentQueue.length} track${((currentTrack ? 1 : 0) + currentQueue.length) !== 1 ? 's' : ''} will be saved`),

        // Name input
        React.createElement('div', { className: 'mb-4' },
          React.createElement('label', {
            htmlFor: 'queue-playlist-name',
            className: 'block text-sm text-gray-400 mb-2'
          }, 'Playlist Name'),
          React.createElement('input', {
            id: 'queue-playlist-name',
            type: 'text',
            value: queueSavePlaylistName,
            onChange: (e) => setQueueSavePlaylistName(e.target.value),
            onKeyDown: (e) => {
              if (e.key === 'Enter' && queueSavePlaylistName.trim()) {
                handleSaveQueueConfirm();
              }
            },
            autoFocus: true,
            className: 'w-full bg-gray-800 border border-gray-600 rounded-lg px-4 py-3 text-white placeholder-gray-500 focus:outline-none focus:border-purple-500 focus:ring-1 focus:ring-purple-500'
          })
        ),

        // Actions
        React.createElement('div', { className: 'flex gap-3' },
          React.createElement('button', {
            onClick: () => setQueueSaveDialogOpen(false),
            className: 'flex-1 py-2.5 px-4 bg-gray-700 hover:bg-gray-600 text-white font-medium rounded-lg transition-colors'
          }, 'Cancel'),
          React.createElement('button', {
            onClick: handleSaveQueueConfirm,
            disabled: !queueSavePlaylistName.trim(),
            className: 'flex-1 py-2.5 px-4 bg-purple-600 hover:bg-purple-500 disabled:bg-gray-700 disabled:text-gray-500 text-white font-medium rounded-lg transition-colors disabled:cursor-not-allowed'
          }, 'Save')
        )
      )
    ),

    // Import Playlist Dialog Modal
    showUrlImportDialog && React.createElement('div', {
      className: 'fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50',
      onClick: (e) => {
        // Close when clicking backdrop
        if (e.target === e.currentTarget) {
          setShowUrlImportDialog(false);
          setUrlImportValue('');
        }
      }
    },
      React.createElement('div', {
        className: 'bg-white rounded-xl p-6 max-w-md w-full mx-4 shadow-xl'
      },
        // Header
        React.createElement('div', {
          className: 'flex items-center justify-between mb-6'
        },
          React.createElement('h2', { className: 'text-xl font-bold text-gray-900' }, 'ðŸ“¥ Import Playlist'),
          React.createElement('button', {
            onClick: () => {
              setShowUrlImportDialog(false);
              setUrlImportValue('');
            },
            className: 'p-2 hover:bg-gray-100 rounded-lg transition-colors text-gray-500'
          }, React.createElement(X))
        ),

        // Option 1: Import from file
        React.createElement('div', { className: 'mb-6' },
          React.createElement('h3', { className: 'text-sm font-semibold text-gray-700 mb-2' }, 'ðŸ“ From File'),
          React.createElement('p', { className: 'text-xs text-gray-500 mb-3' }, 'Import an XSPF playlist file from your computer.'),
          React.createElement('button', {
            onClick: async () => {
              setShowUrlImportDialog(false);
              await handleImportPlaylist();
            },
            className: 'w-full px-4 py-3 bg-green-600 hover:bg-green-700 text-white rounded-lg transition-colors flex items-center justify-center gap-2',
            disabled: urlImportLoading
          },
            React.createElement('span', null, 'ðŸ“'),
            'Choose File...'
          )
        ),

        // Divider
        React.createElement('div', { className: 'flex items-center gap-4 mb-6' },
          React.createElement('div', { className: 'flex-1 h-px bg-gray-200' }),
          React.createElement('span', { className: 'text-gray-400 text-sm' }, 'or'),
          React.createElement('div', { className: 'flex-1 h-px bg-gray-200' })
        ),

        // Option 2: Import from URL
        React.createElement('div', null,
          React.createElement('h3', { className: 'text-sm font-semibold text-gray-700 mb-2' }, 'ðŸŒ From URL'),
          React.createElement('p', { className: 'text-xs text-gray-500 mb-3' }, 'Import a hosted XSPF playlist. It will auto-update when the source changes.'),
          React.createElement('input', {
            type: 'url',
            value: urlImportValue,
            onChange: (e) => setUrlImportValue(e.target.value),
            placeholder: 'https://example.com/playlist.xspf',
            className: 'w-full px-4 py-3 bg-gray-50 rounded-lg border border-gray-200 focus:border-green-500 focus:outline-none text-gray-900 mb-3',
            disabled: urlImportLoading
          }),
          React.createElement('button', {
            onClick: async () => {
              if (!urlImportValue.trim()) return;
              setUrlImportLoading(true);
              try {
                const result = await handleImportPlaylistFromUrl(urlImportValue.trim());
                setShowUrlImportDialog(false);
                setUrlImportValue('');
                showConfirmDialog({
                  type: 'success',
                  title: result.updated ? 'Playlist Updated' : 'Playlist Imported',
                  message: result.playlist.title
                });
              } catch (error) {
                showConfirmDialog({
                  type: 'error',
                  title: 'Import Failed',
                  message: error.message
                });
              } finally {
                setUrlImportLoading(false);
              }
            },
            disabled: urlImportLoading || !urlImportValue.trim(),
            className: `w-full px-4 py-3 bg-blue-600 hover:bg-blue-700 rounded-lg transition-colors flex items-center justify-center gap-2 ${
              (urlImportLoading || !urlImportValue.trim()) ? 'opacity-50 cursor-not-allowed' : ''
            }`
          },
            urlImportLoading ? 'â³ Importing...' : 'ðŸŒ Import from URL'
          )
        )
      )
    ),

    // Add Friend Modal - Cinematic Light styling
    addFriendModalOpen && React.createElement('div', {
      className: 'fixed inset-0 flex items-center justify-center z-50',
      style: { backgroundColor: 'rgba(0, 0, 0, 0.4)', backdropFilter: 'blur(8px)' },
      onClick: (e) => {
        if (e.target === e.currentTarget) {
          setAddFriendModalOpen(false);
          setAddFriendInput('');
        }
      }
    },
      React.createElement('div', {
        className: 'max-w-md w-full mx-4 overflow-hidden',
        style: {
          backgroundColor: '#ffffff',
          borderRadius: '16px',
          boxShadow: '0 25px 50px -12px rgba(0, 0, 0, 0.25)'
        },
        onClick: (e) => e.stopPropagation()
      },
        // Header
        React.createElement('div', {
          className: 'flex items-center justify-between',
          style: { padding: '20px 24px 16px', borderBottom: '1px solid rgba(0, 0, 0, 0.06)' }
        },
          React.createElement('h3', {
            style: { fontSize: '17px', fontWeight: '600', color: '#1f2937' }
          }, 'Add Friend'),
          React.createElement('button', {
            onClick: () => {
              setAddFriendModalOpen(false);
              setAddFriendInput('');
            },
            className: 'transition-colors',
            style: {
              padding: '6px',
              color: '#9ca3af',
              borderRadius: '8px'
            },
            onMouseEnter: (e) => { e.currentTarget.style.color = '#6b7280'; e.currentTarget.style.backgroundColor = 'rgba(0, 0, 0, 0.05)'; },
            onMouseLeave: (e) => { e.currentTarget.style.color = '#9ca3af'; e.currentTarget.style.backgroundColor = 'transparent'; }
          },
            React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
              React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M6 18L18 6M6 6l12 12' })
            )
          )
        ),
        // Body
        React.createElement('div', { style: { padding: '20px 24px' } },
          React.createElement('p', {
            style: { fontSize: '14px', color: '#4b5563', marginBottom: '16px', lineHeight: '1.5' }
          },
            'Enter a Last.fm or ListenBrainz username, or paste a profile URL.'
          ),
          React.createElement('input', {
            type: 'text',
            value: addFriendInput,
            onChange: (e) => setAddFriendInput(e.target.value),
            onKeyDown: (e) => {
              if (e.key === 'Enter' && addFriendInput.trim()) {
                addFriend(addFriendInput);
              }
            },
            placeholder: 'Username or profile URL',
            style: {
              width: '100%',
              padding: '12px 16px',
              fontSize: '14px',
              color: '#1f2937',
              backgroundColor: '#ffffff',
              border: '1px solid #e5e7eb',
              borderRadius: '10px',
              outline: 'none',
              transition: 'border-color 150ms ease, box-shadow 150ms ease'
            },
            onFocus: (e) => { e.target.style.borderColor = '#9ca3af'; e.target.style.boxShadow = '0 0 0 3px rgba(156, 163, 175, 0.1)'; },
            onBlur: (e) => { e.target.style.borderColor = '#e5e7eb'; e.target.style.boxShadow = 'none'; },
            autoFocus: true
          }),
          // Example hints
          React.createElement('div', { style: { marginTop: '12px', fontSize: '12px', color: '#9ca3af' } },
            React.createElement('p', null, 'Examples:'),
            React.createElement('p', { style: { marginTop: '4px' } }, 'â€¢ username'),
            React.createElement('p', null, 'â€¢ https://www.last.fm/user/username'),
            React.createElement('p', null, 'â€¢ https://listenbrainz.org/user/username')
          )
        ),
        // Footer
        React.createElement('div', {
          className: 'flex justify-end gap-3',
          style: { padding: '16px 24px 20px', borderTop: '1px solid rgba(0, 0, 0, 0.06)' }
        },
          React.createElement('button', {
            onClick: () => {
              setAddFriendModalOpen(false);
              setAddFriendInput('');
            },
            className: 'transition-colors',
            style: {
              padding: '10px 18px',
              fontSize: '14px',
              fontWeight: '500',
              color: '#6b7280',
              borderRadius: '10px'
            },
            onMouseEnter: (e) => { e.currentTarget.style.color = '#374151'; e.currentTarget.style.backgroundColor = 'rgba(0, 0, 0, 0.05)'; },
            onMouseLeave: (e) => { e.currentTarget.style.color = '#6b7280'; e.currentTarget.style.backgroundColor = 'transparent'; }
          }, 'Cancel'),
          React.createElement('button', {
            onClick: () => addFriend(addFriendInput),
            disabled: addFriendLoading || !addFriendInput.trim(),
            className: 'flex items-center gap-2 transition-colors',
            style: {
              padding: '10px 18px',
              fontSize: '14px',
              fontWeight: '500',
              color: '#ffffff',
              backgroundColor: addFriendLoading || !addFriendInput.trim() ? '#c4b5fd' : '#7c3aed',
              borderRadius: '10px',
              cursor: addFriendLoading || !addFriendInput.trim() ? 'not-allowed' : 'pointer',
              opacity: addFriendLoading || !addFriendInput.trim() ? '0.6' : '1'
            },
            onMouseEnter: (e) => { if (!addFriendLoading && addFriendInput.trim()) e.currentTarget.style.backgroundColor = '#6d28d9'; },
            onMouseLeave: (e) => { if (!addFriendLoading && addFriendInput.trim()) e.currentTarget.style.backgroundColor = '#7c3aed'; }
          },
            addFriendLoading && React.createElement('svg', {
              className: 'w-4 h-4 animate-spin',
              fill: 'none',
              viewBox: '0 0 24 24'
            },
              React.createElement('circle', { className: 'opacity-25', cx: '12', cy: '12', r: '10', stroke: 'currentColor', strokeWidth: '4' }),
              React.createElement('path', { className: 'opacity-75', fill: 'currentColor', d: 'M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z' })
            ),
            addFriendLoading ? 'Adding...' : 'Add Friend'
          )
        )
      )
    ),

    // Resolver Detail Modal
    selectedResolver && React.createElement('div', {
      className: 'fixed inset-0 flex items-center justify-center z-50',
      style: {
        backgroundColor: 'rgba(0, 0, 0, 0.4)',
        backdropFilter: 'blur(4px)'
      },
      onClick: (e) => { if (e.target === e.currentTarget) setSelectedResolver(null); }
    },
      React.createElement('div', {
        style: {
          backgroundColor: '#ffffff',
          borderRadius: '16px',
          boxShadow: '0 4px 24px rgba(0, 0, 0, 0.15), 0 12px 48px rgba(0, 0, 0, 0.1)',
          maxWidth: '440px',
          width: '100%',
          margin: '0 16px',
          overflow: 'hidden'
        }
      },
        // Modal header with colored background
        React.createElement('div', {
          className: 'flex items-center gap-4',
          style: {
            padding: '24px',
            backgroundColor: selectedResolver.color || '#6B7280'
          }
        },
          // Logo
          React.createElement('div', {
            className: 'flex items-center justify-center',
            style: { width: '56px', height: '56px' }
          }, SERVICE_LOGOS[selectedResolver.id] || React.createElement('span', { style: { fontSize: '32px' } }, selectedResolver.icon)),
          // Name and version
          React.createElement('div', { className: 'flex-1' },
            React.createElement('div', { className: 'flex items-center gap-2' },
              React.createElement('h2', {
                style: {
                  fontSize: '18px',
                  fontWeight: '600',
                  color: '#ffffff'
                }
              }, selectedResolver.name),
              selectedResolver.version && React.createElement('span', {
                style: {
                  padding: '2px 8px',
                  backgroundColor: 'rgba(255, 255, 255, 0.2)',
                  borderRadius: '4px',
                  fontSize: '11px',
                  color: '#ffffff'
                }
              }, 'v', selectedResolver.version)
            ),
            React.createElement('p', {
              style: {
                fontSize: '13px',
                color: 'rgba(255, 255, 255, 0.8)',
                marginTop: '4px'
              }
            }, selectedResolver.author || 'Parachord Team')
          ),
          // Close button
          React.createElement('button', {
            onClick: () => setSelectedResolver(null),
            className: 'flex items-center justify-center transition-colors',
            style: {
              width: '32px',
              height: '32px',
              borderRadius: '50%',
              backgroundColor: 'rgba(255, 255, 255, 0.2)',
              border: 'none',
              color: '#ffffff',
              cursor: 'pointer',
              fontSize: '14px'
            }
          }, 'âœ•')
        ),
        // Modal body
        React.createElement('div', {
          className: 'scrollable-content',
          style: {
            padding: '24px',
            maxHeight: '60vh',
            overflowY: 'auto'
          }
        },
          // Description
          React.createElement('p', {
            style: {
              fontSize: '13px',
              color: '#6b7280',
              lineHeight: '1.6',
              marginBottom: '24px'
            }
          }, selectedResolver.description),

          // Capabilities
          React.createElement('div', { style: { marginBottom: '24px' } },
            React.createElement('h3', {
              style: {
                fontSize: '11px',
                fontWeight: '600',
                color: '#9ca3af',
                textTransform: 'uppercase',
                letterSpacing: '0.08em',
                marginBottom: '12px'
              }
            }, 'Capabilities'),
            React.createElement('div', { className: 'flex flex-wrap gap-2' },
              Object.entries(selectedResolver.capabilities || {}).map(([cap, enabled]) => {
                if (!enabled) return null;
                const capLabels = {
                  resolve: 'Resolve',
                  search: 'Search',
                  stream: 'Stream',
                  browse: 'Browse',
                  urlLookup: 'URL Lookup',
                  recommendations: 'Recommendations',
                  metadata: 'Metadata',
                  generate: 'AI Playlist Generation'
                };
                const label = capLabels[cap] || cap;
                return React.createElement('span', {
                  key: cap,
                  style: {
                    padding: '6px 12px',
                    backgroundColor: 'rgba(124, 58, 237, 0.08)',
                    color: '#7c3aed',
                    borderRadius: '16px',
                    fontSize: '12px',
                    fontWeight: '500'
                  }
                }, label);
              })
            )
          ),

          // Enable/Disable toggle (only for content resolvers, not meta services)
          selectedResolver.type !== 'meta-service' && React.createElement('div', {
            className: 'flex items-center justify-between',
            style: {
              padding: '16px 0',
              borderTop: '1px solid rgba(0, 0, 0, 0.06)'
            }
          },
            React.createElement('div', null,
              React.createElement('span', {
                style: {
                  fontSize: '13px',
                  fontWeight: '500',
                  color: '#1f2937'
                }
              }, 'Enable Resolver'),
              React.createElement('p', {
                style: {
                  fontSize: '12px',
                  color: '#6b7280',
                  marginTop: '2px'
                }
              }, 'Include in search and playback')
            ),
            React.createElement('label', { className: 'relative inline-block w-12 h-6' },
              React.createElement('input', {
                type: 'checkbox',
                checked: activeResolvers.includes(selectedResolver.id),
                onChange: () => toggleResolver(selectedResolver.id),
                className: 'sr-only peer'
              }),
              React.createElement('div', {
                className: 'w-full h-full bg-gray-300 rounded-full peer-checked:bg-purple-600 transition-colors'
              }),
              React.createElement('div', {
                className: 'absolute left-1 top-1 w-4 h-4 bg-white rounded-full shadow transition-transform peer-checked:translate-x-6'
              })
            )
          ),

          // Authentication section (for services that require it)
          selectedResolver.id === 'spotify' && React.createElement('div', {
            style: {
              padding: '16px 0',
              borderTop: '1px solid rgba(0, 0, 0, 0.06)'
            }
          },
            React.createElement('div', { className: 'flex items-center justify-between' },
              React.createElement('div', null,
                React.createElement('span', {
                  style: {
                    fontSize: '13px',
                    fontWeight: '500',
                    color: '#1f2937'
                  }
                }, 'Spotify Account'),
                React.createElement('p', {
                  style: {
                    fontSize: '12px',
                    color: '#6b7280',
                    marginTop: '2px'
                  }
                },
                  spotifyConnected ? 'Connected and ready' : 'Sign in to enable streaming'
                )
              ),
              spotifyConnected
                ? React.createElement('button', {
                    onClick: disconnectSpotify,
                    className: 'transition-colors',
                    style: {
                      padding: '8px 14px',
                      fontSize: '13px',
                      fontWeight: '500',
                      color: '#dc2626',
                      backgroundColor: 'rgba(220, 38, 38, 0.08)',
                      border: 'none',
                      borderRadius: '8px',
                      cursor: 'pointer'
                    }
                  }, 'Disconnect')
                : React.createElement('button', {
                    onClick: connectSpotify,
                    className: 'transition-colors',
                    style: {
                      padding: '8px 14px',
                      fontSize: '13px',
                      fontWeight: '500',
                      color: '#ffffff',
                      backgroundColor: '#22c55e',
                      border: 'none',
                      borderRadius: '8px',
                      cursor: 'pointer'
                    }
                  }, 'Connect')
            ),
            spotifyConnected && React.createElement('div', {
              className: 'flex items-center gap-2',
              style: {
                marginTop: '12px',
                fontSize: '12px',
                color: '#22c55e'
              }
            },
              React.createElement('span', null, 'âœ“'),
              React.createElement('span', null, 'Spotify Premium connected')
            )
          ),

          // Library Sync Section - shown for Spotify - Cinematic Light design
          selectedResolver.id === 'spotify' && React.createElement('div', {
            style: {
              marginTop: '20px',
              padding: '16px',
              backgroundColor: 'rgba(0, 0, 0, 0.02)',
              borderRadius: '12px',
              border: '1px solid rgba(0, 0, 0, 0.04)'
            }
          },
            React.createElement('h4', {
              style: {
                fontSize: '11px',
                fontWeight: '600',
                color: '#9ca3af',
                textTransform: 'uppercase',
                letterSpacing: '0.08em',
                marginBottom: '14px'
              }
            }, 'Library Sync'),
            resolverSyncSettings.spotify?.enabled
              ? React.createElement('div', {
                  style: { display: 'flex', flexDirection: 'column', gap: '12px' }
                },
                  // Status row
                  React.createElement('div', {
                    style: { display: 'flex', alignItems: 'center', justifyContent: 'space-between', fontSize: '13px' }
                  },
                    React.createElement('span', {
                      style: { color: '#6b7280' }
                    }, 'Status'),
                    React.createElement('span', {
                      style: { color: '#22c55e', display: 'flex', alignItems: 'center', gap: '6px', fontWeight: '500' }
                    },
                      React.createElement('span', {
                        style: { width: '8px', height: '8px', backgroundColor: '#22c55e', borderRadius: '50%' }
                      }),
                      'Active'
                    )
                  ),
                  // Last synced row
                  React.createElement('div', {
                    style: { display: 'flex', alignItems: 'center', justifyContent: 'space-between', fontSize: '13px' }
                  },
                    React.createElement('span', {
                      style: { color: '#6b7280' }
                    }, 'Last synced'),
                    React.createElement('span', {
                      style: { color: '#1f2937' }
                    },
                      resolverSyncSettings.spotify?.lastSyncAt
                        ? new Date(resolverSyncSettings.spotify.lastSyncAt).toLocaleString()
                        : 'Never'
                    )
                  ),
                  // Action buttons
                  React.createElement('div', {
                    style: { display: 'flex', gap: '8px', marginTop: '4px' }
                  },
                    React.createElement('button', {
                      onClick: () => openSyncSetupModal('spotify'),
                      style: {
                        padding: '8px 14px',
                        backgroundColor: 'rgba(0, 0, 0, 0.04)',
                        color: '#1f2937',
                        fontSize: '13px',
                        fontWeight: '500',
                        borderRadius: '8px',
                        border: '1px solid rgba(0, 0, 0, 0.06)',
                        cursor: 'pointer',
                        transition: 'all 150ms ease'
                      },
                      onMouseEnter: (e) => { e.currentTarget.style.backgroundColor = 'rgba(0, 0, 0, 0.08)'; },
                      onMouseLeave: (e) => { e.currentTarget.style.backgroundColor = 'rgba(0, 0, 0, 0.04)'; }
                    }, 'Manage Sync'),
                    React.createElement('button', {
                      onClick: () => setStopSyncDialog({ open: true, providerId: 'spotify' }),
                      style: {
                        padding: '8px 14px',
                        backgroundColor: 'transparent',
                        color: '#9ca3af',
                        fontSize: '13px',
                        fontWeight: '500',
                        border: 'none',
                        cursor: 'pointer',
                        transition: 'color 150ms ease'
                      },
                      onMouseEnter: (e) => e.currentTarget.style.color = '#dc2626',
                      onMouseLeave: (e) => e.currentTarget.style.color = '#9ca3af'
                    }, 'Stop Syncing')
                  )
                )
              : React.createElement('button', {
                  onClick: () => openSyncSetupModal('spotify'),
                  style: {
                    width: '100%',
                    padding: '10px 16px',
                    backgroundColor: '#1DB954',
                    color: '#ffffff',
                    borderRadius: '10px',
                    fontWeight: '500',
                    fontSize: '13px',
                    border: 'none',
                    cursor: 'pointer',
                    transition: 'background-color 150ms ease'
                  },
                  onMouseEnter: (e) => e.currentTarget.style.backgroundColor = '#1ed760',
                  onMouseLeave: (e) => e.currentTarget.style.backgroundColor = '#1DB954'
                }, 'Set Up Library Sync')
          ),

          // Auto-launch Spotify section
          selectedResolver.id === 'spotify' && React.createElement('div', {
            style: {
              marginTop: '20px',
              padding: '16px',
              backgroundColor: 'rgba(0, 0, 0, 0.02)',
              borderRadius: '12px',
              border: '1px solid rgba(0, 0, 0, 0.04)'
            }
          },
            React.createElement('h4', {
              style: {
                fontSize: '11px',
                fontWeight: '600',
                color: '#9ca3af',
                textTransform: 'uppercase',
                letterSpacing: '0.08em',
                marginBottom: '14px'
              }
            }, 'Startup'),
            React.createElement('div', { className: 'flex items-center justify-between' },
              React.createElement('div', null,
                React.createElement('p', { style: { fontSize: '13px', fontWeight: '500', color: '#374151' } },
                  'Auto-launch Spotify'
                ),
                React.createElement('p', { style: { fontSize: '12px', color: '#6b7280', marginTop: '2px', lineHeight: '1.5' } },
                  'Start Spotify in background when Parachord opens. Ensures a device is always available for playback.'
                )
              ),
              React.createElement('button', {
                onClick: async () => {
                  const newValue = !autoLaunchSpotify;
                  setAutoLaunchSpotify(newValue);
                  if (window.electron?.store) {
                    await window.electron.store.set('auto_launch_spotify', newValue);
                  }
                  // If enabling, launch Spotify now
                  if (newValue && window.electron?.spotify?.launchInBackground) {
                    window.electron.spotify.launchInBackground();
                    showToast('Spotify launched in background', 'success');
                  }
                },
                className: `relative w-11 h-6 rounded-full transition-colors ${autoLaunchSpotify ? 'bg-green-500' : 'bg-gray-300'}`,
                style: { flexShrink: 0, marginLeft: '16px' }
              },
                React.createElement('span', {
                  className: `absolute top-0.5 left-0.5 w-5 h-5 bg-white rounded-full shadow transition-transform ${autoLaunchSpotify ? 'translate-x-5' : 'translate-x-0'}`
                })
              )
            )
          ),

          // Qobuz authentication section
          selectedResolver.id === 'qobuz' && React.createElement('div', {
            style: {
              padding: '16px 0',
              borderTop: '1px solid rgba(0, 0, 0, 0.06)'
            }
          },
            React.createElement('div', null,
              React.createElement('span', {
                style: {
                  fontSize: '13px',
                  fontWeight: '500',
                  color: '#1f2937'
                }
              }, 'Qobuz Streaming'),
              React.createElement('p', {
                style: {
                  fontSize: '12px',
                  color: '#6b7280',
                  marginTop: '4px',
                  lineHeight: '1.5'
                }
              },
                'Currently using 30-second previews. Full streaming requires Qobuz subscription.'
              )
            )
          ),

          // Last.fm authentication section
          selectedResolver.id === 'lastfm' && React.createElement('div', {
            style: {
              padding: '16px 0',
              borderTop: '1px solid rgba(0, 0, 0, 0.06)'
            }
          },
            // Connected state
            metaServiceConfigs.lastfm?.username
              ? React.createElement('div', null,
                  React.createElement('div', { className: 'flex items-center justify-between' },
                    React.createElement('div', null,
                      React.createElement('span', {
                        style: {
                          fontSize: '13px',
                          fontWeight: '500',
                          color: '#1f2937'
                        }
                      }, 'Last.fm Account'),
                      React.createElement('p', {
                        style: {
                          fontSize: '12px',
                          color: '#6b7280',
                          marginTop: '2px'
                        }
                      },
                        `Connected as ${metaServiceConfigs.lastfm.username}`
                      )
                    ),
                    React.createElement('button', {
                      onClick: disconnectLastfm,
                      className: 'transition-colors',
                      style: {
                        padding: '8px 14px',
                        fontSize: '13px',
                        fontWeight: '500',
                        color: '#dc2626',
                        backgroundColor: 'rgba(220, 38, 38, 0.08)',
                        border: 'none',
                        borderRadius: '8px',
                        cursor: 'pointer'
                      }
                    }, 'Disconnect')
                  ),
                  React.createElement('div', {
                    className: 'flex items-center gap-2',
                    style: {
                      marginTop: '12px',
                      fontSize: '12px',
                      color: '#22c55e'
                    }
                  },
                    React.createElement('span', null, 'âœ“'),
                    React.createElement('span', null, 'Connected to Last.fm')
                  ),
                  // Show API key status if configured
                  metaServiceConfigs.lastfm.apiKey && React.createElement('p', {
                    style: {
                      marginTop: '8px',
                      fontSize: '11px',
                      color: '#6b7280'
                    }
                  }, 'ðŸ”‘ Using custom API key'),

                  // Scrobbling section for Last.fm
                  React.createElement('div', {
                    style: {
                      marginTop: '16px',
                      paddingTop: '16px',
                      borderTop: '1px solid rgba(0, 0, 0, 0.06)'
                    }
                  },
                    React.createElement('div', { className: 'flex items-center justify-between', style: { marginBottom: '12px' } },
                      React.createElement('div', null,
                        React.createElement('span', {
                          style: {
                            fontSize: '13px',
                            fontWeight: '500',
                            color: '#1f2937'
                          }
                        }, 'Scrobbling'),
                        React.createElement('p', {
                          style: {
                            fontSize: '12px',
                            color: '#6b7280',
                            marginTop: '2px'
                          }
                        },
                          'Report your listening history to Last.fm'
                        )
                      )
                    ),
                    // Scrobbler card for Last.fm
                    window.scrobblers && window.scrobblers.find(s => s.id === 'lastfm') &&
                      React.createElement(ScrobblerSettingsCard, {
                        scrobbler: window.scrobblers.find(s => s.id === 'lastfm'),
                        config: scrobblerConfigs['lastfm'],
                        onConfigChange: (id, newConfig) => {
                          setScrobblerConfigs(prev => ({ ...prev, [id]: newConfig }));
                        }
                      })
                  )
                )
              // Not connected state
              : React.createElement('div', null,
                  React.createElement('span', {
                    style: {
                      fontSize: '13px',
                      fontWeight: '500',
                      color: '#1f2937'
                    }
                  }, 'Last.fm Account'),
                  React.createElement('p', {
                    style: {
                      fontSize: '12px',
                      color: '#6b7280',
                      marginTop: '4px',
                      marginBottom: '16px',
                      lineHeight: '1.5'
                    }
                  },
                    'Enter your Last.fm username to enable personalized recommendations.'
                  ),
                  // Username input
                  React.createElement('div', { style: { marginBottom: '16px' } },
                    React.createElement('label', {
                      style: {
                        display: 'block',
                        fontSize: '12px',
                        fontWeight: '500',
                        color: '#374151',
                        marginBottom: '6px'
                      }
                    }, 'Username'),
                    React.createElement('input', {
                      type: 'text',
                      value: lastfmUsernameInput,
                      onChange: (e) => setLastfmUsernameInput(e.target.value),
                      placeholder: 'Your Last.fm username',
                      style: {
                        width: '100%',
                        padding: '10px 12px',
                        fontSize: '13px',
                        color: '#1f2937',
                        backgroundColor: '#ffffff',
                        border: '1px solid rgba(0, 0, 0, 0.1)',
                        borderRadius: '8px',
                        outline: 'none'
                      }
                    })
                  ),
                  // Advanced accordion
                  React.createElement('div', { style: { marginBottom: '16px' } },
                    React.createElement('button', {
                      onClick: () => setLastfmAdvancedOpen(!lastfmAdvancedOpen),
                      className: 'flex items-center gap-1',
                      style: {
                        fontSize: '12px',
                        color: '#6b7280',
                        backgroundColor: 'transparent',
                        border: 'none',
                        cursor: 'pointer',
                        padding: '0'
                      }
                    },
                      React.createElement('span', {
                        className: `transform transition-transform ${lastfmAdvancedOpen ? 'rotate-90' : ''}`
                      }, 'â–¶'),
                      'Advanced'
                    ),
                    lastfmAdvancedOpen && React.createElement('div', {
                      style: {
                        marginTop: '12px',
                        padding: '12px',
                        backgroundColor: 'rgba(0, 0, 0, 0.02)',
                        borderRadius: '8px'
                      }
                    },
                      React.createElement('p', {
                        style: {
                          fontSize: '11px',
                          color: '#6b7280',
                          marginBottom: '12px',
                          lineHeight: '1.5'
                        }
                      },
                        'Optional: Use your own Last.fm API credentials to avoid rate limiting.'
                      ),
                      React.createElement('div', { style: { marginBottom: '10px' } },
                        React.createElement('label', {
                          style: {
                            display: 'block',
                            fontSize: '11px',
                            fontWeight: '500',
                            color: '#374151',
                            marginBottom: '4px'
                          }
                        }, 'API Key'),
                        React.createElement('input', {
                          type: 'text',
                          value: lastfmApiKeyInput,
                          onChange: (e) => setLastfmApiKeyInput(e.target.value),
                          placeholder: 'Your Last.fm API key',
                          style: {
                            width: '100%',
                            padding: '8px 10px',
                            fontSize: '12px',
                            color: '#1f2937',
                            backgroundColor: '#ffffff',
                            border: '1px solid rgba(0, 0, 0, 0.1)',
                            borderRadius: '6px',
                            outline: 'none'
                          }
                        })
                      ),
                      React.createElement('div', null,
                        React.createElement('label', {
                          style: {
                            display: 'block',
                            fontSize: '11px',
                            fontWeight: '500',
                            color: '#374151',
                            marginBottom: '4px'
                          }
                        }, 'API Secret'),
                        React.createElement('input', {
                          type: 'password',
                          value: lastfmApiSecretInput,
                          onChange: (e) => setLastfmApiSecretInput(e.target.value),
                          placeholder: 'Your Last.fm API secret',
                          style: {
                            width: '100%',
                            padding: '8px 10px',
                            fontSize: '12px',
                            color: '#1f2937',
                            backgroundColor: '#ffffff',
                            border: '1px solid rgba(0, 0, 0, 0.1)',
                            borderRadius: '6px',
                            outline: 'none'
                          }
                        })
                      )
                    )
                  ),
                  // Connect button
                  React.createElement('button', {
                    onClick: () => connectLastfm(lastfmUsernameInput, lastfmApiKeyInput, lastfmApiSecretInput),
                    disabled: lastfmConnecting || !lastfmUsernameInput.trim(),
                    className: 'transition-colors',
                    style: {
                      width: '100%',
                      padding: '10px 16px',
                      fontSize: '13px',
                      fontWeight: '500',
                      color: '#ffffff',
                      backgroundColor: lastfmConnecting || !lastfmUsernameInput.trim() ? '#9ca3af' : '#dc2626',
                      border: 'none',
                      borderRadius: '8px',
                      cursor: lastfmConnecting || !lastfmUsernameInput.trim() ? 'not-allowed' : 'pointer',
                      opacity: lastfmConnecting || !lastfmUsernameInput.trim() ? 0.6 : 1
                    }
                  }, lastfmConnecting ? 'Connecting...' : 'Connect')
                )
          ),

          // ListenBrainz authentication section
          selectedResolver.id === 'listenbrainz' && React.createElement('div', {
            style: {
              padding: '16px 0',
              borderTop: '1px solid rgba(0, 0, 0, 0.06)'
            }
          },
            // Connected state
            metaServiceConfigs.listenbrainz?.username
              ? React.createElement('div', null,
                  React.createElement('div', { className: 'flex items-center justify-between' },
                    React.createElement('div', null,
                      React.createElement('span', {
                        style: {
                          fontSize: '13px',
                          fontWeight: '500',
                          color: '#1f2937'
                        }
                      }, 'ListenBrainz Account'),
                      React.createElement('p', {
                        style: {
                          fontSize: '12px',
                          color: '#6b7280',
                          marginTop: '2px'
                        }
                      },
                        `Connected as ${metaServiceConfigs.listenbrainz.username}`
                      )
                    ),
                    React.createElement('button', {
                      onClick: disconnectListenbrainz,
                      className: 'transition-colors',
                      style: {
                        padding: '8px 14px',
                        fontSize: '13px',
                        fontWeight: '500',
                        color: '#dc2626',
                        backgroundColor: 'rgba(220, 38, 38, 0.08)',
                        border: 'none',
                        borderRadius: '8px',
                        cursor: 'pointer'
                      }
                    }, 'Disconnect')
                  ),
                  React.createElement('div', {
                    className: 'flex items-center gap-2',
                    style: {
                      marginTop: '12px',
                      fontSize: '12px',
                      color: '#22c55e'
                    }
                  },
                    React.createElement('span', null, 'âœ“'),
                    React.createElement('span', null, 'Connected to ListenBrainz')
                  ),
                  // Show token status if configured
                  metaServiceConfigs.listenbrainz.userToken && React.createElement('p', {
                    style: {
                      marginTop: '8px',
                      fontSize: '11px',
                      color: '#6b7280'
                    }
                  }, 'ðŸ”‘ User token configured'),

                  // Scrobbling section for ListenBrainz
                  React.createElement('div', {
                    style: {
                      marginTop: '16px',
                      paddingTop: '16px',
                      borderTop: '1px solid rgba(0, 0, 0, 0.06)'
                    }
                  },
                    React.createElement('div', { className: 'flex items-center justify-between', style: { marginBottom: '12px' } },
                      React.createElement('div', null,
                        React.createElement('span', {
                          style: {
                            fontSize: '13px',
                            fontWeight: '500',
                            color: '#1f2937'
                          }
                        }, 'Scrobbling'),
                        React.createElement('p', {
                          style: {
                            fontSize: '12px',
                            color: '#6b7280',
                            marginTop: '2px'
                          }
                        },
                          'Report your listening history to ListenBrainz'
                        )
                      )
                    ),
                    // Scrobbler card for ListenBrainz
                    window.scrobblers && window.scrobblers.find(s => s.id === 'listenbrainz') &&
                      React.createElement(ScrobblerSettingsCard, {
                        scrobbler: window.scrobblers.find(s => s.id === 'listenbrainz'),
                        config: scrobblerConfigs['listenbrainz'],
                        onConfigChange: (id, newConfig) => {
                          setScrobblerConfigs(prev => ({ ...prev, [id]: newConfig }));
                        }
                      })
                  )
                )
              // Not connected state
              : React.createElement('div', null,
                  React.createElement('span', {
                    style: {
                      fontSize: '13px',
                      fontWeight: '500',
                      color: '#1f2937'
                    }
                  }, 'ListenBrainz Account'),
                  React.createElement('p', {
                    style: {
                      fontSize: '12px',
                      color: '#6b7280',
                      marginTop: '4px',
                      marginBottom: '16px',
                      lineHeight: '1.5'
                    }
                  },
                    'Enter your ListenBrainz username to enable open-source music recommendations and history.'
                  ),
                  // Username input
                  React.createElement('div', { style: { marginBottom: '16px' } },
                    React.createElement('label', {
                      style: {
                        display: 'block',
                        fontSize: '12px',
                        fontWeight: '500',
                        color: '#374151',
                        marginBottom: '6px'
                      }
                    }, 'Username'),
                    React.createElement('input', {
                      type: 'text',
                      value: listenbrainzUsernameInput,
                      onChange: (e) => setListenbrainzUsernameInput(e.target.value),
                      placeholder: 'Your ListenBrainz username',
                      style: {
                        width: '100%',
                        padding: '10px 12px',
                        fontSize: '13px',
                        color: '#1f2937',
                        backgroundColor: '#ffffff',
                        border: '1px solid rgba(0, 0, 0, 0.1)',
                        borderRadius: '8px',
                        outline: 'none'
                      }
                    })
                  ),
                  // Advanced accordion
                  React.createElement('div', { style: { marginBottom: '16px' } },
                    React.createElement('button', {
                      onClick: () => setListenbrainzAdvancedOpen(!listenbrainzAdvancedOpen),
                      className: 'flex items-center gap-1',
                      style: {
                        fontSize: '12px',
                        color: '#6b7280',
                        backgroundColor: 'transparent',
                        border: 'none',
                        cursor: 'pointer',
                        padding: '0'
                      }
                    },
                      React.createElement('span', {
                        className: `transform transition-transform ${listenbrainzAdvancedOpen ? 'rotate-90' : ''}`
                      }, 'â–¶'),
                      'Advanced'
                    ),
                    listenbrainzAdvancedOpen && React.createElement('div', {
                      style: {
                        marginTop: '12px',
                        padding: '12px',
                        backgroundColor: 'rgba(0, 0, 0, 0.02)',
                        borderRadius: '8px'
                      }
                    },
                      React.createElement('p', {
                        style: {
                          fontSize: '11px',
                          color: '#6b7280',
                          marginBottom: '12px',
                          lineHeight: '1.5'
                        }
                      },
                        'Optional: Add your user token to enable listen submissions and access private data. Find it at listenbrainz.org/settings/'
                      ),
                      React.createElement('div', null,
                        React.createElement('label', {
                          style: {
                            display: 'block',
                            fontSize: '11px',
                            fontWeight: '500',
                            color: '#374151',
                            marginBottom: '4px'
                          }
                        }, 'User Token'),
                        React.createElement('input', {
                          type: 'password',
                          value: listenbrainzTokenInput,
                          onChange: (e) => setListenbrainzTokenInput(e.target.value),
                          placeholder: 'Your ListenBrainz user token',
                          style: {
                            width: '100%',
                            padding: '8px 10px',
                            fontSize: '12px',
                            color: '#1f2937',
                            backgroundColor: '#ffffff',
                            border: '1px solid rgba(0, 0, 0, 0.1)',
                            borderRadius: '6px',
                            outline: 'none'
                          }
                        })
                      )
                    )
                  ),
                  // Connect button
                  React.createElement('button', {
                    onClick: () => connectListenbrainz(listenbrainzUsernameInput, listenbrainzTokenInput),
                    disabled: listenbrainzConnecting || !listenbrainzUsernameInput.trim(),
                    className: 'transition-colors',
                    style: {
                      width: '100%',
                      padding: '10px 16px',
                      fontSize: '13px',
                      fontWeight: '500',
                      color: '#ffffff',
                      backgroundColor: listenbrainzConnecting || !listenbrainzUsernameInput.trim() ? '#9ca3af' : '#6366f1',
                      border: 'none',
                      borderRadius: '8px',
                      cursor: listenbrainzConnecting || !listenbrainzUsernameInput.trim() ? 'not-allowed' : 'pointer',
                      opacity: listenbrainzConnecting || !listenbrainzUsernameInput.trim() ? 0.6 : 1
                    }
                  }, listenbrainzConnecting ? 'Connecting...' : 'Connect')
                )
          ),

          // AI Service configuration (ChatGPT and Gemini)
          (selectedResolver.id === 'chatgpt' || selectedResolver.id === 'gemini') && React.createElement('div', {
            style: {
              padding: '16px 0',
              borderTop: '1px solid rgba(0, 0, 0, 0.06)'
            }
          },
            React.createElement('span', {
              style: {
                fontSize: '13px',
                fontWeight: '500',
                color: '#1f2937'
              }
            }, 'API Configuration'),
            React.createElement('p', {
              style: {
                fontSize: '12px',
                color: '#6b7280',
                marginTop: '4px',
                marginBottom: '16px',
                lineHeight: '1.5'
              }
            },
              selectedResolver.id === 'chatgpt'
                ? 'Enter your OpenAI API key to enable AI playlist generation.'
                : 'Enter your Google API key to enable AI playlist generation.'
            ),
            // API Key input
            React.createElement('div', { style: { marginBottom: '16px' } },
              React.createElement('label', {
                style: {
                  display: 'block',
                  fontSize: '12px',
                  fontWeight: '500',
                  color: '#374151',
                  marginBottom: '6px'
                }
              }, 'API Key'),
              React.createElement('input', {
                type: 'password',
                defaultValue: metaServiceConfigs[selectedResolver.id]?.apiKey || '',
                onBlur: (e) => {
                  saveMetaServiceConfig(selectedResolver.id, {
                    ...metaServiceConfigs[selectedResolver.id],
                    apiKey: e.target.value,
                    enabled: !!e.target.value
                  });
                },
                placeholder: selectedResolver.id === 'chatgpt' ? 'sk-...' : 'AIza...',
                style: {
                  width: '100%',
                  padding: '10px 12px',
                  fontSize: '13px',
                  color: '#1f2937',
                  backgroundColor: '#ffffff',
                  border: '1px solid rgba(0, 0, 0, 0.1)',
                  borderRadius: '8px',
                  outline: 'none'
                }
              }),
              React.createElement('a', {
                href: '#',
                onClick: (e) => {
                  e.preventDefault();
                  const url = selectedResolver.id === 'chatgpt'
                    ? 'https://platform.openai.com/api-keys'
                    : 'https://aistudio.google.com/app/apikey';
                  window.electron?.shell?.openExternal?.(url);
                },
                style: {
                  display: 'inline-block',
                  marginTop: '6px',
                  fontSize: '12px',
                  color: '#7c3aed',
                  fontWeight: '500',
                  textDecoration: 'none'
                }
              }, 'Get your API key â†’')
            ),
            // Model selector
            React.createElement('div', { style: { marginBottom: '16px' } },
              React.createElement('label', {
                style: {
                  display: 'block',
                  fontSize: '12px',
                  fontWeight: '500',
                  color: '#374151',
                  marginBottom: '6px'
                }
              }, 'Model'),
              React.createElement('select', {
                value: metaServiceConfigs[selectedResolver.id]?.model || (selectedResolver.id === 'chatgpt' ? 'gpt-4o-mini' : 'gemini-2.5-flash'),
                onChange: (e) => {
                  saveMetaServiceConfig(selectedResolver.id, {
                    ...metaServiceConfigs[selectedResolver.id],
                    model: e.target.value
                  });
                },
                style: {
                  width: '100%',
                  padding: '10px 12px',
                  fontSize: '13px',
                  color: '#1f2937',
                  backgroundColor: '#ffffff',
                  border: '1px solid rgba(0, 0, 0, 0.1)',
                  borderRadius: '8px',
                  outline: 'none',
                  cursor: 'pointer'
                }
              },
                selectedResolver.id === 'chatgpt' ? [
                  React.createElement('option', { key: 'gpt-4o-mini', value: 'gpt-4o-mini' }, 'GPT-4o Mini (Recommended)'),
                  React.createElement('option', { key: 'gpt-4o', value: 'gpt-4o' }, 'GPT-4o'),
                  React.createElement('option', { key: 'gpt-3.5-turbo', value: 'gpt-3.5-turbo' }, 'GPT-3.5 Turbo')
                ] : [
                  React.createElement('option', { key: 'gemini-2.5-flash', value: 'gemini-2.5-flash' }, 'Gemini 2.5 Flash (Recommended)'),
                  React.createElement('option', { key: 'gemini-2.5-pro', value: 'gemini-2.5-pro' }, 'Gemini 2.5 Pro')
                ]
              )
            ),
            // Connection status
            metaServiceConfigs[selectedResolver.id]?.apiKey && React.createElement('div', {
              className: 'flex items-center gap-2 text-green-600 text-sm'
            },
              React.createElement('span', null, 'âœ“'),
              React.createElement('span', null, 'API key configured')
            )
          ),

          // Libre.fm scrobbling section
          selectedResolver.id === 'librefm' && React.createElement('div', {
            className: 'py-3 border-t border-gray-100'
          },
            React.createElement('div', { className: 'mb-4' },
              React.createElement('span', { className: 'font-medium text-gray-900' }, 'Libre.fm Scrobbling'),
              React.createElement('p', { className: 'text-xs text-gray-500 mt-1' },
                'Open-source scrobbling service - an alternative to Last.fm. Report your listening history to Libre.fm.'
              )
            ),
            // Scrobbler card for Libre.fm
            window.scrobblers && window.scrobblers.find(s => s.id === 'librefm') &&
              React.createElement(ScrobblerSettingsCard, {
                scrobbler: window.scrobblers.find(s => s.id === 'librefm'),
                config: scrobblerConfigs['librefm'],
                onConfigChange: (id, newConfig) => {
                  setScrobblerConfigs(prev => ({ ...prev, [id]: newConfig }));
                }
              })
          ),

          // Local Files settings section
          selectedResolver.id === 'localfiles' && React.createElement('div', {
            style: {
              padding: '16px 0',
              borderTop: '1px solid rgba(0, 0, 0, 0.06)'
            }
          },
            React.createElement('h3', {
              style: {
                fontSize: '13px',
                fontWeight: '500',
                color: '#1f2937',
                marginBottom: '8px'
              }
            }, 'Watch Folders'),
            React.createElement('p', {
              style: {
                fontSize: '12px',
                color: '#6b7280',
                marginBottom: '16px',
                lineHeight: '1.5'
              }
            },
              'Add folders containing your music files. Parachord will automatically index and watch them for changes.'
            ),

            // Watch folders list
            React.createElement('div', { style: { marginBottom: '16px' } },
              watchFolders.length === 0
                ? React.createElement('p', {
                    style: {
                      fontSize: '13px',
                      color: '#9ca3af',
                      fontStyle: 'italic'
                    }
                  }, 'No watch folders configured')
                : watchFolders.map(folder =>
                    React.createElement('div', {
                      key: folder.path,
                      className: 'flex items-center justify-between',
                      style: {
                        padding: '12px',
                        backgroundColor: 'rgba(0, 0, 0, 0.02)',
                        borderRadius: '8px',
                        marginBottom: '8px'
                      }
                    },
                      React.createElement('div', { className: 'flex-1 min-w-0' },
                        React.createElement('p', {
                          className: 'truncate',
                          style: {
                            fontSize: '13px',
                            fontWeight: '500',
                            color: '#1f2937'
                          }
                        }, folder.path),
                        React.createElement('p', {
                          style: {
                            fontSize: '11px',
                            color: '#6b7280',
                            marginTop: '2px'
                          }
                        },
                          `${folder.track_count || 0} tracks`
                        )
                      ),
                      React.createElement('div', { className: 'flex items-center gap-2', style: { marginLeft: '16px' } },
                        React.createElement('button', {
                          onClick: () => handleRescanFolder(folder.path),
                          disabled: isScanning,
                          className: 'transition-colors',
                          style: {
                            padding: '6px',
                            fontSize: '14px',
                            color: '#6b7280',
                            backgroundColor: 'transparent',
                            border: 'none',
                            borderRadius: '6px',
                            cursor: isScanning ? 'not-allowed' : 'pointer',
                            opacity: isScanning ? 0.5 : 1
                          },
                          title: 'Rescan folder'
                        }, '\u21BB'),
                        React.createElement('button', {
                          onClick: () => handleRemoveWatchFolder(folder.path),
                          className: 'transition-colors',
                          style: {
                            padding: '6px',
                            fontSize: '14px',
                            color: '#6b7280',
                            backgroundColor: 'transparent',
                            border: 'none',
                            borderRadius: '6px',
                            cursor: 'pointer'
                          },
                          title: 'Remove folder'
                        }, '\u2715')
                      )
                    )
                  )
            ),

            // Add folder button
            React.createElement('button', {
              onClick: handleAddWatchFolder,
              disabled: isScanning,
              className: 'flex items-center justify-center gap-2 transition-colors',
              style: {
                width: '100%',
                padding: '10px 16px',
                fontSize: '13px',
                fontWeight: '500',
                color: '#6b7280',
                backgroundColor: 'transparent',
                border: '1px dashed rgba(0, 0, 0, 0.15)',
                borderRadius: '8px',
                cursor: isScanning ? 'not-allowed' : 'pointer',
                opacity: isScanning ? 0.5 : 1
              }
            },
              React.createElement('span', null, '+'),
              'Add Watch Folder'
            ),

            // Scan progress
            isScanning && React.createElement('div', { style: { marginTop: '16px' } },
              React.createElement('div', { className: 'flex items-center gap-2', style: { marginBottom: '8px' } },
                React.createElement('div', {
                  className: 'animate-spin',
                  style: {
                    width: '14px',
                    height: '14px',
                    border: '2px solid #7c3aed',
                    borderTopColor: 'transparent',
                    borderRadius: '50%'
                  }
                }),
                React.createElement('span', {
                  style: {
                    fontSize: '13px',
                    color: '#6b7280'
                  }
                }, 'Scanning...')
              ),
              React.createElement('div', {
                style: {
                  width: '100%',
                  backgroundColor: 'rgba(0, 0, 0, 0.06)',
                  borderRadius: '4px',
                  height: '6px'
                }
              },
                React.createElement('div', {
                  style: {
                    width: `${scanProgress.total > 0 ? (scanProgress.current / scanProgress.total) * 100 : 0}%`,
                    backgroundColor: '#7c3aed',
                    height: '6px',
                    borderRadius: '4px',
                    transition: 'width 0.3s ease'
                  }
                })
              ),
              React.createElement('p', {
                className: 'truncate',
                style: {
                  fontSize: '11px',
                  color: '#9ca3af',
                  marginTop: '6px'
                }
              },
                scanProgress.file || 'Preparing...'
              )
            ),

            // Stats
            React.createElement('div', {
              style: {
                marginTop: '24px',
                paddingTop: '16px',
                borderTop: '1px solid rgba(0, 0, 0, 0.06)'
              }
            },
              React.createElement('h4', {
                style: {
                  fontSize: '11px',
                  fontWeight: '600',
                  color: '#9ca3af',
                  textTransform: 'uppercase',
                  letterSpacing: '0.08em',
                  marginBottom: '12px'
                }
              }, 'Library Stats'),
              React.createElement('div', { className: 'grid grid-cols-2 gap-4' },
                React.createElement('div', null,
                  React.createElement('p', {
                    style: {
                      fontSize: '12px',
                      color: '#6b7280'
                    }
                  }, 'Total Tracks'),
                  React.createElement('p', {
                    style: {
                      fontSize: '14px',
                      fontWeight: '500',
                      color: '#1f2937',
                      marginTop: '2px'
                    }
                  }, localFilesStats.totalTracks.toLocaleString())
                ),
                React.createElement('div', null,
                  React.createElement('p', {
                    style: {
                      fontSize: '12px',
                      color: '#6b7280'
                    }
                  }, 'Last Scan'),
                  React.createElement('p', {
                    style: {
                      fontSize: '14px',
                      fontWeight: '500',
                      color: '#1f2937',
                      marginTop: '2px'
                    }
                  },
                    localFilesStats.lastScan
                      ? new Date(localFilesStats.lastScan).toLocaleDateString()
                      : 'Never'
                  )
                )
              ),
              React.createElement('button', {
                onClick: handleRescanAll,
                disabled: isScanning || watchFolders.length === 0,
                className: 'mt-4 px-4 py-2 text-sm text-purple-600 hover:bg-purple-50 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed'
              }, 'Rescan All Folders')
            )
          )
        ),

        // Modal footer with action buttons
        React.createElement('div', {
          className: 'flex items-center justify-between',
          style: {
            padding: '16px 24px',
            backgroundColor: 'rgba(0, 0, 0, 0.02)',
            borderTop: '1px solid rgba(0, 0, 0, 0.06)'
          }
        },
          // Left side: Remove button (only for user-installed resolvers)
          React.createElement('div', null,
            // Check if this is a user-installed resolver (not built-in)
            !['spotify', 'bandcamp', 'qobuz', 'musicbrainz'].includes(selectedResolver.id) &&
              React.createElement('button', {
                onClick: async () => {
                  await handleUninstallResolver(selectedResolver.id);
                  setSelectedResolver(null);
                },
                className: 'transition-colors',
                style: {
                  padding: '8px 14px',
                  fontSize: '13px',
                  fontWeight: '500',
                  color: '#dc2626',
                  backgroundColor: 'transparent',
                  border: 'none',
                  borderRadius: '8px',
                  cursor: 'pointer'
                }
              }, 'Remove')
          ),
          // Right side: Update button (if available) and Done
          React.createElement('div', { className: 'flex items-center gap-2' },
            // Update button - show if marketplace has newer version
            (() => {
              const marketplaceResolver = marketplaceManifest?.resolvers?.find(r => r.id === selectedResolver.id);
              const hasUpdate = marketplaceResolver &&
                marketplaceResolver.version !== selectedResolver.version &&
                marketplaceResolver.version > selectedResolver.version;
              if (hasUpdate) {
                return React.createElement('button', {
                  onClick: async () => {
                    await handleInstallFromMarketplace(marketplaceResolver);
                    setSelectedResolver(null);
                  },
                  disabled: installingResolvers.has(selectedResolver.id),
                  className: 'transition-colors',
                  style: {
                    padding: '8px 14px',
                    fontSize: '13px',
                    fontWeight: '500',
                    color: '#ffffff',
                    backgroundColor: installingResolvers.has(selectedResolver.id) ? '#9ca3af' : '#f97316',
                    border: 'none',
                    borderRadius: '8px',
                    cursor: installingResolvers.has(selectedResolver.id) ? 'not-allowed' : 'pointer',
                    opacity: installingResolvers.has(selectedResolver.id) ? 0.6 : 1
                  }
                }, installingResolvers.has(selectedResolver.id) ? 'Updating...' : `Update to v${marketplaceResolver.version}`);
              }
              return null;
            })(),
            React.createElement('button', {
              onClick: () => setSelectedResolver(null),
              className: 'transition-colors',
              style: {
                padding: '8px 16px',
                fontSize: '13px',
                fontWeight: '500',
                color: '#374151',
                backgroundColor: 'rgba(0, 0, 0, 0.04)',
                border: 'none',
                borderRadius: '8px',
                cursor: 'pointer'
              }
            }, 'Done')
          )
        )
      )
    ),

    // Marketplace Item Detail Modal
    selectedMarketplaceItem && React.createElement('div', {
      className: 'fixed inset-0 flex items-center justify-center z-50',
      style: {
        backgroundColor: 'rgba(0, 0, 0, 0.4)',
        backdropFilter: 'blur(4px)'
      },
      onClick: (e) => { if (e.target === e.currentTarget) setSelectedMarketplaceItem(null); }
    },
      React.createElement('div', {
        style: {
          backgroundColor: '#ffffff',
          borderRadius: '16px',
          boxShadow: '0 4px 24px rgba(0, 0, 0, 0.15), 0 12px 48px rgba(0, 0, 0, 0.1)',
          maxWidth: '440px',
          width: '100%',
          margin: '0 16px',
          overflow: 'hidden'
        }
      },
        // Modal header with colored background
        React.createElement('div', {
          className: 'flex items-center gap-4',
          style: {
            padding: '24px',
            backgroundColor: selectedMarketplaceItem.color || '#6B7280'
          }
        },
          // Logo
          React.createElement('div', {
            className: 'flex items-center justify-center',
            style: { width: '56px', height: '56px' }
          }, SERVICE_LOGOS[selectedMarketplaceItem.id] || React.createElement('span', { style: { fontSize: '32px' } }, selectedMarketplaceItem.icon)),
          // Name and version
          React.createElement('div', { className: 'flex-1' },
            React.createElement('div', { className: 'flex items-center gap-2' },
              React.createElement('h2', {
                style: {
                  fontSize: '18px',
                  fontWeight: '600',
                  color: '#ffffff'
                }
              }, selectedMarketplaceItem.name),
              selectedMarketplaceItem.version && React.createElement('span', {
                style: {
                  padding: '2px 8px',
                  backgroundColor: 'rgba(255, 255, 255, 0.2)',
                  borderRadius: '4px',
                  fontSize: '11px',
                  color: '#ffffff'
                }
              }, 'v', selectedMarketplaceItem.version)
            ),
            React.createElement('p', {
              style: {
                fontSize: '13px',
                color: 'rgba(255, 255, 255, 0.8)',
                marginTop: '4px'
              }
            }, selectedMarketplaceItem.author || 'Unknown')
          ),
          // Close button
          React.createElement('button', {
            onClick: () => setSelectedMarketplaceItem(null),
            className: 'flex items-center justify-center transition-colors',
            style: {
              width: '32px',
              height: '32px',
              borderRadius: '50%',
              backgroundColor: 'rgba(255, 255, 255, 0.2)',
              border: 'none',
              color: '#ffffff',
              cursor: 'pointer',
              fontSize: '14px'
            }
          }, 'âœ•')
        ),
        // Modal body
        React.createElement('div', {
          style: { padding: '24px' }
        },
          // Description
          React.createElement('p', {
            style: {
              fontSize: '13px',
              color: '#6b7280',
              lineHeight: '1.6',
              marginBottom: '24px'
            }
          }, selectedMarketplaceItem.description),

          // Capabilities
          selectedMarketplaceItem.capabilities && React.createElement('div', { style: { marginBottom: '24px' } },
            React.createElement('h3', {
              style: {
                fontSize: '11px',
                fontWeight: '600',
                color: '#9ca3af',
                textTransform: 'uppercase',
                letterSpacing: '0.08em',
                marginBottom: '12px'
              }
            }, 'Capabilities'),
            React.createElement('div', { className: 'flex flex-wrap gap-2' },
              Object.entries(selectedMarketplaceItem.capabilities || {}).map(([cap, enabled]) => {
                if (!enabled) return null;
                const capLabels = {
                  resolve: 'Resolve',
                  search: 'Search',
                  stream: 'Stream',
                  browse: 'Browse',
                  urlLookup: 'URL Lookup',
                  recommendations: 'Recommendations',
                  metadata: 'Metadata',
                  generate: 'AI Playlist Generation'
                };
                const label = capLabels[cap] || cap;
                return React.createElement('span', {
                  key: cap,
                  style: {
                    padding: '6px 12px',
                    backgroundColor: 'rgba(124, 58, 237, 0.08)',
                    color: '#7c3aed',
                    borderRadius: '16px',
                    fontSize: '12px',
                    fontWeight: '500'
                  }
                }, label);
              })
            )
          ),

          // Category
          selectedMarketplaceItem.category && React.createElement('div', null,
            React.createElement('h3', { className: 'text-sm font-semibold text-gray-900 mb-2' }, 'Category'),
            React.createElement('span', {
              className: 'px-3 py-1 bg-purple-100 text-purple-700 rounded-full text-xs capitalize'
            }, selectedMarketplaceItem.category)
          ),

          // API Key Configuration (for AI services with generate capability)
          selectedMarketplaceItem.capabilities?.generate && React.createElement('div', {
            className: 'border-t border-gray-100 pt-4'
          },
            React.createElement('h3', { className: 'text-sm font-semibold text-gray-900 mb-3' }, 'Configuration'),
            // API Key input
            React.createElement('div', { className: 'space-y-2' },
              React.createElement('label', { className: 'block text-sm text-gray-600' }, 'API Key'),
              React.createElement('input', {
                type: 'password',
                defaultValue: metaServiceConfigs[selectedMarketplaceItem.id]?.apiKey || '',
                onBlur: (e) => {
                  saveMetaServiceConfig(selectedMarketplaceItem.id, {
                    ...metaServiceConfigs[selectedMarketplaceItem.id],
                    apiKey: e.target.value,
                    enabled: true
                  });
                },
                placeholder: selectedMarketplaceItem.id === 'chatgpt' ? 'sk-...' : 'AIza...',
                className: 'w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent'
              }),
              React.createElement('a', {
                href: '#',
                onClick: (e) => {
                  e.preventDefault();
                  const url = selectedMarketplaceItem.id === 'chatgpt'
                    ? 'https://platform.openai.com/api-keys'
                    : 'https://aistudio.google.com/app/apikey';
                  window.electron?.shell?.openExternal?.(url);
                },
                className: 'text-xs text-purple-600 hover:text-purple-700 inline-block'
              }, 'Get your API key â†’')
            ),
            // Model selector
            React.createElement('div', { className: 'mt-4 space-y-2' },
              React.createElement('label', { className: 'block text-sm text-gray-600' }, 'Model'),
              React.createElement('select', {
                defaultValue: metaServiceConfigs[selectedMarketplaceItem.id]?.model || (selectedMarketplaceItem.id === 'chatgpt' ? 'gpt-4o-mini' : 'gemini-2.5-flash'),
                onChange: (e) => {
                  saveMetaServiceConfig(selectedMarketplaceItem.id, {
                    ...metaServiceConfigs[selectedMarketplaceItem.id],
                    model: e.target.value
                  });
                },
                className: 'w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent bg-white'
              },
                selectedMarketplaceItem.id === 'chatgpt' ? [
                  React.createElement('option', { key: 'gpt-4o-mini', value: 'gpt-4o-mini' }, 'GPT-4o Mini (Recommended)'),
                  React.createElement('option', { key: 'gpt-4o', value: 'gpt-4o' }, 'GPT-4o'),
                  React.createElement('option', { key: 'gpt-3.5-turbo', value: 'gpt-3.5-turbo' }, 'GPT-3.5 Turbo')
                ] : [
                  React.createElement('option', { key: 'gemini-2.5-flash', value: 'gemini-2.5-flash' }, 'Gemini 2.5 Flash (Recommended)'),
                  React.createElement('option', { key: 'gemini-2.5-pro', value: 'gemini-2.5-pro' }, 'Gemini 2.5 Pro')
                ]
              )
            )
          ),

          // Update available notice (only when installed and update exists)
          selectedMarketplaceItem.isInstalled &&
            selectedMarketplaceItem.installedResolver?.version !== selectedMarketplaceItem.version &&
            React.createElement('div', {
              className: 'flex items-center gap-2',
              style: {
                padding: '12px 0',
                borderTop: '1px solid rgba(0, 0, 0, 0.06)',
                fontSize: '12px',
                color: '#f97316'
              }
            },
              React.createElement('span', null, 'â¬†'),
              React.createElement('span', null, `Update available: v${selectedMarketplaceItem.version}`)
            )
        ),
        // Modal footer with action buttons
        React.createElement('div', {
          className: 'flex items-center justify-between',
          style: {
            padding: '16px 24px',
            backgroundColor: 'rgba(0, 0, 0, 0.02)',
            borderTop: '1px solid rgba(0, 0, 0, 0.06)'
          }
        },
          selectedMarketplaceItem.isInstalled
            ? React.createElement(React.Fragment, null,
                // Remove button on the left (disabled for built-in)
                React.createElement('button', {
                  onClick: async () => {
                    await handleUninstallResolver(selectedMarketplaceItem.id);
                    setSelectedMarketplaceItem(null);
                  },
                  disabled: ['spotify', 'bandcamp', 'qobuz', 'youtube', 'localfiles', 'applemusic', 'chatgpt', 'gemini'].includes(selectedMarketplaceItem.id),
                  className: 'transition-colors',
                  style: {
                    padding: '8px 14px',
                    fontSize: '13px',
                    fontWeight: '500',
                    color: '#dc2626',
                    backgroundColor: 'transparent',
                    border: 'none',
                    borderRadius: '8px',
                    cursor: ['spotify', 'bandcamp', 'qobuz', 'youtube', 'localfiles', 'applemusic', 'chatgpt', 'gemini'].includes(selectedMarketplaceItem.id) ? 'not-allowed' : 'pointer',
                    opacity: ['spotify', 'bandcamp', 'qobuz', 'youtube', 'localfiles', 'applemusic', 'chatgpt', 'gemini'].includes(selectedMarketplaceItem.id) ? 0.5 : 1
                  },
                  title: ['spotify', 'bandcamp', 'qobuz', 'youtube', 'localfiles', 'applemusic', 'chatgpt', 'gemini'].includes(selectedMarketplaceItem.id)
                    ? 'Built-in plug-ins cannot be removed'
                    : 'Remove this plug-in'
                }, 'Remove'),
                // Right side buttons
                React.createElement('div', { className: 'flex items-center gap-2' },
                  // Update button if newer version available
                  selectedMarketplaceItem.installedResolver?.version !== selectedMarketplaceItem.version &&
                    React.createElement('button', {
                      onClick: async () => {
                        await handleInstallFromMarketplace(selectedMarketplaceItem);
                        setSelectedMarketplaceItem(null);
                      },
                      disabled: installingResolvers.has(selectedMarketplaceItem.id),
                      className: 'transition-colors',
                      style: {
                        padding: '8px 14px',
                        fontSize: '13px',
                        fontWeight: '500',
                        color: '#ffffff',
                        backgroundColor: installingResolvers.has(selectedMarketplaceItem.id) ? '#9ca3af' : '#f97316',
                        border: 'none',
                        borderRadius: '8px',
                        cursor: installingResolvers.has(selectedMarketplaceItem.id) ? 'not-allowed' : 'pointer',
                        opacity: installingResolvers.has(selectedMarketplaceItem.id) ? 0.6 : 1
                      }
                    }, installingResolvers.has(selectedMarketplaceItem.id) ? 'Updating...' : 'Update'),
                  // Done button
                  React.createElement('button', {
                    onClick: () => setSelectedMarketplaceItem(null),
                    className: 'transition-colors',
                    style: {
                      padding: '8px 16px',
                      fontSize: '13px',
                      fontWeight: '500',
                      color: '#374151',
                      backgroundColor: 'rgba(0, 0, 0, 0.04)',
                      border: 'none',
                      borderRadius: '8px',
                      cursor: 'pointer'
                    }
                  }, 'Done')
                )
              )
            : React.createElement(React.Fragment, null,
                // Empty left side for non-installed
                React.createElement('div', null),
                // Right side with Install and Done buttons
                React.createElement('div', { className: 'flex items-center gap-2' },
                  React.createElement('button', {
                    onClick: async () => {
                      await handleInstallFromMarketplace(selectedMarketplaceItem);
                      setSelectedMarketplaceItem(null);
                    },
                    disabled: installingResolvers.has(selectedMarketplaceItem.id),
                    className: 'transition-colors',
                    style: {
                      padding: '8px 14px',
                      fontSize: '13px',
                      fontWeight: '500',
                      color: '#ffffff',
                      backgroundColor: installingResolvers.has(selectedMarketplaceItem.id) ? '#9ca3af' : '#7c3aed',
                      border: 'none',
                      borderRadius: '8px',
                      cursor: installingResolvers.has(selectedMarketplaceItem.id) ? 'not-allowed' : 'pointer',
                      opacity: installingResolvers.has(selectedMarketplaceItem.id) ? 0.6 : 1
                    }
                  }, installingResolvers.has(selectedMarketplaceItem.id) ? 'Installing...' : 'Install'),
                  React.createElement('button', {
                    onClick: () => setSelectedMarketplaceItem(null),
                    className: 'transition-colors',
                    style: {
                      padding: '8px 16px',
                      fontSize: '13px',
                      fontWeight: '500',
                      color: '#374151',
                      backgroundColor: 'rgba(0, 0, 0, 0.04)',
                      border: 'none',
                      borderRadius: '8px',
                      cursor: 'pointer'
                    }
                  }, 'Done')
                )
              )
        )
      )
    ),

    // Add to Playlist Slide-out Panel - refined styling
    addToPlaylistPanel.open && React.createElement('div', {
      className: 'fixed inset-0 z-50',
      style: { pointerEvents: 'none' }
    },
      // Backdrop (only covers area outside sidebar)
      React.createElement('div', {
        className: 'absolute inset-0 transition-opacity',
        style: {
          left: '256px',
          pointerEvents: 'auto',
          backgroundColor: 'rgba(0, 0, 0, 0.4)'
        },
        onClick: () => {
          setAddToPlaylistPanel(prev => ({ ...prev, open: false }));
          setSelectedPlaylistsForAdd([]);
          setNewPlaylistFormOpen(false);
          setNewPlaylistName('');
          setAddToPlaylistSearch('');
          setAddToPlaylistSearchOpen(false);
        },
        onDragOver: (e) => {
          e.preventDefault();
        },
        onDrop: (e) => {
          e.preventDefault();
        }
      }),

      // Panel - positioned at right edge of sidebar, full height above playbar
      React.createElement('div', {
        className: 'absolute flex flex-col',
        style: {
          left: '256px',
          top: '0',
          bottom: '85px',
          width: '384px',
          pointerEvents: 'auto',
          backgroundColor: '#ffffff',
          borderRadius: '0 16px 16px 0',
          boxShadow: '0 25px 50px -12px rgba(0, 0, 0, 0.25)',
          overflow: 'hidden'
        },
        onDragOver: (e) => {
          // Allow drag events to pass through to children
          e.preventDefault();
        },
        onDrop: (e) => {
          e.preventDefault();
        }
      },
        // Header with title - matches Playlists view header gradient
        React.createElement('div', {
          style: {
            padding: '20px 24px',
            background: 'linear-gradient(135deg, #f43f5e 0%, #ec4899 50%, #c026d3 100%)',
            borderBottom: '1px solid rgba(0, 0, 0, 0.1)'
          }
        },
          React.createElement('div', {
            className: 'flex items-center gap-3'
          },
            React.createElement('div', {
              style: {
                width: '32px',
                height: '32px',
                borderRadius: '8px',
                backgroundColor: 'rgba(255, 255, 255, 0.2)',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center'
              }
            },
              React.createElement('svg', {
                width: 18,
                height: 18,
                viewBox: '0 0 24 24',
                fill: 'none',
                stroke: '#ffffff',
                strokeWidth: 2,
                strokeLinecap: 'round',
                strokeLinejoin: 'round'
              },
                React.createElement('path', { d: 'M11 12H3' }),
                React.createElement('path', { d: 'M16 6H3' }),
                React.createElement('path', { d: 'M16 18H3' }),
                React.createElement('path', { d: 'M18 9v6' }),
                React.createElement('path', { d: 'M21 12h-6' })
              )
            ),
            React.createElement('span', {
              style: {
                fontSize: '16px',
                fontWeight: '600',
                color: '#ffffff'
              }
            }, 'Add to Playlist')
          )
        ),

        // Track info section with DONE button - refined
        React.createElement('div', {
          style: {
            padding: '16px 20px',
            backgroundColor: 'rgba(0, 0, 0, 0.02)',
            borderBottom: '1px solid rgba(0, 0, 0, 0.06)'
          }
        },
          React.createElement('div', {
            className: 'flex items-center gap-3'
          },
            // Album art thumbnail - refined with dark placeholder
            React.createElement('div', {
              className: 'flex-shrink-0 flex items-center justify-center overflow-hidden relative',
              style: {
                width: '48px',
                height: '48px',
                borderRadius: '8px',
                background: 'linear-gradient(145deg, #1f1f1f 0%, #2d2d2d 50%, #1a1a1a 100%)'
              }
            },
              // Placeholder always rendered behind
              React.createElement(Music, { size: 20, style: { color: '#4b5563' } }),
              addToPlaylistPanel.tracks[0]?.albumArt && React.createElement('img', {
                src: addToPlaylistPanel.tracks[0].albumArt,
                className: 'absolute inset-0 w-full h-full object-cover',
                style: { borderRadius: '8px' },
                onError: (e) => { e.target.style.display = 'none'; }
              })
            ),
            // Track/source info
            React.createElement('div', {
              className: 'flex-1 min-w-0'
            },
              React.createElement('p', {
                className: 'truncate',
                style: {
                  fontSize: '13px',
                  fontWeight: '500',
                  color: '#1f2937'
                }
              }, addToPlaylistPanel.sourceName),
              React.createElement('p', {
                style: {
                  fontSize: '12px',
                  color: '#6b7280',
                  marginTop: '2px'
                }
              }, addToPlaylistPanel.tracks[0]?.artist || `${addToPlaylistPanel.tracks.length} tracks`)
            ),
            // DONE button - executes additions for all selected playlists
            React.createElement('button', {
              onClick: () => {
                // Add tracks to all selected playlists
                if (selectedPlaylistsForAdd.length > 0) {
                  const tracksToAdd = addToPlaylistPanel.tracks.map(t => ({
                    title: t.title,
                    artist: t.artist,
                    album: t.album,
                    duration: t.duration,
                    id: t.id || `${t.artist}-${t.title}`.toLowerCase().replace(/[^a-z0-9-]/g, '')
                  }));

                  setPlaylists(prev => prev.map(p => {
                    if (selectedPlaylistsForAdd.includes(p.id)) {
                      const updatedPlaylist = {
                        ...p,
                        tracks: [...(p.tracks || []), ...tracksToAdd],
                        lastModified: Date.now()
                      };
                      // Save each updated playlist to disk
                      savePlaylistToStore(updatedPlaylist);
                      return updatedPlaylist;
                    }
                    return p;
                  }));

                  // Mark synced playlists as locally modified
                  selectedPlaylistsForAdd.forEach(id => markPlaylistAsLocallyModified(id));

                  // Show sidebar badge with total tracks added
                  showSidebarBadge('playlists', tracksToAdd.length * selectedPlaylistsForAdd.length);
                }

                // Close panel and reset state
                setAddToPlaylistPanel(prev => ({ ...prev, open: false }));
                setSelectedPlaylistsForAdd([]);
                setNewPlaylistFormOpen(false);
                setNewPlaylistName('');
                setAddToPlaylistSearch('');
                setAddToPlaylistSearchOpen(false);
              },
              className: 'transition-colors',
              style: {
                padding: '8px 14px',
                fontSize: '13px',
                fontWeight: '500',
                color: '#ffffff',
                backgroundColor: selectedPlaylistsForAdd.length > 0 ? '#7c3aed' : 'rgba(0, 0, 0, 0.04)',
                border: 'none',
                borderRadius: '8px',
                cursor: 'pointer'
              }
            }, selectedPlaylistsForAdd.length > 0
              ? `Add to ${selectedPlaylistsForAdd.length} Playlist${selectedPlaylistsForAdd.length > 1 ? 's' : ''}`
              : 'Done')
          )
        ),

        // Filter bar (sticky) - sort dropdown and search
        React.createElement('div', {
          className: 'flex items-center px-5 py-2 bg-white',
          style: { flexShrink: 0, borderBottom: '1px solid rgba(0, 0, 0, 0.06)' }
        },
          // Sort dropdown
          React.createElement('div', { className: 'relative' },
            React.createElement('button', {
              onClick: (e) => { e.stopPropagation(); setAddToPlaylistSortDropdownOpen(!addToPlaylistSortDropdownOpen); },
              className: 'flex items-center gap-1 px-2 py-1 text-xs text-gray-500 hover:text-gray-700 transition-colors'
            },
              React.createElement('span', null, playlistsSortOptions.find(o => o.value === addToPlaylistSort)?.label || 'Sort'),
              React.createElement('svg', { className: 'w-3 h-3', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M19 9l-7 7-7-7' })
              )
            ),
            addToPlaylistSortDropdownOpen && React.createElement('div', {
              className: 'absolute left-0 top-full mt-1 bg-white py-1 min-w-[140px] z-30',
              style: { borderRadius: '8px', boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)', border: '1px solid rgba(0, 0, 0, 0.1)' }
            },
              playlistsSortOptions.map(option =>
                React.createElement('button', {
                  key: option.value,
                  onClick: (e) => {
                    e.stopPropagation();
                    setAddToPlaylistSort(option.value);
                    setAddToPlaylistSortDropdownOpen(false);
                  },
                  className: `w-full px-3 py-1.5 text-left text-xs hover:bg-gray-100 flex items-center justify-between ${
                    addToPlaylistSort === option.value ? 'text-gray-900 font-medium' : 'text-gray-600'
                  }`
                },
                  option.label,
                  addToPlaylistSort === option.value && React.createElement('svg', {
                    className: 'w-3 h-3',
                    fill: 'none',
                    viewBox: '0 0 24 24',
                    stroke: 'currentColor'
                  },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M5 13l4 4L19 7' })
                  )
                )
              )
            )
          ),
          React.createElement('div', { className: 'flex-1' }),
          // Search
          React.createElement('div', { className: 'flex items-center' },
            addToPlaylistSearchOpen ?
              React.createElement('div', { className: 'flex items-center px-2 py-1', style: { border: '1px solid rgba(0, 0, 0, 0.1)', borderRadius: '8px' } },
                React.createElement('input', {
                  type: 'text',
                  value: addToPlaylistSearch,
                  onChange: (e) => setAddToPlaylistSearch(e.target.value),
                  onBlur: () => { if (!addToPlaylistSearch.trim()) setAddToPlaylistSearchOpen(false); },
                  autoFocus: true,
                  placeholder: 'Filter...',
                  className: 'bg-transparent text-gray-700 text-xs placeholder-gray-400 outline-none',
                  style: { width: '120px' }
                }),
                addToPlaylistSearch && React.createElement('button', {
                  onClick: () => { setAddToPlaylistSearch(''); setAddToPlaylistSearchOpen(false); },
                  className: 'ml-1 text-gray-400 hover:text-gray-600'
                },
                  React.createElement('svg', { className: 'w-3 h-3', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                    React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M6 18L18 6M6 6l12 12' })
                  )
                )
              )
            :
              React.createElement('button', {
                onClick: () => setAddToPlaylistSearchOpen(true),
                className: 'p-1 text-gray-400 hover:text-gray-600 transition-colors'
              },
                React.createElement('svg', { className: 'w-4 h-4', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
                  React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' })
                )
              )
          )
        ),

        // Playlist list (scrollable) - includes New Playlist row at top
        React.createElement('div', {
          className: 'flex-1 overflow-y-auto min-h-0'
        },
          // New Playlist row (always shown at top)
          // TODO: Fix drag-and-drop to create new playlist - onDrop events not firing in Electron
          // The visual highlight works (onDragEnter/onDragLeave) but onDrop never fires.
          // Attempted: dataTransfer fallback, mouseUp fallback, pointerEvents:none on children.
          // For now, users must click "New Playlist" row to open form, then drag to existing playlists works.
          React.createElement('div', {
            key: 'new-playlist-row',
            onClick: () => {
              if (!newPlaylistFormOpen) {
                setNewPlaylistFormOpen(true);
                setNewPlaylistName('');
                setDroppedTrackForNewPlaylist(null);
              }
            },
            onMouseUp: () => {
              // Fallback for drop - if we're hovering while a track is being dragged
              if (dropTargetNewPlaylist && draggingTrackForPlaylist) {
                console.log('ðŸ–±ï¸ MouseUp on New Playlist row while dragging:', draggingTrackForPlaylist.title);
                setDroppedTrackForNewPlaylist(draggingTrackForPlaylist);
                setNewPlaylistFormOpen(true);
                setNewPlaylistName('');
                setDropTargetNewPlaylist(false);
              }
            },
            onDragEnter: (e) => {
              e.preventDefault();
              e.stopPropagation();
              if (draggingTrackForPlaylist) {
                setDropTargetNewPlaylist(true);
              }
            },
            onDragOver: (e) => {
              e.preventDefault();
              e.stopPropagation();
              e.dataTransfer.dropEffect = 'copy';
            },
            onDragLeave: (e) => {
              e.preventDefault();
              e.stopPropagation();
              if (!e.currentTarget.contains(e.relatedTarget)) {
                setDropTargetNewPlaylist(false);
              }
            },
            onDrop: (e) => {
              e.preventDefault();
              e.stopPropagation();
              console.log('ðŸŽ¯ Drop on New Playlist row');

              // Try to get track from state or dataTransfer
              let trackToUse = draggingTrackForPlaylist;
              if (!trackToUse) {
                try {
                  const data = JSON.parse(e.dataTransfer.getData('text/plain'));
                  if (data.type === 'track' && data.track) {
                    trackToUse = data.track;
                  }
                } catch (err) {
                  // ignore
                }
              }

              if (trackToUse) {
                setDroppedTrackForNewPlaylist(trackToUse);
                setNewPlaylistFormOpen(true);
                setNewPlaylistName('');
                setDropTargetNewPlaylist(false);
              }
            },
            className: `flex items-center gap-3 px-5 py-2.5 cursor-pointer transition-all border-b border-gray-100 ${
              dropTargetNewPlaylist
                ? 'bg-purple-100 border-l-4 border-l-purple-500 pl-4'
                : newPlaylistFormOpen
                  ? 'bg-gray-100'
                  : 'hover:bg-gray-50'
            }`
          },
            // Plus icon in square (like playlist thumbnail)
            React.createElement('div', {
              className: 'w-10 h-10 rounded bg-gray-200 flex-shrink-0 flex items-center justify-center',
              style: { pointerEvents: 'none' } // Let parent handle all events
            },
              React.createElement('span', { className: 'text-gray-500 text-xl font-light' }, '+')
            ),
            // "New Playlist" text or input form
            newPlaylistFormOpen ?
              React.createElement('div', {
                className: 'flex-1 flex gap-2',
                onClick: (e) => e.stopPropagation(), // Prevent row click when interacting with form
                style: { pointerEvents: 'auto' } // Allow form interaction
              },
                React.createElement('input', {
                  type: 'text',
                  value: newPlaylistName,
                  onChange: (e) => setNewPlaylistName(e.target.value),
                  onKeyDown: (e) => {
                    if (e.key === 'Enter' && newPlaylistName.trim()) {
                      // Create new playlist with the tracks
                      const playlistId = newPlaylistName.trim().toLowerCase().replace(/[^a-z0-9]/g, '-') + '-' + Date.now();
                      // Use dropped track if available, otherwise use panel tracks
                      const sourceTracks = droppedTrackForNewPlaylist ? [droppedTrackForNewPlaylist] : addToPlaylistPanel.tracks;
                      const tracksToAdd = sourceTracks.map(t => ({
                        title: t.title,
                        artist: t.artist,
                        album: t.album,
                        duration: t.duration,
                        id: t.id || `${t.artist}-${t.title}`.toLowerCase().replace(/[^a-z0-9-]/g, '')
                      }));
                      const newPlaylist = {
                        id: playlistId,
                        filename: `${playlistId}.xspf`,
                        title: newPlaylistName.trim(),
                        creator: 'Me',
                        tracks: tracksToAdd,
                        createdAt: Date.now(),
                        addedAt: Date.now(),
                        lastModified: Date.now()
                      };
                      setPlaylists(prev => [newPlaylist, ...prev]);
                      fetchPlaylistCovers(playlistId, newPlaylist.tracks);
                      setSelectedPlaylistsForAdd(prev => [...prev, playlistId]);
                      savePlaylistToStore(newPlaylist); // Save to disk
                      showSidebarBadge('playlists', tracksToAdd.length);
                      setNewPlaylistFormOpen(false);
                      setNewPlaylistName('');
                      setDroppedTrackForNewPlaylist(null); // Clear dropped track
                    } else if (e.key === 'Escape') {
                      setNewPlaylistFormOpen(false);
                      setNewPlaylistName('');
                      setDroppedTrackForNewPlaylist(null); // Clear dropped track
                    }
                  },
                  placeholder: 'Playlist name...',
                  autoFocus: true,
                  className: 'flex-1 px-3 py-1.5 text-sm border border-gray-300 rounded focus:outline-none focus:border-purple-500 focus:ring-1 focus:ring-purple-500'
                }),
                React.createElement('button', {
                  onClick: () => {
                    if (!newPlaylistName.trim()) return;
                    // Create new playlist with the tracks
                    const playlistId = newPlaylistName.trim().toLowerCase().replace(/[^a-z0-9]/g, '-') + '-' + Date.now();
                    // Use dropped track if available, otherwise use panel tracks
                    const sourceTracks = droppedTrackForNewPlaylist ? [droppedTrackForNewPlaylist] : addToPlaylistPanel.tracks;
                    const tracksToAdd = sourceTracks.map(t => ({
                      title: t.title,
                      artist: t.artist,
                      album: t.album,
                      duration: t.duration,
                      id: t.id || `${t.artist}-${t.title}`.toLowerCase().replace(/[^a-z0-9-]/g, '')
                    }));
                    const newPlaylist = {
                      id: playlistId,
                      filename: `${playlistId}.xspf`,
                      title: newPlaylistName.trim(),
                      creator: 'Me',
                      tracks: tracksToAdd,
                      createdAt: Date.now(),
                      addedAt: Date.now(),
                      lastModified: Date.now()
                    };
                    setPlaylists(prev => [newPlaylist, ...prev]);
                    fetchPlaylistCovers(playlistId, newPlaylist.tracks);
                    setSelectedPlaylistsForAdd(prev => [...prev, playlistId]);
                    savePlaylistToStore(newPlaylist); // Save to disk
                    showSidebarBadge('playlists', tracksToAdd.length);
                    setNewPlaylistFormOpen(false);
                    setNewPlaylistName('');
                    setDroppedTrackForNewPlaylist(null); // Clear dropped track
                  },
                  disabled: !newPlaylistName.trim(),
                  className: `px-3 py-1.5 text-sm font-medium rounded transition-colors ${
                    newPlaylistName.trim()
                      ? 'bg-green-500 hover:bg-green-600 text-white'
                      : 'bg-gray-200 text-gray-400 cursor-not-allowed'
                  }`
                }, 'Create')
              )
            :
              React.createElement('span', {
                className: 'flex-1 text-sm text-gray-600',
                style: { pointerEvents: 'none' } // Let parent handle all events
              }, 'New Playlist')
          ),

          // Existing playlists (filtered and sorted)
          (() => {
            // Filter playlists by search
            let filteredPlaylists = playlists;
            if (addToPlaylistSearch.trim()) {
              const query = addToPlaylistSearch.toLowerCase();
              filteredPlaylists = playlists.filter(p => p.title.toLowerCase().includes(query));
            }
            // Sort playlists
            const sortedPlaylists = [...filteredPlaylists];
            switch (addToPlaylistSort) {
              case 'added':
                sortedPlaylists.sort((a, b) => {
                  const aTime = Number(a.addedAt) || Number(a.lastModified) || Number(a.createdAt) || 0;
                  const bTime = Number(b.addedAt) || Number(b.lastModified) || Number(b.createdAt) || 0;
                  return bTime - aTime;
                });
                break;
              case 'created':
                sortedPlaylists.sort((a, b) => (Number(b.createdAt) || 0) - (Number(a.createdAt) || 0));
                break;
              case 'modified':
                sortedPlaylists.sort((a, b) => (Number(b.lastModified) || 0) - (Number(a.lastModified) || 0));
                break;
              case 'alpha-asc':
                sortedPlaylists.sort((a, b) => (a.title || '').localeCompare(b.title || ''));
                break;
              case 'alpha-desc':
                sortedPlaylists.sort((a, b) => (b.title || '').localeCompare(a.title || ''));
                break;
            }

            if (sortedPlaylists.length === 0) {
              return React.createElement('div', {
                className: 'px-5 py-8 text-center text-gray-400 text-sm'
              }, addToPlaylistSearch ? 'No matching playlists' : 'No playlists yet');
            }

            return sortedPlaylists.map(playlist => {
              const isAdded = selectedPlaylistsForAdd.includes(playlist.id);
              const isDropTarget = dropTargetPlaylistId === playlist.id;

              // Helper to add tracks to this playlist
              const addTracksToPlaylistHelper = (tracks) => {
                if (isAdded || !tracks || tracks.length === 0) return;

                // Add tracks to this playlist immediately
                const tracksToAdd = tracks.map(t => ({
                  title: t.title,
                  artist: t.artist,
                  album: t.album,
                  duration: t.duration,
                  id: t.id || `${t.artist}-${t.title}`.toLowerCase().replace(/[^a-z0-9-]/g, '')
                }));

                // Build updated playlist for saving
                const updatedPlaylist = {
                  ...playlist,
                  tracks: [...(playlist.tracks || []), ...tracksToAdd],
                  lastModified: Date.now()
                };

                setPlaylists(prev => prev.map(p => {
                  if (p.id === playlist.id) {
                    return updatedPlaylist;
                  }
                  return p;
                }));

                // Save to disk
                savePlaylistToStore(updatedPlaylist);

                // Mark synced playlist as locally modified
                markPlaylistAsLocallyModified(playlist.id);

                // Mark as added
                setSelectedPlaylistsForAdd(prev => [...prev, playlist.id]);

                // Show sidebar badge
                showSidebarBadge('playlists', tracks.length);
              };

              return React.createElement('div', {
                key: playlist.id,
                onClick: () => {
                  // Toggle selection instead of immediately adding
                  setSelectedPlaylistsForAdd(prev =>
                    prev.includes(playlist.id)
                      ? prev.filter(id => id !== playlist.id)
                      : [...prev, playlist.id]
                  );
                },
                onDragEnter: (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  if (!isAdded) {
                    setDropTargetPlaylistId(playlist.id);
                  }
                },
                onDragOver: (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  e.dataTransfer.dropEffect = 'copy';
                  if (!isAdded && dropTargetPlaylistId !== playlist.id) {
                    setDropTargetPlaylistId(playlist.id);
                  }
                },
                onDragLeave: (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  // Only clear if we're actually leaving this element
                  if (!e.currentTarget.contains(e.relatedTarget)) {
                    setDropTargetPlaylistId(null);
                  }
                },
                onDrop: (e) => {
                  e.preventDefault();
                  e.stopPropagation();

                  // Try to get track from state first, then dataTransfer as fallback
                  let trackFromDrag = draggingTrackForPlaylist;
                  if (!trackFromDrag) {
                    try {
                      const data = JSON.parse(e.dataTransfer.getData('text/plain'));
                      if (data.type === 'track' && data.track) {
                        trackFromDrag = data.track;
                      }
                    } catch (err) {
                      // ignore parse errors
                    }
                  }

                  const tracksToUse = trackFromDrag
                    ? [trackFromDrag]
                    : addToPlaylistPanel.tracks;
                  addTracksToPlaylistHelper(tracksToUse);
                  // Clear the dragging state
                  setDraggingTrackForPlaylist(null);
                  setDropTargetPlaylistId(null);
                },
                className: `flex items-center gap-3 px-5 py-2.5 cursor-pointer transition-all border-b border-gray-100 ${
                  isAdded
                    ? 'bg-green-50'
                    : isDropTarget
                      ? 'bg-purple-100 border-l-4 border-l-purple-500 pl-4'
                      : 'hover:bg-gray-50'
                }`
              },
                // Playlist thumbnail (gray square)
                React.createElement('div', {
                  className: 'w-10 h-10 rounded bg-gray-200 flex-shrink-0 flex items-center justify-center overflow-hidden'
                },
                  // Could show playlist cover here if available
                  allPlaylistCovers[playlist.id]?.[0] ?
                    React.createElement('img', {
                      src: allPlaylistCovers[playlist.id][0],
                      className: 'w-full h-full object-cover'
                    })
                  :
                    React.createElement(Music, { size: 16, className: 'text-gray-400' })
                ),
                // Playlist name
                React.createElement('span', {
                  className: 'flex-1 text-sm text-gray-900 truncate'
                }, playlist.title),
                // Song count - shows updated count from playlists state
                React.createElement('span', {
                  className: `text-sm flex-shrink-0 ${isAdded ? 'text-green-600 font-medium' : 'text-gray-400'}`
                }, `${playlist.tracks?.length || 0} songs`),
                // Checkmark if added
                isAdded && React.createElement('svg', {
                  className: 'w-5 h-5 text-green-500 flex-shrink-0',
                  fill: 'none',
                  viewBox: '0 0 24 24',
                  stroke: 'currentColor'
                },
                  React.createElement('path', {
                    strokeLinecap: 'round',
                    strokeLinejoin: 'round',
                    strokeWidth: 2,
                    d: 'M5 13l4 4L19 7'
                  })
                )
              );
            });
          })()
        )
      )
    ),

    // ID3 Tag Editor Modal
    id3EditorOpen && React.createElement('div', {
      className: 'fixed inset-0 flex items-center justify-center z-[60]',
      style: {
        backgroundColor: 'rgba(0, 0, 0, 0.4)',
        backdropFilter: 'blur(4px)'
      },
      onClick: (e) => {
        if (e.target === e.currentTarget && !id3EditorSaving) {
          setId3EditorOpen(false);
          setId3EditorTrack(null);
        }
      }
    },
      React.createElement('div', {
        style: {
          backgroundColor: '#ffffff',
          borderRadius: '16px',
          boxShadow: '0 4px 24px rgba(0, 0, 0, 0.15), 0 12px 48px rgba(0, 0, 0, 0.1)',
          maxWidth: '440px',
          width: '100%',
          margin: '0 16px',
          overflow: 'hidden'
        },
        onClick: (e) => e.stopPropagation()
      },
        // Header - refined with purple gradient
        React.createElement('div', {
          style: {
            padding: '20px 24px',
            background: 'linear-gradient(135deg, #7c3aed 0%, #6366f1 100%)'
          }
        },
          React.createElement('h2', {
            style: {
              fontSize: '16px',
              fontWeight: '600',
              color: '#ffffff'
            }
          }, 'Edit ID3 Tags'),
          React.createElement('p', {
            className: 'truncate',
            style: {
              fontSize: '13px',
              color: 'rgba(255, 255, 255, 0.8)',
              marginTop: '4px'
            }
          },
            id3EditorTrack?.filePath?.split('/').pop() || 'Unknown file'
          )
        ),
        // Body - refined styling
        React.createElement('div', {
          className: 'scrollable-content',
          style: {
            padding: '24px',
            maxHeight: '60vh',
            overflowY: 'auto'
          }
        },
          // Title field
          React.createElement('div', { style: { marginBottom: '16px' } },
            React.createElement('label', {
              style: {
                display: 'block',
                fontSize: '12px',
                fontWeight: '500',
                color: '#374151',
                marginBottom: '6px'
              }
            }, 'Title'),
            React.createElement('input', {
              type: 'text',
              value: id3EditorValues.title,
              onChange: (e) => setId3EditorValues(v => ({ ...v, title: e.target.value })),
              placeholder: 'Track title',
              style: {
                width: '100%',
                padding: '10px 12px',
                fontSize: '13px',
                color: '#1f2937',
                backgroundColor: '#ffffff',
                border: '1px solid rgba(0, 0, 0, 0.1)',
                borderRadius: '8px',
                outline: 'none'
              }
            })
          ),
          // Artist field
          React.createElement('div', { style: { marginBottom: '16px' } },
            React.createElement('label', {
              style: {
                display: 'block',
                fontSize: '12px',
                fontWeight: '500',
                color: '#374151',
                marginBottom: '6px'
              }
            }, 'Artist'),
            React.createElement('input', {
              type: 'text',
              value: id3EditorValues.artist,
              onChange: (e) => setId3EditorValues(v => ({ ...v, artist: e.target.value })),
              placeholder: 'Artist name',
              style: {
                width: '100%',
                padding: '10px 12px',
                fontSize: '13px',
                color: '#1f2937',
                backgroundColor: '#ffffff',
                border: '1px solid rgba(0, 0, 0, 0.1)',
                borderRadius: '8px',
                outline: 'none'
              }
            })
          ),
          // Album field
          React.createElement('div', { style: { marginBottom: '16px' } },
            React.createElement('label', {
              style: {
                display: 'block',
                fontSize: '12px',
                fontWeight: '500',
                color: '#374151',
                marginBottom: '6px'
              }
            }, 'Album'),
            React.createElement('input', {
              type: 'text',
              value: id3EditorValues.album,
              onChange: (e) => setId3EditorValues(v => ({ ...v, album: e.target.value })),
              placeholder: 'Album name',
              style: {
                width: '100%',
                padding: '10px 12px',
                fontSize: '13px',
                color: '#1f2937',
                backgroundColor: '#ffffff',
                border: '1px solid rgba(0, 0, 0, 0.1)',
                borderRadius: '8px',
                outline: 'none'
              }
            })
          ),
          // Track Number and Year row
          React.createElement('div', { className: 'flex gap-4', style: { marginBottom: '20px' } },
            // Track Number field
            React.createElement('div', { className: 'flex-1' },
              React.createElement('label', {
                style: {
                  display: 'block',
                  fontSize: '12px',
                  fontWeight: '500',
                  color: '#374151',
                  marginBottom: '6px'
                }
              }, 'Track #'),
              React.createElement('input', {
                type: 'text',
                value: id3EditorValues.trackNumber,
                onChange: (e) => setId3EditorValues(v => ({ ...v, trackNumber: e.target.value })),
                placeholder: '1',
                style: {
                  width: '100%',
                  padding: '10px 12px',
                  fontSize: '13px',
                  color: '#1f2937',
                  backgroundColor: '#ffffff',
                  border: '1px solid rgba(0, 0, 0, 0.1)',
                  borderRadius: '8px',
                  outline: 'none'
                }
              })
            ),
            // Year field
            React.createElement('div', { className: 'flex-1' },
              React.createElement('label', {
                style: {
                  display: 'block',
                  fontSize: '12px',
                  fontWeight: '500',
                  color: '#374151',
                  marginBottom: '6px'
                }
              }, 'Year'),
              React.createElement('input', {
                type: 'text',
                value: id3EditorValues.year,
                onChange: (e) => setId3EditorValues(v => ({ ...v, year: e.target.value })),
                placeholder: '2024',
                style: {
                  width: '100%',
                  padding: '10px 12px',
                  fontSize: '13px',
                  color: '#1f2937',
                  backgroundColor: '#ffffff',
                  border: '1px solid rgba(0, 0, 0, 0.1)',
                  borderRadius: '8px',
                  outline: 'none'
                }
              })
            )
          ),

          // Album Art section
          React.createElement('div', {
            style: {
              paddingTop: '20px',
              borderTop: '1px solid rgba(0, 0, 0, 0.06)'
            }
          },
            React.createElement('div', { className: 'flex items-center justify-between', style: { marginBottom: '12px' } },
              React.createElement('label', {
                style: {
                  fontSize: '12px',
                  fontWeight: '500',
                  color: '#374151'
                }
              }, 'Album Art'),
              id3ArtLoading && React.createElement('span', {
                className: 'flex items-center gap-1',
                style: {
                  fontSize: '12px',
                  color: '#7c3aed'
                }
              },
                React.createElement('span', { className: 'animate-spin' }, 'âŸ³'),
                'Searching...'
              )
            ),

            // Current selection - refined
            id3SelectedArt && React.createElement('div', {
              className: 'flex items-center gap-3',
              style: {
                marginBottom: '12px',
                padding: '12px',
                backgroundColor: 'rgba(34, 197, 94, 0.08)',
                border: '1px solid rgba(34, 197, 94, 0.2)',
                borderRadius: '10px'
              }
            },
              React.createElement('img', {
                src: id3SelectedArt.thumbnailUrl,
                alt: 'Selected album art',
                style: {
                  width: '56px',
                  height: '56px',
                  borderRadius: '8px',
                  objectFit: 'cover'
                }
              }),
              React.createElement('div', { className: 'flex-1 min-w-0' },
                React.createElement('div', {
                  className: 'truncate',
                  style: {
                    fontSize: '13px',
                    fontWeight: '500',
                    color: '#166534'
                  }
                }, id3SelectedArt.releaseName),
                React.createElement('div', {
                  className: 'truncate',
                  style: {
                    fontSize: '12px',
                    color: '#22c55e',
                    marginTop: '2px'
                  }
                }, id3SelectedArt.artistName),
                id3SelectedArt.year && React.createElement('div', {
                  style: {
                    fontSize: '12px',
                    color: '#22c55e'
                  }
                }, id3SelectedArt.year)
              ),
              React.createElement('button', {
                onClick: () => setId3SelectedArt(null),
                style: {
                  padding: '4px',
                  color: '#22c55e',
                  backgroundColor: 'transparent',
                  border: 'none',
                  cursor: 'pointer'
                }
              }, 'âœ•')
            ),

            // Art suggestions grid - refined
            id3ArtSuggestions.length > 0 && !id3SelectedArt && React.createElement('div', {
              className: 'grid grid-cols-4 gap-2'
            },
              id3ArtSuggestions.map((art, idx) =>
                React.createElement('button', {
                  key: art.releaseId || idx,
                  onClick: () => setId3SelectedArt(art),
                  className: 'relative group transition-all',
                  style: {
                    borderRadius: '8px',
                    overflow: 'hidden',
                    border: '2px solid transparent',
                    backgroundColor: 'transparent',
                    padding: '0',
                    cursor: 'pointer'
                  },
                  title: `${art.releaseName} by ${art.artistName}${art.year ? ` (${art.year})` : ''}`
                },
                  React.createElement('img', {
                    src: art.thumbnailUrl,
                    alt: art.releaseName,
                    className: 'w-full aspect-square object-cover'
                  }),
                  React.createElement('div', {
                    className: 'absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center'
                  },
                    React.createElement('span', {
                      style: {
                        fontSize: '11px',
                        fontWeight: '500',
                        color: '#ffffff'
                      }
                    }, 'Select')
                  )
                )
              )
            ),

            // Empty state messages - refined
            !id3ArtLoading && id3ArtSuggestions.length === 0 && !id3SelectedArt && React.createElement('div', {
              style: {
                textAlign: 'center',
                padding: '16px 0',
                fontSize: '13px',
                color: '#9ca3af'
              }
            },
              (!id3EditorValues.artist || !id3EditorValues.album)
                ? 'Enter artist and album to see artwork suggestions'
                : 'No artwork found for this album'
            )
          )
        ),
        // Footer with buttons - refined
        React.createElement('div', {
          className: 'flex justify-end gap-3',
          style: {
            padding: '16px 24px',
            backgroundColor: 'rgba(0, 0, 0, 0.02)',
            borderTop: '1px solid rgba(0, 0, 0, 0.06)'
          }
        },
          React.createElement('button', {
            onClick: () => {
              setId3EditorOpen(false);
              setId3EditorTrack(null);
            },
            disabled: id3EditorSaving,
            className: 'transition-colors',
            style: {
              padding: '10px 16px',
              fontSize: '13px',
              fontWeight: '500',
              color: '#374151',
              backgroundColor: '#ffffff',
              border: '1px solid rgba(0, 0, 0, 0.1)',
              borderRadius: '8px',
              cursor: id3EditorSaving ? 'not-allowed' : 'pointer',
              opacity: id3EditorSaving ? 0.5 : 1
            }
          }, 'Cancel'),
          React.createElement('button', {
            onClick: async () => {
              if (!id3EditorTrack?.filePath) return;

              setId3EditorSaving(true);
              try {
                const tagsToSave = {
                  title: id3EditorValues.title,
                  artist: id3EditorValues.artist,
                  album: id3EditorValues.album,
                  trackNumber: id3EditorValues.trackNumber ? parseInt(id3EditorValues.trackNumber, 10) : null,
                  year: id3EditorValues.year ? parseInt(id3EditorValues.year, 10) : null
                };

                // If album art was selected, include it
                if (id3SelectedArt?.fullUrl) {
                  tagsToSave.albumArtUrl = id3SelectedArt.fullUrl;
                }

                const result = await window.electron.localFiles.saveId3Tags(
                  id3EditorTrack.filePath,
                  tagsToSave
                );

                if (result.success) {
                  console.log('ðŸ·ï¸ ID3 tags saved successfully');
                  // Update track in library
                  setLibrary(prev => prev.map(t =>
                    t.filePath === id3EditorTrack.filePath
                      ? {
                          ...t,
                          ...id3EditorValues,
                          trackNumber: id3EditorValues.trackNumber ? parseInt(id3EditorValues.trackNumber, 10) : t.trackNumber,
                          year: id3EditorValues.year ? parseInt(id3EditorValues.year, 10) : t.year,
                          albumArt: id3SelectedArt?.fullUrl || t.albumArt
                        }
                      : t
                  ));
                  setId3EditorOpen(false);
                  setId3EditorTrack(null);
                  setId3SelectedArt(null);
                  setId3ArtSuggestions([]);
                } else {
                  alert('Failed to save ID3 tags: ' + result.error);
                }
              } catch (error) {
                console.error('Error saving ID3 tags:', error);
                alert('Failed to save ID3 tags: ' + error.message);
              } finally {
                setId3EditorSaving(false);
              }
            },
            disabled: id3EditorSaving,
            className: 'flex items-center gap-2 transition-colors',
            style: {
              padding: '10px 16px',
              fontSize: '13px',
              fontWeight: '500',
              color: '#ffffff',
              backgroundColor: id3EditorSaving ? '#9ca3af' : '#7c3aed',
              border: 'none',
              borderRadius: '8px',
              cursor: id3EditorSaving ? 'not-allowed' : 'pointer',
              opacity: id3EditorSaving ? 0.6 : 1
            }
          },
            id3EditorSaving && React.createElement('span', { className: 'animate-spin' }, 'âŸ³'),
            id3EditorSaving ? 'Saving...' : 'Save'
          )
        )
      )
    ),

    // Confirmation Dialog Modal - refined styling
    confirmDialog.show && React.createElement('div', {
      className: 'fixed inset-0 flex items-center justify-center z-[60]',
      style: {
        backgroundColor: 'rgba(0, 0, 0, 0.4)',
        backdropFilter: 'blur(4px)'
      },
      onClick: (e) => {
        if (e.target === e.currentTarget) closeConfirmDialog();
      }
    },
      React.createElement('div', {
        style: {
          backgroundColor: '#ffffff',
          borderRadius: '16px',
          boxShadow: '0 4px 24px rgba(0, 0, 0, 0.15), 0 12px 48px rgba(0, 0, 0, 0.1)',
          maxWidth: '360px',
          width: '100%',
          margin: '0 16px',
          overflow: 'hidden'
        },
        onClick: (e) => e.stopPropagation()
      },
        // Header with colored indicator
        React.createElement('div', {
          className: 'flex flex-col items-center text-center',
          style: { padding: '32px 24px 20px' }
        },
          // Icon based on type
          React.createElement('div', {
            className: 'flex items-center justify-center',
            style: {
              width: '56px',
              height: '56px',
              borderRadius: '50%',
              backgroundColor: confirmDialog.type === 'success' ? 'rgba(34, 197, 94, 0.1)' :
                confirmDialog.type === 'error' ? 'rgba(220, 38, 38, 0.1)' :
                'rgba(124, 58, 237, 0.1)',
              marginBottom: '16px'
            }
          },
            React.createElement('span', {
              style: {
                fontSize: '24px',
                color: confirmDialog.type === 'success' ? '#22c55e' :
                  confirmDialog.type === 'error' ? '#dc2626' :
                  '#7c3aed'
              }
            }, confirmDialog.type === 'success' ? 'âœ“' :
               confirmDialog.type === 'error' ? 'âœ•' : 'â„¹')
          ),
          // Title
          confirmDialog.title && React.createElement('h3', {
            style: {
              fontSize: '16px',
              fontWeight: '600',
              color: confirmDialog.type === 'success' ? '#166534' :
                confirmDialog.type === 'error' ? '#991b1b' :
                '#1f2937',
              marginBottom: '8px'
            }
          }, confirmDialog.title),
          // Message
          confirmDialog.message && React.createElement('p', {
            style: {
              fontSize: '13px',
              color: '#6b7280',
              lineHeight: '1.5'
            }
          }, confirmDialog.message)
        ),
        // Footer with button
        React.createElement('div', { style: { padding: '4px 24px 24px' } },
          React.createElement('button', {
            onClick: () => {
              if (confirmDialog.onConfirm) confirmDialog.onConfirm();
              closeConfirmDialog();
            },
            className: 'w-full transition-colors',
            style: {
              padding: '12px 16px',
              fontSize: '13px',
              fontWeight: '500',
              color: '#ffffff',
              backgroundColor: confirmDialog.type === 'success' ? '#22c55e' :
                confirmDialog.type === 'error' ? '#dc2626' :
                '#7c3aed',
              border: 'none',
              borderRadius: '10px',
              cursor: 'pointer'
            }
          }, 'OK')
        )
      )
    ),

    // Sync Setup Modal - Cinematic Light design
    syncSetupModal.open && React.createElement('div', {
      className: 'fixed inset-0 z-50 flex items-center justify-center',
      style: { backgroundColor: 'rgba(0, 0, 0, 0.4)', backdropFilter: 'blur(8px)' },
      onClick: () => !syncSetupModal.progress && setSyncSetupModal(prev => ({ ...prev, open: false }))
    },
      // Modal
      React.createElement('div', {
        className: 'relative w-full max-w-lg mx-4 overflow-hidden',
        style: {
          backgroundColor: '#ffffff',
          borderRadius: '16px',
          boxShadow: '0 25px 50px -12px rgba(0, 0, 0, 0.25)'
        },
        onClick: (e) => e.stopPropagation()
      },
        // Header with Spotify green accent bar
        React.createElement('div', {
          style: {
            height: '4px',
            background: 'linear-gradient(90deg, #1DB954 0%, #1ed760 100%)'
          }
        }),
        React.createElement('div', {
          className: 'flex items-center justify-between',
          style: { padding: '20px 24px 16px', borderBottom: '1px solid rgba(0, 0, 0, 0.06)' }
        },
          React.createElement('div', { className: 'flex items-center gap-3' },
            React.createElement('div', {
              className: 'w-10 h-10 rounded-xl flex items-center justify-center',
              style: { backgroundColor: '#1DB954' }
            },
              // Spotify icon
              React.createElement('svg', {
                className: 'w-6 h-6',
                viewBox: '0 0 24 24',
                fill: '#ffffff'
              },
                React.createElement('path', {
                  d: 'M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.419 1.56-.299.421-1.02.599-1.559.3z'
                })
              )
            ),
            React.createElement('div', null,
              React.createElement('h2', {
                style: { fontSize: '17px', fontWeight: '600', color: '#1f2937' }
              }, syncSetupModal.step === 'complete' ? 'Sync Complete' : 'Sync Your Spotify Library'),
              React.createElement('p', {
                style: { fontSize: '13px', color: '#6b7280', marginTop: '2px' }
              },
                syncSetupModal.step === 'options' && 'Choose what to sync',
                syncSetupModal.step === 'playlists' && 'Select playlists to sync',
                syncSetupModal.step === 'syncing' && 'Syncing your library...',
                syncSetupModal.step === 'complete' && 'Your library has been synced'
              )
            )
          ),
          // Close button
          !syncSetupModal.progress && React.createElement('button', {
            onClick: () => setSyncSetupModal(prev => ({ ...prev, open: false })),
            className: 'transition-colors',
            style: { padding: '6px', color: '#9ca3af', borderRadius: '8px' },
            onMouseEnter: (e) => { e.currentTarget.style.color = '#6b7280'; e.currentTarget.style.backgroundColor = 'rgba(0, 0, 0, 0.05)'; },
            onMouseLeave: (e) => { e.currentTarget.style.color = '#9ca3af'; e.currentTarget.style.backgroundColor = 'transparent'; }
          },
            React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
              React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M6 18L18 6M6 6l12 12' })
            )
          )
        ),

        // Content
        React.createElement('div', {
          className: 'scrollable-content',
          style: { padding: '20px 24px', maxHeight: '400px', overflowY: 'auto' }
        },
          // Error message
          syncSetupModal.error && React.createElement('div', {
            style: {
              marginBottom: '16px',
              padding: '12px 16px',
              backgroundColor: 'rgba(239, 68, 68, 0.08)',
              border: '1px solid rgba(239, 68, 68, 0.2)',
              borderRadius: '10px',
              fontSize: '13px',
              color: '#dc2626'
            }
          }, syncSetupModal.error),

          // Options step
          syncSetupModal.step === 'options' && React.createElement('div', {
            style: { display: 'flex', flexDirection: 'column', gap: '10px' }
          },
            [
              { key: 'syncPlaylists', label: 'Playlists', desc: 'Select which playlists to sync' },
              { key: 'syncTracks', label: 'Liked Songs', desc: 'Your saved tracks' },
              { key: 'syncAlbums', label: 'Saved Albums', desc: 'Albums in your library' },
              { key: 'syncArtists', label: 'Followed Artists', desc: 'Artists you follow' }
            ].map(option =>
              React.createElement('label', {
                key: option.key,
                className: 'flex items-center gap-3 cursor-pointer transition-colors',
                style: {
                  padding: '14px 16px',
                  backgroundColor: syncSetupModal.settings[option.key] ? 'rgba(29, 185, 84, 0.06)' : 'rgba(0, 0, 0, 0.02)',
                  borderRadius: '12px',
                  border: syncSetupModal.settings[option.key] ? '1px solid rgba(29, 185, 84, 0.3)' : '1px solid rgba(0, 0, 0, 0.06)'
                }
              },
                React.createElement('input', {
                  type: 'checkbox',
                  checked: syncSetupModal.settings[option.key],
                  onChange: (e) => setSyncSetupModal(prev => ({
                    ...prev,
                    settings: { ...prev.settings, [option.key]: e.target.checked }
                  })),
                  style: {
                    width: '18px',
                    height: '18px',
                    accentColor: '#1DB954',
                    cursor: 'pointer'
                  }
                }),
                React.createElement('div', null,
                  React.createElement('div', { style: { fontSize: '14px', fontWeight: '500', color: '#1f2937' } }, option.label),
                  React.createElement('div', { style: { fontSize: '12px', color: '#6b7280', marginTop: '2px' } }, option.desc)
                )
              )
            )
          ),

          // Playlists step
          syncSetupModal.step === 'playlists' && React.createElement('div', {
            style: { display: 'flex', flexDirection: 'column', gap: '12px' }
          },
            syncSetupModal.playlists.length === 0
              ? React.createElement('div', {
                  style: { textAlign: 'center', padding: '32px 0', color: '#6b7280', fontSize: '14px' }
                }, 'Loading playlists...')
              : React.createElement(React.Fragment, null,
                  // Filter tabs
                  React.createElement('div', {
                    style: {
                      display: 'flex',
                      gap: '4px',
                      padding: '4px',
                      backgroundColor: 'rgba(0, 0, 0, 0.04)',
                      borderRadius: '10px',
                      marginBottom: '4px'
                    }
                  },
                    [
                      { key: 'all', label: 'All' },
                      { key: 'owned', label: 'Created by Me' },
                      { key: 'following', label: 'Following' }
                    ].map(filter =>
                      React.createElement('button', {
                        key: filter.key,
                        onClick: () => setSyncSetupModal(prev => ({ ...prev, playlistFilter: filter.key })),
                        style: {
                          flex: 1,
                          padding: '8px 12px',
                          fontSize: '13px',
                          fontWeight: '500',
                          color: syncSetupModal.playlistFilter === filter.key ? '#1f2937' : '#6b7280',
                          backgroundColor: syncSetupModal.playlistFilter === filter.key ? '#ffffff' : 'transparent',
                          border: 'none',
                          borderRadius: '8px',
                          cursor: 'pointer',
                          transition: 'all 150ms ease',
                          boxShadow: syncSetupModal.playlistFilter === filter.key ? '0 1px 3px rgba(0,0,0,0.1)' : 'none'
                        }
                      }, filter.label)
                    )
                  ),
                  // Select all / deselect all for current filter
                  React.createElement('div', {
                    style: { display: 'flex', justifyContent: 'flex-end', gap: '12px', marginBottom: '4px' }
                  },
                    React.createElement('button', {
                      onClick: () => {
                        const filteredIds = syncSetupModal.playlists
                          .filter(p => syncSetupModal.playlistFilter === 'all' ? true :
                            syncSetupModal.playlistFilter === 'owned' ? p.isOwnedByUser : !p.isOwnedByUser)
                          .map(p => p.externalId);
                        setSyncSetupModal(prev => ({
                          ...prev,
                          selectedPlaylists: [...new Set([...prev.selectedPlaylists, ...filteredIds])]
                        }));
                      },
                      style: {
                        fontSize: '12px',
                        fontWeight: '500',
                        color: '#1DB954',
                        backgroundColor: 'transparent',
                        border: 'none',
                        cursor: 'pointer'
                      }
                    }, 'Select All'),
                    React.createElement('button', {
                      onClick: () => {
                        const filteredIds = new Set(syncSetupModal.playlists
                          .filter(p => syncSetupModal.playlistFilter === 'all' ? true :
                            syncSetupModal.playlistFilter === 'owned' ? p.isOwnedByUser : !p.isOwnedByUser)
                          .map(p => p.externalId));
                        setSyncSetupModal(prev => ({
                          ...prev,
                          selectedPlaylists: prev.selectedPlaylists.filter(id => !filteredIds.has(id))
                        }));
                      },
                      style: {
                        fontSize: '12px',
                        fontWeight: '500',
                        color: '#6b7280',
                        backgroundColor: 'transparent',
                        border: 'none',
                        cursor: 'pointer'
                      }
                    }, 'Deselect All')
                  ),
                  // Playlist list
                  React.createElement('div', {
                    style: { display: 'flex', flexDirection: 'column', gap: '4px', maxHeight: '280px', overflowY: 'auto' }
                  },
                    syncSetupModal.playlists
                      .filter(playlist => {
                        if (syncSetupModal.playlistFilter === 'all') return true;
                        if (syncSetupModal.playlistFilter === 'owned') return playlist.isOwnedByUser;
                        return !playlist.isOwnedByUser;
                      })
                      .map(playlist =>
                        React.createElement('label', {
                          key: playlist.externalId,
                          className: 'flex items-center gap-3 cursor-pointer transition-colors',
                          style: {
                            padding: '10px 12px',
                            borderRadius: '10px',
                            backgroundColor: syncSetupModal.selectedPlaylists.includes(playlist.externalId) ? 'rgba(29, 185, 84, 0.06)' : 'transparent'
                          },
                          onMouseEnter: (e) => { if (!syncSetupModal.selectedPlaylists.includes(playlist.externalId)) e.currentTarget.style.backgroundColor = 'rgba(0, 0, 0, 0.03)'; },
                          onMouseLeave: (e) => { if (!syncSetupModal.selectedPlaylists.includes(playlist.externalId)) e.currentTarget.style.backgroundColor = 'transparent'; }
                        },
                          React.createElement('input', {
                            type: 'checkbox',
                            checked: syncSetupModal.selectedPlaylists.includes(playlist.externalId),
                            onChange: (e) => {
                              setSyncSetupModal(prev => ({
                                ...prev,
                                selectedPlaylists: e.target.checked
                                  ? [...prev.selectedPlaylists, playlist.externalId]
                                  : prev.selectedPlaylists.filter(id => id !== playlist.externalId)
                              }));
                            },
                            style: { width: '16px', height: '16px', accentColor: '#1DB954', cursor: 'pointer' }
                          }),
                          playlist.image && React.createElement('img', {
                            src: playlist.image,
                            style: { width: '40px', height: '40px', borderRadius: '6px', objectFit: 'cover' },
                            alt: ''
                          }),
                          React.createElement('div', { style: { flex: 1, minWidth: 0 } },
                            React.createElement('div', { style: { fontSize: '14px', color: '#1f2937', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' } }, playlist.name),
                            React.createElement('div', { style: { fontSize: '12px', color: '#9ca3af' } },
                              `${playlist.trackCount} tracks`,
                              !playlist.isOwnedByUser && ' Â· Following'
                            )
                          )
                        )
                      )
                  ),
                  // Empty state for filter
                  syncSetupModal.playlists.filter(p =>
                    syncSetupModal.playlistFilter === 'all' ? true :
                    syncSetupModal.playlistFilter === 'owned' ? p.isOwnedByUser : !p.isOwnedByUser
                  ).length === 0 && React.createElement('div', {
                    style: { textAlign: 'center', padding: '24px 0', color: '#9ca3af', fontSize: '13px' }
                  }, syncSetupModal.playlistFilter === 'owned' ? 'No playlists created by you' : 'No playlists you\'re following')
                )
          ),

          // Syncing step
          syncSetupModal.step === 'syncing' && syncSetupModal.progress && React.createElement('div', {
            style: { padding: '32px 0', textAlign: 'center' }
          },
            // Animated sync icon
            React.createElement('div', {
              style: {
                width: '48px',
                height: '48px',
                margin: '0 auto 16px',
                borderRadius: '50%',
                backgroundColor: 'rgba(29, 185, 84, 0.1)',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center'
              }
            },
              React.createElement('svg', {
                className: 'animate-spin',
                style: { width: '24px', height: '24px', color: '#1DB954' },
                fill: 'none',
                viewBox: '0 0 24 24'
              },
                React.createElement('circle', { cx: '12', cy: '12', r: '10', stroke: 'currentColor', strokeWidth: '3', opacity: 0.2 }),
                React.createElement('path', { fill: 'currentColor', d: 'M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z' })
              )
            ),
            React.createElement('div', {
              style: { fontSize: '15px', fontWeight: '500', color: '#1f2937' }
            }, syncSetupModal.progress.message),
            syncSetupModal.progress.total > 0 && React.createElement('div', {
              style: { fontSize: '13px', color: '#6b7280', marginTop: '4px' }
            }, `${syncSetupModal.progress.current} of ${syncSetupModal.progress.total}`),
            syncSetupModal.progress.total > 0 && React.createElement('div', {
              style: { height: '6px', backgroundColor: 'rgba(0, 0, 0, 0.06)', borderRadius: '3px', overflow: 'hidden', marginTop: '16px' }
            },
              React.createElement('div', {
                style: {
                  height: '100%',
                  backgroundColor: '#1DB954',
                  borderRadius: '3px',
                  transition: 'width 300ms ease-out',
                  width: `${(syncSetupModal.progress.current / syncSetupModal.progress.total) * 100}%`
                }
              })
            )
          ),

          // Complete step
          syncSetupModal.step === 'complete' && syncSetupModal.results && React.createElement('div', {
            style: { padding: '16px 0' }
          },
            // Success icon
            React.createElement('div', {
              style: {
                width: '48px',
                height: '48px',
                margin: '0 auto 20px',
                borderRadius: '50%',
                backgroundColor: 'rgba(29, 185, 84, 0.1)',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center'
              }
            },
              React.createElement('svg', {
                style: { width: '24px', height: '24px', color: '#1DB954' },
                fill: 'none',
                viewBox: '0 0 24 24',
                stroke: 'currentColor'
              },
                React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2.5, d: 'M5 13l4 4L19 7' })
              )
            ),
            // Results
            React.createElement('div', { style: { display: 'flex', flexDirection: 'column', gap: '12px' } },
              syncSetupModal.results.tracks && React.createElement('div', {
                style: { display: 'flex', justifyContent: 'space-between', fontSize: '13px', padding: '10px 14px', backgroundColor: 'rgba(0, 0, 0, 0.02)', borderRadius: '8px' }
              },
                React.createElement('span', { style: { color: '#6b7280' } }, 'Tracks'),
                React.createElement('span', { style: { color: '#1f2937', fontWeight: '500' } },
                  `+${syncSetupModal.results.tracks.added} added, -${syncSetupModal.results.tracks.removed} removed`
                )
              ),
              syncSetupModal.results.albums && React.createElement('div', {
                style: { display: 'flex', justifyContent: 'space-between', fontSize: '13px', padding: '10px 14px', backgroundColor: 'rgba(0, 0, 0, 0.02)', borderRadius: '8px' }
              },
                React.createElement('span', { style: { color: '#6b7280' } }, 'Albums'),
                React.createElement('span', { style: { color: '#1f2937', fontWeight: '500' } },
                  `+${syncSetupModal.results.albums.added} added, -${syncSetupModal.results.albums.removed} removed`
                )
              ),
              syncSetupModal.results.artists && React.createElement('div', {
                style: { display: 'flex', justifyContent: 'space-between', fontSize: '13px', padding: '10px 14px', backgroundColor: 'rgba(0, 0, 0, 0.02)', borderRadius: '8px' }
              },
                React.createElement('span', { style: { color: '#6b7280' } }, 'Artists'),
                React.createElement('span', { style: { color: '#1f2937', fontWeight: '500' } },
                  `+${syncSetupModal.results.artists.added} added, -${syncSetupModal.results.artists.removed} removed`
                )
              ),
              syncSetupModal.results.playlists && React.createElement('div', {
                style: { display: 'flex', justifyContent: 'space-between', fontSize: '13px', padding: '10px 14px', backgroundColor: 'rgba(0, 0, 0, 0.02)', borderRadius: '8px' }
              },
                React.createElement('span', { style: { color: '#6b7280' } }, 'Playlists'),
                React.createElement('span', { style: { color: '#1f2937', fontWeight: '500' } },
                  `+${syncSetupModal.results.playlists.added} added` +
                  (syncSetupModal.results.playlists.updated > 0 ? `, ${syncSetupModal.results.playlists.updated} with updates` : '')
                )
              )
            )
          )
        ),

        // Footer
        React.createElement('div', {
          className: 'flex justify-end gap-3',
          style: { padding: '16px 24px 20px', borderTop: '1px solid rgba(0, 0, 0, 0.06)' }
        },
          // Options step buttons
          syncSetupModal.step === 'options' && React.createElement(React.Fragment, null,
            React.createElement('button', {
              onClick: () => setSyncSetupModal(prev => ({ ...prev, open: false })),
              style: {
                padding: '10px 20px',
                fontSize: '14px',
                fontWeight: '500',
                color: '#6b7280',
                backgroundColor: 'transparent',
                border: 'none',
                borderRadius: '10px',
                cursor: 'pointer'
              },
              onMouseEnter: (e) => e.currentTarget.style.color = '#1f2937',
              onMouseLeave: (e) => e.currentTarget.style.color = '#6b7280'
            }, 'Cancel'),
            React.createElement('button', {
              onClick: async () => {
                if (syncSetupModal.settings.syncPlaylists) {
                  // Load playlists first
                  setSyncSetupModal(prev => ({ ...prev, step: 'playlists', error: null }));
                  const result = await window.electron.sync.fetchPlaylists(syncSetupModal.providerId);
                  if (result.success) {
                    setSyncSetupModal(prev => ({
                      ...prev,
                      playlists: result.playlists,
                      folders: result.folders
                    }));
                  } else {
                    // Handle failed playlist fetch - show error and go back to options
                    setSyncSetupModal(prev => ({
                      ...prev,
                      step: 'options',
                      error: result.error || 'Failed to load playlists. Please try again.'
                    }));
                  }
                } else {
                  startSync();
                }
              },
              style: {
                padding: '10px 24px',
                fontSize: '14px',
                fontWeight: '500',
                color: '#ffffff',
                backgroundColor: '#1DB954',
                border: 'none',
                borderRadius: '10px',
                cursor: 'pointer',
                transition: 'background-color 150ms ease'
              },
              onMouseEnter: (e) => e.currentTarget.style.backgroundColor = '#1ed760',
              onMouseLeave: (e) => e.currentTarget.style.backgroundColor = '#1DB954'
            }, syncSetupModal.settings.syncPlaylists ? 'Next' : 'Start Sync')
          ),

          // Playlists step buttons
          syncSetupModal.step === 'playlists' && React.createElement(React.Fragment, null,
            React.createElement('button', {
              onClick: () => setSyncSetupModal(prev => ({ ...prev, step: 'options' })),
              style: {
                padding: '10px 20px',
                fontSize: '14px',
                fontWeight: '500',
                color: '#6b7280',
                backgroundColor: 'transparent',
                border: 'none',
                borderRadius: '10px',
                cursor: 'pointer'
              },
              onMouseEnter: (e) => e.currentTarget.style.color = '#1f2937',
              onMouseLeave: (e) => e.currentTarget.style.color = '#6b7280'
            }, 'Back'),
            React.createElement('button', {
              onClick: startSync,
              style: {
                padding: '10px 24px',
                fontSize: '14px',
                fontWeight: '500',
                color: '#ffffff',
                backgroundColor: '#1DB954',
                border: 'none',
                borderRadius: '10px',
                cursor: 'pointer',
                transition: 'background-color 150ms ease'
              },
              onMouseEnter: (e) => e.currentTarget.style.backgroundColor = '#1ed760',
              onMouseLeave: (e) => e.currentTarget.style.backgroundColor = '#1DB954'
            }, 'Start Sync')
          ),

          // Complete step button
          syncSetupModal.step === 'complete' && React.createElement('button', {
            onClick: () => setSyncSetupModal(prev => ({ ...prev, open: false })),
            style: {
              padding: '10px 24px',
              fontSize: '14px',
              fontWeight: '500',
              color: '#ffffff',
              backgroundColor: '#1DB954',
              border: 'none',
              borderRadius: '10px',
              cursor: 'pointer',
              transition: 'background-color 150ms ease'
            },
            onMouseEnter: (e) => e.currentTarget.style.backgroundColor = '#1ed760',
            onMouseLeave: (e) => e.currentTarget.style.backgroundColor = '#1DB954'
          }, 'Done')
        )
      )
    ),

    // Sync Status Modal (Quick View from Collection) - Cinematic Light design
    syncStatusModal.open && React.createElement('div', {
      className: 'fixed inset-0 z-50 flex items-center justify-center',
      style: { backgroundColor: 'rgba(0, 0, 0, 0.4)', backdropFilter: 'blur(8px)' },
      onClick: () => setSyncStatusModal({ open: false })
    },
      // Modal
      React.createElement('div', {
        className: 'relative w-full max-w-md mx-4 overflow-hidden',
        style: {
          backgroundColor: '#ffffff',
          borderRadius: '16px',
          boxShadow: '0 25px 50px -12px rgba(0, 0, 0, 0.25)'
        },
        onClick: (e) => e.stopPropagation()
      },
        // Header with close button
        React.createElement('div', {
          className: 'flex items-center justify-between',
          style: { padding: '20px 24px 16px', borderBottom: '1px solid rgba(0, 0, 0, 0.06)' }
        },
          React.createElement('h2', {
            style: { fontSize: '17px', fontWeight: '600', color: '#1f2937' }
          }, 'Library Sync'),
          React.createElement('button', {
            onClick: () => setSyncStatusModal({ open: false }),
            className: 'transition-colors',
            style: { padding: '6px', color: '#9ca3af', borderRadius: '8px' },
            onMouseEnter: (e) => { e.currentTarget.style.color = '#6b7280'; e.currentTarget.style.backgroundColor = 'rgba(0, 0, 0, 0.05)'; },
            onMouseLeave: (e) => { e.currentTarget.style.color = '#9ca3af'; e.currentTarget.style.backgroundColor = 'transparent'; }
          },
            React.createElement('svg', { className: 'w-5 h-5', fill: 'none', viewBox: '0 0 24 24', stroke: 'currentColor' },
              React.createElement('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M6 18L18 6M6 6l12 12' })
            )
          )
        ),

        // Content
        React.createElement('div', {
          style: { padding: '20px 24px' }
        },
          // List enabled sync providers with progress
          React.createElement('div', { style: { display: 'flex', flexDirection: 'column', gap: '16px' } },
            Object.entries(resolverSyncSettings)
              .filter(([_, settings]) => settings.enabled)
              .map(([providerId, settings]) => {
                const status = syncStatus[providerId];
                const isInProgress = status?.inProgress;
                const progress = status?.progress;

                return React.createElement('div', {
                  key: providerId,
                  style: {
                    padding: '14px 16px',
                    backgroundColor: 'rgba(0, 0, 0, 0.02)',
                    borderRadius: '12px',
                    border: '1px solid rgba(0, 0, 0, 0.04)'
                  }
                },
                  React.createElement('div', {
                    style: { display: 'flex', alignItems: 'center', gap: '12px' }
                  },
                    // Status indicator - animated when syncing
                    React.createElement('div', {
                      className: isInProgress ? 'animate-pulse' : '',
                      style: {
                        width: '10px',
                        height: '10px',
                        borderRadius: '50%',
                        backgroundColor: isInProgress ? '#3b82f6' : '#22c55e',
                        boxShadow: isInProgress ? '0 0 8px rgba(59, 130, 246, 0.5)' : 'none'
                      }
                    }),
                    React.createElement('div', { style: { flex: 1 } },
                      React.createElement('div', {
                        style: { fontSize: '14px', fontWeight: '500', color: '#1f2937', textTransform: 'capitalize' }
                      }, providerId),
                      React.createElement('div', {
                        style: { fontSize: '12px', color: '#6b7280', marginTop: '2px' }
                      }, isInProgress
                        ? (progress?.phase === 'tracks' ? `Syncing tracks... ${progress.current || 0}/${progress.total || '?'}` :
                           progress?.phase === 'albums' ? `Syncing albums... ${progress.current || 0}/${progress.total || '?'}` :
                           progress?.phase === 'artists' ? `Syncing artists... ${progress.current || 0}/${progress.total || '?'}` :
                           progress?.phase === 'playlists' ? `Syncing playlists... ${progress.current || 0}/${progress.total || '?'}` :
                           'Syncing...')
                        : 'Last sync: ' + (settings.lastSyncAt
                          ? new Date(settings.lastSyncAt).toLocaleString()
                          : 'Never'))
                    )
                  ),
                  // Progress bar when syncing
                  isInProgress && progress?.total > 0 && React.createElement('div', {
                    style: {
                      height: '4px',
                      backgroundColor: 'rgba(0, 0, 0, 0.06)',
                      borderRadius: '2px',
                      overflow: 'hidden',
                      marginTop: '10px',
                      marginLeft: '22px'
                    }
                  },
                    React.createElement('div', {
                      style: {
                        height: '100%',
                        backgroundColor: '#3b82f6',
                        borderRadius: '2px',
                        transition: 'width 300ms ease-out',
                        width: `${Math.round((progress.current / progress.total) * 100)}%`
                      }
                    })
                  )
                );
              })
          ),

          // No providers message
          Object.keys(resolverSyncSettings).filter(id => resolverSyncSettings[id]?.enabled).length === 0 &&
            React.createElement('div', {
              style: { textAlign: 'center', padding: '24px 0', color: '#6b7280', fontSize: '14px' }
            }, 'No sync providers enabled'),

          // Message about closing safely - only show when sync is in progress
          Object.values(syncStatus).some(s => s?.inProgress) &&
            React.createElement('div', {
              style: { fontSize: '12px', color: '#9ca3af', textAlign: 'center', marginTop: '16px' }
            }, 'Sync continues in the background. Safe to close this window.')
        ),

        // Footer
        React.createElement('div', {
          className: 'flex justify-between',
          style: { padding: '16px 24px 20px', borderTop: '1px solid rgba(0, 0, 0, 0.06)' }
        },
          React.createElement('button', {
            onClick: () => {
              setSyncStatusModal({ open: false });
              // Navigate to settings - to be wired up later
            },
            style: {
              fontSize: '13px',
              fontWeight: '500',
              color: '#6b7280',
              backgroundColor: 'transparent',
              border: 'none',
              cursor: 'pointer'
            },
            onMouseEnter: (e) => e.currentTarget.style.color = '#1f2937',
            onMouseLeave: (e) => e.currentTarget.style.color = '#6b7280'
          }, 'Manage settings'),
          React.createElement('button', {
            onClick: async () => {
              let latestCollection = null;
              for (const [providerId, settings] of Object.entries(resolverSyncSettings)) {
                if (settings.enabled) {
                  try {
                    const authStatus = await window.electron.sync.checkAuth(providerId);
                    if (authStatus.authenticated) {
                      const result = await window.electron.sync.start(providerId, { settings });
                      if (result.success && result.collection) {
                        latestCollection = result.collection;
                      }
                    }
                  } catch (error) {
                    console.error(`[Sync] Quick sync failed for ${providerId}:`, error);
                  }
                }
              }
              // Update UI with synced collection
              if (latestCollection) {
                setCollectionData({
                  tracks: latestCollection.tracks || [],
                  albums: latestCollection.albums || [],
                  artists: latestCollection.artists || []
                });
              } else {
                const newCollection = await window.electron.collection.load();
                setCollectionData(newCollection);
              }
              const loadedPlaylists = await window.electron.playlists.load();
              setPlaylists(loadedPlaylists);
            },
            disabled: Object.values(syncStatus).some(s => s?.inProgress),
            style: {
              padding: '8px 16px',
              fontSize: '13px',
              fontWeight: '500',
              color: Object.values(syncStatus).some(s => s?.inProgress) ? '#9ca3af' : '#ffffff',
              backgroundColor: Object.values(syncStatus).some(s => s?.inProgress) ? 'rgba(0, 0, 0, 0.04)' : '#1DB954',
              border: 'none',
              borderRadius: '8px',
              cursor: Object.values(syncStatus).some(s => s?.inProgress) ? 'not-allowed' : 'pointer',
              transition: 'background-color 150ms ease'
            },
            onMouseEnter: (e) => { if (!Object.values(syncStatus).some(s => s?.inProgress)) e.currentTarget.style.backgroundColor = '#1ed760'; },
            onMouseLeave: (e) => { if (!Object.values(syncStatus).some(s => s?.inProgress)) e.currentTarget.style.backgroundColor = '#1DB954'; }
          }, Object.values(syncStatus).some(s => s?.inProgress) ? 'Syncing...' : 'Sync Now')
        )
      )
    ),

    // Stop Sync Confirmation Dialog - Cinematic Light design
    stopSyncDialog.open && React.createElement('div', {
      className: 'fixed inset-0 z-50 flex items-center justify-center',
      style: { backgroundColor: 'rgba(0, 0, 0, 0.4)', backdropFilter: 'blur(8px)' },
      onClick: () => setStopSyncDialog({ open: false, providerId: null })
    },
      // Dialog
      React.createElement('div', {
        className: 'relative w-full max-w-sm mx-4 overflow-hidden',
        style: {
          backgroundColor: '#ffffff',
          borderRadius: '16px',
          boxShadow: '0 25px 50px -12px rgba(0, 0, 0, 0.25)'
        },
        onClick: (e) => e.stopPropagation()
      },
        // Content
        React.createElement('div', {
          style: { padding: '24px' }
        },
          React.createElement('h2', {
            style: { fontSize: '17px', fontWeight: '600', color: '#1f2937', marginBottom: '8px' }
          }, 'Stop Syncing?'),
          React.createElement('p', {
            style: { fontSize: '14px', color: '#6b7280', marginBottom: '20px', lineHeight: '1.5' }
          }, 'What would you like to do with your synced items?'),

          // Options
          React.createElement('div', {
            style: { display: 'flex', flexDirection: 'column', gap: '10px' }
          },
            // Keep items option
            React.createElement('button', {
              onClick: () => stopSyncing(stopSyncDialog.providerId, false),
              style: {
                width: '100%',
                padding: '14px 16px',
                textAlign: 'left',
                backgroundColor: 'rgba(0, 0, 0, 0.02)',
                border: '1px solid rgba(0, 0, 0, 0.06)',
                borderRadius: '12px',
                cursor: 'pointer',
                transition: 'all 150ms ease'
              },
              onMouseEnter: (e) => { e.currentTarget.style.backgroundColor = 'rgba(0, 0, 0, 0.04)'; e.currentTarget.style.borderColor = 'rgba(0, 0, 0, 0.1)'; },
              onMouseLeave: (e) => { e.currentTarget.style.backgroundColor = 'rgba(0, 0, 0, 0.02)'; e.currentTarget.style.borderColor = 'rgba(0, 0, 0, 0.06)'; }
            },
              React.createElement('div', {
                style: { fontSize: '14px', fontWeight: '500', color: '#1f2937' }
              }, 'Keep imported items'),
              React.createElement('div', {
                style: { fontSize: '12px', color: '#6b7280', marginTop: '4px' }
              }, 'Items stay in your Collection as local items')
            ),
            // Remove items option
            React.createElement('button', {
              onClick: () => stopSyncing(stopSyncDialog.providerId, true),
              style: {
                width: '100%',
                padding: '14px 16px',
                textAlign: 'left',
                backgroundColor: 'rgba(239, 68, 68, 0.04)',
                border: '1px solid rgba(239, 68, 68, 0.15)',
                borderRadius: '12px',
                cursor: 'pointer',
                transition: 'all 150ms ease'
              },
              onMouseEnter: (e) => { e.currentTarget.style.backgroundColor = 'rgba(239, 68, 68, 0.08)'; e.currentTarget.style.borderColor = 'rgba(239, 68, 68, 0.25)'; },
              onMouseLeave: (e) => { e.currentTarget.style.backgroundColor = 'rgba(239, 68, 68, 0.04)'; e.currentTarget.style.borderColor = 'rgba(239, 68, 68, 0.15)'; }
            },
              React.createElement('div', {
                style: { fontSize: '14px', fontWeight: '500', color: '#dc2626' }
              }, 'Remove synced items'),
              React.createElement('div', {
                style: { fontSize: '12px', color: '#6b7280', marginTop: '4px' }
              }, 'Remove everything synced from this provider')
            )
          )
        ),

        // Footer
        React.createElement('div', {
          style: { padding: '16px 24px 20px', borderTop: '1px solid rgba(0, 0, 0, 0.06)', textAlign: 'center' }
        },
          React.createElement('button', {
            onClick: () => setStopSyncDialog({ open: false, providerId: null }),
            style: {
              fontSize: '14px',
              fontWeight: '500',
              color: '#6b7280',
              backgroundColor: 'transparent',
              border: 'none',
              cursor: 'pointer',
              padding: '8px 16px'
            },
            onMouseEnter: (e) => e.currentTarget.style.color = '#1f2937',
            onMouseLeave: (e) => e.currentTarget.style.color = '#6b7280'
          }, 'Cancel')
        )
      )
    ),

    // First-Run Tutorial Modal - Cinematic Light design
    firstRunTutorial.open && React.createElement('div', {
      className: 'fixed inset-0 z-50 flex items-center justify-center',
      style: { backgroundColor: 'rgba(0, 0, 0, 0.4)', backdropFilter: 'blur(8px)' }
    },
      // Modal
      React.createElement('div', {
        className: 'relative w-full max-w-xl mx-4 overflow-hidden',
        style: {
          backgroundColor: '#ffffff',
          borderRadius: '16px',
          boxShadow: '0 25px 50px -12px rgba(0, 0, 0, 0.25)'
        },
        onClick: (e) => e.stopPropagation()
      },
        // Welcome Step
        firstRunTutorial.step === 'welcome' && React.createElement(React.Fragment, null,
          // Accent bar
          React.createElement('div', {
            style: {
              height: '4px',
              backgroundColor: '#7c3aed'
            }
          }),
          // Header
          React.createElement('div', {
            style: {
              padding: '32px 32px 24px',
              textAlign: 'center',
              borderBottom: '1px solid rgba(0, 0, 0, 0.06)'
            }
          },
            // Parachord wordmark logo - centered
            React.createElement('div', {
              style: { marginBottom: '12px', display: 'flex', justifyContent: 'center' }
            },
              React.createElement(ParachordWordmark, { fill: '#1f2937', height: 44 })
            ),
            React.createElement('p', {
              style: { fontSize: '15px', color: '#6b7280', lineHeight: '1.5' }
            }, 'Your music is everywhere, but you shouldn\'t have to be.')
          ),
          // Content
          React.createElement('div', {
            style: { padding: '24px 32px' }
          },
            React.createElement('p', {
              style: { fontSize: '14px', color: '#4b5563', lineHeight: '1.7', marginBottom: '20px' }
            }, 'Parachord brings all your music together in one place. Search across multiple services, build unified playlists, and enjoy your music from wherever it lives.'),
            // Feature highlights with SVG icons
            React.createElement('div', {
              style: { display: 'flex', flexDirection: 'column', gap: '12px' }
            },
              [
                { icon: React.createElement('svg', { width: 18, height: 18, viewBox: '0 0 24 24', fill: 'none', stroke: '#7c3aed', strokeWidth: 2, strokeLinecap: 'round', strokeLinejoin: 'round' },
                  React.createElement('path', { d: 'M9 18V5l12-2v13' }),
                  React.createElement('circle', { cx: 6, cy: 18, r: 3 }),
                  React.createElement('circle', { cx: 18, cy: 16, r: 3 })
                ), text: 'Play from Spotify, YouTube, Bandcamp, and more' },
                { icon: React.createElement('svg', { width: 18, height: 18, viewBox: '0 0 24 24', fill: 'none', stroke: '#7c3aed', strokeWidth: 2, strokeLinecap: 'round', strokeLinejoin: 'round' },
                  React.createElement('circle', { cx: 11, cy: 11, r: 8 }),
                  React.createElement('path', { d: 'M21 21l-4.35-4.35' })
                ), text: 'Search all your sources at once' },
                { icon: React.createElement('svg', { width: 18, height: 18, viewBox: '0 0 24 24', fill: 'none', stroke: '#7c3aed', strokeWidth: 2, strokeLinecap: 'round', strokeLinejoin: 'round' },
                  React.createElement('path', { d: 'M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z' }),
                  React.createElement('path', { d: 'M14 2v6h6' }),
                  React.createElement('line', { x1: 16, y1: 13, x2: 8, y2: 13 }),
                  React.createElement('line', { x1: 16, y1: 17, x2: 8, y2: 17 })
                ), text: 'Create playlists that span services' },
                { icon: React.createElement('svg', { width: 18, height: 18, viewBox: '0 0 24 24', fill: 'none', stroke: '#7c3aed', strokeWidth: 2, strokeLinecap: 'round', strokeLinejoin: 'round' },
                  React.createElement('path', { d: 'M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2' }),
                  React.createElement('circle', { cx: 9, cy: 7, r: 4 }),
                  React.createElement('path', { d: 'M23 21v-2a4 4 0 0 0-3-3.87' }),
                  React.createElement('path', { d: 'M16 3.13a4 4 0 0 1 0 7.75' })
                ), text: 'Connect with friends on Last.fm & ListenBrainz' }
              ].map((item, i) =>
                React.createElement('div', {
                  key: i,
                  style: { display: 'flex', alignItems: 'center', gap: '12px' }
                },
                  React.createElement('div', {
                    style: { width: '32px', height: '32px', borderRadius: '8px', backgroundColor: 'rgba(124, 58, 237, 0.08)', display: 'flex', alignItems: 'center', justifyContent: 'center', flexShrink: 0 }
                  }, item.icon),
                  React.createElement('span', {
                    style: { fontSize: '13px', color: '#374151' }
                  }, item.text)
                )
              )
            )
          ),
          // Footer
          React.createElement('div', {
            style: {
              padding: '16px 32px 24px',
              borderTop: '1px solid rgba(0,0,0,0.06)',
              display: 'flex',
              justifyContent: 'space-between',
              alignItems: 'center'
            }
          },
            React.createElement('button', {
              onClick: async () => {
                await window.electron.store.set('tutorial_completed', true);
                setFirstRunTutorial(prev => ({ ...prev, open: false }));
              },
              style: {
                fontSize: '14px',
                fontWeight: '500',
                color: '#6b7280',
                backgroundColor: 'transparent',
                border: 'none',
                cursor: 'pointer',
                padding: '10px 16px',
                borderRadius: '10px'
              },
              onMouseEnter: (e) => e.currentTarget.style.color = '#1f2937',
              onMouseLeave: (e) => e.currentTarget.style.color = '#6b7280'
            }, 'Skip tutorial'),
            React.createElement('button', {
              onClick: () => setFirstRunTutorial(prev => ({ ...prev, step: 'sources' })),
              style: {
                padding: '10px 24px',
                fontSize: '14px',
                fontWeight: '500',
                color: '#ffffff',
                backgroundColor: '#7c3aed',
                border: 'none',
                borderRadius: '10px',
                cursor: 'pointer',
                transition: 'background-color 150ms ease'
              },
              onMouseEnter: (e) => e.currentTarget.style.backgroundColor = '#6d28d9',
              onMouseLeave: (e) => e.currentTarget.style.backgroundColor = '#7c3aed'
            }, 'Get Started')
          )
        ),

        // Sources Step - Uses actual loadedResolvers and activeResolvers
        firstRunTutorial.step === 'sources' && React.createElement(React.Fragment, null,
          // Accent bar
          React.createElement('div', {
            style: { height: '4px', backgroundColor: '#7c3aed' }
          }),
          // Header
          React.createElement('div', {
            style: {
              padding: '24px 32px 20px',
              borderBottom: '1px solid rgba(0,0,0,0.06)'
            }
          },
            React.createElement('h2', {
              style: { fontSize: '18px', fontWeight: '600', color: '#1f2937', marginBottom: '4px' }
            }, 'Enable Your Music Sources'),
            React.createElement('p', {
              style: { fontSize: '14px', color: '#6b7280' }
            }, 'Click to enable or disable sources. You can configure them in Settings.')
          ),
          // Content - Resolver cards grid (same design as Settings > Installed)
          React.createElement('div', {
            style: { padding: '24px 32px' }
          },
            React.createElement('div', {
              style: { display: 'flex', flexWrap: 'wrap', gap: '16px', justifyContent: 'center' }
            },
              loadedResolvers.filter(r => r.capabilities?.resolve).map(resolver => {
                const isActive = activeResolvers.includes(resolver.id);
                const logo = SERVICE_LOGOS[resolver.id];
                return React.createElement('div', {
                  key: resolver.id,
                  className: `flex flex-col items-center cursor-pointer transition-all ${!isActive ? 'opacity-50 grayscale' : ''}`,
                  style: { width: '90px' },
                  onClick: () => {
                    if (isActive) {
                      setActiveResolvers(prev => prev.filter(id => id !== resolver.id));
                    } else {
                      setActiveResolvers(prev => [...prev, resolver.id]);
                    }
                  }
                },
                  // Card with colored background
                  React.createElement('div', {
                    style: {
                      width: '80px',
                      height: '80px',
                      borderRadius: '16px',
                      backgroundColor: resolver.color || '#6B7280',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      boxShadow: isActive ? '0 4px 12px rgba(0, 0, 0, 0.15)' : '0 2px 8px rgba(0, 0, 0, 0.1)',
                      marginBottom: '8px'
                    }
                  },
                    logo ? logo : React.createElement('span', { className: 'text-3xl text-white' }, resolver.icon)
                  ),
                  // Name
                  React.createElement('span', {
                    style: { fontSize: '12px', fontWeight: '500', color: '#374151', textAlign: 'center' }
                  }, resolver.name)
                );
              })
            ),
            // Info text
            React.createElement('p', {
              style: { fontSize: '12px', color: '#9ca3af', textAlign: 'center', marginTop: '20px' }
            }, 'Some sources may require login or configuration after setup.')
          ),
          // Footer
          React.createElement('div', {
            style: {
              padding: '16px 32px 20px',
              borderTop: '1px solid rgba(0,0,0,0.06)',
              display: 'flex',
              justifyContent: 'space-between',
              alignItems: 'center'
            }
          },
            React.createElement('button', {
              onClick: () => setFirstRunTutorial(prev => ({ ...prev, step: 'welcome' })),
              style: {
                fontSize: '14px',
                fontWeight: '500',
                color: '#6b7280',
                backgroundColor: 'transparent',
                border: 'none',
                cursor: 'pointer',
                padding: '10px 16px',
                borderRadius: '10px',
                display: 'flex',
                alignItems: 'center',
                gap: '6px'
              },
              onMouseEnter: (e) => e.currentTarget.style.color = '#1f2937',
              onMouseLeave: (e) => e.currentTarget.style.color = '#6b7280'
            },
              React.createElement('svg', { width: 16, height: 16, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2 },
                React.createElement('path', { d: 'M19 12H5M12 19l-7-7 7-7' })
              ),
              'Back'
            ),
            React.createElement('button', {
              onClick: () => setFirstRunTutorial(prev => ({ ...prev, step: 'complete' })),
              style: {
                padding: '10px 24px',
                fontSize: '14px',
                fontWeight: '500',
                color: '#ffffff',
                backgroundColor: '#7c3aed',
                border: 'none',
                borderRadius: '10px',
                cursor: 'pointer',
                transition: 'background-color 150ms ease'
              },
              onMouseEnter: (e) => e.currentTarget.style.backgroundColor = '#6d28d9',
              onMouseLeave: (e) => e.currentTarget.style.backgroundColor = '#7c3aed'
            }, 'Continue')
          )
        ),

        // Complete Step
        firstRunTutorial.step === 'complete' && React.createElement(React.Fragment, null,
          // Accent bar
          React.createElement('div', {
            style: { height: '4px', backgroundColor: '#10b981' }
          }),
          // Header
          React.createElement('div', {
            style: {
              padding: '32px 32px 24px',
              textAlign: 'center',
              borderBottom: '1px solid rgba(0,0,0,0.06)'
            }
          },
            React.createElement('div', {
              style: {
                width: '56px',
                height: '56px',
                margin: '0 auto 16px',
                borderRadius: '50%',
                backgroundColor: 'rgba(16, 185, 129, 0.1)',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center'
              }
            },
              React.createElement('svg', {
                width: 28,
                height: 28,
                viewBox: '0 0 24 24',
                fill: 'none',
                stroke: '#10b981',
                strokeWidth: 2.5,
                strokeLinecap: 'round',
                strokeLinejoin: 'round'
              },
                React.createElement('path', { d: 'M20 6L9 17l-5-5' })
              )
            ),
            React.createElement('h1', {
              style: { fontSize: '20px', fontWeight: '600', color: '#1f2937', marginBottom: '6px' }
            }, 'You\'re All Set!'),
            React.createElement('p', {
              style: { fontSize: '14px', color: '#6b7280' }
            }, 'Click below to configure your plugins and start listening.')
          ),
          // Content - Show active sources
          React.createElement('div', {
            style: { padding: '24px 32px' }
          },
            // Active sources summary
            loadedResolvers.filter(r => r.capabilities?.resolve && activeResolvers.includes(r.id)).length > 0 && React.createElement('div', {
              style: { marginBottom: '16px' }
            },
              React.createElement('div', {
                style: { fontSize: '12px', fontWeight: '600', color: '#9ca3af', textTransform: 'uppercase', letterSpacing: '0.05em', marginBottom: '12px' }
              }, 'Active Sources'),
              React.createElement('div', {
                style: { display: 'flex', flexWrap: 'wrap', gap: '8px', justifyContent: 'center' }
              },
                loadedResolvers.filter(r => r.capabilities?.resolve && activeResolvers.includes(r.id)).map(resolver =>
                  React.createElement('span', {
                    key: resolver.id,
                    style: {
                      padding: '6px 12px',
                      fontSize: '13px',
                      fontWeight: '500',
                      color: resolver.color || '#6b7280',
                      backgroundColor: `${resolver.color || '#6b7280'}15`,
                      borderRadius: '8px'
                    }
                  }, resolver.name)
                )
              )
            ),
            // Info text
            React.createElement('p', {
              style: { fontSize: '13px', color: '#6b7280', textAlign: 'center', lineHeight: '1.6' }
            }, 'You can configure login credentials, add local music folders, and customize your experience in the Installed Plugins settings.')
          ),
          // Footer
          React.createElement('div', {
            style: {
              padding: '16px 32px 24px',
              borderTop: '1px solid rgba(0,0,0,0.06)',
              display: 'flex',
              justifyContent: 'center',
              gap: '12px'
            }
          },
            React.createElement('button', {
              onClick: () => setFirstRunTutorial(prev => ({ ...prev, step: 'sources' })),
              style: {
                padding: '10px 20px',
                fontSize: '14px',
                fontWeight: '500',
                color: '#6b7280',
                backgroundColor: 'transparent',
                border: '1px solid rgba(0,0,0,0.1)',
                borderRadius: '10px',
                cursor: 'pointer',
                transition: 'all 150ms ease'
              },
              onMouseEnter: (e) => { e.currentTarget.style.borderColor = 'rgba(0,0,0,0.2)'; e.currentTarget.style.color = '#1f2937'; },
              onMouseLeave: (e) => { e.currentTarget.style.borderColor = 'rgba(0,0,0,0.1)'; e.currentTarget.style.color = '#6b7280'; }
            }, 'Back'),
            React.createElement('button', {
              onClick: async () => {
                // Save tutorial completion
                await window.electron.store.set('tutorial_completed', true);
                // Save active resolvers
                await window.electron.store.set('active_resolvers', activeResolvers);
                // Close tutorial
                setFirstRunTutorial(prev => ({ ...prev, open: false }));
                // Always navigate to Settings > Installed Plugins
                setSettingsTab('installed');
                navigateTo('settings');
              },
              style: {
                padding: '10px 24px',
                fontSize: '14px',
                fontWeight: '500',
                color: '#ffffff',
                backgroundColor: '#7c3aed',
                border: 'none',
                borderRadius: '10px',
                cursor: 'pointer',
                transition: 'background-color 150ms ease'
              },
              onMouseEnter: (e) => e.currentTarget.style.backgroundColor = '#6d28d9',
              onMouseLeave: (e) => e.currentTarget.style.backgroundColor = '#7c3aed'
            }, 'Go to Settings')
          )
        )
      )
    ),

    // Queue Drawer - slides up above the playbar with matching dark theme
    // Gradient transparency: more opaque near playbar, more transparent at top
    React.createElement('div', {
      className: 'fixed left-0 right-0 backdrop-blur-md border-t border-gray-700/50 shadow-2xl transition-all duration-300 ease-in-out z-40',
      style: {
        bottom: queueDrawerOpen ? '85px' : -queueDrawerHeight, // Position above the playbar (85px height)
        height: queueDrawerHeight + 'px',
        background: 'linear-gradient(to top, rgba(17, 24, 39, 0.9), rgba(17, 24, 39, 0.5))'
      }
    },
      // Drawer header with drag handle - dark translucent theme
      // Clicking anywhere on header (except drag handle and Clear) closes drawer
      React.createElement('div', {
        className: 'flex items-center justify-between px-4 py-2 bg-gray-900/60 border-b border-gray-700/50 cursor-pointer hover:bg-gray-800/60 transition-colors',
        onClick: () => setQueueDrawerOpen(false)
      },
        React.createElement('div', {
          className: 'flex items-center gap-3'
        },
          // Drag handle for resizing - stops click propagation
          React.createElement('div', {
            className: 'w-8 h-1 bg-gray-600 rounded-full cursor-ns-resize',
            onClick: (e) => e.stopPropagation(),
            onMouseDown: (e) => {
              e.stopPropagation();
              const startY = e.clientY;
              const startHeight = queueDrawerHeight;

              const handleMouseMove = (moveEvent) => {
                const deltaY = startY - moveEvent.clientY;
                const newHeight = Math.max(200, Math.min(600, startHeight + deltaY));
                setQueueDrawerHeight(newHeight);
              };

              const handleMouseUp = () => {
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
              };

              document.addEventListener('mousemove', handleMouseMove);
              document.addEventListener('mouseup', handleMouseUp);
            }
          }),
          React.createElement('span', {
            style: {
              fontSize: '11px',
              fontWeight: '600',
              color: '#e5e7eb',
              textTransform: 'uppercase',
              letterSpacing: '0.08em'
            }
          }, 'Queue'),
          React.createElement('span', {
            style: {
              fontSize: '11px',
              color: '#9ca3af',
              marginLeft: '8px'
            }
          }, `${currentQueue.length} track${currentQueue.length !== 1 ? 's' : ''}`),
          // Shuffle indicator
          shuffleMode && React.createElement('span', {
            style: {
              fontSize: '10px',
              color: '#a78bfa',
              marginLeft: '8px',
              display: 'flex',
              alignItems: 'center',
              gap: '4px'
            }
          },
            React.createElement('svg', { width: '12', height: '12', viewBox: '0 0 24 24', fill: 'currentColor' },
              React.createElement('path', { d: 'M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zm.33 9.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04-3.13-3.13z' })
            ),
            'shuffled'
          )
        ),
        React.createElement('div', {
          className: 'flex items-center gap-2'
        },
          // Save as Playlist button - shows when there's a current track or queue
          (currentTrack || currentQueue.length > 0) && React.createElement('button', {
            onClick: (e) => { e.stopPropagation(); handleSaveQueueAsPlaylist(); },
            className: 'px-3 py-1 text-xs text-gray-400 hover:text-white border border-gray-600 rounded hover:bg-white/10 transition-colors'
          }, 'SAVE'),
          // Unshuffle button - shows when shuffle is active
          shuffleMode && originalQueueRef.current && React.createElement('button', {
            onClick: (e) => { e.stopPropagation(); restoreOriginalOrder(); },
            className: 'px-3 py-1 text-xs text-purple-400 hover:text-purple-300 border border-purple-500/50 rounded hover:bg-purple-500/10 transition-colors',
            title: 'Restore original queue order'
          }, 'UNSHUFFLE'),
          // Clear button
          currentQueue.length > 0 && React.createElement('button', {
            onClick: (e) => { e.stopPropagation(); clearQueue(); },
            className: 'px-3 py-1 text-xs text-gray-400 hover:text-white border border-gray-600 rounded hover:bg-white/10 transition-colors'
          }, 'CLEAR'),
          // Close button
          React.createElement('button', {
            onClick: () => setQueueDrawerOpen(false),
            className: 'flex items-center gap-1 px-3 py-1 text-xs text-gray-400 hover:text-white border border-gray-600 rounded hover:bg-white/10 transition-colors'
          },
            'CLOSE',
            React.createElement('span', { className: 'text-gray-500' }, 'Ã—')
          )
        )
      ),

      // Queue content - dark theme
      React.createElement('div', {
        ref: queueContentRef,
        className: 'overflow-y-auto relative scrollable-content-dark',
        style: { height: (queueDrawerHeight - 44 - (playbackContext ? 32 : 0)) + 'px' },
        onDragEnter: (e) => handleDragEnter(e, 'queue'),
        onDragOver: (e) => handleDragOver(e, 'queue'),
        onDragLeave: handleDragLeave,
        onDrop: (e) => handleDrop(e, 'queue')
      },
        // Drop zone overlay
        React.createElement(DropZoneOverlay, {
          zone: 'queue',
          isActive: isDraggingUrl && dropZoneTarget === 'queue'
        }),
        currentQueue.length === 0 ?
          React.createElement('div', {
            className: 'flex flex-col items-center justify-center h-full text-gray-500'
          },
            React.createElement('svg', { className: 'w-10 h-10 text-gray-300 mb-2', fill: 'currentColor', viewBox: '0 0 24 24' },
              React.createElement('path', { d: 'M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z' })
            ),
            React.createElement('span', { className: 'text-gray-400' }, 'Queue is empty'),
            React.createElement('span', { className: 'text-sm text-gray-500 mt-1' }, 'Play a playlist to add tracks')
          )
        :
          // Virtualized queue list - renders only visible items for performance
          // Uses @tanstack/react-virtual to efficiently handle large queues
          React.createElement(VirtualizedQueueList, {
            queue: currentQueue,
            currentTrack,
            resolverOrder,
            allResolvers,
            queueDropTarget,
            draggedQueueTrack,
            insertedTrackId,
            droppingFromIndex,
            spinoffMode,
            playbackContext,
            listenAlongFriend,
            addToPlaylistPanel,
            selectedPlaylistsForAdd,
            containerHeight: queueDrawerHeight - 44 - (playbackContext ? 32 : 0),
            parentRef: queueContentRef,
            // Callbacks
            setDraggedQueueTrack,
            setDraggingTrackForPlaylist,
            setQueueDropTarget,
            setDropTargetPlaylistId,
            setDropTargetNewPlaylist,
            setAddToPlaylistPanel,
            moveInQueue,
            setDroppingFromIndex,
            setCurrentQueue,
            handlePlay,
            exitSpinoff,
            fetchArtistData,
            removeFromQueue,
            handleUrlDrop,
            formatTime,
            // Resolution scheduler integration
            onVisibilityChange: (tracks) => updateSchedulerVisibility('queue', tracks),
            onTrackHover: (trackId) => setSchedulerHoverTrack(trackId, 'queue'),
            onTrackHoverEnd: () => clearSchedulerHoverTrack(),
            currentTrackIndex: currentQueue.findIndex(t => t.id === currentTrack?.id)
          })
      ),

      // Playback context banner - shows where playback originated from (at bottom of queue)
      // aiPlaylist type is not clickable (no navigation back to ephemeral AI-generated sidebar)
      playbackContext && React.createElement('div', {
        className: `flex items-center justify-between px-4 py-1.5 bg-purple-900/40 border-t border-purple-700/30 transition-colors ${
          (playbackContext.type === 'spinoff' || playbackContext.type === 'aiPlaylist') ? 'cursor-default' : 'cursor-pointer hover:bg-purple-900/50'
        }`,
        onClick: () => {
          // AI Playlist is not navigable (ephemeral sidebar)
          if (playbackContext.type === 'aiPlaylist') return;
          // Navigate to the context source (skip if already on target page)
          if (playbackContext.type === 'playlist' && playbackContext.id) {
            const playlist = playlists.find(p => p.id === playbackContext.id);
            if (playlist) {
              loadPlaylist(playlist); // loadPlaylist has its own "already viewing" check
            }
          } else if (playbackContext.type === 'album' && playbackContext.artist) {
            // handleCollectionAlbumClick has its own "already viewing" check
            handleCollectionAlbumClick({
              title: playbackContext.name,
              artist: playbackContext.artist
            });
          } else if (playbackContext.type === 'search') {
            navigateTo('search'); // navigateTo skips if already on page
          } else if (playbackContext.type === 'library') {
            // Skip if already on library with tracks tab
            if (activeView !== 'library' || collectionTab !== 'tracks') {
              setCollectionTab('tracks');
              navigateTo('library');
            }
          } else if (playbackContext.type === 'recommendations') {
            navigateTo('recommendations');
          } else if (playbackContext.type === 'history') {
            navigateTo('history');
          } else if (playbackContext.type === 'friend') {
            navigateTo('friendHistory');
          } else if (playbackContext.type === 'spinoff') {
            // Spinoff has no destination page - do nothing
          } else if (playbackContext.type === 'listenAlong') {
            // Navigate to the friend's history page
            const friend = friends.find(f => f.id === playbackContext.friendId);
            if (friend) {
              setCurrentFriend(friend);
              navigateTo('friendHistory');
            }
          } else if (playbackContext.type === 'url' && playbackContext.url) {
            // Open the source URL in the default browser
            window.electron.shell.openExternal(playbackContext.url);
          }
          setQueueDrawerOpen(false);
        },
        title: playbackContext.type === 'url' ? 'Open source page' : 'Go to source'
      },
        React.createElement('div', { className: 'flex items-center gap-2' },
          React.createElement('span', { className: 'text-xs text-purple-300' },
            playbackContext.type === 'spinoff' ? 'Playing' :
            playbackContext.type === 'listenAlong' ? 'Listening along with' : 'Playing from'
          ),
          React.createElement('span', { className: 'text-xs font-medium text-purple-100' },
            playbackContext.type === 'playlist' ? `${playbackContext.name || 'Playlist'}` :
            playbackContext.type === 'album' ? `${playbackContext.name || 'Album'} by ${playbackContext.artist || 'Unknown'}` :
            playbackContext.type === 'search' ? `"${playbackContext.name || 'Search'}"` :
            playbackContext.type === 'library' ? 'Collection' :
            playbackContext.type === 'recommendations' ? 'Recommendations' :
            playbackContext.type === 'aiPlaylist' ? 'AI Playlist' :
            playbackContext.type === 'history' ? 'History' :
            playbackContext.type === 'friend' ? `${playbackContext.name || 'Friend'}'s ${playbackContext.tab === 'topTracks' ? 'top tracks' : 'recent listens'}` :
            playbackContext.type === 'spinoff' ? `spun off from "${playbackContext.sourceTrack?.title || 'Unknown'}" by ${playbackContext.sourceTrack?.artist || 'Unknown'}` :
            playbackContext.type === 'listenAlong' ? `${playbackContext.name || 'Friend'}` :
            playbackContext.type === 'url' ? playbackContext.name || 'External link' :
            playbackContext.name || 'Unknown'
          )
        ),
        // Hide arrow for spinoff and aiPlaylist (not clickable)
        playbackContext.type !== 'spinoff' && playbackContext.type !== 'aiPlaylist' && React.createElement('svg', {
          className: 'w-4 h-4 text-purple-400',
          fill: 'none',
          stroke: 'currentColor',
          viewBox: '0 0 24 24'
        },
          playbackContext.type === 'url'
            ? React.createElement('path', {
                strokeLinecap: 'round',
                strokeLinejoin: 'round',
                strokeWidth: 2,
                d: 'M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14'
              })
            : React.createElement('path', {
                strokeLinecap: 'round',
                strokeLinejoin: 'round',
                strokeWidth: 2,
                d: 'M14 5l7 7m0 0l-7 7m7-7H3'
              })
        )
      )
    )
  );
};

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(React.createElement(Parachord));