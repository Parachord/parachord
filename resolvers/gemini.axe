{
  "manifest": {
    "id": "gemini",
    "name": "Google Gemini",
    "type": "meta-service",
    "version": "1.0.0",
    "author": "Parachord Team",
    "description": "Generate playlists using Google Gemini. Requires your own API key.",
    "icon": "✦",
    "color": "#4285f4",
    "homepage": "https://ai.google.dev"
  },

  "capabilities": {
    "generate": true
  },

  "settings": {
    "requiresAuth": true,
    "authType": "apiKey",
    "configurable": {
      "apiKey": {
        "type": "password",
        "label": "API Key",
        "placeholder": "AIza...",
        "helpUrl": "https://aistudio.google.com/app/apikey"
      },
      "model": {
        "type": "select",
        "label": "Model",
        "default": "gemini-2.5-flash",
        "options": [
          { "value": "gemini-2.5-flash", "label": "Gemini 2.5 Flash (Recommended)" },
          { "value": "gemini-2.5-pro", "label": "Gemini 2.5 Pro" }
        ]
      }
    }
  },

  "implementation": {
    "generate": "async function(prompt, config) { if (!config.apiKey) { throw new Error('API key required. Add your Google API key in Settings → General → AI Integration.'); } try { const model = config.model || 'gemini-2.5-flash'; const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${config.apiKey}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: [{ parts: [{ text: 'You are a music recommendation assistant. Given a prompt, return ONLY a valid JSON object (no markdown, no code blocks, no explanation) with a \"tracks\" array containing 10-15 track recommendations. Each track must have \"artist\" and \"title\" fields.\\n\\nExample response format:\\n{\"tracks\": [{\"artist\": \"Artist Name\", \"title\": \"Song Title\"}]}\\n\\nPrompt: ' + prompt }] }], generationConfig: { responseMimeType: 'application/json' } }) }); if (!response.ok) { const error = await response.json().catch(() => ({})); if (response.status === 400 && error.error?.message?.includes('API key')) { throw new Error('Invalid API key. Check your Google API key in Settings.'); } if (response.status === 429) { throw new Error('Rate limit exceeded. Please wait a moment and try again.'); } throw new Error(error.error?.message || 'Gemini API request failed'); } const data = await response.json(); let content = data.candidates?.[0]?.content?.parts?.[0]?.text; if (!content) { throw new Error('No response from Gemini'); } content = content.trim(); if (content.startsWith('```json')) { content = content.slice(7); } else if (content.startsWith('```')) { content = content.slice(3); } if (content.endsWith('```')) { content = content.slice(0, -3); } content = content.trim(); const jsonMatch = content.match(/\\{[\\s\\S]*\\}/); if (jsonMatch) { content = jsonMatch[0]; } const parsed = JSON.parse(content); const tracks = parsed.tracks || parsed.playlist || parsed.songs || []; if (!Array.isArray(tracks) || tracks.length === 0) { throw new Error('AI returned no tracks. Try a different prompt.'); } return tracks.map(t => ({ artist: t.artist || t.Artist || '', title: t.title || t.track || t.song || t.Title || '' })).filter(t => t.artist && t.title); } catch (error) { if (error.message.includes('API key') || error.message.includes('Rate limit') || error.message.includes('No response') || error.message.includes('no tracks')) { throw error; } console.error('Gemini generate error:', error); throw new Error('Failed to generate playlist: ' + error.message); } }",

    "init": "async function(config) { console.log('Gemini plugin initialized'); }",

    "cleanup": "async function() { console.log('Gemini plugin cleanup'); }"
  }
}
